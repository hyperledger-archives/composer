<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"composer-common_lib_filewallet.js.html":{"id":"composer-common_lib_filewallet.js.html","title":"Source: composer-common/lib/filewallet.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/filewallet.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const fs = require('fs'); const homedir = require('homedir'); const Logger = require('./log/logger'); const mkdirp = require('mkdirp'); const path = require('path'); const thenify = require('thenify'); const thenifyAll = require('thenify-all'); const Wallet = require('./wallet'); const LOG = Logger.getLog('FileWallet'); /** * Class implementing a wallet (a container of credentials) that * stores the credentials on the file system. * @protected */ class FileWallet extends Wallet { /** * Get the current home directory. * @return {string} The current home directory. */ static getHomeDirectory() { return homedir(); } /** * Constructor. * @param {Object} [options] The options to use. * @param {string} [options.directory] The directory to store * credentials in. * @param {Object} [fs] The file system implementation to use. */ constructor(options) { super(); const method = 'constructor'; LOG.entry(method, options); // Generate the directory if not specified in the options. options = options || {}; this.directory = options.directory; if (!this.directory) { let h = FileWallet.getHomeDirectory(); if (h) { this.directory = path.resolve(h, '.composer-credentials'); } else { this.directory = path.resolve('/', '.composer-credentials'); } LOG.debug(method, 'Generated directory', this.directory); } // Use the default fs implementation if one is not specified. let theFS = options.fs; if (!theFS) { theFS = fs; } // Promisify all of the APIs that we want to use. this.fs = thenifyAll(theFS, {}); this.mkdirp = thenify((dir, cb) =&gt; { return mkdirp(dir, { fs: theFS }, cb); }); LOG.exit(method); } /** * List all of the credentials in the wallet. * @return {Promise} A promise that is resolved with * an array of credential names, or rejected with an * error. */ list() { const method = 'list'; LOG.entry(method); const result = []; return this.fs.readdir(this.directory) .then((files) =&gt; { files.forEach((file) =&gt; { LOG.debug(method, 'Found file', file); result.push(file); }); result.sort(); }) .catch((error) =&gt; { // Ignore any errors. LOG.debug(method, 'Ignoring error', error); }) .then(() =&gt; { LOG.exit(method, result); return result; }); } /** * Check to see if the named credentials are in * the wallet. * @param {string} name The name of the credentials. * @return {Promise} A promise that is resolved with * a boolean; true if the named credentials are in the * wallet, false otherwise. */ contains(name) { const method = 'contains'; LOG.entry(method, name); let result = false; const file = path.resolve(this.directory, name); return this.fs.readFile(file, 'utf8') .then((value) =&gt; { LOG.debug(method, 'Read file successfully'); result = true; }) .catch((error) =&gt; { // Ignore any errors. LOG.debug(method, 'Ignoring error', error); }) .then(() =&gt; { LOG.exit(method, result); return result; }); } /** * Get the named credentials from the wallet. * @abstract * @param {string} name The name of the credentials. * @return {Promise} A promise that is resolved with * the named credentials, or rejected with an error. */ get(name) { const method = 'get'; LOG.entry(method, name); const file = path.resolve(this.directory, name); return this.fs.readFile(file, 'utf8') .then((value) =&gt; { LOG.debug(method, 'Read file successfully'); LOG.exit(method, value); return value; }) .catch((error) =&gt; { LOG.error(method, error); throw error; }); } /** * Add a new credential to the wallet. * @abstract * @param {string} name The name of the credentials. * @param {string} value The credentials. * @return {Promise} A promise that is resolved when * complete, or rejected with an error. */ add(name, value) { const method = 'add'; LOG.entry(method, name, value); const file = path.resolve(this.directory, name); return this.mkdirp(this.directory) .then(() =&gt; { return this.fs.writeFile(file, value, { flag: 'wx', mode: 0o600 }); }) .then((value) =&gt; { LOG.debug(method, 'Wrote file successfully'); LOG.exit(method); }) .catch((error) =&gt; { LOG.error(method, error); throw error; }); } /** * Update existing credentials in the wallet. * @abstract * @param {string} name The name of the credentials. * @param {string} value The credentials. * @return {Promise} A promise that is resolved when * complete, or rejected with an error. */ update(name, value) { const method = 'update'; LOG.entry(method, name, value); const file = path.resolve(this.directory, name); return this.fs.readFile(file, 'utf8') .then(() =&gt; { LOG.debug(method, 'Read file successfully'); return this.fs.writeFile(file, value, { mode: 0o600 }); }) .then((value) =&gt; { LOG.debug(method, 'Wrote file successfully'); LOG.exit(method); }) .catch((error) =&gt; { LOG.error(method, error); throw error; }); } /** * Remove existing credentials from the wallet. * @abstract * @param {string} name The name of the credentials. * @return {Promise} A promise that is resolved when * complete, or rejected with an error. */ remove(name) { const method = 'remove'; LOG.entry(method, name); const file = path.resolve(this.directory, name); return this.fs.unlink(file) .then((value) =&gt; { LOG.debug(method, 'Removed file successfully'); LOG.exit(method); }) .catch((error) =&gt; { LOG.error(method, error); throw error; }); } } module.exports = FileWallet; Ã— Search results Close "},"composer-runtime_lib_identitymanager.js.html":{"id":"composer-runtime_lib_identitymanager.js.html","title":"Source: composer-runtime/lib/identitymanager.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/identitymanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const Resource = require('composer-common').Resource; const LOG = Logger.getLog('IdentityManager'); /** * A class for managing and persisting identities. * @protected */ class IdentityManager { /** * Constructor. * @param {DataService} dataService The data service to use. * @param {RegistryManager} registryManager The registry manager to use. */ constructor(dataService, registryManager) { this.dataService = dataService; this.registryManager = registryManager; } /** * Add a new mapping for the specified identity (user ID) to the specified * participant. * @param {(Resource|string)} participant The participant, or the unique * identifier of the participant. * @param {string} userID The identity (user ID) to map to the participant. * @return {Promise} A promise that is resolved when a new mapping for the * specified identity has been created. */ addIdentityMapping(participant, userID) { const method = 'addIdentityMapping'; LOG.entry(method, participant, userID); let participantFQI, participantFQT, participantID; if (participant instanceof Resource) { participantFQI = participant.getFullyQualifiedIdentifier(); participantFQT = participant.getFullyQualifiedType(); participantID = participant.getIdentifier(); } else { participantFQI = participant; let hashIndex = participantFQI.indexOf('#'); if (hashIndex === -1) { throw new Error('Invalid fully qualified participant identifier'); } participantFQT = participantFQI.substring(0, hashIndex); participantID = participantFQI.substring(hashIndex + 1); } LOG.debug(method, 'Looking for participant registry', participantFQT); return this.registryManager.get('Participant', participantFQT) .then((participantRegistry) =&gt; { LOG.debug(method, 'Found participant registry, looking for participant', participantID); return participantRegistry.get(participantID); }) .then((participant) =&gt; { LOG.debug(method, 'Found participant, getting $sysidentities collection'); return this.dataService.getCollection('$sysidentities'); }) .then((sysidentities) =&gt; { LOG.debug(method, 'Got $sysidentities collection, checking for existing mapping'); return sysidentities.exists(userID) .then((exists) =&gt; { if (exists) { LOG.error(method, 'Found an existing mapping for user ID', userID); throw new Error(`Found an existing mapping for user ID '${userID}'`); } LOG.debug(method, 'No existing mapping exists for user ID, adding'); return sysidentities.add(userID, { participant: participantFQI }); }); }) .then(() =&gt; { LOG.exit(method); }); } /** * Remove an existing mapping for the specified identity (user ID) to a * participant. * @param {string} userID The identity (user ID). * @return {Promise} A promise that is resolved when a new mapping for the * specified identity has been created. */ removeIdentityMapping(userID) { const method = 'removeIdentityMapping'; LOG.entry(method, userID); LOG.debug(method, 'Getting $sysidentities collection'); return this.dataService.getCollection('$sysidentities') .then((sysidentities) =&gt; { LOG.debug(method, 'Got $sysidentities collection, checking for existing mapping'); return sysidentities.exists(userID) .then((exists) =&gt; { if (!exists) { LOG.debug('No existing mapping exists for user ID, ignoring'); return; } return sysidentities.remove(userID); }); }) .then(() =&gt; { LOG.exit(method); }); } /** * Retrieve the participant for the specified identity (user ID). * @param {string} userID The identity (user ID). * @return {Promise} A promise that is resolved with a {@link Resource} * representing the participant, or rejected with an error. */ getParticipant(userID) { const method = 'getParticipant'; LOG.entry(method, userID); LOG.debug(method, 'Getting $sysidentities collection'); let participantFQI, participantFQT, participantID; return this.dataService.getCollection('$sysidentities') .then((sysidentities) =&gt; { LOG.debug(method, 'Got $sysidentities collection, checking for existing mapping'); return sysidentities.get(userID); }) .then((mapping) =&gt; { participantFQI = mapping.participant; LOG.debug(method, 'Found mapping, participant is', participantFQI); let hashIndex = participantFQI.indexOf('#'); if (hashIndex === -1) { throw new Error('Invalid fully qualified participant identifier'); } participantFQT = participantFQI.substring(0, hashIndex); participantID = participantFQI.substring(hashIndex + 1); LOG.debug(method, 'Looking for participant registry', participantFQT); return this.registryManager.get('Participant', participantFQT); }) .then((participantRegistry) =&gt; { LOG.debug(method, 'Found participant registry, looking for participant', participantID); return participantRegistry.get(participantID); }) .then((participant) =&gt; { LOG.exit(method, participant); return participant; }); } } module.exports = IdentityManager; Ã— Search results Close "},"composer-runtime_lib_jstransactionexecutor.js.html":{"id":"composer-runtime_lib_jstransactionexecutor.js.html","title":"Source: composer-runtime/lib/jstransactionexecutor.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/jstransactionexecutor.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const TransactionExecutor = require('./transactionexecutor'); const LOG = Logger.getLog('JSTransactionExecutor'); /** * A class for executing JavaScript transaction processor functions. * @protected */ class JSTransactionExecutor extends TransactionExecutor { /** * Get the type of this transaction executor. * @return {string} The type of this transaction executor. */ getType() { return 'JS'; } /** * Execute the specified transaction. * @param {Api} api The API to use. * @param {ScriptManager} scriptManager The script manager to use. * @param {Resource} transaction The transaction to execute. * @param {Resource} resolvedTransaction The resolved transaction to execute. * @return {Promise} A promise that is resolved when the transaction has been * executed, or rejected with an error. */ execute(api, scriptManager, transaction, resolvedTransaction) { const method = 'execute'; LOG.entry(method, api, scriptManager, transaction, resolvedTransaction); // Find all of the function names. let functionNames = this.findFunctionNames(scriptManager, transaction); // If we didn't find any functions to call, then throw an error! if (functionNames.length === 0) { LOG.error(`Could not find any functions to execute for transaction ${transaction.getFullyQualifiedIdentifier()}`); throw new Error(`Could not find any functions to execute for transaction ${transaction.getFullyQualifiedIdentifier()}`); } // Find all of the scripts, and build a function for each script function to call. let functions = this.compileScripts(scriptManager, functionNames); // Bind the API into the global object. Object.getOwnPropertyNames(api).forEach((key) =&gt; { LOG.debug(method, 'Binding API function', key); global[key] = api[key].bind(api); }); // Execute each function for the transaction. return functions.reduce((result, func) =&gt; { return result.then(() =&gt; { LOG.debug(method, 'Executing function'); let funcResult = func(resolvedTransaction); if (funcResult instanceof Promise) { return funcResult.then(() =&gt; { LOG.debug(method, 'Function executed (returned promise)'); }); } else { LOG.debug(method, 'Function executed'); } }); }, Promise.resolve()) .then(() =&gt; { LOG.exit(method); }); } /** * Find all of the function names that should be executed. * @param {ScriptManager} scriptManager The script manager to use. * @param {Resource} transaction The transaction to execute. * @return {string[]} All function names to execute. */ findFunctionNames(scriptManager, transaction) { const method = 'findFunctionNames'; LOG.entry(method, scriptManager, transaction); // Find all of the scripts. let functionNames = []; scriptManager.getScripts().forEach((script) =&gt; { // Look at all the functions. LOG.debug(method, 'Looking at script', script.getIdentifier()); script.getFunctionDeclarations().forEach((functionDeclaration) =&gt; { // Is this function annotated with @transaction? LOG.debug(method, 'Looking at function declaration', functionDeclaration.getName()); if (functionDeclaration.getDecorators().indexOf('transaction') !== -1) { // Yes - is the type of the only parameter (validated elsewhere) // the same type as the transaction? LOG.debug(method, 'Function is annotated with @transaction'); if (functionDeclaration.getParameterTypes()[0] === transaction.getFullyQualifiedType()) { LOG.debug(method, 'Function parameter type matches transaction'); functionNames.push(functionDeclaration.getName()); } else { LOG.debug(method, 'Function parameter type does not match transaction'); } // It's not annotated with @transaction, does it start with on&lt;transactionType&gt;? // This is to keep supporting the original transaction processor function format // which went by naming conventions rather than annotations. } else if (functionDeclaration.getTransactionDeclarationName() === transaction.getType()) { LOG.debug(method, 'Function name matches on&lt;transactionType&gt;'); functionNames.push(functionDeclaration.getName()); // Must be a query or utility function. } else { LOG.debug(method, 'Function is query or utility function'); } }); }); LOG.exit(method, functionNames); return functionNames; } /** * Compile the scripts into functions for execution. * @param {ScriptManager} scriptManager The script manager to use. * @param {string[]} functionNames The function names to execute. * @return {Function[]} All functions to execute. */ compileScripts(scriptManager, functionNames) { const method = 'compileScripts'; LOG.entry(method, scriptManager, functionNames); // This is the source for all of the scripts. let source = ''; // Find all of the scripts. scriptManager.getScripts().forEach((script) =&gt; { // Concatenate the script source. LOG.debug(method, 'Looking at script', script.getIdentifier()); source += script.getContents() + '\\n'; }); // For each transaction processor function we found, build a function. let functions = functionNames.map((functionName) =&gt; { // The source for the function is all of the scripts and a call to execute // the current transaction processor function. LOG.debug(method, 'Building function for transaction processor function', functionName); let functionSource = source; functionSource += `return ${functionName}($transaction);\\n`; LOG.debug(method, 'Creating new function from source', functionSource); return new Function('$transaction', functionSource); }); LOG.exit(method, functions); return functions; } } module.exports = JSTransactionExecutor; Ã— Search results Close "},"composer-admin_index.js.html":{"id":"composer-admin_index.js.html","title":"Source: composer-admin/index.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-admin/index.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * The composer-common module cannot load connector modules from parent modules * when the dependencies are linked together using npm link or lerna. To work * around this, the packages that require the connectors register themselves as * modules that can load connection managers. */ require('composer-common').ConnectionProfileManager.registerConnectionManagerLoader(module); /** * &lt;p&gt; * The composer-admin module. Defines the administration API for Fabric Composer. * &lt;/p&gt; * &lt;p&gt; * Fabric Composer is a framework for creating blockchain backed digital networks and * exchanging assets between participants via processing transactions. * &lt;/p&gt; * @module composer-admin */ module.exports.AdminConnection = require('./lib/adminconnection'); /** * Expose key composer-common classes to simplify client application dependencies * @ignore */ module.exports.BusinessNetworkDefinition = require('composer-common').BusinessNetworkDefinition; module.exports.Logger = require('composer-common').Logger; Ã— Search results Close "},"composer-admin_lib_adminconnection.js.html":{"id":"composer-admin_lib_adminconnection.js.html","title":"Source: composer-admin/lib/adminconnection.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-admin/lib/adminconnection.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Util = require('composer-common').Util; const ConnectionProfileManager = require('composer-common').ConnectionProfileManager; const FSConnectionProfileStore = require('composer-common').FSConnectionProfileStore; const fs = require('fs'); /** * This class creates an administration connection to a Fabric Composer runtime. The * connection can then be used to: * &lt;ul&gt; * &lt;li&gt;Deploy BusinessNetworkDefinitions&lt;/li&gt; * &lt;li&gt;Undeploy BusinessNetworkDefinitions&lt;/li&gt; * &lt;li&gt;Update BusinessNetworkDefinitions&lt;/li&gt; * &lt;li&gt;Send a ping message to the runtime to ensure it is running and * correctly configured.&lt;/li&gt; * &lt;li&gt;Store a connection profile document in the connection profile store&lt;/li&gt; * &lt;/ul&gt; * * @class * @memberof module:composer-admin */ class AdminConnection { /** * Create an instance of the AdminConnection class. * @param {Object} [options] - an optional set of options to configure the instance. * @param {Object} [options.fs] - specify an fs implementation to use. */ constructor(options) { options = options || {}; this.connectionProfileStore = new FSConnectionProfileStore(options.fs || fs); this.connectionProfileManager = new ConnectionProfileManager(this.connectionProfileStore); this.connection = null; this.securityContext = null; } /** * Connects and logs in to the Hyperledger Fabric using a named connection * profile. The connection profile must exist in the profile store. * @example * // Connect to Hyperledger Fabric * var adminConnection = new AdminConnection(); * adminConnection.connect('testprofile', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(){ * // Connected. * }) * .catch(function(error){ * // Add optional error handling here. * }); * @param {string} connectionProfile - The name of the connection profile * @param {string} enrollmentID the enrollment ID of the user * @param {string} enrollmentSecret the enrollment secret of the user * @param {string} businessNetworkIdentifier the id of the network (for update) or null * @return {Promise} A promise that indicates the connection is complete */ connect(connectionProfile, enrollmentID, enrollmentSecret, businessNetworkIdentifier) { return this.connectionProfileManager.connect(connectionProfile, businessNetworkIdentifier) .then((connection) =&gt; { this.connection = connection; return connection.login(enrollmentID, enrollmentSecret); }) .then((securityContext) =&gt; { this.securityContext = securityContext; return Promise.resolve('connected'); }); } /** * Stores a connection profile into the profile store being used by this * AdminConnection. * @example * // Create a connection profile * var adminConnection = new AdminConnection(); * var adminOptions = { * type: 'hlf', * keyValStore: '/tmp/keyValStore', * membershipServicesURL: 'grpc://membersrvc:7054', * peerURL: 'grpc://vp0:7051', * eventHubURL: 'grpc://vp0:7053' * }; * return adminConnection.createProfile('testprofile', adminOptions) * .then(function(){ * // Created profile * }) * .catch(function(error){ * // Add optional error handling here. * }); * @param {string} connectionProfile - The name of the connection profile * @param {Object} data - The connection profile data * @return {Promise} A promise that indicates that the connection profile is deployed */ createProfile(connectionProfile, data) { return this.connectionProfileManager.getConnectionProfileStore().save(connectionProfile, data); } /** * Deletes the specified connection profile from the profile store being used by this * AdminConnection. * @example * // Delete a connection profile * var adminConnection = new AdminConnection(); * return adminConnection.deleteProfile('testprofile') * .then(function(){ * // Deleted profile * }) * .catch(function(error){ * // Add optional error handling here. * }); * @param {string} connectionProfile - The name of the connection profile * @return {Promise} A promise that indicates that the connection profile is deployed */ deleteProfile(connectionProfile) { return this.connectionProfileManager.getConnectionProfileStore().delete(connectionProfile); } /** * Retrieve the specified connection profile from the profile store being * used by this AdminConnection. * @example * // Retrieve the connection profile. * const adminConnection = new AdminConnection(); * return adminConnection.getProfile('testprofile') * .then((profile) =&gt; { * // Retrieved profile * console.log(profile); * }); * @param {string} connectionProfile - The name of the connection profile * @return {Promise} A promise that is resolved with the connection profile data. */ getProfile(connectionProfile) { return this.connectionProfileManager.getConnectionProfileStore().load(connectionProfile); } /** * Retrieve all connection profiles from the profile store being used by this * AdminConnection. * @example * // Retrieve all the connection profiles. * const adminConnection = new AdminConnection(); * return adminConnection.getAllProfiles() * .then((profiles) =&gt; { * // Retrieved profiles * for (let profile in profiles) { * console.log(profile, profiles[profile]); * } * }); * @return {Promise} A promise that is resolved with the connection profile data. */ getAllProfiles() { return this.connectionProfileManager.getConnectionProfileStore().loadAll(); } /** * Disconnects this connection. * @example * // Disconnect from a Business Network * var adminConnection = new AdminConnection(); * return adminConnection.disconnect() * .then(function(){ * // Disconnected. * }) * .catch(function(error){ * // Add optional error handling here. * }); * @return {Promise} A promise that will be resolved when the connection is * terminated. */ disconnect() { if (!this.connection) { return Promise.resolve(); } return this.connection.disconnect() .then(() =&gt; { this.connection = null; this.securityContext = null; }); } /** * Deploys a new BusinessNetworkDefinition to the fabric. The connection must * be connected for this method to succeed. * @example * // Deploy a Business Network Definition * var adminConnection = new AdminConnection(); * var businessNetworkDefinition = BusinessNetworkDefinition.fromArchive(myArchive); * return adminConnection.deploy(businessNetworkDefinition) * .then(function(){ * // Business network definition deployed * }) * .catch(function(error){ * // Add optional error handling here. * }); * @param {BusinessNetworkDefinition} businessNetworkDefinition - The business network to deploy * @return {Promise} A promise that will be fufilled when the business network has been * deployed. */ deploy(businessNetworkDefinition) { Util.securityCheck(this.securityContext); return this.connection.deploy(this.securityContext, true, businessNetworkDefinition); } /** * Undeploys a BusinessNetworkDefinition from the fabric. The business network will no * longer be able to process transactions. * @example * // Undeploy a Business Network Definition * var adminConnection = new AdminConnection(); * return adminConnection.undeploy('identifier') * .then(function(){ * // Undeployed Business Network Definition * }) * .catch(function(error){ * // Add optional error handling here. * }) * @param {string} businessNetworkIdentifier - The identifier of the network to undeploy * @return {Promise} A promise that will be fufilled when the business network has been * undeployed. */ undeploy(businessNetworkIdentifier) { Util.securityCheck(this.securityContext); return this.connection.undeploy(this.securityContext, businessNetworkIdentifier); } /** * Updates an existing BusinessNetworkDefinition on the fabric. The BusinessNetworkDefinition * must have been previously deployed. * @example * // Updates a Business Network Definition * var adminConnection = new AdminConnection(); * var businessNetworkDefinition = BusinessNetworkDefinition.fromArchive(myArchive); * return adminConnection.update(businessNetworkDefinition) * .then(function(){ * // Business network definition updated * }) * .catch(function(error){ * // Add optional error handling here. * }); * @param {BusinessNetworkDefinition} businessNetworkDefinition - The new BusinessNetworkDefinition * @return {Promise} A promise that will be fufilled when the business network has been * updated. */ update(businessNetworkDefinition) { Util.securityCheck(this.securityContext); return this.connection.update(this.securityContext, businessNetworkDefinition); } /** * Test the connection to the runtime and verify that the version of the * runtime is compatible with this level of the node.js module. * @example * // Test the connection to the runtime * var adminConnection = new AdminConnection(); * return adminConnection.ping() * .then(function(){ * // Connection has been tested * }) * .catch(function(error){ * // Add optional error handling here. * }); * @return {Promise} A promise that will be fufilled when the connection has * been tested. The promise will be rejected if the version is incompatible. */ ping() { Util.securityCheck(this.securityContext); return this.connection.ping(this.securityContext); } /** * List all of the deployed business networks. The connection must * be connected for this method to succeed. * @example * // List all of the deployed business networks. * var adminConnection = new AdminConnection(); * return adminConnection.list() * .then((businessNetworks) =&gt; { * // Connection has been tested * return businessNetworks.forEach((businessNetwork) =&gt; { * console.log('Deployed business network', businessNetwork); * }); * }) * .catch(function(error){ * // Add optional error handling here. * }); * @return {Promise} A promise that will be resolved with an array of * business network identifiers, or rejected with an error. */ list() { Util.securityCheck(this.securityContext); return this.connection.list(this.securityContext); } } module.exports = AdminConnection; Ã— Search results Close "},"composer-client_index.js.html":{"id":"composer-client_index.js.html","title":"Source: composer-client/index.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-client/index.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * The composer-common module cannot load connector modules from parent modules * when the dependencies are linked together using npm link or lerna. To work * around this, the packages that require the connectors register themselves as * modules that can load connection managers. */ require('composer-common').ConnectionProfileManager.registerConnectionManagerLoader(module); /** * &lt;p&gt; * The composer-client module. Defines the client API for Composer. * &lt;/p&gt; * &lt;p&gt; * Composer is a framework for creating blockchain backed digital networks and * exchanging assets between participants via processing transactions. * &lt;/p&gt; * &lt;p&gt; * Applications interact with the framework by instantiating the {@link BusinessNetworkConnection} * class. * &lt;/p&gt; * @module composer-client */ module.exports.BusinessNetworkConnection = require('./lib/businessnetworkconnection'); /** * Expose key composer-common classes to simplify client application dependencies * @ignore */ module.exports.Logger = require('composer-common').Logger; Ã— Search results Close "},"composer-client_lib_assetregistry.js.html":{"id":"composer-client_lib_assetregistry.js.html","title":"Source: composer-client/lib/assetregistry.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-client/lib/assetregistry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Registry = require('./registry'); const Util = require('composer-common').Util; const REGISTRY_TYPE = 'Asset'; /** * The AssetRegistry is used to manage a set of assets stored on the blockchain. * &lt;p&gt;&lt;a href=&quot;./diagrams/assetregistry.svg&quot;&gt;&lt;img src=&quot;./diagrams/assetregistry.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends Registry * @see See [Registry]{@link module:composer-client.Registry} * @class * @memberof module:composer-client */ class AssetRegistry extends Registry { /** * Get a list of all existing asset registries. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @return {Promise} A promise that will be resolved with a list of {@link AssetRegistry} * instances representing the asset registries. */ static getAllAssetRegistries(securityContext, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getAllRegistries(securityContext, REGISTRY_TYPE) .then((assetRegistries) =&gt; { return assetRegistries.map((assetRegistry) =&gt; { return new AssetRegistry(assetRegistry.id, assetRegistry.name, securityContext, modelManager, factory, serializer); }); }); } /** * Get an existing asset registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the asset registry. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @return {Promise} A promise that will be resolved with a {@link AssetRegistry} * instance representing the asset registry. */ static getAssetRegistry(securityContext, id, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getRegistry(securityContext, REGISTRY_TYPE, id) .then((registry) =&gt; { return new AssetRegistry(registry.id, registry.name, securityContext, modelManager, factory, serializer); }); } /** * Determine whether an registry exists. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the asset registry. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @return {Promise} A promise that will be resolved with a boolean indicating whether the asset registry exists */ static existsAssetRegistry(securityContext, id, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.existsRegistry(securityContext, REGISTRY_TYPE, id); } /** * Add a new asset registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the asset registry. * @param {string} name The name of the asset registry. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @return {Promise} A promise that will be resolved with a {@link AssetRegistry} * instance representing the new asset registry. */ static addAssetRegistry(securityContext, id, name, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.addRegistry(securityContext, REGISTRY_TYPE, id, name) .then(() =&gt; { return new AssetRegistry(id, name, securityContext, modelManager, factory, serializer); }); } /** * Create an asset registry. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkConnection}&lt;/strong&gt; * &lt;/p&gt; * @protected * @param {string} id The unique identifier of the asset registry. * @param {string} name The display name for the asset registry. * @param {SecurityContext} securityContext The security context to use for this asset registry. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. */ constructor(id, name, securityContext, modelManager, factory, serializer) { super(REGISTRY_TYPE, id, name, securityContext, modelManager, factory, serializer); } } module.exports = AssetRegistry; Ã— Search results Close "},"composer-runtime_lib_registry.js.html":{"id":"composer-runtime_lib_registry.js.html","title":"Source: composer-runtime/lib/registry.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/registry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const EventEmitter = require('events'); const Resource = require('composer-common').Resource; /** * A class for managing and persisting resources. * @protected */ class Registry extends EventEmitter { /** * Constructor. * @param {string} dataCollection The data collection to use. * @param {Serializer} serializer The serializer to use. * @param {AccessController} accessController The access controller to use. * @param {string} type The type of the registry. * @param {string} id The ID of the registry. * @param {string} name The name of the registry. */ constructor(dataCollection, serializer, accessController, type, id, name) { super(); this.dataCollection = dataCollection; this.serializer = serializer; this.accessController = accessController; this.type = type; this.id = id; this.name = name; } /** * Get all the resources in this registry. * @return {Promise} A promise that will be resolved with an array of {@link * Resource} objects when complete, or rejected with an error. */ getAll() { return this.dataCollection.getAll() .then((resources) =&gt; { return resources.map((resource) =&gt; { return this.serializer.fromJSON(resource); }).filter((resource) =&gt; { try { this.accessController.check(resource, 'READ'); return true; } catch (e) { return false; } }); }); } /** * Get the specified resource in this registry. * @param {string} id The ID of the resource. * @return {Promise} A promise that will be resolved with a {@link Resource} * object when complete, or rejected with an error. */ get(id) { return Promise.resolve() .then(() =&gt; { return this.dataCollection.get(id); }) .then((resource) =&gt; { let result = this.serializer.fromJSON(resource); try { this.accessController.check(result, 'READ'); return result; } catch (e) { throw new Error(`Object with ID '${id}' in collection with ID '${this.type}:${this.id}' does not exist`); } }); } /** * Determine whether the specified resource exists in this registry. * @param {string} id The ID of the resource. * @return {Promise} A promise that will be resolved with a boolean * indicating whether the asset exists. */ exists(id) { return this.dataCollection.exists(id) .then((exists) =&gt; { if (exists) { return this.dataCollection.get(id) .then((resource) =&gt; { let result = this.serializer.fromJSON(resource); try { this.accessController.check(result, 'READ'); return true; } catch (e) { return false; } }); } }); } /** * An event signalling that a resource has been added to this registry. * @event Registry#resourceadded * @protected * @type {object} * @param {Registry} registry The registry. * @param {Resource} resource The resource. */ /** * Add all of the specified resources to this registry. * @param {Resource[]} resources The resources to add to this registry. * @param {Object} [options] Options for processing the resources. * @param {boolean} [options.convertResourcesToRelationships] Permit resources * in the place of relationships, defaults to false. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ addAll(resources, options) { options = options || {}; return resources.reduce((result, resource) =&gt; { return result.then(() =&gt; { return this.add(resource, options); }); }, Promise.resolve()); } /** * Add the specified resource to this registry. * @param {Resource} resource The resource to add to this registry. * @param {Object} [options] Options for processing the resources. * @param {boolean} [options.convertResourcesToRelationships] Permit resources * in the place of relationships, defaults to false. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ add(resource, options) { this.accessController.check(resource, 'CREATE'); options = options || {}; let id = resource.getIdentifier(); let object = this.serializer.toJSON(resource, { convertResourcesToRelationships: options.convertResourcesToRelationships }); return this.dataCollection.add(id, object) .then(() =&gt; { this.emit('resourceadded', { registry: this, resource: resource }); }); } /** * An event signalling that a resource has been updated in this registry. * @event Registry#resourceupdated * @protected * @type {object} * @param {Registry} registry The registry. * @param {Resource} oldResource The old version of the resource. * @param {Resource} newResource The new version of the resource. */ /** * Update all of the specified resources in this registry. * @param {Resource[]} resources The resources to update in this registry. * @param {Object} [options] Options for processing the resources. * @param {boolean} [options.convertResourcesToRelationships] Permit resources * in the place of relationships, defaults to false. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ updateAll(resources, options) { options = options || {}; return resources.reduce((result, resource) =&gt; { return result.then(() =&gt; { return this.update(resource, options); }); }, Promise.resolve()); } /** * Update the specified resource in this registry. * @param {Resource} resource The resource to update in this registry. * @param {Object} [options] Options for processing the resources. * @param {boolean} [options.convertResourcesToRelationships] Permit resources * in the place of relationships, defaults to false. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ update(resource, options) { options = options || {}; let id = resource.getIdentifier(); let object = this.serializer.toJSON(resource, { convertResourcesToRelationships: options.convertResourcesToRelationships }); return this.dataCollection.get(id) .then((oldResource) =&gt; { return this.serializer.fromJSON(oldResource); }) .then((oldResource) =&gt; { // We must perform access control checks on the old version of the resource! this.accessController.check(oldResource, 'UPDATE'); return this.dataCollection.update(id, object) .then(() =&gt; { this.emit('resourceupdated', { registry: this, oldResource: oldResource, newResource: resource }); }); }); } /** * An event signalling that a resource has been removed from this registry. * @event Registry#resourceremoved * @protected * @type {object} * @param {Registry} registry The registry. * @param {string} resourceID The ID of the resource. */ /** * Remove all of the specified resources from this registry. * @param {string[]|Resource[]} resources The resources to remove from this registry. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ removeAll(resources) { return resources.reduce((result, resource) =&gt; { return result.then(() =&gt; { return this.remove(resource); }); }, Promise.resolve()); } /** * Remove the specified resource from this registry. * @param {string|Resource} resource The resource to remove from this registry. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ remove(resource) { return Promise.resolve() .then(() =&gt; { // If the resource is a string, then we need to retrieve // the resource using its ID from the registry. We need to // do this to figure out the type of the resource for // access control. if (resource instanceof Resource) { return resource; } else { return this.dataCollection.get(resource) .then((resource) =&gt; { return this.serializer.fromJSON(resource); }); } }) .then((resource) =&gt; { this.accessController.check(resource, 'DELETE'); let id = resource.getIdentifier(); return this.dataCollection.remove(id) .then(() =&gt; { this.emit('resourceremoved', { registry: this, resourceID: id }); }); }); } /** * Return an object suitable for serialization. * @return {Object} An object suitable for serialization. */ toJSON() { return { type: this.type, id: this.id, name: this.name }; } } module.exports = Registry; Ã— Search results Close "},"composer-client_lib_businessnetworkconnection.js.html":{"id":"composer-client_lib_businessnetworkconnection.js.html","title":"Source: composer-client/lib/businessnetworkconnection.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-client/lib/businessnetworkconnection.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AssetRegistry = require('./assetregistry'); const BusinessNetworkDefinition = require('composer-common').BusinessNetworkDefinition; const ConnectionProfileManager = require('composer-common').ConnectionProfileManager; const EventEmitter = require('events'); const fs = require('fs'); const FSConnectionProfileStore = require('composer-common').FSConnectionProfileStore; const Logger = require('composer-common').Logger; const ParticipantRegistry = require('./participantregistry'); const Resource = require('composer-common').Resource; const TransactionDeclaration = require('composer-common').TransactionDeclaration; const TransactionRegistry = require('./transactionregistry'); const Util = require('composer-common').Util; const uuid = require('uuid'); const LOG = Logger.getLog('BusinessNetworkConnection'); /** * Use this class to connect to and then interact with a deployed BusinessNetworkDefinition. * Use the AdminConnection class in the composer-admin module to deploy BusinessNetworksDefinitions. * @extends EventEmitter * @see See [EventEmitter]{@link module:composer-client.EventEmitter} * @class * @memberof module:composer-client */ class BusinessNetworkConnection extends EventEmitter { /** * Create an instance of the BusinessNetworkConnection class. * must be called to connect to a deployed BusinessNetworkDefinition. * @param {Object} [options] - an optional set of options to configure the instance. * @param {Object} [options.fs] - specify an fs implementation to use. * @param {boolean} [options.developmentMode] - specify whether or not the instance * is in development mode. Use only for testing purposes! */ constructor(options) { super(); options = options || {}; this.developmentMode = options.developmentMode || false; this.connection = null; this.connectionProfileStore = new FSConnectionProfileStore(options.fs || fs); this.connectionProfileManager = new ConnectionProfileManager(this.connectionProfileStore); this.connection = null; this.securityContext = null; this.businessNetwork = null; } /** * Returns the currently connected BusinessNetworkDefinition * @example * // Get the Business Network Definition * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.getBusinessNetwork(); * }) * .then(function(BusinessNetworkDefinition){ * // Retrieved Business Network Definition * }); * @returns {BusinessNetworkDefinition} the business network */ getBusinessNetwork() { return this.businessNetwork; } /** * Get a list of all existing asset registries. * @example * // Get all asset registries * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.getAllAssetRegistries(); * }) * .then(function(assetRegistries){ * // Retrieved Asset Registries * }); * @param {SecurityContext} securityContext - The user's security context * @return {Promise} - A promise that will be resolved with a list of existing * asset registries */ getAllAssetRegistries() { Util.securityCheck(this.securityContext); return AssetRegistry.getAllAssetRegistries(this.securityContext, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer()); } /** * Get an existing asset registry. * @example * // Get a asset registry * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.getAssetRegistry('businessNetworkIdentifier.registryId'); * }) * .then(function(assetRegistry){ * // Retrieved Asset Registry * }); * @param {string} id - The unique identifier of the asset registry * @return {Promise} - A promise that will be resolved with the existing asset * registry, or rejected if the asset registry does not exist. */ getAssetRegistry(id) { Util.securityCheck(this.securityContext); return AssetRegistry.getAssetRegistry(this.securityContext, id, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer()); } /** * Determine whether a asset registry exists. * @example * // Determine whether an asset registry exists * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.existsAssetRegistry('businessNetworkIdentifier.registryId'); * }) * .then(function(exists){ * // if (exists === true) { * // logic here... * //} * }); * @param {string} id - The unique identifier of the asset registry * @return {Promise} - A promise that will be resolved with a boolean indicating whether the asset * registry exists. */ existsAssetRegistry(id) { Util.securityCheck(this.securityContext); return AssetRegistry.existsAssetRegistry(this.securityContext, id, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer()); } /** * Add a new asset registry. * @example * // Add a new asset registry * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.addAssetRegistry('registryId','registryName'); * }); * @param {string} id - The unique identifier of the asset registry * @param {string} name - The name of the asset registry * @return {Promise} - A promise that will be resolved with the new asset * registry after it has been added. */ addAssetRegistry(id, name) { Util.securityCheck(this.securityContext); return AssetRegistry.addAssetRegistry(this.securityContext, id, name, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer()); } /** * Get a list of all existing participant registries. * @example * // Get all participant registries * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.getAllParticipantRegistries(); * }) * .then(function(participantRegistries){ * // Retrieved Participant Registries * }); * @param {SecurityContext} securityContext - The user's security context * @return {Promise} - A promise that will be resolved with a list of existing * participant registries */ getAllParticipantRegistries() { Util.securityCheck(this.securityContext); return ParticipantRegistry.getAllParticipantRegistries(this.securityContext, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer()); } /** * Get an existing participant registry. * @example * // Get a participant registry * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.getParticipantRegistry('businessNetworkIdentifier.registryId'); * }) * .then(function(participantRegistry){ * // Retrieved Participant Registry * }); * @param {string} id - The unique identifier of the participant registry * @return {Promise} - A promise that will be resolved with the existing participant * registry, or rejected if the participant registry does not exist. */ getParticipantRegistry(id) { Util.securityCheck(this.securityContext); return ParticipantRegistry.getParticipantRegistry(this.securityContext, id, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer()); } /** * Add a new participant registry. * @example * // Add a new participant registry * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.addParticipantRegistry('registryId','registryName'); * }); * @param {string} id - The unique identifier of the participant registry * @param {string} name - The name of the participant registry * @return {Promise} - A promise that will be resolved with the new participant * registry after it has been added. */ addParticipantRegistry(id, name) { Util.securityCheck(this.securityContext); return ParticipantRegistry.addParticipantRegistry(this.securityContext, id, name, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer()); } /** * Get the transaction registry. * @example * // Get the transaction registry * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.getTransactionRegistry(); * }) * .then(function(transactionRegistry){ * // Retrieved Transaction Registry * }); * @return {Promise} - A promise that will be resolved to the {@link TransactionRegistry} */ getTransactionRegistry() { Util.securityCheck(this.securityContext); return TransactionRegistry .getAllTransactionRegistries(this.securityContext, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer()) .then((transactionRegistries) =&gt; { if (transactionRegistries.length &gt;= 1) { return transactionRegistries[0]; } else { throw new Error('Failed to find the default transaction registry'); } }); } /** * Connects to a business network using a connection profile, and authenticates to the Hyperledger Fabric. * @example * // Connect and log in to HLF * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * // Connected * }); * @param {string} connectionProfile - The name of the connection profile * @param {string} businessNetwork - The identifier of the business network * @param {string} enrollmentID the enrollment ID of the user * @param {string} enrollmentSecret the enrollment secret of the user * @return {Promise} A promise to a BusinessNetworkDefinition that indicates the connection is complete */ connect(connectionProfile, businessNetwork, enrollmentID, enrollmentSecret) { return this.connectionProfileManager.connect(connectionProfile, businessNetwork) .then((connection) =&gt; { this.connection = connection; return connection.login(enrollmentID, enrollmentSecret); }) .then((securityContext) =&gt; { this.securityContext = securityContext; return this.connection.ping(this.securityContext); }) .then(() =&gt; { return Util.queryChainCode(this.securityContext, 'getBusinessNetwork', []); }) .then((buffer) =&gt; { let businessNetworkJSON = JSON.parse(buffer.toString()); let businessNetworkArchive = Buffer.from(businessNetworkJSON.data, 'base64'); return BusinessNetworkDefinition.fromArchive(businessNetworkArchive); }) .then((businessNetwork) =&gt; { this.businessNetwork = businessNetwork; return this.businessNetwork; }); } /** * Disconnects from the Hyperledger Fabric. * @example * // Disconnects from HLF * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.disconnect(); * }) * .then(function(){ * // Disconnected. * }); * @return {Promise} A promise that will be resolved when the connection is * terminated. */ disconnect() { if (!this.connection) { return Promise.resolve(); } return this.connection.disconnect() .then(() =&gt; { this.connection = null; this.securityContext = null; this.businessNetwork = null; }); } /** * Submit a transaction for processing by the currently connected business network. * @example * // Submits a transaction * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * var factory = businessNetworkDefinition.getBusinessNetwork().getFactory(); * var transaction = factory.newTransaction('network.transactions', 'TransactionType'); * return businessNetworkDefinition.submitTransaction(transaction); * }) * .then(function(){ * // Submitted a transaction. * }); * @param {Resource} transaction - The transaction to submit. Use {@link * Factory#newTransaction newTransaction} to create this object. * @return {Promise} A promise that will be fulfilled when the transaction has * been processed. */ submitTransaction(transaction) { const self = this; Util.securityCheck(this.securityContext); if (!transaction) { throw new Error('transaction not specified'); } let classDeclaration = transaction.getClassDeclaration(); if (!(classDeclaration instanceof TransactionDeclaration)) { throw new Error(classDeclaration.getFullyQualifiedName() + ' is not a transaction'); } let id = transaction.getIdentifier(); if (id === null || id === undefined) { id = uuid.v4(); transaction.setIdentifier(id); } let timestamp = transaction.timestamp; if (timestamp === null || timestamp === undefined) { timestamp = transaction.timestamp = new Date(); } let data = self.getBusinessNetwork().getSerializer().toJSON(transaction); return self.getTransactionRegistry(self.securityContext) .then((transactionRegistry) =&gt; { return Util.invokeChainCode(self.securityContext, 'submitTransaction', [transactionRegistry.id, JSON.stringify(data)]); }); } /** * Test the connection to the runtime and verify that the version of the * runtime is compatible with this level of the client node.js module. * @example * // Test the connection to the runtime * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.ping(); * }) * .then(function(){ * // Connection tested. * }); * @return {Promise} A promise that will be fufilled when the connection has * been tested. The promise will be rejected if the version is incompatible. */ ping() { Util.securityCheck(this.securityContext); return this.connection.ping(this.securityContext); } /** * Issue an identity with the specified user ID and map it to the specified * participant. * @param {Resource|string} participant The participant, or the fully qualified * identifier of the participant. The participant must already exist. * @param {string} userID The user ID for the identity. * @param {object} [options] Options for the new identity. * @param {boolean} [options.issuer] Whether or not the new identity should have * permissions to create additional new identities. False by default. * @return {Promise} A promise that will be fulfilled when the identity has * been added to the specified participant. The promise will be rejected if * the participant does not exist, or if the identity is already mapped to * another participant. */ issueIdentity(participant, userID, options) { const method = 'issueIdentity'; LOG.entry(method, participant, userID); if (!participant) { throw new Error('participant not specified'); } else if (!userID) { throw new Error('userID not specified'); } let participantFQI; if (participant instanceof Resource) { participantFQI = participant.getFullyQualifiedIdentifier(); } else { participantFQI = participant; } Util.securityCheck(this.securityContext); return this.connection.createIdentity(this.securityContext, userID, options) .then((identity) =&gt; { return Util.invokeChainCode(this.securityContext, 'addParticipantIdentity', [participantFQI, userID]) .then(() =&gt; { LOG.exit(method, identity); return identity; }); }); } /** * Revoke the specified identity by removing any existing mapping to a participant. * @param {string} identity The identity, for example the enrollment ID. * @return {Promise} A promise that will be fulfilled when the identity has * been removed from the specified participant. The promise will be rejected if * the participant does not exist, or if the identity is not mapped to the * participant. */ revokeIdentity(identity) { const method = 'revokeIdentity'; LOG.entry(method, identity); if (!identity) { throw new Error('identity not specified'); } Util.securityCheck(this.securityContext); // It is not currently possible to revoke the certificate, so we just call // the runtime to remove the mapping. return Util.invokeChainCode(this.securityContext, 'removeIdentity', [identity]) .then(() =&gt; { LOG.exit(method); }); } } module.exports = BusinessNetworkConnection; Ã— Search results Close "},"composer-client_lib_participantregistry.js.html":{"id":"composer-client_lib_participantregistry.js.html","title":"Source: composer-client/lib/participantregistry.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-client/lib/participantregistry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Registry = require('./registry'); const Util = require('composer-common').Util; const REGISTRY_TYPE = 'Participant'; /** * The ParticipantRegistry is used to manage a set of participants stored on the blockchain. * &lt;p&gt;&lt;a href=&quot;./diagrams/participantregistry.svg&quot;&gt;&lt;img src=&quot;./diagrams/participantregistry.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends Registry * @see See [Registry]{@link module:composer-client.Registry} * @class * @memberof module:composer-client */ class ParticipantRegistry extends Registry { /** * Get a list of all existing participant registries. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {ModelManager} modelManager The ModelManager to use for this participant registry. * @param {Factory} factory The factory to use for this participant registry. * @param {Serializer} serializer The Serializer to use for this participant registry. * @return {Promise} A promise that will be resolved with a list of {@link ParticipantRegistry} * instances representing the participant registries. */ static getAllParticipantRegistries(securityContext, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getAllRegistries(securityContext, REGISTRY_TYPE) .then((participantRegistries) =&gt; { return participantRegistries.map((participantRegistry) =&gt; { return new ParticipantRegistry(participantRegistry.id, participantRegistry.name, securityContext, modelManager, factory, serializer); }); }); } /** * Get an existing participant registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the participant registry. * @param {ModelManager} modelManager The ModelManager to use for this participant registry. * @param {Factory} factory The factory to use for this participant registry. * @param {Serializer} serializer The Serializer to use for this participant registry. * @return {Promise} A promise that will be resolved with a {@link ParticipantRegistry} * instance representing the participant registry. */ static getParticipantRegistry(securityContext, id, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getRegistry(securityContext, REGISTRY_TYPE, id) .then((registry) =&gt; { return new ParticipantRegistry(registry.id, registry.name, securityContext, modelManager, factory, serializer); }); } /** * Add a new participant registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the participant registry. * @param {string} name The name of the participant registry. * @param {ModelManager} modelManager The ModelManager to use for this participant registry. * @param {Factory} factory The factory to use for this participant registry. * @param {Serializer} serializer The Serializer to use for this participant registry. * @return {Promise} A promise that will be resolved with a {@link ParticipantRegistry} * instance representing the new participant registry. */ static addParticipantRegistry(securityContext, id, name, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.addRegistry(securityContext, REGISTRY_TYPE, id, name) .then(() =&gt; { return new ParticipantRegistry(id, name, securityContext, modelManager, factory, serializer); }); } /** * Create an participant registry. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkConnection}&lt;/strong&gt; * &lt;/p&gt; * @protected * @param {string} id The unique identifier of the participant registry. * @param {string} name The display name for the participant registry. * @param {SecurityContext} securityContext The security context to use for this participant registry. * @param {ModelManager} modelManager The ModelManager to use for this participant registry. * @param {Factory} factory The factory to use for this participant registry. * @param {Serializer} serializer The Serializer to use for this participant registry. */ constructor(id, name, securityContext, modelManager, factory, serializer) { super(REGISTRY_TYPE, id, name, securityContext, modelManager, factory, serializer); } } module.exports = ParticipantRegistry; Ã— Search results Close "},"composer-client_lib_registry.js.html":{"id":"composer-client_lib_registry.js.html","title":"Source: composer-client/lib/registry.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-client/lib/registry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Resource = require('composer-common').Resource; const Util = require('composer-common').Util; /** * Class representing an Abstract Registry. * &lt;p&gt;&lt;a href=&quot;./diagrams/registry.svg&quot;&gt;&lt;img src=&quot;./diagrams/registry.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @abstract * @class * @memberof module:composer-client */ class Registry { /** * Get a list of all existing registries. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} registryType The type of this registry. * @return {Promise} A promise that will be resolved with an array of JSON * objects representing the registries. */ static getAllRegistries(securityContext, registryType) { Util.securityCheck(securityContext); if (!registryType) { throw new Error('registryType not specified'); } return Util.queryChainCode(securityContext, 'getAllRegistries', [registryType]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }); } /** * Get an existing registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} registryType The type of this registry. * @param {string} id The unique identifier of the registry. * @return {Promise} A promise that will be resolved with a JSON object * representing the registry. */ static getRegistry(securityContext, registryType, id) { Util.securityCheck(securityContext); if (!registryType) { throw new Error('registryType not specified'); } else if (!id) { throw new Error('id not specified'); } return Util.queryChainCode(securityContext, 'getRegistry', [registryType, id]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }); } /** * Determines whether a registry exists. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} registryType The type of this registry. * @param {string} id The unique identifier of the registry. * @return {Promise} A promise that will be resolved with true/false depending on whether the registry exists */ static existsRegistry(securityContext, registryType, id) { Util.securityCheck(securityContext); if (!registryType) { throw new Error('registryType not specified'); } else if (!id) { throw new Error('id not specified'); } return Util.queryChainCode(securityContext, 'existsRegistry', [registryType, id]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }); } /** * Add a new asset registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} registryType The type of this registry. * @param {string} id The unique identifier of the registry. * @param {string} name The name of the registry. * @return {Promise} A promise that will be resolved with a JSON object * representing the registry. */ static addRegistry(securityContext, registryType, id, name) { Util.securityCheck(securityContext); if (!registryType) { throw new Error('registryType not specified'); } else if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } return Util.invokeChainCode(securityContext, 'addRegistry', [registryType, id, name]) .then(() =&gt; { return { id: id, name: name }; }); } /** * Create a registry. * * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkConnection}&lt;/strong&gt; * &lt;/p&gt; * * @protected * @param {string} registryType The type of this registry. * @param {string} id The unique identifier of the registry. * @param {string} name The display name for the registry. * @param {SecurityContext} securityContext The users security context. * @param {ModelManager} modelManager The ModelManager to use for this registry. * @param {Factory} factory The factory to use for this registry. * @param {Serializer} serializer The Serializer to use for this registry. */ constructor(registryType, id, name, securityContext, modelManager, factory, serializer) { if (!registryType) { throw new Error('registryType not specified'); } else if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } else if (!securityContext) { throw new Error('securityContext not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } this.registryType = registryType; this.id = id; this.name = name; this.securityContext = securityContext; this.modelManager = modelManager; this.factory = factory; this.serializer = serializer; } /** * Adds a list of new resources to the registry. * * @param {Resource[]} resources The resources to be added to the registry. * @return {Promise} A promise that will be resolved when the resource is * added to the registry. */ addAll(resources) { Util.securityCheck(this.securityContext); if (!resources) { throw new Error('resources not specified'); } let serializedResources = resources.map((resource) =&gt; { return this.serializer.toJSON(resource); }); return Util.invokeChainCode(this.securityContext, 'addAllResourcesToRegistry', [this.registryType, this.id, JSON.stringify(serializedResources)]); } /** * Adds a new resource to the registry. * * @param {Resource} resource The resource to be added to the registry. * @return {Promise} A promise that will be resolved when the resource is * added to the registry. */ add(resource) { Util.securityCheck(this.securityContext); if (!resource) { throw new Error('resource not specified'); } let serializedResource = this.serializer.toJSON(resource); return Util.invokeChainCode(this.securityContext, 'addResourceToRegistry', [this.registryType, this.id, JSON.stringify(serializedResource)]); } /** * Updates a list of resources in the registry. * * @param {Resource[]} resources The resources to be updated in the asset registry. * @return {Promise} A promise that will be resolved when the resource is * added to the registry. */ updateAll(resources) { Util.securityCheck(this.securityContext); if (!resources) { throw new Error('resources not specified'); } let serializedResources = resources.map((resource) =&gt; { return this.serializer.toJSON(resource); }); return Util.invokeChainCode(this.securityContext, 'updateAllResourcesInRegistry', [this.registryType, this.id, JSON.stringify(serializedResources)]); } /** * Updates a resource in the registry. * * @param {Resource} resource The resource to be updated in the registry. * @return {Promise} A promise that will be resolved when the resource is * updated in the registry. */ update(resource) { Util.securityCheck(this.securityContext); if (!resource) { throw new Error('resource not specified'); } let serializedResource = this.serializer.toJSON(resource); return Util.invokeChainCode(this.securityContext, 'updateResourceInRegistry', [this.registryType, this.id, JSON.stringify(serializedResource)]); } /** * Removes a list of resources from the registry. * * @param {(Resource[]|string[])} resources The resources, or the unique identifiers of the resources. * @return {Promise} A promise that will be resolved when the resource is * added to the registry. */ removeAll(resources) { Util.securityCheck(this.securityContext); if (!resources) { throw new Error('resources not specified'); } let data = resources.map((resource) =&gt; { if (resource instanceof Resource) { return resource.getIdentifier(); } else { return resource; } }); return Util.invokeChainCode(this.securityContext, 'removeAllResourcesFromRegistry', [this.registryType, this.id, JSON.stringify(data)]); } /** * Remove an asset with a given type and id from the registry. * * @param {(Resource|string)} resource The resource, or the unique identifier of the resource. * @return {Promise} A promise that will be resolved when the resource is * removed from the registry. */ remove(resource) { Util.securityCheck(this.securityContext); if (!resource) { throw new Error('resource not specified'); } let id; if (resource instanceof Resource) { id = resource.getIdentifier(); } else { id = resource; } return Util.invokeChainCode(this.securityContext, 'removeResourceFromRegistry', [this.registryType, this.id, id]); } /** * Get all of the resources in the registry. * * @return {Promise} A promise that will be resolved with an array of JSON * objects representing the resources. */ getAll() { Util.securityCheck(this.securityContext); return Util.queryChainCode(this.securityContext, 'getAllResourcesInRegistry', [this.registryType, this.id]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }) .then((resources) =&gt; { return resources.map((resource) =&gt; { return this.serializer.fromJSON(resource); }); }); } /** * Get a specific resource in the registry. * * @param {string} id The unique identifier of the resource. * @return {Promise} A promise that will be resolved with a JSON object * representing the resource. */ get(id) { Util.securityCheck(this.securityContext); if (!id) { throw new Error('id not specified'); } return Util.queryChainCode(this.securityContext, 'getResourceInRegistry', [this.registryType, this.id, id]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }) .then((resource) =&gt; { return this.serializer.fromJSON(resource); }); } /** * Determines whether a specific resource exists in the registry. * * @param {string} id The unique identifier of the resource. * @return {Promise} A promise that will be resolved with true/false depending on whether the resource exists. */ exists(id) { Util.securityCheck(this.securityContext); if (!id) { throw new Error('id not specified'); } return Util.queryChainCode(this.securityContext, 'existsResourceInRegistry', [this.registryType, this.id, id]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }); } /** * Find resources in the registry that match the specified JSONata expression. * The JSONata expression is applied to each resource in the registry, and * resources are returned if the JSONata expression returns a truthy value for that * resource. * * @param {string} expression The JSONata expression. * @return {Promise} A promise that will be resolved with an array of {@link * Resource} instances representing the assets that match the query. */ find(expression) { Util.securityCheck(this.securityContext); if (!expression) { throw new Error('expression not specified'); } return Util.queryChainCode(this.securityContext, 'findResourcesInRegistry', [this.registryType, this.id, expression]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }) .then((resources) =&gt; { return resources.map((resource) =&gt; { return this.serializer.fromJSON(resource); }); }); } /** * Execute a query against all resources in the registry. The JSONata * expression is applied to each resource in the registry, and the result * of the JSONata expression is returned if the result is truthy. The result * is a JavaScript object, and should only be used for visualization * purposes. You cannot use the {@link add} or {@link update} functions with * data returned by this function. * * @param {string} expression The JSONata expression. * @return {Promise} A promise that will be resolved with an array of JavaScript * objects representing the resources and all of their resolved relationships. */ query(expression) { Util.securityCheck(this.securityContext); if (!expression) { throw new Error('expression not specified'); } return Util.queryChainCode(this.securityContext, 'queryResourcesInRegistry', [this.registryType, this.id, expression]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }); } /** * Get all of the resources in the registry, and resolve all of their relationships * to other assets, participants, and transactions. The result is a JavaScript * object, and should only be used for visualization purposes. You cannot use * the {@link add} or {@link update} functions with a resolved resource. * * @return {Promise} A promise that will be resolved with an array of JavaScript * objects representing the resources and all of their resolved relationships. */ resolveAll() { Util.securityCheck(this.securityContext); return Util.queryChainCode(this.securityContext, 'resolveAllResourcesInRegistry', [this.registryType, this.id]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }); } /** * Get a specific resource in the registry, and resolve all of its relationships * to other assets, participants, and transactions. The result is a JavaScript * object, and should only be used for visualization purposes. You cannot use * the {@link add} or {@link update} functions with a resolved resource. * * @param {string} id The unique identifier of the asset. * @return {Promise} A promise that will be resolved with a JavaScript object * representing the resource and all of its resolved relationships. */ resolve(id) { Util.securityCheck(this.securityContext); if (!id) { throw new Error('id not specified'); } return Util.queryChainCode(this.securityContext, 'resolveResourceInRegistry', [this.registryType, this.id, id]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }); } } module.exports = Registry; Ã— Search results Close "},"composer-client_lib_transactionregistry.js.html":{"id":"composer-client_lib_transactionregistry.js.html","title":"Source: composer-client/lib/transactionregistry.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-client/lib/transactionregistry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Registry = require('./registry'); const Util = require('composer-common').Util; const REGISTRY_TYPE = 'Transaction'; /** * The TransactionRegistry is used to store a set of transactions on the blockchain. * &lt;p&gt;&lt;a href=&quot;./diagrams/transactionregistry.svg&quot;&gt;&lt;img src=&quot;./diagrams/transactionregistry.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends Registry * @see See [Registry]{@link module:composer-client.Registry} * @class * @memberof module:composer-client */ class TransactionRegistry extends Registry { /** * Get a list of all existing transaction registries. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {ModelManager} modelManager The ModelManager to use for this transaction registry. * @param {Factory} factory The factory to use for this transaction registry. * @param {Serializer} serializer The Serializer to use for this transaction registry. * @return {Promise} A promise that will be resolved with a list of {@link TransactionRegistry} * instances representing the transaction registries. */ static getAllTransactionRegistries(securityContext, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getAllRegistries(securityContext, REGISTRY_TYPE) .then((transactionRegistries) =&gt; { return transactionRegistries.map((transactionRegistry) =&gt; { return new TransactionRegistry(transactionRegistry.id, transactionRegistry.name, securityContext, modelManager, factory, serializer); }); }); } /** * Get an existing transaction registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the transaction registry. * @param {ModelManager} modelManager The ModelManager to use for this transaction registry. * @param {Factory} factory The factory to use for this transaction registry. * @param {Serializer} serializer The Serializer to use for this transaction registry. * @return {Promise} A promise that will be resolved with a {@link TransactionRegistry} * instance representing the transaction registry. */ static getTransactionRegistry(securityContext, id, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getRegistry(securityContext, REGISTRY_TYPE, id) .then((registry) =&gt; { return new TransactionRegistry(registry.id, registry.name, securityContext, modelManager, factory, serializer); }); } /** * Add a new transaction registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the transaction registry. * @param {string} name The name of the transaction registry. * @param {ModelManager} modelManager The ModelManager to use for this transaction registry. * @param {Factory} factory The factory to use for this transaction registry. * @param {Serializer} serializer The Serializer to use for this transaction registry. * @return {Promise} A promise that will be resolved with a {@link TransactionRegistry} * instance representing the new transaction registry. */ static addTransactionRegistry(securityContext, id, name, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.addRegistry(securityContext, REGISTRY_TYPE, id, name) .then(() =&gt; { return new TransactionRegistry(id, name, securityContext, modelManager, factory, serializer); }); } /** * Create an transaction registry. * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkConnection}&lt;/strong&gt; * &lt;/p&gt; * * @protected * @param {string} id The unique identifier of the transaction registry. * @param {string} name The display name for the transaction registry. * @param {SecurityContext} securityContext The security context to use for this asset registry. * @param {ModelManager} modelManager The ModelManager to use for this transaction registry. * @param {Factory} factory The factory to use for this transaction registry. * @param {Serializer} serializer The Serializer to use for this transaction registry. */ constructor(id, name, securityContext, modelManager, factory, serializer) { super(REGISTRY_TYPE, id, name, securityContext, modelManager, factory, serializer); } /** * Unsupported operation; you cannot add a transaction to a transaction * registry. Call {@link BusinessNetworkConnection.submitTransaction} to submit a transaction. * * @param {Resource} resource The resource to be added to the registry. * @param {string} data The data for the resource. */ add(resource) { throw new Error('cannot add transactions to a transaction registry'); } /** * Unsupported operation; you cannot add a transaction to a transaction * registry. Call {@link BusinessNetworkConnection.submitTransaction} to submit a transaction. * * @param {Resource[]} resources The resources to be added to the registry. */ addAll(resources) { throw new Error('cannot add transactions to a transaction registry'); } /** * Unsupported operation; you cannot update a transaction in a transaction * registry. This method will always throw an exception when called. * * @param {Resource} resource The resource to be updated in the registry. */ update(resource) { throw new Error('cannot update transactions in a transaction registry'); } /** * Unsupported operation; you cannot update a transaction in a transaction * registry. Call {@link BusinessNetworkConnection.submitTransaction} to submit a transaction. * * @param {Resource[]} resources The resources to be updated in the asset registry. */ updateAll(resources) { throw new Error('cannot update transactions in a transaction registry'); } /** * Unsupported operation; you cannot remove a transaction from a transaction * registry. This method will always throw an exception when called. * * @param {(Resource|string)} resource The resource, or the unique identifier of the resource. */ remove(resource) { throw new Error('cannot remove transactions from a transaction registry'); } /** * Unsupported operation; you cannot remove a transaction from a transaction * registry. This method will always throw an exception when called. * * @param {(Resource[]|string[])} resources The resources, or the unique identifiers of the resources. */ removeAll(resources) { throw new Error('cannot remove transactions from a transaction registry'); } } module.exports = TransactionRegistry; Ã— Search results Close "},"composer-common_index.js.html":{"id":"composer-common_index.js.html","title":"Source: composer-common/index.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/index.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Fabric-Composer module. Fabric-Composer is a framework for creating * blockchain backed digital networks and exchanging assets between participants * via processing transactions. * @module composer-common */ /* istanbul ignore next */ if (!nodeHasNewBufferVersion()) { const originalBufferFrom = Buffer.from; const newBufferFrom = function (str, encoding) { if (arguments.length === 2 &amp;&amp; typeof str === 'string' &amp;&amp; encoding === 'base64') { return new Buffer(str, encoding); } return originalBufferFrom.apply(null, arguments); }; Object.defineProperty(Buffer, 'from', { value: newBufferFrom }); } /** * Check whether we're running in a version of node which has the updated Buffer implementation * Used above to fall back to the old version if needed. * @return {boolean} whether the new version is supported */ function nodeHasNewBufferVersion() { try { Buffer.from('b2xkbm9kZQ==', 'base64'); return true; } catch (e) { return false; } } module.exports.AclFile = require('./lib/acl/aclfile'); module.exports.AclManager = require('./lib/aclmanager'); module.exports.AssetDeclaration = require('./lib/introspect/assetdeclaration'); module.exports.BaseException = require('./lib/baseexception'); module.exports.BusinessNetworkDefinition = require('./lib/businessnetworkdefinition'); module.exports.ClassDeclaration = require('./lib/introspect/classdeclaration'); module.exports.Concept = require('./lib/model/concept'); module.exports.Connection = require('./lib/connection'); module.exports.ConnectionManager = require('./lib/connectionmanager'); module.exports.ConnectionProfileManager = require('./lib/connectionprofilemanager'); module.exports.ConnectionProfileStore = require('./lib/connectionprofilestore'); module.exports.Factory = require('./lib/factory'); module.exports.FileWallet = require('./lib/filewallet'); module.exports.FileWriter = require('./lib/codegen/filewriter'); module.exports.FSConnectionProfileStore = require('./lib/fsconnectionprofilestore'); module.exports.Globalize = require('./lib/globalize'); module.exports.Introspector = require('./lib/introspect/introspector'); module.exports.Logger = require('./lib/log/logger'); module.exports.ModelFile = require('./lib/introspect/modelfile'); module.exports.ModelManager = require('./lib/modelmanager'); module.exports.ParticipantDeclaration = require('./lib/introspect/participantdeclaration'); module.exports.Property = require('./lib/introspect/property'); module.exports.Relationship = require('./lib/model/relationship'); module.exports.Resource = require('./lib/model/resource'); module.exports.ScriptManager = require('./lib/scriptmanager'); module.exports.SecurityContext = require('./lib/securitycontext'); module.exports.SecurityException = require('./lib/securityexception'); module.exports.Serializer = require('./lib/serializer'); module.exports.TransactionDeclaration = require('./lib/introspect/transactiondeclaration'); module.exports.TypescriptVisitor = require('./lib/codegen/fromcto/typescript/typescriptvisitor'); module.exports.Util = require('./lib/util'); module.exports.Wallet = require('./lib/wallet'); Ã— Search results Close "},"composer-common_lib_acl_aclfile.js.html":{"id":"composer-common_lib_acl_aclfile.js.html","title":"Source: composer-common/lib/acl/aclfile.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/acl/aclfile.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const parser = require('./parser'); const AclRule = require('./aclrule'); const ParseException = require('../introspect/parseexception'); /** * Class representing an ACL File. * @private * @class * @memberof module:composer-common */ class AclFile { /** * Create an AclFile. This should only be called by framework code. * @param {string} id - The identifier of this ACL File (may be a filename for example) * @param {ModelManager} modelManager - the ModelManager that manages this * ModelFile and that will be used to validate the rules in the AclFile * @param {string} definitions - The ACL rules as a string. * @throws {InvalidModelException} */ constructor(id, modelManager, definitions) { this.modelManager = modelManager; this.rules = []; this.identifier = id; if(!definitions || typeof definitions !== 'string') { throw new Error('AclFile expects an AclFile as a string as input.'); } this.definitions = definitions; try { this.ast = parser.parse(definitions); } catch(err) { if(err.location &amp;&amp; err.location.start) { throw new ParseException( err.message + ' Line ' + err.location.start.line + ' column ' + err.location.start.column, err.location ); } else { throw err; } } for(let n=0; n &lt; this.ast.rules.length; n++ ) { let thing = this.ast.rules[n]; this.rules.push( new AclRule(this, thing)); } // console.log(JSON.stringify(this.ast)); } /** * Returns the identifier of this ACL File. * @return {string} the identifier of this ACL File */ getIdentifier() { return this.identifier; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the ModelManager associated with this AclFile * * @return {ModelManager} The ModelManager for this ModelFile */ getModelManager() { return this.modelManager; } /** * Validates the ModelFile. * * @throws {IllegalModelException} if the model is invalid * @private */ validate() { for(let n=0; n &lt; this.rules.length; n++) { let aclRule = this.rules[n]; aclRule.validate(); } } /** * Get all declarations in this ACL file * @return {AclRule[]} the AclRules defined in the ACL file */ getAclRules() { return this.rules; } /** * Get the definitions for this ACL file. * @return {string} The definitions for this ACL file. */ getDefinitions() { return this.definitions; } /** * Convert the specified JSON into an instance of an ACL file. * @param {ModelManager} modelManager - the ModelManager that manages this * ModelFile * @param {Object} aclFile - A serialized instance of an AclFile. * @param {string} aclFile.definitions - The definitions for the AclFile. * @return {AclFile} An instance of an AclFile. */ static fromJSON(modelManager, aclFile) { return new AclFile(aclFile.identifier, modelManager, aclFile.definitions); } /** * Convert this ACL file into an object that is suitable for converting * into a JSON string for serialization purposes. * @return {Object} An object suitable for converting into a JSON string. */ toJSON() { return { identifier: this.identifier, definitions: this.definitions, }; } } module.exports = AclFile; Ã— Search results Close "},"composer-common_lib_aclmanager.js.html":{"id":"composer-common_lib_aclmanager.js.html","title":"Source: composer-common/lib/aclmanager.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/aclmanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AclFile = require('./acl/aclfile'); /** * &lt;p&gt; * Manages a set of ACL rules. * &lt;/p&gt; * @private * @class * @memberof module:composer-common */ class AclManager { /** * Create the AclManager. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkDefinition}&lt;/strong&gt; * &lt;/p&gt; * @param {ModelManager} modelManager - The ModelManager to use for this AclManager * @param {AclFile} aclFile - The AclFile that stores the rules */ constructor(modelManager) { this.modelManager = modelManager; this.aclFile = null; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Create an ACL file using the specified ID and contents. * @param {string} identifier The identifier of the ACL file. * @param {string} contents The contents of the ACL file. * @return {AclFile} The new ACL file. */ createAclFile(identifier, contents) { return new AclFile(identifier, this.modelManager, contents); } /** * Set the AclFile for this AclManager * @param {AclFile} aclFile - the AclFile to associate with this AclManager * @private */ setAclFile(aclFile) { aclFile.validate(); this.aclFile = aclFile; } /** * Get the AclFile associated with this AclManager * @return {AclFile} The AclFile for this AclManager or null if it has not been set */ getAclFile() { return this.aclFile; } /** * Get the AclRules associated with this AclManager * @return {AclRule[]} The AclRules for the AclManager or an empty array if not set */ getAclRules() { if(this.aclFile) { return this.aclFile.getAclRules(); } return []; } /** * Stop serialization of this object. * @return {Object} An empty object. */ toJSON() { return {}; } } module.exports = AclManager; Ã— Search results Close "},"composer-common_lib_acl_aclrule.js.html":{"id":"composer-common_lib_acl_aclrule.js.html","title":"Source: composer-common/lib/acl/aclrule.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/acl/aclrule.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const IllegalModelException = require('../introspect/illegalmodelexception'); const ModelBinding = require('./modelbinding'); const Predicate = require('./predicate'); /** * AclRule captures the details of an Access Control Rule. It is defined in terms of * an ACTION performed on a NOUN by a PARTICIPANT with a PREDICATE used to filter the * NOUN/PARTICPANT interaction. * * @private * @class * @memberof module:composer-common */ class AclRule { /** * Create an AclRule from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {AclFile} aclFile - the AclFile for this rule * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(aclFile, ast) { if(!aclFile || !ast) { throw new IllegalModelException('Invalid AclFile or AST'); } this.ast = ast; this.aclFile = aclFile; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the AclFile that owns this AclRule. * * @return {AclFile} the owning AclFile */ getAclFile() { return this.aclFile; } /** * Process the AST and build the model * * @throws {InvalidModelException} * @private */ process() { this.name = this.ast.id.name; this.noun = new ModelBinding(this, this.ast.noun); this.verb = this.ast.verb; this.participant = null; if(this.ast.participant &amp;&amp; this.ast.participant !== 'ANY') { this.participant = new ModelBinding(this, this.ast.participant); } this.predicate = null; if(this.ast.predicate) { this.predicate = new Predicate(this, this.ast.predicate); } this.action = this.ast.action; this.description = this.ast.description; } /** * Semantic validation of the structure of this AclRule. * * @throws {InvalidModelException} * @private */ validate() { this.noun.validate(); if(this.participant) { this.participant.validate(); } if(this.predicate) { this.predicate.validate(); } } /** * Returns the name of this AclRule. * * @return {string} the name of the AclRule */ getName() { return this.name; } /** * Returns the noun for this ACL rule. * * @return {ModelBinding} the noun ModelBinding */ getNoun() { return this.noun; } /** * Returns the verb associated with this ACL Rule. * * @return {string} the verb */ getVerb() { return this.verb; } /** * Returns the participant for this ACL rule. Returns null if this rule * does not filter based on participant. * * @return {ModelBinding} the participant ModelBinding or null */ getParticipant() { return this.participant; } /** * Returns the predicate associated with this ACL Rule * * @return {Predicate} the predicate */ getPredicate() { return this.predicate; } /** * Returns the action associated with this ACL Rule. * * @return {string} the action */ getAction() { return this.action; } /** * Returns the description associated with this ACL Rule. * * @return {string} the description */ getDescription() { return this.description; } /** * Returns a new object representing this Acl Rule that is * suitable for serializing as JSON. * @return {Object} A new object suitable for serializing as JSON. */ toJSON() { let result = { name: this.name, noun: this.noun, verb: this.verb, participant: this.participant, predicate: this.predicate, action: this.action, description: this.description }; return result; } } module.exports = AclRule; Ã— Search results Close "},"composer-common_lib_codegen_fromjs_apisignaturegenerator.js.html":{"id":"composer-common_lib_codegen_fromjs_apisignaturegenerator.js.html","title":"Source: composer-common/lib/codegen/fromjs/apisignaturegenerator.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/codegen/fromjs/apisignaturegenerator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const fs = require('fs'); const Writer = require('../writer'); /** * Converts the includes, classes and methods in a Javascript * file into an API Signature File called api.txt, stored in the * output directory. * @private * @class * @memberof module:composer-common */ class APISignatureGenerator { /** * @param {Object} program - the program arguments * @param {Object} file - the file instance being processed * @param {Object[]} includes - the includes (require statements) within the file * @param {Object[]} classes - the classes within the file * @param {Object[]} functions - the functions within the file */ generate(program, file, includes, classes, functions) { // generate the output if(classes.length &gt; 0 || functions.length &gt; 0) { let writer = new Writer(); for(let n=0; n &lt; classes.length; n++) { const clazz = classes[n]; let superType = ''; if(clazz.superClass) { superType = ' extends ' + clazz.superClass; } writer.writeLine(0, 'class ' + clazz.name + superType + ' {' ); for(let i=0; i &lt; clazz.methods.length; i++) { const method = clazz.methods[i]; let throws = ''; if(method.throws) { throws = 'throws ' + method.throws; } writer.writeLine(1, method.visibility + ' ' + method.returnType + ' ' + method.name + paramsToString(method.methodArgs) + ' ' + throws ); } writer.writeLine(0, '}'); } for(let n=0; n &lt; functions.length; n++) { const func = functions[n]; let throws = ''; if(func.throws) { throws = 'throws ' + func.throws; } writer.writeLine(1, func.visibility + ' ' + func.returnType + ' ' + func.name + paramsToString(func.methodArgs) + ' ' + throws ); } fs.appendFileSync(program.outputDir + '/api.txt', writer.getBuffer()); } } } /** * Converts an array of parameter types to a string * @param {string[]} paramTypes array of parameter type names * @return {string} - string representation * @private */ function paramsToString(paramTypes) { let result = '('; for(let n=0; n &lt; paramTypes.length; n++) { result += paramTypes[n]; if(n &lt; paramTypes.length-1) { result += ','; } } result += ')'; return result; } module.exports = APISignatureGenerator; Ã— Search results Close "},"composer-common_lib_introspect_assetdeclaration.js.html":{"id":"composer-common_lib_introspect_assetdeclaration.js.html","title":"Source: composer-common/lib/introspect/assetdeclaration.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/introspect/assetdeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); /** * AssetDeclaration defines the schema (aka model or class) for * an Asset. It extends ClassDeclaration which manages a set of * fields, a super-type and the specification of an * identifying field. * @private * @extends ClassDeclaration * @see See [ClassDeclaration]{@link module:composer-common.ClassDeclaration} * @class * @memberof module:composer-common */ class AssetDeclaration extends ClassDeclaration { /** * Create an AssetDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } /** * Returns true if this class can be pointed to by a relationship * * @return {boolean} true if the class may be pointed to by a relationship */ isRelationshipTarget() { return true; } } module.exports = AssetDeclaration; Ã— Search results Close "},"composer-common_lib_baseexception.js.html":{"id":"composer-common_lib_baseexception.js.html","title":"Source: composer-common/lib/baseexception.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/baseexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * A base class for all Composer exceptions * &lt;p&gt;&lt;a href=&quot;./diagrams/baseexception.svg&quot;&gt;&lt;img src=&quot;./diagrams/baseexception.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends Error * @class * @memberof module:composer-common */ class BaseException extends Error { /** * Create the BaseException. * @param {string} message - The exception message. */ constructor(message) { super(message); this.name = this.constructor.name; this.message = message; if (typeof Error.captureStackTrace === 'function') { Error.captureStackTrace(this, this.constructor); } } } module.exports = BaseException; Ã— Search results Close "},"composer-common_lib_businessnetworkdefinition.js.html":{"id":"composer-common_lib_businessnetworkdefinition.js.html","title":"Source: composer-common/lib/businessnetworkdefinition.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/businessnetworkdefinition.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('./log/logger'); const ModelManager = require('./modelmanager'); const Introspector = require('./introspect/introspector'); const AclManager = require('./aclmanager'); const AclFile = require('./acl/aclfile'); const Factory = require('./factory'); const Serializer = require('./serializer'); const ScriptManager = require('./scriptmanager'); const JSZip = require('jszip'); const semver = require('semver'); const fs = require('fs'); const fsPath = require('path'); const minimatch = require('minimatch'); const ENCODING = 'utf8'; const LOG = Logger.getLog('BusinessNetworkDefinition'); /** * &lt;p&gt; * A BusinessNetworkDefinition defines a set of Participants that exchange Assets by * sending Transactions. This class manages the metadata and domain-specific types for * the network as well as a set of executable scripts. * &lt;/p&gt; * @class * @memberof module:composer-common */ class BusinessNetworkDefinition { /** * Create the BusinessNetworkDefinition. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkDefinition.fromArchive}&lt;/strong&gt; * &lt;/p&gt; * @param {String} identifier - the identifier of the business network. The * identifier is formed from a business network name + '@' + version. The * version is a semver valid version string. * @param {String} description - the description of the business network */ constructor(identifier, description) { const method = 'constructor'; LOG.entry(method, identifier, description); this.identifier = identifier; const atIndex = this.identifier.lastIndexOf('@'); if (atIndex &gt;= 0) { this.name = this.identifier.substring(0, atIndex); } else { throw new Error('Malformed business network identifier. It must be &quot;name@major.minor.micro&quot;'); } this.version = this.identifier.substring(atIndex + 1); if (!semver.valid(this.version)) { throw new Error('Version number is invalid. Should be valid according to semver but found: ' + this.version); } this.description = description; this.modelManager = new ModelManager(); this.aclManager = new AclManager(this.modelManager); this.scriptManager = new ScriptManager(this.modelManager); this.introspector = new Introspector(this.modelManager); this.factory = new Factory(this.modelManager); this.serializer = new Serializer(this.factory, this.modelManager); LOG.exit(method); } /** * Returns the identifier for this business network * @return {String} the identifier of this business network */ getIdentifier() { return this.identifier; } /** * Returns the name for this business network * @return {String} the name of this business network */ getName() { return this.name; } /** * Returns the version for this business network * @return {String} the version of this business network. Use semver module * to parse. */ getVersion() { return this.version; } /** * Returns the description for this business network * @return {String} the description of this business network */ getDescription() { return this.description; } /** * Create a BusinessNetworkDefinition from an archive. * @param {Buffer} Buffer - the Buffer to a zip archive * @return {Promise} a Promise to the instantiated business network */ static fromArchive(Buffer) { const method = 'fromArchive'; LOG.entry(method, Buffer.length); return JSZip.loadAsync(Buffer).then(function(zip) { const allPromises = []; let ctoModelFiles = []; let jsScriptFiles = []; let permissionsFiles = []; let businessNetworkDefinition; LOG.debug(method, 'Loading package.json'); let packageJson = zip.file('package.json'); if (packageJson === null) { throw Error('package.json must exist'); } const packagePromise = packageJson.async('string'); allPromises.push(packagePromise); packagePromise.then(contents =&gt; { LOG.debug(method, 'Loaded package.json'); let jsonObject = JSON.parse(contents); let packageName = jsonObject.name; let packageVersion = jsonObject.version; let packageDescription = jsonObject.description; businessNetworkDefinition = new BusinessNetworkDefinition(packageName + '@' + packageVersion, packageDescription); }); LOG.debug(method, 'Looking for model files'); let ctoFiles = zip.file(/models\\/.*\\.cto$/); //Matches any file which is in the 'models' folder and has a .cto extension ctoFiles.forEach(function(file) { LOG.debug(method, 'Found model file, loading it', file.name); const ctoPromise = file.async('string'); allPromises.push(ctoPromise); ctoPromise.then(contents =&gt; { LOG.debug(method, 'Loaded model file'); ctoModelFiles.push(contents); }); }); LOG.debug(method, 'Looking for JavaScript files'); let jsFiles = zip.file(/lib\\/.*\\.js$/); //Matches any file which is in the 'lib' folder and has a .js extension jsFiles.forEach(function(file) { LOG.debug(method, 'Found JavaScript file, loading it', file.name); const jsPromise = file.async('string'); allPromises.push(jsPromise); jsPromise.then(contents =&gt; { LOG.debug(method, 'Loaded JavaScript file'); let tempObj = { 'name': file.name, 'contents': contents }; jsScriptFiles.push(tempObj); }); }); LOG.debug(method, 'Loading permissions.acl'); let aclFile = zip.file('permissions.acl'); if (aclFile !== null) { const aclPromise = aclFile.async('string'); allPromises.push(aclPromise); aclPromise.then(contents =&gt; { LOG.debug(method, 'Loaded permissions.acl'); permissionsFiles.push(contents); }); } return Promise.all(allPromises) .then(() =&gt; { LOG.debug(method, 'Loaded all model, JavaScript, and ACL files'); LOG.debug(method, 'Adding model files to model manager'); businessNetworkDefinition.modelManager.addModelFiles(ctoModelFiles); // Adds all cto files to model manager LOG.debug(method, 'Added model files to model manager'); // console.log('What are the jsObjectsArray?',jsObjectArray); LOG.debug(method, 'Adding JavaScript files to script manager'); jsScriptFiles.forEach(function(obj) { let jsObject = businessNetworkDefinition.scriptManager.createScript(obj.name, 'js', obj.contents); businessNetworkDefinition.scriptManager.addScript(jsObject); // Adds all js files to script manager }); LOG.debug(method, 'Added JavaScript files to script manager'); LOG.debug(method, 'Adding ACL files to ACL manager'); permissionsFiles.forEach((permissionFile) =&gt; { businessNetworkDefinition.getAclManager().setAclFile( new AclFile('permissions.acl', businessNetworkDefinition.getModelManager(), permissionFile)); }); LOG.debug(method, 'Added ACL files to ACL manager'); LOG.exit(method, businessNetworkDefinition.toString()); return businessNetworkDefinition; // Returns business network (with model manager and script manager) }); }); } /** * Store a BusinessNetworkDefinition as an archive. * @return {Buffer} buffer - the zlib buffer */ toArchive() { let zip = new JSZip(); let packageFileContents = JSON.stringify({ name: this.name, version: this.version, description: this.description }); zip.file('package.json', packageFileContents); const aclFile = this.getAclManager().getAclFile(); if(aclFile) { zip.file(aclFile.getIdentifier(), aclFile.definitions); } let modelManager = this.getModelManager(); let modelFiles = modelManager.getModelFiles(); modelFiles.forEach(function(file) { zip.folder('models').file(file.namespace + '.cto', file.definitions); }); let scriptManager = this.getScriptManager(); let scriptFiles = scriptManager.getScripts(); scriptFiles.forEach(function(file) { let fileIdentifier = file.identifier; let fileName = fileIdentifier.substring(fileIdentifier.lastIndexOf('/') + 1); zip.folder('lib').file(fileName, file.contents); }); return zip.generateAsync({ type: 'nodebuffer' }).then(something =&gt; { return Promise.resolve(something).then(result =&gt; { return result; }); }); } /** * Builds a BusinessNetworkDefintion from the contents of a directory. * The directory must include a package.json in the root (used to specify * the name, version and description of the business network). This method * is designed to work with business networks that refer to external models * using npm dependencies as well as business networks that statically * package their model files. * &lt;p&gt; * If package.json contains a dependencies property then this method will search for * model (CTO) files under the node_modules directory for each dependency that * passes the options.dependencyGlob pattern. * &lt;/p&gt; * &lt;p&gt; * In addition all model files will be added that are not under node_modules * and that pass the options.modelFileGlob pattern. By default you should put * model files under a directory called 'models'. * &lt;/p&gt; * &lt;p&gt; * All script (js) files will be added that are not under node_modules and * that pass the options.scriptGlob pattern. By default you should put Javascript * files under the 'lib' directory. * &lt;/p&gt; * * @param {String} path to a local directory * @param {Object} [options] - an optional set of options to configure the instance. * @param {Object} [options.dependencyGlob] - specify the glob pattern used to match * the npm dependencies to process. Defaults to ** * @param {boolean} [options.modelFileGlob] - specify the glob pattern used to match * the model files to include. Defaults to **\\/models/**\\/*.cto * @param {boolean} [options.scriptGlob] - specify the glob pattern used to match * the script files to include. Defaults to **\\/lib/**\\/*.js * @return {Promise} a Promise to the instantiated business network */ static fromDirectory(path, options) { if(!options) { options = {}; } if(!options.dependencyGlob) { options.dependencyGlob = '**'; } if(!options.modelFileGlob) { options.modelFileGlob = '**/models/**/*.cto'; } if(!options.scriptGlob) { options.scriptGlob = '**/lib/**/*.js'; } const method = 'fromDirectory'; LOG.entry(method, path); // grab the package.json let packageJsonContents = fs.readFileSync( fsPath.resolve(path, 'package.json'), ENCODING); if(!packageJsonContents) { throw new Error('Failed to find package.json'); } LOG.debug(method, 'Loaded package.json', packageJsonContents); // parse the package.json let jsonObject = JSON.parse(packageJsonContents); let packageName = jsonObject.name; let packageVersion = jsonObject.version; let packageDescription = jsonObject.description; // create the business network definition const businessNetwork = new BusinessNetworkDefinition(packageName + '@' + packageVersion, packageDescription); const modelFiles = []; // process each module dependency // filtering using a glob on the module dependency name if(jsonObject.dependencies) { LOG.debug(method, 'All dependencies', Object.keys(jsonObject.dependencies).toString()); const dependencies = Object.keys(jsonObject.dependencies).filter(minimatch.filter(options.dependencyGlob)); LOG.debug(method, 'Matched dependencies', dependencies); for( let dep of dependencies) { // find all the *.cto files under the npm install dependency path let dependencyPath = fsPath.resolve(path, 'node_modules', dep); LOG.debug(method, 'Checking dependency path', dependencyPath); if (!fs.existsSync(dependencyPath)) { // need to check to see if this is in a peer directory as well // LOG.debug(method,'trying different path '+path.replace(packageName,'')); dependencyPath = fsPath.resolve(path.replace(packageName,''),dep); if(!fs.existsSync(dependencyPath)){ throw new Error('npm dependency path ' + dependencyPath + ' does not exist. Did you run npm install?'); } } BusinessNetworkDefinition.processDirectory(dependencyPath, { accepts: function(file) { return minimatch(file, options.modelFileGlob); }, acceptsDir: function(dir) { return true; }, process: function(path,contents) { modelFiles.push(contents); LOG.debug(method, 'Found model file', path); } }); } } // define a help function that will filter out files // that are inside a node_modules directory under the path // we are processing const isFileInNodeModuleDir = function(file) { const method = 'isFileInNodeModuleDir'; let filePath = fsPath.parse(file); let subPath = filePath.dir.substring(path.length); let result = subPath.split(fsPath.sep).some((element) =&gt; { return element === 'node_modules'; }); LOG.debug(method, file, result); return result; }; // find CTO files outside the npm install directory // BusinessNetworkDefinition.processDirectory(path, { accepts: function(file) { return isFileInNodeModuleDir(file) === false &amp;&amp; minimatch(file, options.modelFileGlob); }, acceptsDir: function(dir) { return !isFileInNodeModuleDir(dir); }, process: function(path,contents) { modelFiles.push(contents); LOG.debug(method, 'Found model file', path); } }); businessNetwork.getModelManager().addModelFiles(modelFiles); LOG.debug(method, 'Added model files', modelFiles.length); // find script files outside the npm install directory const scriptFiles = []; BusinessNetworkDefinition.processDirectory(path, { accepts: function(file) { return isFileInNodeModuleDir(file) === false &amp;&amp; minimatch(file, options.scriptGlob); }, acceptsDir: function(dir) { return !isFileInNodeModuleDir(dir); }, process: function(path,contents) { let filePath = fsPath.parse(path); const jsScript = businessNetwork.getScriptManager().createScript(path, filePath.ext.toLowerCase(), contents); scriptFiles.push(jsScript); LOG.debug(method, 'Found script file ', path); } }); if(modelFiles.length === 0) { throw new Error('Failed to find a model file.'); } for( let script of scriptFiles) { businessNetwork.getScriptManager().addScript(script); } LOG.debug(method, 'Added script files', scriptFiles.length); // grab the permissions.acl const aclPath = fsPath.resolve(path, 'permissions.acl'); if(fs.existsSync(aclPath)) { let permissionsAclContents = fs.readFileSync( aclPath, ENCODING); if(permissionsAclContents) { LOG.debug(method, 'Loaded permissions.acl', permissionsAclContents); const aclFile = new AclFile('permissions.acl', businessNetwork.getModelManager(), permissionsAclContents); businessNetwork.getAclManager().setAclFile(aclFile); } } LOG.exit(method, path); return Promise.resolve(businessNetwork); } /** * @param {String} path - the path to process * @param {Object} fileProcessor - the file processor. It must have * accept and process methods. * @private */ static processDirectory(path, fileProcessor) { const items = BusinessNetworkDefinition.walkSync(path, [], fileProcessor); items.sort(); LOG.debug('processDirectory', 'Path ' + path, items); items.forEach((item) =&gt; { BusinessNetworkDefinition.processFile(item, fileProcessor); }); } /** * @param {String} file - the file to process * @param {Object} fileProcessor - the file processor. It must have * accepts and process methods. * @private */ static processFile(file, fileProcessor) { if (fileProcessor.accepts(file)) { LOG.debug('processFile', 'FileProcessor accepted', file ); let fileContents = fs.readFileSync(file, ENCODING); fileProcessor.process(file, fileContents); } else { LOG.debug('processFile', 'FileProcessor rejected', file ); } } /** * @param {String} dir - the dir to walk * @param {Object[]} filelist - input files * @param {Object} fileProcessor - the file processor. It must have * accepts and process methods. * @return {Object[]} filelist - output files * @private */ static walkSync(dir, filelist, fileProcessor) { let files = fs.readdirSync(dir); files.forEach(function (file) { let nestedPath = fsPath.join(dir, file); if (fs.lstatSync(nestedPath).isDirectory()) { if (fileProcessor.acceptsDir(nestedPath)) { filelist = BusinessNetworkDefinition.walkSync(nestedPath, filelist, fileProcessor); } } else { filelist.push(nestedPath); } }); return filelist; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor, parameters) { return visitor.visit(this, parameters); } /** * Provides access to the Introspector for this business network. The Introspector * is used to reflect on the types defined within this business network. * @return {Introspector} the Introspector for this business network */ getIntrospector() { return this.introspector; } /** * Provides access to the Factory for this business network. The Factory * is used to create the types defined in this business network. * @return {Factory} the Factory for this business network */ getFactory() { return this.factory; } /** * Provides access to the Serializer for this business network. The Serializer * is used to serialize instances of the types defined within this business network. * @return {Serializer} the Serializer for this business network */ getSerializer() { return this.serializer; } /** * Provides access to the ScriptManager for this business network. The ScriptManager * manage access to the scripts that have been defined within this business network. * @return {ScriptManager} the ScriptManager for this business network * @private */ getScriptManager() { return this.scriptManager; } /** * Provides access to the AclManager for this business network. The AclManager * manage access to the access conrol rules that have been defined for this business network. * @return {AclManager} the AclManager for this business network * @private */ getAclManager() { return this.aclManager; } /** * Provides access to the ModelManager for this business network. The ModelManager * manage access to the models that have been defined within this business network. * @return {ModelManager} the ModelManager for this business network * @private */ getModelManager() { return this.modelManager; } } module.exports = BusinessNetworkDefinition; Ã— Search results Close "},"composer-common_lib_introspect_classdeclaration.js.html":{"id":"composer-common_lib_introspect_classdeclaration.js.html","title":"Source: composer-common/lib/introspect/classdeclaration.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/introspect/classdeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Field = require('./field'); const EnumValueDeclaration = require('./enumvaluedeclaration'); const RelationshipDeclaration = require('./relationshipdeclaration'); const IllegalModelException = require('./illegalmodelexception'); const Globalize = require('../globalize'); /** * ClassDeclaration defines the structure (model/schema) of composite data. * It is composed of a set of Properties, may have an identifying field, and may * have a super-type. * A ClassDeclaration is conceptually owned with a ModelFile which * defines all the classes that are part of a namespace. * * @private * @abstract * @class * @memberof module:composer-common */ class ClassDeclaration { /** * Create a ClassDeclaration from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {ModelFile} modelFile - the ModelFile for this class * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(modelFile, ast) { if(!modelFile || !ast) { throw new IllegalModelException(Globalize.formatMessage('classdeclaration-constructor-modelastreq')); } this.ast = ast; this.modelFile = modelFile; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the ModelFile that defines this class. * * @return {ModelFile} the owning ModelFile */ getModelFile() { return this.modelFile; } /** * Process the AST and build the model * * @throws {InvalidModelException} * @private */ process() { this.name = this.ast.id.name; this.properties = []; this.superType = null; this.idField = null; this.abstract = false; if(this.ast.abstract) { this.abstract = true; } if(this.ast.classExtension) { this.superType = this.ast.classExtension.class.name; } if(this.ast.idField) { this.idField = this.ast.idField.name; } for(let n=0; n &lt; this.ast.body.declarations.length; n++ ) { let thing = this.ast.body.declarations[n]; //console.log('Found: ' + thing.type + ' ' + thing.id.name); if(thing.type === 'FieldDeclaration') { this.properties.push( new Field(this, thing) ); } else if(thing.type === 'RelationshipDeclaration') { this.properties.push( new RelationshipDeclaration(this, thing) ); } else if(thing.type === 'EnumPropertyDeclaration') { this.properties.push( new EnumValueDeclaration(this, thing) ); } else { let formatter = Globalize.messageFormatter('classdeclaration-process-unrecmodelelem'); throw new IllegalModelException(formatter({ 'type': thing.type })); } } } /** * Semantic validation of the structure of this class. Subclasses should * override this method to impose additional semantic constraints on the * contents/relations of fields. * * @throws {InvalidModelException} * @private */ validate() { // TODO (LG) check that all imported classes exist, rather than just // used imports // if we have a super type make sure it exists if(this.superType!==null) { let classDecl = null; if(this.getModelFile().isImportedType(this.superType)) { let fqnSuper = this.getModelFile().resolveImport(this.superType); classDecl = this.modelFile.getModelManager().getType(fqnSuper); } else { classDecl = this.getModelFile().getType(this.superType); } if(classDecl===null) { throw new IllegalModelException('Could not find super type ' + this.superType); } // TODO (DCS) // else { // // check that assets only inherit from assets etc. // if( Object.getPrototypeOf(classDecl) !== Object.getPrototypeOf(this)) { // throw new Error('Invalid super type for ' + this.name + ' is must be of type ' + Object.getPrototypeOf(this) ); // } // } } if(this.idField) { const field = this.getProperty(this.idField); if(!field) { let formatter = Globalize('en').messageFormatter('classdeclaration-validate-identifiernotproperty'); throw new IllegalModelException(formatter({ 'class': this.name, 'idField': this.idField })); } else { // check that identifiers are strings if(field.getType() !== 'String') { let formatter = Globalize('en').messageFormatter('classdeclaration-validate-identifiernotstring'); throw new IllegalModelException( formatter({ 'class': this.name, 'idField': this.idField })); } if(field.isOptional()) { throw new IllegalModelException('Identifying fields cannot be optional.'); } } } else { if( this.isAbstract() === false &amp;&amp; this.isEnum() === false &amp;&amp; this.isConcept() === false) { if( this.getIdentifierFieldName() === null) { let formatter = Globalize('en').messageFormatter('classdeclaration-validate-missingidentifier'); throw new IllegalModelException( formatter({ 'class': this.name })); } } } // we also have to check fields defined in super classes const properties = this.getProperties(); for(let n=0; n &lt; properties.length; n++) { let field = properties[n]; // check we don't have a field with the same name for(let i=n+1; i &lt; properties.length; i++) { let otherField = properties[i]; if(field.getName() === otherField.getName()) { let formatter = Globalize('en').messageFormatter('classdeclaration-validate-duplicatefieldname'); throw new IllegalModelException( formatter({ 'class': this.name, 'fieldName': field.getName() })); } } field.validate(this); } } /** * Returns true if this class is declared as abstract in the model file * * @return {boolean} true if the class is abstract */ isAbstract() { return this.abstract; } /** * Returns true if this class is an enumeration. * * @return {boolean} true if the class is an enumerated type */ isEnum() { return false; } /** * Returns true if this class is the definition of a concept. * * @return {boolean} true if the class is a concept */ isConcept() { return false; } /** * Returns true if this class can be pointed to by a relationship * * @return {boolean} true if the class may be pointed to by a relationship */ isRelationshipTarget() { return false; } /** * Returns the short name of a class. This name does not include the * namespace from the owning ModelFile. * * @return {string} the short name of this class */ getName() { return this.name; } /** * Returns the fully qualified name of this class. * The name will include the namespace if present. * * @return {string} the fully-qualified name of this class */ getFullyQualifiedName() { return this.modelFile.getNamespace() + '.' + this.name; } /** * Returns the name of the identifying field for this class. Note * that the identifying field may come from a super type. * * @return {string} the name of the id field for this class */ getIdentifierFieldName() { if(this.idField) { return this.idField; } else { if(this.getSuperType()) { // we first check our own modelfile, as we may be called from validate // in which case our model file has not yet been added to the model modelManager let classDecl = this.getModelFile().getLocalType(this.getSuperType()); // not a local type, so we try the model manager if(!classDecl) { classDecl = this.modelFile.getModelManager().getType(this.getSuperType()); } return classDecl.getIdentifierFieldName(); } else { return null; } } } /** * Returns the field with a given name or null if it does not exist. * The field must be directly owned by this class -- the super-type is * not introspected. * * @param {string} name the name of the field * @return {Property} the field definition or null if it does not exist. */ getOwnProperty(name) { for(let n=0; n &lt; this.properties.length; n++) { const field = this.properties[n]; if(field.getName() === name) { return field; } } return null; } /** * Returns the fields directly defined by this class. * * @return {Property[]} the array of fields */ getOwnProperties() { return this.properties; } /** * Returns the FQN of the super type for this class or null if this * class does not have a super type. * * @return {string} the FQN name of the super type or null */ getSuperType() { if(this.superType) { const type = this.getModelFile().getType(this.superType); if(type === null) { throw new Error('Could not find super type:' + this.superType ); } else { return type.getFullyQualifiedName(); } } return null; } /** * Returns the property with a given name or null if it does not exist. * Fields defined in super-types are also introspected. * * @param {string} name the name of the field * @return {Property} the field, or null if it does not exist */ getProperty(name) { let result = this.getOwnProperty(name); let classDecl = null; if(result === null &amp;&amp; this.superType!==null) { if(this.getModelFile().isImportedType(this.superType)) { let fqnSuper = this.getModelFile().resolveImport(this.superType); classDecl = this.modelFile.getModelManager().getType(fqnSuper); } else { classDecl = this.getModelFile().getType(this.superType); } result = classDecl.getProperty(name); } return result; } /** * Returns the properties defined in this class and all super classes. * * @return {Property[]} the array of fields */ getProperties() { let result = this.getOwnProperties(); let classDecl = null; if(this.superType!==null) { if(this.getModelFile().isImportedType(this.superType)) { let fqnSuper = this.getModelFile().resolveImport(this.superType); classDecl = this.modelFile.getModelManager().getType(fqnSuper); } else { classDecl = this.getModelFile().getType(this.superType); } if(classDecl===null) { throw new IllegalModelException('Could not find super type ' + this.superType); } // go get the fields from the super type result = result.concat(classDecl.getProperties()); } else { // console.log('No super type for ' + this.getName() ); } return result; } /** * Stop serialization of this object. * @return {Object} An empty object. */ toJSON() { return {}; } /** * Returns the string representation of this class * @return {String} the string representation of the class */ toString() { let superType = ''; if(this.superType) { superType = ' super=' + this.superType; } return 'ClassDeclaration {id=' + this.getFullyQualifiedName() + superType + ' enum=' + this.isEnum() + ' abstract=' + this.isAbstract() + '}'; } } module.exports = ClassDeclaration; Ã— Search results Close "},"composer-common_lib_model_concept.js.html":{"id":"composer-common_lib_model_concept.js.html","title":"Source: composer-common/lib/model/concept.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/model/concept.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Typed = require('./typed'); /** * &lt;p&gt; * Resource is an instance that has a type. The type of the resource * specifies a set of properites (which themselves have types). * &lt;/p&gt; * &lt;p&gt; * Type information in Composer is used to validate the structure of * Resource instances and for serialization. * &lt;/p&gt; * &lt;p&gt; * Resources are used in Composer to represent Assets, Participants, Transactions and * other domain classes that can be serialized for long-term persistent storage. * &lt;/p&gt; * @extends Identifiable * @see See [Resource]{@link module:composer-common.Resource} * @class * @memberof module:composer-common */ class Concept extends Typed { /** * This constructor should not be called directly. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @private */ constructor(modelManager, ns, type) { super(modelManager, ns, type); } /** * Determine if this typed is a concept. * @return {boolean} True if this typed is a concept, * false if not. */ isConcept() { return true; } } module.exports = Concept; Ã— Search results Close "},"composer-common_lib_introspect_conceptdeclaration.js.html":{"id":"composer-common_lib_introspect_conceptdeclaration.js.html","title":"Source: composer-common/lib/introspect/conceptdeclaration.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/introspect/conceptdeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); /** * ConceptDeclaration defines the schema (aka model or class) for * an Concept. It extends ClassDeclaration which manages a set of * fields, a super-type and the specification of an * identifying field. * @private * @extends ClassDeclaration * @see See [ClassDeclaration]{@link module:composer-common.ClassDeclaration} * @class * @memberof module:composer-common */ class ConceptDeclaration extends ClassDeclaration { /** * Create an AssetDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } /** * Returns true if this class is the definition of a concept. * * @return {boolean} true if the class is a concept */ isConcept() { return true; } } module.exports = ConceptDeclaration; Ã— Search results Close "},"composer-common_lib_connection.js.html":{"id":"composer-common_lib_connection.js.html","title":"Source: composer-common/lib/connection.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/connection.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ConnectionManager = require('./connectionmanager'); /** * Base class representing a connection to a business network. * @private * @abstract * @class * @memberof module:composer-common */ class Connection { /** * Constructor. * @param {ConnectionManager} connectionManager The owning connection manager. * @param {string} connectionProfile The name of the connection profile associated with this connection * @param {string} businessNetworkIdentifier The identifier of the business network for this connection, or null if an admin connection */ constructor(connectionManager, connectionProfile, businessNetworkIdentifier) { if (!(connectionManager instanceof ConnectionManager)) { throw new Error('connectionManager not specified'); } else if (!connectionProfile) { throw new Error('connectionProfile not specified'); } this.connectionManager = connectionManager; this.connectionProfile = connectionProfile; this.businessNetworkIdentifier = businessNetworkIdentifier; } /** * Get the connection manager that owns this connection. * @return {ConnectionManager} The owning connection manager. */ getConnectionManager() { return this.connectionManager; } /** * Returns a string that can be used to identify this connection. * @return {string} the identifier of this connection */ getIdentifier() { if(this.businessNetworkIdentifier) { return this.businessNetworkIdentifier + '@' + this.connectionProfile; } else { return this.connectionProfile; } } /** * Terminate the connection to the business network. * @abstract * @return {Promise} A promise that is resolved once the connection has been * terminated, or rejected with an error. */ disconnect() { return Promise.reject(new Error('abstract function called')); } /** * Login as a participant on the business network. * @abstract * @param {string} enrollmentID The enrollment ID of the participant. * @param {string} enrollmentSecret The enrollment secret of the participant. * @return {Promise} A promise that is resolved with a {@link SecurityContext} * object representing the logged in participant, or rejected with a login error. */ login(enrollmentID, enrollmentSecret) { return Promise.reject(new Error('abstract function called')); } /** * Deploy a business network definition. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {boolean} [force] Force the deployment of the business network artifacts. * @param {BusinessNetworkDefinition} businessNetworkDefinition The BusinessNetworkDefinition to deploy * @return {Promise} A promise that is resolved once the business network * artifacts have been deployed, or rejected with an error. */ deploy(securityContext, force, businessNetworkDefinition) { return Promise.reject(new Error('abstract function called')); } /** * Updates an existing deployed business network definition. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {BusinessNetworkDefinition} businessNetworkDefinition The BusinessNetworkDefinition to deploy * @return {Promise} A promise that is resolved once the business network * artifacts have been updated, or rejected with an error. */ update(securityContext, businessNetworkDefinition) { return Promise.reject(new Error('abstract function called')); } /** * Undeploy a business network definition. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {string} businessNetworkIdentifier The identifier of the business network to remove * @return {Promise} A promise that is resolved once the business network * artifacts have been undeployed, or rejected with an error. */ undeploy(securityContext, businessNetworkIdentifier) { return Promise.reject(new Error('abstract function called')); } /** * Test (&quot;ping&quot;) the connection to the business network. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @return {Promise} A promise that is resolved once the connection to the * business network has been tested, or rejected with an error. */ ping(securityContext) { return Promise.reject(new Error('abstract function called')); } /** * Invoke a &quot;query&quot; chaincode function with the specified name and arguments. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {string} functionName The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that is resolved with the data returned by the * chaincode function once it has been invoked, or rejected with an error. */ queryChainCode(securityContext, functionName, args) { return Promise.reject(new Error('abstract function called')); } /** * Invoke a &quot;invoke&quot; chaincode function with the specified name and arguments. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {string} functionName The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that is resolved once the chaincode function * has been invoked, or rejected with an error. */ invokeChainCode(securityContext, functionName, args) { return Promise.reject(new Error('abstract function called')); } /** * Create a new identity for the specified user ID. * @param {SecurityContext} securityContext The participant's security context. * @param {string} userID The user ID. * @param {object} [options] Options for the new identity. * @param {boolean} [options.issuer] Whether or not the new identity should have * permissions to create additional new identities. False by default. * @param {string} [options.affiliation] Specify the affiliation for the new * identity. Defaults to 'institution_a'. * @return {Promise} A promise that is resolved with a generated user * secret once the new identity has been created, or rejected with an error. */ createIdentity(securityContext, userID, options) { return Promise.reject(new Error('abstract function called')); } /** * List all of the deployed business networks. The connection must * be connected for this method to succeed. * @param {SecurityContext} securityContext The participant's security context. * @return {Promise} A promise that will be resolved with an array of * business network identifiers, or rejected with an error. */ list(securityContext) { return Promise.reject(new Error('abstract function called')); } /** * Stop serialization of this object. * @return {Object} An empty object. */ toJSON() { return {}; } } module.exports = Connection; Ã— Search results Close "},"composer-common_lib_connectionmanager.js.html":{"id":"composer-common_lib_connectionmanager.js.html","title":"Source: composer-common/lib/connectionmanager.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/connectionmanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ConnectionProfileManager = require('./connectionprofilemanager'); /** * Base class representing a connection manager that establishes and manages * connections to one or more business networks. The ConnectionManager loads * connection profiles using the ConnectionProfileManager. * * @private * @abstract * @class * @memberof module:composer-common */ class ConnectionManager { /** * Create the ConnectionManager * @param {ConnectionProfileManager} connectionProfileManager - the ConnectionProfileManager * that controls this instance. */ constructor(connectionProfileManager) { if(!(connectionProfileManager instanceof ConnectionProfileManager)) { throw new Error('Must create ConnectionManager with a ConnectionProfileManager implementation.'); } this.connectionProfileManager = connectionProfileManager; } /** * Returns the ConnectionProfileManager associated with this ConnectionManager * @return {ConnectionProfileManager} the connection profile manager for this * connection manager. */ getConnectionProfileManager() { return this.connectionProfileManager; } /** * Establish a connection to the business network, using connection information * from the connection profile. * * @param {string} connectionProfile The name of the connection profile * @param {string} businessNetworkIdentifier The identifier of the business network, or null if this is an admin connection * @param {object} connectionOptions The connection options loaded from the profile * @return {Promise} A promise that is resolved with a {@link Connection} * object once the connection is established, or rejected with a connection error. * @abstract */ connect(connectionProfile, businessNetworkIdentifier, connectionOptions) { return Promise.reject(new Error('abstract function called')); } /** * Stop serialization of this object. * @return {Object} An empty object. */ toJSON() { return {}; } } module.exports = ConnectionManager; Ã— Search results Close "},"composer-common_lib_connectionprofilemanager.js.html":{"id":"composer-common_lib_connectionprofilemanager.js.html","title":"Source: composer-common/lib/connectionprofilemanager.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/connectionprofilemanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; let LOG; const connectionManagerLoaders = []; const connectionManagerClasses = {}; const connectionManagers = {}; /** * A connection profile manager that manages a set of connection profiles. Each * connection profile defines an arbitrary set of configuration data and is associated * with a ConnectionManager. * @private * @class * @memberof module:composer-common */ class ConnectionProfileManager { /** * The composer-common module cannot load connector modules from parent modules * when the dependencies are linked together using npm link or lerna. To work * around this, the packages that require the connectors register themselves as * modules that can load connection managers. * @param {Object} module The module that can load connector modules. */ static registerConnectionManagerLoader(module) { connectionManagerLoaders.push(module); } /** * Register a new ConnectionManager class. * @param {string} type - the profile type identifier of the ConnectionManager * @param {function} ctor - the constructor of the ConnectionManager */ static registerConnectionManager(type, ctor) { connectionManagerClasses[type] = ctor; } /** * Create the ConnectionManager and attach a file system * @param {ConnectionProfileStore} connectionProfileStore - Node.js FS implementation, for example BrowserFS */ constructor(connectionProfileStore) { if (!LOG) { LOG = require('./log/logger').getLog('ConnectionProfileManager'); } LOG.info('constructor','Created a new ConnectionProfileManager', connectionProfileStore); if(!connectionProfileStore) { throw new Error('Must create ConnectionProfileManager with a ConnectionProfileStore implementation.'); } this.connectionProfileStore = connectionProfileStore; } /** * Returns the ConnectionProfileStore associated with this * instance. * @return {ConnectionProfileStore} the associated store. */ getConnectionProfileStore() { return this.connectionProfileStore; } /** * Adds a ConnectionManager to the mappings of this ConnectionProfileManager * @param {string} type - the profile type identifier of the ConnectionManager * @param {ConnectionManager} connectionManager - the instance */ addConnectionManager(type, connectionManager) { LOG.info('addConnectionManager','Adding a new connection manager', type); connectionManagers[type] = connectionManager; } /** * Retrieves the ConnectionManager for the given connection profile. * * @param {string} connectionProfile The name of the connection profile * @return {Promise} A promise that is resolved with a {@link ConnectionManager} * object once the connection is established, or rejected with a connection error. */ getConnectionManager(connectionProfile) { LOG.info('getConnectionManager','Looking up a connection manager for profile', connectionProfile); return this.connectionProfileStore.load(connectionProfile) .then((data) =&gt; { let connectionManager = connectionManagers[data.type]; if(!connectionManager) { const mod = `composer-connector-${data.type}`; try { // Check for the connection manager class registered using // registerConnectionManager (used by the web connector). let connectionManagerClass = connectionManagerClasses[data.type]; if (connectionManagerClass) { connectionManager = new(connectionManagerClass)(this); } else { // Not registered using registerConnectionManager, we now // need to search for the connector module in our module // and all of the parent modules (the ones who require'd // us) as we do not depend on any connector modules. let curmod = module; while (curmod) { try { connectionManager = new(curmod.require(mod))(this); break; } catch (e) { // Continue to search the parent. } curmod = curmod.parent; } if (!connectionManager) { connectionManagerLoaders.some((connectionManagerLoader) =&gt; { try { connectionManager = new(connectionManagerLoader.require(mod))(this); return true; } catch (e) { // Search the next one. return false; } }); } if (!connectionManager) { // We still didn't find it, so try plain old require // one last time. connectionManager = new(require(mod))(this); } } } catch (e) { throw new Error(`Failed to load connector module &quot;${mod}&quot; for connection profile &quot;${connectionProfile}&quot;`); } connectionManagers[data.type] = connectionManager; } return connectionManager; }); } /** * Establish a connection to the business network, using connection information * from the connection profile. * * @param {string} connectionProfile The name of the connection profile * @param {string} businessNetworkIdentifier The identifier of the business network, or null if this is an admin connection * @return {Promise} A promise that is resolved with a {@link Connection} * object once the connection is established, or rejected with a connection error. * @abstract */ connect(connectionProfile, businessNetworkIdentifier) { LOG.info('connect','Connecting using ' + connectionProfile, businessNetworkIdentifier); return this.connectionProfileStore.load(connectionProfile) .then((connectOptions) =&gt; { return this.getConnectionManager(connectionProfile) .then((connectionManager) =&gt; { return connectionManager.connect(connectionProfile, businessNetworkIdentifier, connectOptions); }); }); } /** * Stop serialization of this object. * @return {Object} An empty object. */ toJSON() { return {}; } /** * Clear the static object containing all the connection managers */ static removeAllConnectionManagers() { connectionManagerLoaders.length = 0; Object.keys(connectionManagerClasses).forEach((key) =&gt; { connectionManagerClasses[key] = null; }); Object.keys(connectionManagers).forEach((key) =&gt; { connectionManagers[key] = null; }); } } module.exports = ConnectionProfileManager; Ã— Search results Close "},"composer-common_lib_connectionprofilestore.js.html":{"id":"composer-common_lib_connectionprofilestore.js.html","title":"Source: composer-common/lib/connectionprofilestore.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/connectionprofilestore.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Manages persistence of connection profiles. * * @private * @abstract * @class * @memberof module:composer-common */ class ConnectionProfileStore { /** * Loads connectOptions for a given connection profile. * * @param {string} connectionProfile The name of the connection profile to load * @return {Promise} A promise that is resolved with a JS Object for the * data in the connection profile. */ load(connectionProfile) { return Promise.reject(new Error('abstract function called')); } /** * Save connectOptions for a given connection profile. * * @param {string} connectionProfile The name of the connection profile to save * @param {Object} connectOptions The connection options object * @return {Promise} A promise that once the data is written */ save(connectionProfile, connectOptions) { return Promise.reject(new Error('abstract function called')); } /** * Loads all of the connection profiles. * * @return {Promise} A promise that is resolved with a JS Object where the * keys are the connection profiles, and the values are the connection options. */ loadAll() { return Promise.reject(new Error('abstract function called')); } /** * Delete the given connection profile. * * @param {string} connectionProfile The name of the connection profile to delete * @return {Promise} A promise that is resolved when the connection profile * is deleted. */ delete(connectionProfile) { return Promise.reject(new Error('abstract function called')); } } module.exports = ConnectionProfileStore; Ã— Search results Close "},"composer-common_lib_introspect_enumdeclaration.js.html":{"id":"composer-common_lib_introspect_enumdeclaration.js.html","title":"Source: composer-common/lib/introspect/enumdeclaration.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/introspect/enumdeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); /** * EnumDeclaration defines an enumeration of static values. * @private * @extends ClassDeclaration * @see See [ClassDeclaration]{@link module:composer-common.ClassDeclaration} * @class * @memberof module:composer-common */ class EnumDeclaration extends ClassDeclaration { /** * Create an AssetDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } /** * Returns true if this class is an enumeration. * * @return {boolean} true if the class is an enumerated type */ isEnum() { return true; } /** * Returns the string representation of this class * @return {String} the string representation of the class */ toString() { return 'EnumDeclaration {id=' + this.getFullyQualifiedName() + '}'; } } module.exports = EnumDeclaration; Ã— Search results Close "},"composer-common_lib_factory.js.html":{"id":"composer-common_lib_factory.js.html","title":"Source: composer-common/lib/factory.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/factory.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const debug = require('debug')('ibm-concerto'); const Globalize = require('./globalize'); const InstanceGenerator = require('./serializer/instancegenerator'); const Relationship = require('./model/relationship'); const Resource = require('./model/resource'); const ValidatedResource = require('./model/validatedresource'); const Concept = require('./model/concept'); const ValidatedConcept = require('./model/validatedconcept'); const ResourceValidator = require('./serializer/resourcevalidator'); const TransactionDeclaration = require('./introspect/transactiondeclaration'); const TypedStack = require('./serializer/typedstack'); const uuid = require('uuid'); /** * Use the Factory to create instances of Resource: transactions, participants * and assets. * &lt;p&gt;&lt;a href=&quot;./diagrams/factory.svg&quot;&gt;&lt;img src=&quot;./diagrams/factory.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @class * @memberof module:composer-common */ class Factory { /** * Create the factory. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Fabric-Composer}&lt;/strong&gt; * &lt;/p&gt; * @param {ModelManager} modelManager - The ModelManager to use for this registry */ constructor(modelManager) { this.modelManager = modelManager; } /** * Create a new Resource with a given namespace, type name and id * @param {string} ns - the namespace of the Resource * @param {string} type - the type of the Resource * @param {string} id - the identifier * @param {Object} [options] - an optional set of options * @param {boolean} [options.disableValidation] - pass true if you want the factory to * return a {@link Resource} instead of a {@link ValidatedResource}. Defaults to false. * @param {boolean} [options.generate] - pass true if you want the factory to return a * resource instance with generated sample data. * @return {Resource} the new instance * @throws {ModelException} if the type is not registered with the ModelManager * @deprecated - use newResource instead */ newInstance(ns, type, id, options) { return this.newResource(ns, type, id, options); } /** * Create a new Resource with a given namespace, type name and id * @param {string} ns - the namespace of the Resource * @param {string} type - the type of the Resource * @param {string} id - the identifier * @param {Object} [options] - an optional set of options * @param {boolean} [options.disableValidation] - pass true if you want the factory to * return a {@link Resource} instead of a {@link ValidatedResource}. Defaults to false. * @param {boolean} [options.generate] - pass true if you want the factory to return a * resource instance with generated sample data. * @return {Resource} the new instance * @throws {ModelException} if the type is not registered with the ModelManager */ newResource(ns, type, id, options) { let modelFile = this.modelManager.getModelFile(ns); if(!modelFile) { let formatter = Globalize.messageFormatter('factory-newinstance-notregisteredwithmm'); throw new Error(formatter({ namespace: ns })); } if(!modelFile.isDefined(type)) { let formatter = Globalize.messageFormatter('factory-newinstance-typenotdeclaredinns'); throw new Error(formatter({ namespace: ns, type: type })); } let classDecl = modelFile.getType(type); if(classDecl.isAbstract()) { throw new Error('Cannot create abstract type ' + classDecl.getFullyQualifiedName()); } let newObj = null; options = options || {}; if(options.disableValidation) { newObj = new Resource(this.modelManager,ns,type,id); } else { newObj = new ValidatedResource(this.modelManager,ns,type,id, new ResourceValidator()); } newObj.assignFieldDefaults(); if(options.generate) { let visitor = new InstanceGenerator(); let parameters = { stack: new TypedStack(newObj), modelManager: this.modelManager, factory: this }; classDecl.accept(visitor, parameters); } // if we have an identifier, we set it now let idField = classDecl.getIdentifierFieldName(); if(idField) { newObj[idField] = id; } debug('Factory.newInstance created %s', id ); return newObj; } /** * Create a new Resource with a given namespace, type name and id * @param {string} ns - the namespace of the Resource * @param {string} type - the type of the Resource * @param {Object} [options] - an optional set of options * @param {boolean} [options.disableValidation] - pass true if you want the factory to * return a {@link Resource} instead of a {@link ValidatedResource}. Defaults to false. * @param {boolean} [options.generate] - pass true if you want the factory to return a * resource instance with generated sample data. * @return {Resource} the new instance * @throws {ModelException} if the type is not registered with the ModelManager */ newConcept(ns, type, options) { let modelFile = this.modelManager.getModelFile(ns); if(!modelFile) { let formatter = Globalize.messageFormatter('factory-newinstance-notregisteredwithmm'); throw new Error(formatter({ namespace: ns })); } if(!modelFile.isDefined(type)) { let formatter = Globalize.messageFormatter('factory-newinstance-typenotdeclaredinns'); throw new Error(formatter({ namespace: ns, type: type })); } let classDecl = modelFile.getType(type); if(classDecl.isAbstract()) { throw new Error('Cannot create abstract type ' + classDecl.getFullyQualifiedName()); } let newObj = null; options = options || {}; if(options.disableValidation) { newObj = new Concept(this.modelManager,ns,type); } else { newObj = new ValidatedConcept(this.modelManager,ns,type, new ResourceValidator()); } newObj.assignFieldDefaults(); if(options.generate) { let visitor = new InstanceGenerator(); let parameters = { stack: new TypedStack(newObj), modelManager: this.modelManager, factory: this }; classDecl.accept(visitor, parameters); } debug('Factory.newInstance created concept %s', classDecl.getFullyQualifiedName() ); return newObj; } /** * Create a new Relationship with a given namespace, type and identifier. ` * A relationship is a typed pointer to an instance. I.e the relationship * with namespace = 'org.acme', type = 'Vehicle' and id = 'ABC' creates` * a pointer that points at an instance of org.acme.Vehicle with the id * ABC. * * @param {string} ns - the namespace of the Resource * @param {string} type - the type of the Resource * @param {string} id - the identifier * @return {Relationship} - the new relationship instance * @throws {ModelException} if the type is not registered with the ModelManager */ newRelationship(ns, type, id) { let modelFile = this.modelManager.getModelFile(ns); if(!modelFile) { let formatter = Globalize.messageFormatter('factory-newrelationship-notregisteredwithmm'); throw new Error(formatter({ namespace: ns })); } if(!modelFile.isDefined(type)) { let formatter = Globalize.messageFormatter('factory-newinstance-typenotdeclaredinns'); throw new Error(formatter({ namespace: ns, type: type })); } let relationship = new Relationship(this.modelManager,ns,type,id); return relationship; } /** * Create a new transaction object. The identifier of the transaction is * set to a UUID. * @param {string} ns - the namespace of the transaction. * @param {string} type - the type of the transaction. * @param {string} [id] - an optional identifier for the transaction; if you do not specify * one then an identifier will be automatically generated. * @param {Object} [options] - an optional set of options * @param {boolean} [options.generate] - pass true if you want the factory to return a * resource instance with generated sample data. * @return {Resource} A resource for the new transaction. */ newTransaction(ns, type, id, options) { if (!ns) { throw new Error('ns not specified'); } else if (!type) { throw new Error('type not specified'); } id = id || uuid.v4(); let transaction = this.newInstance(ns, type, id, options); const classDeclaration = transaction.getClassDeclaration(); if (!(classDeclaration instanceof TransactionDeclaration)) { throw new Error(transaction.getClassDeclaration().getFullyQualifiedName() + ' is not a transaction'); } // set the timestamp transaction.timestamp = new Date(); return transaction; } /** * Stop serialization of this object. * @return {Object} An empty object. */ toJSON() { return {}; } } module.exports = Factory; Ã— Search results Close "},"composer-common_lib_introspect_field.js.html":{"id":"composer-common_lib_introspect_field.js.html","title":"Source: composer-common/lib/introspect/field.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/introspect/field.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Property = require('./property'); const NumberValidator = require('./numbervalidator'); const StringValidator = require('./stringvalidator'); /** * Class representing the definition of a Field. A Field is owned * by a ClassDeclaration and has a name, type and additional metadata * (see below). * @private * @extends Property * @see See [Property]{@link module:composer-common.Property} * @class * @memberof module:composer-common */ class Field extends Property { /** * Create an Field. * @param {ClassDeclaration} parent - The owner of this property * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(parent, ast) { super(parent, ast); } /** * Process the AST and build the model * @throws {InvalidModelException} * @private */ process() { super.process(); this.validator = null; switch(this.getType()) { case 'Integer': case 'Double': case 'Long': if(this.ast.range) { this.validator = new NumberValidator(this, this.ast.range); } break; case 'String': if(this.ast.regex) { this.validator = new StringValidator(this, this.ast.regex); } break; } if(this.ast.default) { this.defaultValue = this.ast.default; } else { this.defaultValue = null; } } /** * Returns the validator string for this field * @return {string} the validator for the field or null */ getValidator() { return this.validator; } /** * Returns the default value for the field or null * @return {string} the default value for the field or null */ getDefaultValue() { if(this.defaultValue) { return this.defaultValue; } else { return null; } } /** * Stop serialization of this object. * @return {Object} An empty object. */ toJSON() { return {}; } /** * Returns a string representation of this propertyÂ§ * @return {String} the string version of the property. */ toString() { return 'Field {name=' + this.name + ', type=' + this.getFullyQualifiedTypeName() + ', array=' + this.array + ', optional=' + this.optional +'}'; } } module.exports = Field; Ã— Search results Close "},"composer-common_lib_codegen_filewriter.js.html":{"id":"composer-common_lib_codegen_filewriter.js.html","title":"Source: composer-common/lib/codegen/filewriter.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/codegen/filewriter.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const fs = require('fs'); const mkdirp = require('mkdirp'); const path = require('path'); const Writer = require('./writer'); /** * FileWriter creates text files under a directory tree. It can be used * by code generators to create source files for example. * Basic usage is: openFile(fileName), writeLine(...), closeFile(). * * @private * @extends Writer * @see See [Writer]{@link module:composer-common.Writer} * @class * @memberof module:composer-common */ class FileWriter extends Writer { /** * Create a FileWriter. * * @param {string} outputDirectory - the path to an output directory * that will be used to store generated files. */ constructor(outputDirectory) { super(); this.outputDirectory = outputDirectory; this.relativeDir = null; this.fileName = null; mkdirp.sync(outputDirectory); } /** * Opens a file for writing. The file will be created in the * root directory of this FileWriter. * * @param {string} fileName - the name of the file to open */ openFile(fileName) { this.fileName = fileName; this.relativeDir = null; } /** * Opens a file for writing, with a location relative to the * root directory of this FileWriter. * * @param {string} relativeDir - the relative directory to use * @param {string} fileName - the name of the file to open */ openRelativeFile(relativeDir, fileName) { this.relativeDir = relativeDir; this.fileName = fileName; } /** * Writes text to the current open file * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeLine(tabs,text) { if (this.fileName) { super.writeLine(tabs,text); } else { throw Error('File has not been opened!'); } } /** * Writes text to the start of the current open file * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeBeforeLine(tabs,text) { if (this.fileName) { super.writeBeforeLine(tabs,text); } else { throw Error('File has not been opened!'); } } /** * Closes the current open file */ closeFile() { if (!this.fileName) { throw new Error('No file open'); } let filePath = this.outputDirectory; if (this.relativeDir) { filePath = path.resolve(filePath, this.relativeDir); } filePath = path.resolve(filePath, this.fileName); //console.log('Writing to ' + filePath ); mkdirp.sync(path.dirname(filePath)); fs.writeFileSync(filePath, this.getBuffer()); this.fileName = null; this.relativeDir = null; this.clearBuffer(); } } module.exports = FileWriter; Ã— Search results Close "},"composer-common_lib_fsconnectionprofilestore.js.html":{"id":"composer-common_lib_fsconnectionprofilestore.js.html","title":"Source: composer-common/lib/fsconnectionprofilestore.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/fsconnectionprofilestore.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ConnectionProfileStore = require('./connectionprofilestore'); const homedir = require('homedir'); const mkdirp = require('mkdirp'); const path = require('path'); const rimraf = require('rimraf'); const thenify = require('thenify'); const thenifyAll = require('thenify-all'); const PROFILE_ROOT = (() =&gt; { const h = homedir(); if (h) { return path.resolve(h, '.composer-connection-profiles'); } else { return path.resolve('/', '.composer-connection-profiles'); } })(); const CONNECTION_FILE = 'connection.json'; const ENCODING = 'utf8'; const LOG = require('./log/logger').getLog('FSConnectionProfileStore'); /** * Stores connection profiles on an attached fs fs. * The connection profiles are loaded from the ''&lt;HOME_DIR&gt;/composer-connection-profiles/' * directory. * * @private * @extends ConnectionProfileStore * @see See [ConnectionProfileStore]{@link module:composer-common.ConnectionProfileStore} * @class * @memberof module:composer-common */ class FSConnectionProfileStore extends ConnectionProfileStore { /** * Create the ConnectionManager and attach a file system * @param {fs} fs - Node.js FS implementation, for example BrowserFS */ constructor(fs) { super(); if (!fs) { throw new Error('Must create FSConnectionProfileStore with an fs implementation.'); } this.fs = thenifyAll(fs, {}); this.mkdirp = thenify((dir, cb) =&gt; { return mkdirp(dir, { fs: fs }, cb); }); this.rimraf = thenify((dir, cb) =&gt; { return rimraf(dir, fs, cb); }); } /** * Loads connectOptions for a given connection profile. * * @param {string} connectionProfile The name of the connection profile to load * @return {Promise} A promise that is resolved with a JS Object for the * data in the connection profile. */ load(connectionProfile) { const options = { flag : 'r', encoding : ENCODING }; return this.fs.readFile(path.resolve(PROFILE_ROOT, connectionProfile, CONNECTION_FILE), options) .then((contents) =&gt; { LOG.info('load','Loaded connection profile ' + connectionProfile, contents); return JSON.parse(contents); }) .catch((err) =&gt; { LOG.error('load','Failed to loaded connection profile ' + connectionProfile, err); throw new Error('Failed to load connection profile ' + connectionProfile); }); } /** * Save connectOptions for a given connection profile. * * @param {string} connectionProfile The name of the connection profile to save * @param {Object} connectOptions The connection options object * @return {Promise} A promise that once the data is written */ save(connectionProfile, connectOptions) { const DIR = path.resolve(PROFILE_ROOT, connectionProfile); return this.mkdirp(DIR) .then(() =&gt; { const options = { flag : 'w', encoding : ENCODING }; return this.fs.writeFile(path.resolve(DIR, CONNECTION_FILE), JSON.stringify(connectOptions, null, 4), options); }) .then(() =&gt; { LOG.info('save','Saved connection profile ' + connectionProfile); }) .catch((err) =&gt; { LOG.error('save','Failed to save connection profile ' + connectionProfile, err); throw new Error('Failed to save connection profile ' + connectionProfile); }); } /** * Loads all of the connection profiles. * * @return {Promise} A promise that is resolved with a JS Object where the * keys are the connection profiles, and the values are the connection options. */ loadAll() { const result = {}; return this.fs.readdir(PROFILE_ROOT) .then((files) =&gt; { return files.reduce((promise, file) =&gt; { return promise.then(() =&gt; { return this.load(file); }) .then((profile) =&gt; { result[file] = profile; }) .catch((error) =&gt; { // Ignore any errors. }); }, Promise.resolve()); }) .catch((error) =&gt; { // Ignore any errors. }) .then(() =&gt; { return result; }); } /** * Delete the given connection profile. * * @param {string} connectionProfile The name of the connection profile to delete * @return {Promise} A promise that is resolved when the connection profile * is deleted. */ delete(connectionProfile) { const DIR = path.resolve(PROFILE_ROOT, connectionProfile); return this.rimraf(DIR); } } module.exports = FSConnectionProfileStore; Ã— Search results Close "},"composer-common_lib_introspect_functiondeclaration.js.html":{"id":"composer-common_lib_introspect_functiondeclaration.js.html","title":"Source: composer-common/lib/introspect/functiondeclaration.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/introspect/functiondeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const TransactionDeclaration = require('./transactiondeclaration'); const IllegalModelException = require('./illegalmodelexception'); //const Globalize = require('../globalize'); /** * FunctionDeclaration defines a function that has been defined * in a model file. If the name of the function starts with 'on' * then the name of the function denotes the name of a transaction * declaration that the function processes. * @private * @class * @memberof module:composer-common */ class FunctionDeclaration { /** * Create a FunctionDeclaration * * @param {ModelManager} modelManager - the ModelManager used to validate this function * @param {string} language - the language that the function is written in. E.g. JS. * @param {string} name - the name of the function * @param {string} visibility - the visibility of the function * @param {string} returnType - the return type of the function * @param {string} throws - the type that is thrown by the function * @param {string[]} parameterNames - the names of parameters of the function * @param {string[]} parameterTypes - the type names of parameters of the function * @param {string[]} decorators - the function decorators * @param {string} functionText - the function as text * @throws {IllegalModelException} */ constructor(modelManager, language, name, visibility, returnType, throws, parameterNames, parameterTypes, decorators, functionText) { if(modelManager === null) { throw new Error('ModelManager is required.'); } this.modelManager = modelManager; this.name = name; this.language = language; this.visibility = visibility; this.returnType = returnType; this.throws = throws; this.decorators = decorators; this.parameterNames = parameterNames; this.parameterTypes = parameterTypes; this.functionText = functionText; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the text of this function. * * @return {string} the text that defines the function */ getFunctionText() { return this.functionText; } /** * Returns the type thrown by this function * * @return {string} the type thrown by the function */ getThrows() { return this.throws; } /** * Returns the programming language that the function is written in * * @return {string} the language of the function */ getLanguage() { return this.language; } /** * Returns the decorators that the function was tagged with * * @return {string[]} the @ prefixed decorators for the function */ getDecorators() { return this.decorators; } /** * Returns the visibility of this function * * @return {string} the visibility of the function (+ is public), * (- is private) */ getVisibility() { return this.visibility; } /** * Returns the return type for this function * * @return {string} the return type for the function */ getReturnType() { return this.returnType; } /** * Semantic validation of the structure of this function. * * @throws {InvalidModelException} * @private */ validate() { if(this.decorators.indexOf('transaction') &gt; -1) { if(this.decorators.indexOf('query') &gt; -1) { throw new Error('A function cannot be decorated with both @transaction and @query.'); } if(this.parameterTypes.length !== 1) { throw new IllegalModelException('Transaction processing function ' + this.name + ' must have 1 function argument of type transaction.' ); } const transactionClassName = this.parameterTypes[0]; const classDecl = this.modelManager.getType(transactionClassName); if(!(classDecl instanceof TransactionDeclaration)) { throw new IllegalModelException('Function ' + this.getName() + ' processes ' + transactionClassName + ' which is not a transaction.'); } } } /** * Returns the name of the function * * @return {string} the name of the function. */ getName() { return this.name; } /** * Returns the short name of the transaction declaration * that is being processed. This is calculated by removing * the 'on' prefix from the function name. * If the function name does not start with 'on' then null * * @return {string} the name of the transaction declaration. */ getTransactionDeclarationName() { if(this.name.startsWith('on')) { return this.name.substring(2); } else { return null; } } /** * Returns the names of the parameters processed by the function. * * @return {string[]} the names of the parameters. */ getParameterNames() { return this.parameterNames; } /** * Returns the types of the parameters processed by the function. * * @return {string[]} the types of the parameters. */ getParameterTypes() { return this.parameterTypes; } /** * Stop serialization of this object. * @return {Object} An empty object. */ toJSON() { return {}; } } module.exports = FunctionDeclaration; Ã— Search results Close "},"composer-common_lib_model_identifiable.js.html":{"id":"composer-common_lib_model_identifiable.js.html","title":"Source: composer-common/lib/model/identifiable.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/model/identifiable.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Typed = require('./typed'); /** * Identifiable is an entity with a namespace, type and an identifier. * * This class is abstract. * @abstract * @class * @memberof module:composer-common */ class Identifiable extends Typed{ /** * Create an instance. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {string} id - The identifier of this instance. * @private */ constructor(modelManager, ns, type, id) { super(modelManager, ns, type); this.$identifier = id; } /** * Get the identifier of this instance * @return {string} The identifier for this object */ getIdentifier() { return this.$identifier; } /** * Set the identifier of this instance * @param {string} id - the new identifier for this object */ setIdentifier(id) { this.$identifier = id; const modelFile = this.$modelManager.getModelFile(this.getNamespace()); const typeDeclaration = modelFile.getType(this.getFullyQualifiedType()); const idField = typeDeclaration.getIdentifierFieldName(); this[idField] = id; } /** * Get the fully qualified identifier of this instance. * (namespace '.' type '#' identifier). * @return {string} the fully qualified identifier of this instance */ getFullyQualifiedIdentifier() { return this.getFullyQualifiedType() + '#' + this.$identifier; } /** * Returns the string representation of this class * @return {String} the string representation of the class */ toString() { return 'Identifiable {id=' + this.getFullyQualifiedIdentifier() +'}'; } /** * Determine if this identifiable is a relationship. * @return {boolean} True if this identifiable is a relationship, * false if not. */ isRelationship() { return false; } /** * Determine if this identifiable is a resource. * @return {boolean} True if this identifiable is a resource, * false if not. */ isResource() { return false; } } module.exports = Identifiable; Ã— Search results Close "},"composer-common_lib_introspect_illegalmodelexception.js.html":{"id":"composer-common_lib_introspect_illegalmodelexception.js.html","title":"Source: composer-common/lib/introspect/illegalmodelexception.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/introspect/illegalmodelexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BaseException = require('../baseexception'); /** * Exception throws when a composer file is semantically invalid * @extends BaseException * @see See [BaseException]{@link module:composer-common.BaseException} * @class * @memberof module:composer-common */ class IllegalModelException extends BaseException { /** * Create an IllegalModelException * @param {string} message - the message for the exception */ constructor(message) { super(message); } } module.exports = IllegalModelException; Ã— Search results Close "},"composer-common_lib_serializer_instancegenerator.js.html":{"id":"composer-common_lib_serializer_instancegenerator.js.html","title":"Source: composer-common/lib/serializer/instancegenerator.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/serializer/instancegenerator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('../introspect/classdeclaration'); const EnumDeclaration = require('../introspect/enumdeclaration'); const Field = require('../introspect/field'); const leftPad = require('left-pad'); const ModelUtil = require('../modelutil'); const RelationshipDeclaration = require('../introspect/relationshipdeclaration'); const randomWords = require('random-words'); const Util = require('../util'); /** * Generate sample instance data for the specified class declaration * and resource instance. The specified resource instance will be * updated with either default values or generated sample data. * @private * @class * @memberof module:composer-common */ class InstanceGenerator { /** * Visitor design pattern * @param {Object} thing - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visit(thing, parameters) { if (thing instanceof ClassDeclaration) { return this.visitClassDeclaration(thing, parameters); } else if (thing instanceof RelationshipDeclaration) { return this.visitRelationshipDeclaration(thing, parameters); } else if (thing instanceof Field) { return this.visitField(thing, parameters); } else { throw new Error('Unrecognised ' + JSON.stringify(thing) ); } } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitClassDeclaration(classDeclaration, parameters) { const obj = parameters.stack.pop(); const properties = classDeclaration.getProperties(); for(let n=0; n &lt; properties.length; n++) { const property = properties[n]; const value = obj[property.getName()]; if(Util.isNull(value)) { obj[property.getName()] = property.accept(this,parameters); } } return obj; } /** * Visitor design pattern * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitField(field, parameters) { if (field.isArray()) { let result = []; for (let i = 0; i &lt; 3; i++) { result.push(this.getSampleValue(field, parameters)); } return result; } else { return this.getSampleValue(field, parameters); } } /** * Get a sample value for the specified field. * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @return {*} A sample value for the specified field. */ getSampleValue(field, parameters) { let type = field.getFullyQualifiedTypeName(); if (ModelUtil.isPrimitiveType(type)) { switch(type) { case 'DateTime': return new Date(Math.random() * Date.now()); case 'Integer': return Math.round(Math.random() * Math.pow(2, 16)); case 'Long': return Math.round(Math.random() * Math.pow(2, 32)); case 'Double': return Number((Math.random() * Math.pow(2, 8)).toFixed(3)); case 'Boolean': return Math.round(Math.random()) === 1; default: return randomWords({min: 1, max: 5}).join(' '); } } let classDeclaration = parameters.modelManager.getType(type); if (classDeclaration instanceof EnumDeclaration) { let enumValues = classDeclaration.getOwnProperties(); return enumValues[Math.floor(Math.random() * enumValues.length)].getName(); } else { let identifierFieldName = classDeclaration.getIdentifierFieldName(); let idx = Math.round(Math.random() * 9999).toString(); idx = leftPad(idx, 4, '0'); let id = `${identifierFieldName}:${idx}`; let resource = parameters.factory.newInstance(classDeclaration.getModelFile().getNamespace(), classDeclaration.getName(), id); parameters.stack.push(resource); return classDeclaration.accept(this, parameters); } } /** * Visitor design pattern * @param {RelationshipDeclaration} relationshipDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitRelationshipDeclaration(relationshipDeclaration, parameters) { let classDeclaration = parameters.modelManager.getType(relationshipDeclaration.getFullyQualifiedTypeName()); let identifierFieldName = classDeclaration.getIdentifierFieldName(); let factory = parameters.factory; if (relationshipDeclaration.isArray()) { let result = []; for (let i = 0; i &lt; 3; i++) { let idx = Math.round(Math.random() * 9999).toString(); idx = leftPad(idx, 4, '0'); let id = `${identifierFieldName}:${idx}`; let relationship = factory.newRelationship(classDeclaration.getModelFile().getNamespace(), classDeclaration.getName(), id); result.push(relationship); } return result; } else { let idx = Math.round(Math.random() * 9999).toString(); idx = leftPad(idx, 4, '0'); let id = `${identifierFieldName}:${idx}`; let relationship = factory.newRelationship(classDeclaration.getModelFile().getNamespace(), classDeclaration.getName(), id); return relationship; } } } module.exports = InstanceGenerator; Ã— Search results Close "},"composer-common_lib_introspect_introspector.js.html":{"id":"composer-common_lib_introspect_introspector.js.html","title":"Source: composer-common/lib/introspect/introspector.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/introspect/introspector.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * &lt;p&gt; * Provides access to the structure of transactions, assets and participants. * &lt;/p&gt; * @class * @memberof module:composer-common */ class Introspector { /** * Create the Introspector. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkDefinition}&lt;/strong&gt; * &lt;/p&gt; * @param {ModelManager} modelManager - the ModelManager that backs this Introspector */ constructor(modelManager) { this.modelManager = modelManager; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns all the class declarations for the business network. * @return {ClassDeclaration[]} the array of class declarations */ getClassDeclarations() { let result = []; const modelFiles = this.modelManager.getModelFiles(); for(let n=0; n &lt; modelFiles.length; n++) { const modelFile = modelFiles[n]; result = result.concat(modelFile.getAllDeclarations()); } return result; } /** * Returns the class declaration with the given fully qualified name. * Throws an error if the class declaration does not exist. * @param {String} fullyQualifiedTypeName - the fully qualified name of the type * @return {ClassDeclaration} the class declaration * @throws {Error} if the class declaration does not exist */ getClassDeclaration(fullyQualifiedTypeName) { return this.modelManager.getType(fullyQualifiedTypeName); } /** * Returns the backing ModelManager * @return {ModelManager} the backing ModelManager * @private */ getModelManager() { return this.modelManager; } } module.exports = Introspector; Ã— Search results Close "},"composer-common_lib_codegen_javascriptparser.js.html":{"id":"composer-common_lib_codegen_javascriptparser.js.html","title":"Source: composer-common/lib/codegen/javascriptparser.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/codegen/javascriptparser.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const doctrine = require('doctrine'); const esprima = require('esprima'); const acorn = require('acorn'); /** * Processes a single Javascript file (.js extension) * * @param {string} file - the file to process * @param {Object} fileProcessor - the processor instance to use to generate code * @private * @class * @memberof module:composer-common */ class JavaScriptParser { /** * Create a JavaScriptParser. * * @param {string} fileContents - the text of the JS file to parse * @param {boolean} includePrivates - if true methods tagged as private are also returned */ constructor(fileContents, includePrivates) { let comments = [], tokens = []; let ast = acorn.parse(fileContents, { // collect ranges for each node ranges: true, // collect comments in Esprima's format onComment: comments, // collect token ranges onToken: tokens }); this.includes = []; this.classes = []; this.functions = []; for (let n = 0; n &lt; ast.body.length; n++) { let statement = ast.body[n]; if (statement.type === 'VariableDeclaration') { let variableDeclarations = statement.declarations; for (let n = 0; n &lt; variableDeclarations.length; n++) { let variableDeclaration = variableDeclarations[n]; if (variableDeclaration.init &amp;&amp; variableDeclaration.init.type === 'CallExpression' &amp;&amp; variableDeclaration.init.callee.name === 'require') { let requireName = variableDeclaration.init.arguments[0].value; // we only care about the code we require with a relative path if (requireName.startsWith('.')) { this.includes.push(variableDeclaration.init.arguments[0].value); } } } } else if (statement.type === 'FunctionDeclaration') { //console.log(JSON.stringify(statement)); let closestComment = findCommentBefore(statement.start, statement.end, comments); let returnType = ''; let visibility = '+'; let parameterTypes = []; let parameterNames = []; let decorators = []; let throws = ''; let example = ''; if(closestComment &gt;= 0) { let comment = comments[closestComment].value; //console.log('Found comment: ' + comment ); returnType = getReturnType(comment); visibility = getVisibility(comment); parameterTypes = getMethodArguments(comment); throws = getThrows(comment); decorators = getDecorators(comment); example = getExample(comment); } if(visibility === '+' || includePrivates) { for(let n=0; n &lt; statement.params.length; n++) { parameterNames.push(statement.params[n].name); } const func = { visibility: visibility, returnType: returnType, name: statement.id.name, parameterTypes: parameterTypes, parameterNames: parameterNames, throws: throws, decorators: decorators, functionText : getText(statement.start, statement.end, fileContents), example: example }; //console.log('Function: ' + JSON.stringify(func)); this.functions.push(func); } } else if (statement.type === 'ClassDeclaration') { let closestComment = findCommentBefore(statement.start, statement.end, comments); let privateClass = false; if(closestComment &gt;= 0) { let comment = comments[closestComment].value; privateClass = getVisibility(comment) === '-'; } if(privateClass === false || includePrivates) { const clazz = { name: statement.id.name}; clazz.methods = []; for(let n=0; n &lt; statement.body.body.length; n++) { let thing = statement.body.body[n]; if (thing.type === 'MethodDefinition') { let closestComment = findCommentBefore(thing.key.start, thing.key.end, comments); let returnType = ''; let visibility = '+'; let methodArgs = []; let throws = ''; let decorators = []; let example = ''; if(closestComment &gt;= 0) { let comment = comments[closestComment].value; returnType = getReturnType(comment); visibility = getVisibility(comment); methodArgs = getMethodArguments(comment); decorators = getDecorators(comment); throws = getThrows(comment); example = getExample(comment); } if(visibility === '+' || includePrivates) { const method = { visibility: visibility, returnType: returnType, name: thing.key.name, methodArgs: methodArgs, decorators: decorators, throws: throws, example: example }; clazz.methods.push(method); } } } if (statement.superClass) { clazz.superClass = statement.superClass.name; } this.classes.push(clazz); } } } } /** * Return the includes that were extracted from the JS file. * * @return {Object[]} information about each include */ getIncludes() { return this.includes; } /** * Return the classes that were extracted from the JS file. * * @return {Object[]} information about each class */ getClasses() { return this.classes; } /** * Return the methods that were extracted from the JS file. * * @return {Object[]} information about each method */ getFunctions() { return this.functions; } } /** * Grab the text between a rangeÂ§ * * @param {integer} rangeStart - the start of the range * @param {integer} rangeEnd - the end of the range * @param {string} source - the source text * @return {string} the text between start and end * @private */ function getText(rangeStart, rangeEnd, source) { return source.substring(rangeStart, rangeEnd); } /** * Find the comments that is above and closest to the start of the range. * * @param {integer} rangeStart - the start of the range * @param {integer} rangeEnd - the end of the range * @param {string[]} comments - the end of the range * @return {integer} the comment index or -1 if there are no comments * @private */ function findCommentBefore(rangeStart, rangeEnd, comments) { let foundIndex = -1; let distance = -1; for(let n=0; n &lt; comments.length; n++) { let comment = comments[n]; let endComment = comment.end; if(rangeStart &gt; endComment ) { if(distance === -1 || rangeStart - endComment &lt; distance) { distance = rangeStart - endComment; foundIndex = n; } } } return foundIndex; } /** * Grabs all the @ prefixed decorators from a comment block. * @param {string} comment - the comment block * @return {string[]} the @ prefixed decorators within the comment block * @private */ function getDecorators(comment) { const re = /(?:^|\\W)@(\\w+)/g; let match; const matches = []; match = re.exec(comment); while (match) { matches.push(match[1]); match = re.exec(comment); } return matches; } /** * Extracts the visibilty from a comment block * @param {string} comment - the comment block * @return {string} the return visibility (either + for public, or - for private) * @private */ function getVisibility(comment) { const PRIVATE = 'private'; let parsedComment = doctrine.parse(comment, {unwrap: true, sloppy: true, tags: [PRIVATE]}); const tags = parsedComment.tags; if (tags.length &gt; 0) { return '-'; } return '+'; } /** * Extracts the return type from a comment block. * @param {string} comment - the comment block * @return {string} the return type of the comment * @private */ function getReturnType(comment) { const RETURN = 'return'; const RETURNS = 'returns'; let result = 'void'; let parsedComment = doctrine.parse(comment, {unwrap: true, sloppy: true, tags: [RETURN, RETURNS]}); const tags = parsedComment.tags; if (tags.length &gt; 1) { throw new Error('Malformed JSDoc comment. More than one returns: ' + comment ); } tags.forEach((tag) =&gt; { if (!tag.type.name &amp;&amp; !tag.type) { throw new Error('Malformed JSDoc comment. ' + comment ); } if (tag.type.name) { result = tag.type.name; } else if (tag.type.applications){ result = tag.type.applications[0].name + '[]'; } else if (tag.type.expression) { result = tag.type.expression.name; } }); return result; } /** * Extracts the return type from a comment block. * @param {string} comment - the comment block * @return {string} the return type of the comment * @private */ function getThrows(comment) { const THROWS = 'throws'; const EXCEPTION = 'exception'; let result = ''; let parsedComment = doctrine.parse(comment, {unwrap: true, sloppy: true, tags: [THROWS, EXCEPTION]}); const tags = parsedComment.tags; if (tags.length &gt; 1) { throw new Error('Malformed JSDoc comment. More than one throws/exception: ' + comment ); } tags.forEach((tag) =&gt; { if (!tag.type.type || !tag.type.name) { throw new Error('Malformed JSDoc comment. ' + comment ); } result = tag.type.name; }); return result; } /** * Extracts the method arguments from a comment block. * @param {string} comment - the comment block * @return {string} the the argument types * @private */ function getMethodArguments(comment) { const TAG = 'param'; let paramTypes = []; let parsedComment = doctrine.parse(comment, {unwrap: true, sloppy: true, tags: [TAG]}); const tags = parsedComment.tags; // param is mentined but not picked up by parser if (comment.indexOf('@'+TAG) !== -1 &amp;&amp; tags.length === 0) { throw new Error('Malformed JSDoc comment: ' + comment ); } tags.forEach((tag) =&gt; { //If description starts with } if (tag.description.trim().indexOf('}') === 0 || !tag.type || !tag.name ) { throw new Error('Malformed JSDoc comment: ' + comment ); } else if(tag.type.name) { if (tag.type.name.indexOf(' ') !== -1) { throw new Error('Malformed JSDoc comment: ' + comment ); } } if (tag.type.name) { paramTypes.push(tag.type.name); } else if (tag.type.applications){ paramTypes.push(tag.type.applications[0].name + '[]'); } else if (tag.type.expression) { paramTypes.push(tag.type.expression.name); } }); return paramTypes; } /** * Extracts the example tag from a comment block. * @param {string} comment - the comment block * @return {string} the the argument types * @private */ function getExample(comment) { const EXAMPLE = 'example'; let result = ''; let parsedComment = doctrine.parse(comment, {unwrap: true, sloppy: true, tags: [EXAMPLE]}); const tags = parsedComment.tags; if (tags.length &gt; 0) { result = tags[0].description; } try { // Pass as a function so that return statements are valid let program = 'function testSyntax() {' + result + '}'; esprima.parse(program); } catch (e) { throw Error('Malformed JSDoc Comment. Invalid @example tag: ' + comment); } return result; } module.exports = JavaScriptParser; Ã— Search results Close "},"composer-common_lib_serializer_jsongenerator.js.html":{"id":"composer-common_lib_serializer_jsongenerator.js.html","title":"Source: composer-common/lib/serializer/jsongenerator.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/serializer/jsongenerator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('../introspect/classdeclaration'); const Field = require('../introspect/field'); const RelationshipDeclaration = require('../introspect/relationshipdeclaration'); const Resource = require('../model/resource'); const Typed = require('../model/typed'); const Concept = require('../model/concept'); const Relationship = require('../model/relationship'); const ModelUtil = require('../modelutil'); const Util = require('../util'); /** * Converts the contents of a Resource to JSON. The parameters * object should contain the keys * 'writer' - the JSONWriter instance to use to accumulate the JSON text. * 'stack' - the TypedStack of objects being processed. It should * start with a Resource. * 'modelManager' - the ModelManager to use. * @private * @class * @memberof module:composer-common */ class JSONGenerator { /** * Constructor. * @param {boolean} [convertResourcesToRelationships] Convert resources that * are specified for relationship fields into relationships, false by default. * @param {boolean} [permitResourcesForRelationships] Permit resources in the * place of relationships (serializing them as resources), false by default. */ constructor(convertResourcesToRelationships, permitResourcesForRelationships) { this.convertResourcesToRelationships = convertResourcesToRelationships; this.permitResourcesForRelationships = permitResourcesForRelationships; } /** * Visitor design pattern * @param {Object} thing - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visit(thing, parameters) { if (thing instanceof ClassDeclaration) { return this.visitClassDeclaration(thing, parameters); } else if (thing instanceof RelationshipDeclaration) { return this.visitRelationshipDeclaration(thing, parameters); } else if (thing instanceof Field) { return this.visitField(thing, parameters); } else { throw new Error('Unrecognised ' + JSON.stringify(thing) ); } } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitClassDeclaration(classDeclaration, parameters) { parameters.writer.openObject(); parameters.writer.writeKeyStringValue('$class', classDeclaration.getFullyQualifiedName()); const obj = parameters.stack.pop(); if(!((obj instanceof Resource) || (obj instanceof Concept))) { throw new Error('Expected a Resource or a Concept, but found ' + obj ); } const properties = classDeclaration.getProperties(); for(let n=0; n &lt; properties.length; n++) { const property = properties[n]; const value = obj[property.getName()]; if(!Util.isNull(value)) { parameters.stack.push(value); property.accept(this,parameters); } } parameters.writer.closeObject(); return null; } /** * Visitor design pattern * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitField(field, parameters) { const obj = parameters.stack.pop(); parameters.writer.writeKey(field.getName()); if(field.isArray()) { parameters.writer.openArray(); for(let n=0; n &lt; obj.length; n++) { const item = obj[n]; if(!field.isPrimitive() &amp;&amp; !ModelUtil.isEnum(field)) { parameters.writer.writeComma(); parameters.stack.push(item, Typed); const classDecl = parameters.modelManager.getType(item.getFullyQualifiedType()); classDecl.accept(this, parameters); } else { parameters.writer.writeArrayValue(this.convertToJSON(field,item)); } } parameters.writer.closeArray(); } else if(field.isPrimitive() || ModelUtil.isEnum(field)) { parameters.writer.writeValue(this.convertToJSON(field,obj)); } else { parameters.stack.push(obj); const classDeclaration = parameters.modelManager.getType(field.getFullyQualifiedTypeName()); classDeclaration.accept(this, parameters); } return null; } /** * Converts a primtive object to JSON text. * * @param {Field} field - the field declaration of the object * @param {Object} obj - the object to convert to text * @return {string} the text representation */ convertToJSON(field, obj) { switch(field.getType()) { case 'DateTime': { return `&quot;${obj.toISOString()}&quot;`; } case 'Integer': case 'Long': case 'Double': case 'Boolean':{ return `${obj.toString()}`; } default: { return `&quot;${obj.toString()}&quot;`; } } } /** * Visitor design pattern * @param {RelationshipDeclaration} relationshipDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitRelationshipDeclaration(relationshipDeclaration, parameters) { const obj = parameters.stack.pop(); parameters.writer.writeKey(relationshipDeclaration.getName()); if(relationshipDeclaration.isArray()) { parameters.writer.openArray(); for(let n=0; n &lt; obj.length; n++) { const item = obj[n]; if (this.permitResourcesForRelationships &amp;&amp; item instanceof Resource) { let fqi = item.getFullyQualifiedIdentifier(); if (parameters.seenResources.has(fqi)) { let relationshipText = this.getRelationshipText(relationshipDeclaration, item ); parameters.writer.writeStringValue(relationshipText); } else { parameters.seenResources.add(fqi); parameters.writer.writeComma(); parameters.stack.push(item, Resource); const classDecl = parameters.modelManager.getType(relationshipDeclaration.getFullyQualifiedTypeName()); classDecl.accept(this, parameters); parameters.seenResources.delete(fqi); } } else { let relationshipText = this.getRelationshipText(relationshipDeclaration, item ); parameters.writer.writeArrayStringValue(relationshipText); } } parameters.writer.closeArray(); } else if (this.permitResourcesForRelationships &amp;&amp; obj instanceof Resource) { let fqi = obj.getFullyQualifiedIdentifier(); if (parameters.seenResources.has(fqi)) { let relationshipText = this.getRelationshipText(relationshipDeclaration, obj ); parameters.writer.writeStringValue(relationshipText); } else { parameters.seenResources.add(fqi); parameters.stack.push(obj, Resource); const classDecl = parameters.modelManager.getType(relationshipDeclaration.getFullyQualifiedTypeName()); classDecl.accept(this, parameters); parameters.seenResources.delete(fqi); } } else { let relationshipText = this.getRelationshipText(relationshipDeclaration, obj ); parameters.writer.writeStringValue(relationshipText); } return null; } /** * * Returns the persistent format for a relationship. * @param {RelationshipDeclaration} relationshipDeclaration - the relationship being persisted * @param {Relationship} relationship - the text for the item * @returns {string} the text to use to persist the relationship */ getRelationshipText(relationshipDeclaration, relationship) { let identifiable; if(relationship instanceof Relationship) { identifiable = relationship; } else if (this.convertResourcesToRelationships &amp;&amp; relationship instanceof Resource) { identifiable = relationship; } else if (this.permitResourcesForRelationships &amp;&amp; relationship instanceof Resource) { identifiable = relationship; } else { throw new Error('Did not find a relationship for ' + relationshipDeclaration.getFullyQualifiedTypeName() + ' found ' + relationship ); } let relationshipText = identifiable.getIdentifier(); if(relationshipDeclaration.getNamespace() !== identifiable.getNamespace() ) { relationshipText = identifiable.getFullyQualifiedIdentifier(); } return relationshipText; } } module.exports = JSONGenerator; Ã— Search results Close "},"composer-common_lib_serializer_jsonpopulator.js.html":{"id":"composer-common_lib_serializer_jsonpopulator.js.html","title":"Source: composer-common/lib/serializer/jsonpopulator.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/serializer/jsonpopulator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('../introspect/classdeclaration'); const Field = require('../introspect/field'); const RelationshipDeclaration = require('../introspect/relationshipdeclaration'); const Util = require('../util'); const ModelUtil = require('../modelutil'); /** * Populates a Resource with data from a JSON object graph. The JSON objects * should be the result of calling Serializer.toJSON and then JSON.parse. * The parameters object should contain the keys * 'stack' - the TypedStack of objects being processed. It should * start with the root object from JSON.parse. * 'factory' - the Factory instance to use for creating objects. * 'modelManager' - the ModelManager instance to use to resolve classes * @private * @class * @memberof module:composer-common */ class JSONPopulator { /** * Constructor. * @param {boolean} [acceptResourcesForRelationships] Permit resources in the * place of relationships, false by default. */ constructor(acceptResourcesForRelationships) { this.acceptResourcesForRelationships = acceptResourcesForRelationships; } /** * Visitor design pattern * @param {Object} thing - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visit(thing, parameters) { if (thing instanceof ClassDeclaration) { return this.visitClassDeclaration(thing, parameters); } else if (thing instanceof RelationshipDeclaration) { return this.visitRelationshipDeclaration(thing, parameters); } else if (thing instanceof Field) { return this.visitField(thing, parameters); } else { throw new Error('Unrecognised ' + JSON.stringify(thing) ); } } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitClassDeclaration(classDeclaration, parameters) { const jsonObj = parameters.jsonStack.pop(); const resourceObj = parameters.resourceStack.pop(); const properties = classDeclaration.getProperties(); for(let n=0; n &lt; properties.length; n++) { const property = properties[n]; const value = jsonObj[property.getName()]; if(!Util.isNull(value)) { parameters.jsonStack.push(value); resourceObj[property.getName()] = property.accept(this,parameters); } } return resourceObj; } /** * Visitor design pattern * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitField(field, parameters) { const jsonObj = parameters.jsonStack.pop(); let result = null; if(field.isArray()) { result = []; for(let n=0; n &lt; jsonObj.length; n++) { const jsonItem = jsonObj[n]; result.push(this.convertItem(field,jsonItem, parameters)); } } else { result = this.convertItem(field,jsonObj, parameters); } return result; } /** * * @param {Field} field - the field of the item being converted * @param {Object} jsonItem - the JSON object of the item being converted * @param {Object} parameters - the parameters * @return {Object} - the populated object. */ convertItem(field, jsonItem, parameters) { let result = null; if(!field.isPrimitive() &amp;&amp; !field.isTypeEnum()) { let typeName = jsonItem.$class; if(!typeName) { // If the type name is not specified in the data, then use the // type name from the model. This will only happen in the case of // a sub resource inside another resource. typeName = field.getFullyQualifiedTypeName(); } // This throws if the type does not exist. const classDeclaration = parameters.modelManager.getType(typeName); // create a new instance, using the identifier field name as the ID. let subResource = null; // if this is identifiable, then we create a resource if(!classDeclaration.isConcept()) { subResource = parameters.factory.newInstance(classDeclaration.getModelFile().getNamespace(), classDeclaration.getName(), jsonItem[classDeclaration.getIdentifierFieldName()] ); } else { // otherwise we create a concept subResource = parameters.factory.newConcept(classDeclaration.getModelFile().getNamespace(), classDeclaration.getName() ); } result = subResource; parameters.resourceStack.push(subResource); parameters.jsonStack.push(jsonItem); classDeclaration.accept(this, parameters); } else { result = this.convertToObject(field,jsonItem); } return result; } /** * Converts a primtive object to JSON text. * * @param {Field} field - the field declaration of the object * @param {Object} json - the JSON object to convert to a Composer Object * @return {string} the text representation */ convertToObject(field, json) { let result = null; switch(field.getType()) { case 'DateTime': result = new Date(json); break; case 'Integer': case 'Long': result = parseInt(json); break; case 'Double': result = parseFloat(json); break; case 'Boolean': result = (json === true || json === 'true'); break; case 'String': result = json.toString(); break; default: // everything else should be an enumerated value... result = json; } return result; } /** * Visitor design pattern * @param {RelationshipDeclaration} relationshipDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitRelationshipDeclaration(relationshipDeclaration, parameters) { const jsonObj = parameters.jsonStack.pop(); let result = null; let typeFQN = relationshipDeclaration.getFullyQualifiedTypeName(); let namespace = ModelUtil.getNamespace(typeFQN); if(!namespace) { namespace = relationshipDeclaration.getNamespace(); } let type = ModelUtil.getShortName(typeFQN); if(relationshipDeclaration.isArray()) { result = []; for(let n=0; n &lt; jsonObj.length; n++) { let jsonItem = jsonObj[n]; if (typeof jsonItem === 'string') { result.push(parameters.factory.newRelationship(namespace, type, jsonItem)); } else { if (!this.acceptResourcesForRelationships) { throw new Error('Invalid JSON data. Found a value that is not a string: ' + jsonObj + ' for relationship ' + relationshipDeclaration); } // this isn't a relationship, but it might be an object! if(!jsonItem.$class) { throw new Error('Invalid JSON data. Does not contain a $class type identifier: ' + jsonItem + ' for relationship ' + relationshipDeclaration ); } const classDeclaration = parameters.modelManager.getType(jsonItem.$class); if(!classDeclaration) { throw new Error( 'Failed to find type ' + jsonItem.$class + ' in ModelManager.' ); } // create a new instance, using the identifier field name as the ID. let subResource = parameters.factory.newInstance(classDeclaration.getModelFile().getNamespace(), classDeclaration.getName(), jsonItem[classDeclaration.getIdentifierFieldName()] ); parameters.jsonStack.push(jsonItem); parameters.resourceStack.push(subResource); classDeclaration.accept(this, parameters); result.push(subResource); } } } else { if (typeof jsonObj === 'string') { result = parameters.factory.newRelationship(namespace, type, jsonObj); } else { if (!this.acceptResourcesForRelationships) { throw new Error('Invalid JSON data. Found a value that is not a string: ' + jsonObj + ' for relationship ' + relationshipDeclaration); } // this isn't a relationship, but it might be an object! if(!jsonObj.$class) { throw new Error('Invalid JSON data. Does not contain a $class type identifier: ' + jsonObj + ' for relationship ' + relationshipDeclaration ); } const classDeclaration = parameters.modelManager.getType(jsonObj.$class); if(!classDeclaration) { throw new Error( 'Failed to find type ' + jsonObj.$class + ' in ModelManager.' ); } // create a new instance, using the identifier field name as the ID. let subResource = parameters.factory.newInstance(classDeclaration.getModelFile().getNamespace(), classDeclaration.getName(), jsonObj[classDeclaration.getIdentifierFieldName()] ); parameters.jsonStack.push(jsonObj); parameters.resourceStack.push(subResource); classDeclaration.accept(this, parameters); result = subResource; } } return result; } } module.exports = JSONPopulator; Ã— Search results Close "},"composer-common_lib_codegen_jsonwriter.js.html":{"id":"composer-common_lib_codegen_jsonwriter.js.html","title":"Source: composer-common/lib/codegen/jsonwriter.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/codegen/jsonwriter.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Writer = require('./writer'); /** * JSONWriter manages a text buffer for writing JSON data structures. * It tracks when a comma is needed to separate items. Commas are inserted * automatically based on context. * @private * @extends Writer * @see See [Writer]{@link module:composer-common.Writer} * @class * @memberof module:composer-common */ class JSONWriter extends Writer { /** * Create a JSONWriter. * */ constructor() { super(); this.indent = 0; this.firstItem = true; } /** * Opens an object declaration * @param {string} key - the key */ openObject() { this.write('{'); this.indent++; this.firstItem = true; this.log('{'); } /** * Close the current object declaration. */ closeObject() { this.write('}'); this.indent--; this.firstItem = false; this.log('}'); } /** * Writes a key, in the format * '&quot;key&quot; : ' * @param {string} key - the key */ writeKey(key) { this.writeComma(); this.write(`&quot;${key}&quot;:`); this.log('writeKey', key ); } /** * Writes a comma when this.firstItem === false */ writeComma() { if(this.firstItem === false) { this.write(','); this.log(','); } else { this.log(', (suppressed)'); } } /** * Writes a value, in the format: * '&quot;value&quot;' * @param {string} value - the value */ writeStringValue(value) { this.write(`&quot;${value}&quot;`); this.firstItem = false; this.log('writeStringValue', value); } /** * Writes a value, in the format: * 'value' * @param {string} value - the value */ writeValue(value) { this.write(`${value}`); this.firstItem = false; this.log('writeValue', value); } /** * Writes a key/value, in the format: * '&quot;key&quot; : &quot;value&quot;' * @param {string} key - the key * @param {string} value - the value */ writeKeyStringValue(key,value) { this.writeComma(); this.write(`&quot;${key}&quot;:&quot;${value}&quot;`); this.firstItem = false; this.log('writeKeyStringValue', (key + ':' + value)); } /** * Writes a key/value, in the format: * '&quot;key&quot; : value' * @param {string} key - the key * @param {string} value - the value */ writeKeyValue(key,value) { this.writeComma(); this.write(`&quot;${key}&quot;: ${value}`); this.firstItem = false; this.log('writeKeyValue', key + '=' + value); } /** * Writes an array value, in the format * '&quot;value&quot;' * @param {string} value - the value */ writeArrayStringValue(value) { this.writeComma(); this.write(`&quot;${value}&quot;`); this.firstItem = false; this.log('writeArrayStringValue', value); } /** * Writes an array value, in the format * 'value' * @param {string} value - the value */ writeArrayValue(value) { this.writeComma(); this.write(`${value}`); this.firstItem = false; this.log('writeArrayValue', value); } /** * Opens a new array */ openArray() { this.write('['); this.indent++; this.firstItem = true; this.log('['); } /** * Closes the current array */ closeArray() { this.write(']'); this.indent--; this.firstItem = false; this.log(']'); } /** * @return {String} a string represention of this class */ toString() { return 'indent ' + this.indent + ' firstItem ' + this.firstItem; } /** * @param {String} callSite - the location * @param {String} message - the message to log. */ log(callSite, message) { const log = false; if(log) { let spaces = ''; for(let n=0; n &lt; this.indent; n++) { spaces += ' '; } if(!message) { message = ''; } console.log(spaces + ' ' + message + ' ' + callSite ); } } } module.exports = JSONWriter; Ã— Search results Close "},"composer-common_lib_log_logger.js.html":{"id":"composer-common_lib_log_logger.js.html","title":"Source: composer-common/lib/log/logger.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/log/logger.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; // const beautify = require('json-beautify'); // TODO: Will need to do improvement of the formatting with some module. // const sprintf = require('sprintf-js').sprintf; // const config = require('config'); // Moving config to some other location const Node = require('./node.js'); // Root node of the selection tree let _root = null; let _logger = null; let _clInstances = {}; /** * @description Class that provides the API to enable parts of the *Composer* * library to diagnostic messages. * * The aim is to provide a system whereby * - The *Composer* library has a common API to call and formats the essential data * its way * - It's own control of what level of data points are currently being collected * and for what module/class level * - Provide a default console and/or file basic log if user's application doesn't have * any preference * - Provide hook in which application can provide an injected dependancy to route * tracing to its own Logger * * # Log Levels * Standard log levels are in use. In order these are * - silly, debug, verbose, info, warn, error * In addition, there are functions that record method entry and method exit. these * map down to the debug level. * * Examples of using each function are included for each API below. * * At the top of the class (or file if not object style). issue. * * ``` * const log = require('./log/logger.js').getLog(&lt;CLASSNAME&gt;); * log.info(.....) * ``` * * @todo Confirm the format via iterative use * @todo Precrtiptive on how data is uploaded to logmet etc. ?? * * * * @private * @class * @memberof module:composer-common */ class Logger { /** * Constructor *THIS SHOULD ONLY BE CALLED INTERNALLY* * @param {String} name Classname or other filename for this logger * @private * */ constructor(name) { this.className = name; } /** * * @description Do the formatting of the data that *Composer* wishes to have for all * logging systems. This method does basic formatting before passing to the * log method of the selected logger implementation. * * Internal method * * @private * @param {String} logLevel log loglevel * @param {String} method method name * @param {String} msg to log * @param {others} arguments parameters are treated as data points to be logged */ intlog(logLevel,method,msg){ // first we need to make sure that we have logger setup this._intLogFirst.apply(this,arguments); } /** * @description Main internal logging method * * @param {String} loglevel log loglevel * @param {String} method method name * @param {String} msg to log */ _intLogMain(loglevel,method,msg){ if (typeof arguments[3] ==='undefined'){ _logger.log(loglevel,sprintf('%-25s:%-25s', this.className,method+'()'),msg); } else { let args = []; for(let i = 3; i &lt; arguments.length; i++) { if (arguments[i] instanceof Error){ args.push( {'stack' : sprintf('{%s}%s %s',arguments[i].name,arguments[i].message,arguments[i].stack,null,' ').match(/[^\\r\\n]+/g)}); }else { args.push(arguments[i]); } } _logger.log(loglevel,sprintf('%-25s:%-25s', this.className,method+'()'),msg, args); } } /** * @description initial internal log function that setups the logger to use. * Then it calls the normal internal log method (and modifies the original * function defn) * * @param {String} logLevel log loglevel * @param {String} method method name * @param {String} msg to log */ _intLogFirst(logLevel,method,msg){ // call the setup logger to make sure that things are setup // this is done now to be as late as possible Logger._setupLog(this); //reroute the ingLog method to the main implementation // and call this.intLog = this._intLogMain; // this._intLogMain.apply(this,arguments); this._intLogMain.apply(this,arguments); } /** * @description Log a message at the _debug_level * * @param {String} method calling method * @param {String} msg Text Message * @param {stuff} data Data to log * * @private */ debug(method, msg, data) { const args = Array.prototype.slice.call(arguments); args.unshift('debug'); this.intlog.apply(this, args); } /** * @description Log a message at the _warn_ level * * @param {String} method calling method * @param {String} msg Text Message * @param {stuff} data Data to log at warn level * * @private */ warn(method, msg, data) { const args = Array.prototype.slice.call(arguments); args.unshift('warn'); this.intlog.apply(this, args); } /** * @description Log a message at the _info_ level * * @param {String} method calling method * @param {String} msg Text Message * @param {stuff} data Data to log at an info level * * @private */ info(method, msg, data) { const args = Array.prototype.slice.call(arguments); args.unshift('info'); this.intlog.apply(this, args); } /** * @description Log a message at the _verbose_ level * * @param {String} method calling method * @param {String} msg Text Message * @param {stuff} data Data to log at a verbose level * * @private */ verbose(method,msg, data) { const args = Array.prototype.slice.call(arguments); args.unshift('verbose'); this.intlog.apply(this, args); } /** * @description Log a message at the _error_ level * * @param {String} method calling method * @param {String} msg Text Message * @param {stuff} data Data to log at an error level * * @private */ error(method, msg,data) { const args = Array.prototype.slice.call(arguments); args.unshift('error'); this.intlog.apply(this, args); } /** * @description Logs the entry to a method at the _debug_ level * * @param {String} method Text Message. * @param {stuff} data Data to log at an info level * * @private */ entry(method, data) { const args = Array.prototype.slice.call(arguments); args.shift(); args.unshift('debug', method, '&gt;'); this.intlog.apply(this, args); } /** * @description Logs the entry to a method at the _debug_ level * @param {String} method Method name * @param {objects} data Data to log * * @private */ exit(method, data) { const args = Array.prototype.slice.call(arguments); args.shift(); args.unshift('debug', method, '&lt;'); this.intlog.apply(this, args); } /** * @description Method to call passing an instance of an object that has the * method definition * * log(level,msg,data...) * * @param {Object} newlogger sets a new log processor to the one of your choice * * @private */ static setFunctionalLogger(newlogger){ _logger = newlogger; } /** * @descrption what is the debug environment variable set to * Note that the _envDebug property of this object is for debugging and * emergency use ONLY * * * @return {String} String of the DEBUG env variable * */ static getDebugEnv(){ return process.env.DEBUG || this._envDebug || ''; } /** get the configuration for the logging * @return {Object} with the config iformation * **/ static getLoggerConfig(){ try { // This weird code is needed to trick browserify. const mod = 'config'; const req = require; const config = req(mod); if (config.has('ConcertoConfig.debug')){ return config.get('ConcertoConfig.debug'); } } catch (e) { // We don't care if we can't find the config module, it won't be // there when the code is running inside a browser/chaincode. } return { 'logger': './winstonInjector.js', 'config': { 'console': { 'enabledLevel': 'info', 'alwaysLevel': 'none' }, 'file': { 'filename': 'trace_PID.log', 'enabledLevel': 'silly', 'alwaysLevel': 'info' } }}; } /** * @description Get the logger instance to be used for this class or file. * * @param {String} classname The classname (or filename if not a class) to get the logger for * @return {ConcertoLog} instance of a concertoLog to use * * @private */ static getLog(classname) { if(typeof _clInstances[classname] === 'undefined') { _clInstances[classname] = new Logger(classname); _clInstances[classname].log = Logger._intLogFirst; } return _clInstances[classname]; } /** @description gets the configuration that has been passed in to this node.js runtime * to control the tracing. This will update the concertLogger instance that * is passed in to match the settings * * @param {Logger} concertoLogger the instance of the Logger class to update */ static _setupLog(concertoLogger){ let concertoConfigElements = []; if (_root === null){ // need to do the filtering to see if this shold be enabled or not let string = this.getDebugEnv(); let details = string.split(/[\\s,]+/); _root = new Node('root',false); const regex = /(-?)concerto:(.*)?/; // now we have an array of the elements that we might need to be enabled // for (let i=0; i&lt; details.length;i++){ let e = details[i]; if (e === '*' || e ==='concerto:*'){ _root.include = true; } // determine if the element is for concerto or not let machResult = e.match(regex); if (machResult!==null){ // got a result that we need to trace therefore setup the child node correctly let newNode = new Node(machResult[2] ,(machResult[1]==='') ); _root.addChildNodeAtStart(newNode); // make a note of the debug settings that permit the config elements concertoConfigElements.push(machResult[2]); } } } // need to check the config to determine what exactly we need to be using here if(_logger === null) { let localConfig = this.getLoggerConfig(); // use the config package to get conifguration to see what we should be doing. // and pass the restul fo the data to the logger indicated along with the // array of the data that might have been passed on the DBEUG variable. let loggerToUse = localConfig.logger; let myLogger = require(loggerToUse); _logger = myLogger.getLogger(localConfig.config,concertoConfigElements); } // now we need to check if the name that has come in and should be traced let n = _root.findChild(concertoLogger.classname); if ( typeof n ==='undefined'){ concertoLogger.include = _root.isIncluded(); } else { concertoLogger.include = n.isIncluded(); } return ; } /** * @description clean up the logger; required if anything is dynamically changed */ static reset(){ _root=null; _logger=null; _clInstances=[]; } } module.exports = Logger; Ã— Search results Close "},"composer-common_lib_acl_modelbinding.js.html":{"id":"composer-common_lib_acl_modelbinding.js.html","title":"Source: composer-common/lib/acl/modelbinding.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/acl/modelbinding.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const IllegalModelException = require('../introspect/illegalmodelexception'); const ModelUtil = require('../modelutil'); /** * ModelBinding captures a binding to a model element. A ModelBinding can * be to a namespace, a class, or an instance of a class, and may optionally * be bound to a named variable. * * @private * @class * @memberof module:composer-common */ class ModelBinding { /** * Create an ModelBinding from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {AclRule} aclRule - the AclRule for this ModelBinding * @param {Object} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(aclRule, ast) { if(!aclRule || !ast) { throw new IllegalModelException('Invalid AclRule or AST'); } this.ast = ast; this.aclRule = aclRule; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the AclRule that owns this ModelBinding. * * @return {AclRule} the owning AclRule */ getAclRule() { return this.aclRule; } /** * Process the AST and build the model * * @throws {InvalidModelException} * @private */ process() { this.qualifiedName = this.ast.qualifiedName; this.instanceId = null; if(this.ast.instanceId) { this.instanceId = this.ast.instanceId.name; } this.variableName = null; if(this.ast.variableName) { this.variableName = this.ast.variableName.name; } } /** * Returns strind representation of this object * * @return {string} the string version of the object */ toString() { let result = 'ModelBinding ' + this.qualifiedName; if(this.instanceId) { result += '#' + this.instanceId; } if(this.variableName) { result += ':' + this.variableName; } return result; } /** * Returns the fully qualified name of the model element for this ModelBinding. * * @return {string} the fully qualified model name */ getFullyQualifiedName() { return this.qualifiedName; } /** * Returns the identifier of the instance of the model element for this ModelBinding. * * @return {string} the identifier of the instance, or null */ getInstanceIdentifier() { return this.instanceId; } /** * Returns the name of the variable of the model element for this ModelBinding. * * @return {string} the name of the variable, or null */ getVariableName() { return this.variableName; } /** * Semantic validation of the structure of this ModelBinding. * &lt;p&gt; * Algorithm: * &lt;/p&gt; * &lt;ul&gt; * &lt;li&gt;If we have a variableName, then qualifiedName cannot be a namespace * &lt;li&gt;If we have an instanceId, then qualifiedName cannot be a namespace * &lt;/ul&gt; * &lt;pre&gt; * We assume we have ns.class.property and try to resolve the class in ns * - On success * -- Check that the property exists * - On failure * -- Try to resolve ns.class * -- On failure * --- If instanceId and variableName are null * --- Try to resolve ns * &lt;/pre&gt; * @throws {InvalidModelException} * @private */ validate() { const mm = this.getAclRule().getAclFile().getModelManager(); // assume qualifiedName is ns.class.property const nsDotClass = ModelUtil.getNamespace(this.qualifiedName); const ns = ModelUtil.getNamespace(nsDotClass); const className = ModelUtil.getShortName(nsDotClass); const propertyName = ModelUtil.getShortName(this.qualifiedName); const modelFile = mm.getModelFile(ns); if(modelFile) { const classDeclaration = modelFile.getLocalType(className); if(classDeclaration) { const property = classDeclaration.getProperty(propertyName); if(!property) { throw new Error('Failed to find property ' + this.qualifiedName); } } } else { // assume qualifiedName is ns.class const ns = ModelUtil.getNamespace(this.qualifiedName); const className = ModelUtil.getShortName(this.qualifiedName); const modelFile = mm.getModelFile(ns); if(modelFile) { const classDeclaration = modelFile.getLocalType(className); if(!classDeclaration) { throw new Error('Failed to find class ' + this.qualifiedName); } } else if(this.instanceId === null &amp;&amp; this.variableName === null) { // assume namespace const modelFile = mm.getModelFile(this.qualifiedName); if(!modelFile) { throw new Error('Failed to find namespace ' + this.qualifiedName); } } else { throw new Error('Failed to resolve ' + this.qualifiedName); } } } /** * Returns a new object representing this function declaration that is * suitable for serializing as JSON. * @return {Object} A new object suitable for serializing as JSON. */ toJSON() { let result = { qualifiedName: this.qualifiedName, instanceId: this.instanceId, variableName: this.variableName }; return result; } } module.exports = ModelBinding; Ã— Search results Close "},"composer-common_lib_introspect_modelfile.js.html":{"id":"composer-common_lib_introspect_modelfile.js.html","title":"Source: composer-common/lib/introspect/modelfile.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/introspect/modelfile.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const parser = require('./parser'); const AssetDeclaration = require('./assetdeclaration'); const EnumDeclaration = require('./enumdeclaration'); const ConceptDeclaration = require('./conceptdeclaration'); const ParticipantDeclaration = require('./participantdeclaration'); const TransactionDeclaration = require('./transactiondeclaration'); const IllegalModelException = require('./illegalmodelexception'); const ParseException = require('./parseexception'); const ModelUtil = require('../modelutil'); const Globalize = require('../globalize'); /** * Class representing a Model File. A Model File contains a single namespace * and a set of model elements: assets, transactions etc. * @private * @class * @memberof module:composer-common */ class ModelFile { /** * Create a ModelFile. This should only be called by framework code. * Use the ModelManager to manage ModelFiles. * * @param {ModelManager} modelManager - the ModelManager that manages this * ModelFile * @param {string} definitions - The DSL model as a string. * @throws {InvalidModelException} */ constructor(modelManager, definitions) { this.modelManager = modelManager; this.declarations = []; this.imports = []; if(!definitions || typeof definitions !== 'string') { throw new Error('ModelFile expects a Concerto model as a string as input.'); } this.definitions = definitions; try { this.ast = parser.parse(definitions); } catch(err) { if(err.location &amp;&amp; err.location.start) { throw new ParseException( err.message + ' Line ' + err.location.start.line + ' column ' + err.location.start.column ); } else { throw err; } } this.namespace = this.ast.namespace; if(this.ast.imports) { this.imports = this.ast.imports; } for(let n=0; n &lt; this.ast.body.length; n++ ) { let thing = this.ast.body[n]; if(thing.type === 'AssetDeclaration') { this.declarations.push( new AssetDeclaration(this, thing) ); } else if(thing.type === 'TransactionDeclaration') { this.declarations.push( new TransactionDeclaration(this, thing) ); } else if(thing.type === 'ParticipantDeclaration') { this.declarations.push( new ParticipantDeclaration(this, thing) ); } else if(thing.type === 'EnumDeclaration') { this.declarations.push( new EnumDeclaration(this, thing) ); } else if(thing.type === 'ConceptDeclaration') { this.declarations.push( new ConceptDeclaration(this, thing) ); } else { let formatter = Globalize('en').messageFormatter('modelfile-constructor-unrecmodelelem'); throw new IllegalModelException(formatter({ 'type': thing.type, })); } } } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the ModelManager associated with this ModelFile * * @return {ModelManager} The ModelManager for this ModelFile */ getModelManager() { return this.modelManager; } /** * Returns the types that have been imported into this ModelFile. * * @return {string[]} The array of imports for this ModelFile */ getImports() { return this.imports; } /** * Validates the ModelFile. * * @throws {IllegalModelException} if the model is invalid * @private */ validate() { for(let n=0; n &lt; this.declarations.length; n++) { let classDeclaration = this.declarations[n]; classDeclaration.validate(); } } /** * Check that the type is valid. * @param {string} context - error reporting context * @param {string} type - a short type name * @throws {IllegalModelException} - if the type is not defined * @private */ resolveType(context,type) { // is the type a primitive? if(!ModelUtil.isPrimitiveType(type)) { // is it an imported type? if(!this.isImportedType(type)) { // is the type declared locally? if(!this.isLocalType(type)) { let formatter = Globalize('en').messageFormatter('modelfile-resolvetype-undecltype'); throw new IllegalModelException(formatter({ 'type': type, 'context': context })); } } else { // check whether type is defined in another file this.getModelManager().resolveType(context,this.resolveImport(type)); } } } /** * Returns true if the type is defined in this namespace. * @param {string} type - the short name of the type * @return {boolean} - true if the type is defined in this ModelFile * @private */ isLocalType(type) { let result = (type !== null &amp;&amp; this.getLocalType(type) !== null); //console.log('isLocalType ' + this.getNamespace() + ' ' + type + '=' + result ); return result; } /** * Returns true if the type is imported from another namespace * @param {string} type - the short name of the type * @return {boolean} - true if the type is imported from another namespace * @private */ isImportedType(type) { //console.log('isImportedType ' + this.getNamespace() + ' ' + type ); for(let n=0; n &lt; this.imports.length; n++) { let importName = this.imports[n]; if( ModelUtil.getShortName(importName) === type ) { return true; } } return false; } /** * Returns the FQN for a type that is imported from another namespace * @param {string} type - the short name of the type * @return {string} - the FQN of the resolved import * @throws {Error} - if the type is not imported * @private */ resolveImport(type) { //console.log('resolveImport ' + this.getNamespace() + ' ' + type ); for(let n=0; n &lt; this.imports.length; n++) { let importName = this.imports[n]; if( ModelUtil.getShortName(importName) === type ) { return importName; } } let formatter = Globalize('en').messageFormatter('modelfile-resolveimport-failfindimp'); throw new IllegalModelException(formatter({ 'type': type, 'imports': this.imports, 'namespace': this.getNamespace() })); } /** * Returns true if the type is defined in the model file * @param {string} type the name of the type * @return {boolean} true if the type (asset or transaction) is defined */ isDefined(type) { return ModelUtil.isPrimitiveType(type) || this.getLocalType(type) !== null; } /** * Returns the FQN of the type or null if the type could not be resolved. * For primitive types the type name is returned. * @param {string} type - a FQN or short type name * @return {string | ClassDeclaration} the class declaration for the type or null. * @private */ getType(type) { // is the type a primitive? if(!ModelUtil.isPrimitiveType(type)) { // is it an imported type? if(!this.isImportedType(type)) { // is the type declared locally? if(!this.isLocalType(type)) { return null; } else { return this.getLocalType(type); } } else { // check whether type is defined in another file const fqn = this.resolveImport(type); const modelFile = this.getModelManager().getModelFile(ModelUtil.getNamespace(fqn)); if (!modelFile) { return null; } else { return modelFile.getLocalType(fqn); } } } else { // for primitive types we just return the name return type; } } /** * Returns the FQN of the type or null if the type could not be resolved. * For primitive types the short type name is returned. * @param {string} type - a FQN or short type name * @return {string} the FQN type name or null * @private */ getFullyQualifiedTypeName(type) { // is the type a primitive? if(!ModelUtil.isPrimitiveType(type)) { // is it an imported type? if(!this.isImportedType(type)) { // is the type declared locally? if(!this.isLocalType(type)) { return null; } else { return this.getLocalType(type).getFullyQualifiedName(); } } else { // check whether type is defined in another file const fqn = this.resolveImport(type); const modelFile = this.getModelManager().getModelFile(ModelUtil.getNamespace(fqn)); return modelFile.getLocalType(fqn).getFullyQualifiedName(); } } else { // for primitive types we just return the name return type; } } /** * Returns the type with the specified name or null * @param {string} type the short OR FQN name of the type * @return {ClassDeclaration} the ClassDeclaration, or null if the type does not exist */ getLocalType(type) { if(!type.startsWith(this.getNamespace())) { type = this.getNamespace() + '.' + type; } for(let n=0; n &lt; this.declarations.length; n++) { let classDeclaration = this.declarations[n]; if(type === this.getNamespace() + '.' + classDeclaration.getName() ) { return classDeclaration; } } return null; } /** * Get the AssetDeclarations defined in this ModelFile or null * @param {string} name the name of the type * @return {AssetDeclaration} the AssetDeclaration with the given short name */ getAssetDeclaration(name) { let classDeclaration = this.getLocalType(name); if(classDeclaration instanceof AssetDeclaration) { return classDeclaration; } return null; } /** * Get the TransactionDeclaration defined in this ModelFile or null * @param {string} name the name of the type * @return {TransactionDeclaration} the TransactionDeclaration with the given short name */ getTransactionDeclaration(name) { let classDeclaration = this.getLocalType(name); if(classDeclaration instanceof TransactionDeclaration) { return classDeclaration; } return null; } /** * Get the ParticipantDeclaration defined in this ModelFile or null * @param {string} name the name of the type * @return {ParticipantDeclaration} the ParticipantDeclaration with the given short name */ getParticipantDeclaration(name) { let classDeclaration = this.getLocalType(name); if(classDeclaration instanceof ParticipantDeclaration) { return classDeclaration; } return null; } /** * Get the Namespace for this model file. * @return {string} The Namespace for this model file */ getNamespace() { return this.namespace; } /** * Get the AssetDeclarations defined in this ModelFile * @return {AssetDeclaration[]} the AssetDeclarations defined in the model file */ getAssetDeclarations() { return this.getDeclarations(AssetDeclaration); } /** * Get the TransactionDeclarations defined in this ModelFile * @return {TransactionDeclaration[]} the TransactionDeclarations defined in the model file */ getTransactionDeclarations() { return this.getDeclarations(TransactionDeclaration); } /** * Get the ParticipantDeclarations defined in this ModelFile * @return {ParticipantDeclaration[]} the ParticipantDeclaration defined in the model file */ getParticipantDeclarations() { return this.getDeclarations(ParticipantDeclaration); } /** * Get the ConceptDeclarations defined in this ModelFile * @return {ConceptDeclaration[]} the ParticipantDeclaration defined in the model file */ getConceptDeclarations() { return this.getDeclarations(ConceptDeclaration); } /** * Get the EnumDeclarations defined in this ModelFile * @return {EnumDeclaration[]} the EnumDeclaration defined in the model file */ getEnumDeclarations() { return this.getDeclarations(EnumDeclaration); } /** * Get the instances of a given type in this ModelFile * @param {Function} type - the type of the declaration * @return {ClassDeclaration[]} the ClassDeclaration defined in the model file */ getDeclarations(type) { let result = []; for(let n=0; n &lt; this.declarations.length; n++) { let classDeclaration = this.declarations[n]; if(classDeclaration instanceof type) { result.push(classDeclaration); } } return result; } /** * Get all declarations in this ModelFile * @return {ClassDeclaration[]} the ClassDeclarations defined in the model file */ getAllDeclarations() { return this.declarations; } /** * Get the definitions for this model. * @return {string} The definitions for this model. */ getDefinitions() { return this.definitions; } /** * Return an object suitable for serialization. * @return {Object} An object suitable for serialization. */ toJSON() { return {}; } } module.exports = ModelFile; Ã— Search results Close "},"composer-common_lib_modelmanager.js.html":{"id":"composer-common_lib_modelmanager.js.html","title":"Source: composer-common/lib/modelmanager.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/modelmanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Globalize = require('./globalize'); const IllegalModelException = require('./introspect/illegalmodelexception'); const ModelUtil = require('./modelutil'); const ModelFile = require('./introspect/modelfile'); /** * &lt;p&gt; * The structure of {@link Resource}s (Assets, Transactions, Participants) is modelled * in a set of Composer files. The contents of these files are managed * by the {@link ModelManager}. Each Composer file has a single namespace and contains * a set of asset, transaction and participant type definitions. * &lt;/p&gt; * &lt;p&gt; * Composer applications load their Composer files and then call the {@link ModelManager#addModelFile addModelFile} * method to register the Composer file(s) with the ModelManager. The ModelManager * parses the text of the Composer file and will make all defined types available * to other Composer services, such as the {@link Serializer} (to convert instances to/from JSON) * and {@link Factory} (to create instances). * &lt;/p&gt; * &lt;p&gt;&lt;a href=&quot;./diagrams-private/modelmanager.svg&quot;&gt;&lt;img src=&quot;./diagrams-private/modelmanager.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @private * @class * @memberof module:composer-common */ class ModelManager { /** * Create the ModelManager. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Composer}&lt;/strong&gt; * &lt;/p&gt; */ constructor() { this.modelFiles = {}; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Adds a Composer file (as a string) to the ModelManager. * Composer files have a single namespace. If a Composer file with the * same namespace has already been added to the ModelManager then it * will be replaced. * Note that if there are dependencies between multiple files the files * must be added in dependency order, or the addModelFiles method can be * used to add a set of files irrespective of dependencies. * @param {string} modelFile - The Composer file as a string * @throws {InvalidModelException} * @return {Object} The newly added model file (internal). */ addModelFile(modelFile) { if (typeof modelFile === 'string') { let m = new ModelFile(this, modelFile); m.validate(); this.modelFiles[m.getNamespace()] = m; return m; } else { modelFile.validate(); this.modelFiles[modelFile.getNamespace()] = modelFile; return modelFile; } } /** * Updates a Composer file (as a string) on the ModelManager. * Composer files have a single namespace. If a Composer file with the * same namespace has already been added to the ModelManager then it * will be replaced. * @param {string} modelFile - The Composer file as a string * @throws {InvalidModelException} * @returns {Object} The newly added model file (internal). */ updateModelFile(modelFile) { if (typeof modelFile === 'string') { let m = new ModelFile(this, modelFile); if (!this.modelFiles[m.getNamespace()]) { throw new Error('model file does not exist'); } m.validate(); this.modelFiles[m.getNamespace()] = m; return m; } else { if (!this.modelFiles[modelFile.getNamespace()]) { throw new Error('model file does not exist'); } modelFile.validate(); this.modelFiles[modelFile.getNamespace()] = modelFile; return modelFile; } } /** * Remove the Composer file for a given namespace * @param {string} namespace - The namespace of the model file to * delete. */ deleteModelFile(namespace) { if (!this.modelFiles[namespace]) { throw new Error('model file does not exist'); } delete this.modelFiles[namespace]; } /** * Add a set of Composer files to the model manager. * @param {string[]} modelFiles - An array of Composer files as * strings. * @returns {Object[]} The newly added model files (internal). */ addModelFiles(modelFiles) { const originalModelFiles = {}; Object.assign(originalModelFiles, this.modelFiles); let newModelFiles = []; try { // create the model files modelFiles.forEach((modelFile) =&gt; { if (typeof modelFile === 'string') { let m = new ModelFile(this, modelFile); this.modelFiles[m.getNamespace()] = m; newModelFiles.push(m); } else { this.modelFiles[modelFile.getNamespace()] = modelFile; newModelFiles.push(modelFile); } }); // re-validate all the model files for (let ns in this.modelFiles) { this.modelFiles[ns].validate(); } // return the model files. return newModelFiles; } catch(err) { this.modelFiles = {}; Object.assign(this.modelFiles, originalModelFiles); throw err; } } /** * Get the array of model file instances * @return {ModelFile[]} The ModelFiles registered * @private */ getModelFiles() { let keys = Object.keys(this.modelFiles); let result = []; for(let n=0; n &lt; keys.length;n++) { result.push(this.modelFiles[keys[n]]); } return result; } /** * Check that the type is valid and returns the FQN of the type. * @param {string} context - error reporting context * @param {string} type - a short type name * @return {string} - the resolved type name (fully qualified) * @throws {IllegalModelException} - if the type is not defined * @private */ resolveType(context,type) { // is the type a primitive? if(!ModelUtil.isPrimitiveType(type)) { let ns = ModelUtil.getNamespace(type); let modelFile = this.getModelFile(ns); if(!modelFile) { let formatter = Globalize.messageFormatter('modelmanager-resolvetype-nonsfortype'); throw new IllegalModelException(formatter({ type: type, context: context })); } if(!modelFile.isLocalType(type)) { let formatter = Globalize.messageFormatter('modelmanager-resolvetype-notypeinnsforcontext'); throw new IllegalModelException(formatter({ context: context, type: type, namespace: modelFile.getNamespace() })); } else { return modelFile.getNamespace() + '.' + type; } } else { return type; } } /** * Remove all registered Composer files */ clearModelFiles() { this.modelFiles = {}; } /** * Get the ModelFile associated with a namespace * @param {string} namespace - the namespace containing the ModelFile * @return {ModelFile} registered ModelFile for the namespace or null * @private */ getModelFile(namespace) { return this.modelFiles[namespace]; } /** * Get the namespaces registered with the ModelManager. * @return {string[]} namespaces - the namespaces that have been registered. */ getNamespaces() { return Object.keys(this.modelFiles); } /** * Look up a type in all registered namespaces. * * @param {string} type - the fully qualified name of a type * @return {ClassDeclaration} - the class declaration or null for primitive types * @throws {Error} - if the type cannot be found * @private */ getType(type) { // is the type a primitive? if(!ModelUtil.isPrimitiveType(type)) { let ns = ModelUtil.getNamespace(type); let modelFile = this.getModelFile(ns); if(!modelFile) { let formatter = Globalize.messageFormatter('modelmanager-gettype-noregisteredns'); throw new Error(formatter({ type: type })); } let classDecl = modelFile.getType(type); if(!classDecl) { throw new Error( 'No type ' + type + ' in namespace ' + modelFile.getNamespace() ); } return classDecl; } else { return null; } } /** * Get the AssetDeclarations defined in this model manager * @return {AssetDeclaration[]} the AssetDeclarations defined in the model manager */ getAssetDeclarations() { return this.getModelFiles().reduce((prev, cur) =&gt; { return prev.concat(cur.getAssetDeclarations()); }, []); } /** * Get the TransactionDeclarations defined in this model manager * @return {TransactionDeclaration[]} the TransactionDeclarations defined in the model manager */ getTransactionDeclarations() { return this.getModelFiles().reduce((prev, cur) =&gt; { return prev.concat(cur.getTransactionDeclarations()); }, []); } /** * Get the ParticipantDeclarations defined in this model manager * @return {ParticipantDeclaration[]} the ParticipantDeclaration defined in the model manager */ getParticipantDeclarations() { return this.getModelFiles().reduce((prev, cur) =&gt; { return prev.concat(cur.getParticipantDeclarations()); }, []); } /** * Get the EnumDeclarations defined in this model manager * @return {EnumDeclaration[]} the EnumDeclaration defined in the model manager */ getEnumDeclarations() { return this.getModelFiles().reduce((prev, cur) =&gt; { return prev.concat(cur.getEnumDeclarations()); }, []); } /** * Get the Concepts defined in this model manager * @return {ConceptDeclaration[]} the ConceptDeclaration defined in the model manager */ getConceptDeclarations() { return this.getModelFiles().reduce((prev, cur) =&gt; { return prev.concat(cur.getConceptDeclarations()); }, []); } /** * Stop serialization of this object. * @return {Object} An empty object. */ toJSON() { return {}; } } module.exports = ModelManager; Ã— Search results Close "},"composer-common_lib_introspect_parseexception.js.html":{"id":"composer-common_lib_introspect_parseexception.js.html","title":"Source: composer-common/lib/introspect/parseexception.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/introspect/parseexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BaseException = require('../baseexception'); /** * Exception throws when a Composer file is syntactically invalid * @extends BaseException * @see See [BaseException]{@link module:composer-common.BaseException} * @class * @memberof module:composer-common */ class ParseException extends BaseException { /** * Create an ParseException * @param {string} message - the message for the exception */ constructor(message) { super(message); } } module.exports = ParseException; Ã— Search results Close "},"composer-common_lib_introspect_participantdeclaration.js.html":{"id":"composer-common_lib_introspect_participantdeclaration.js.html","title":"Source: composer-common/lib/introspect/participantdeclaration.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/introspect/participantdeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); /** Class representing the definition of a Participant. * @extends ClassDeclaration * @see See [ClassDeclaration]{@link module:composer-common.ClassDeclaration} * @private * @class * @memberof module:composer-common */ class ParticipantDeclaration extends ClassDeclaration { /** * Create an ParticipantDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } /** * Returns true if this class can be pointed to by a relationship * * @return {boolean} true if the class may be pointed to by a relationship */ isRelationshipTarget() { return true; } } module.exports = ParticipantDeclaration; Ã— Search results Close "},"composer-common_lib_codegen_fromjs_plantumlgenerator.js.html":{"id":"composer-common_lib_codegen_fromjs_plantumlgenerator.js.html","title":"Source: composer-common/lib/codegen/fromjs/plantumlgenerator.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/codegen/fromjs/plantumlgenerator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const fs = require('fs'); const path = require('path'); const FileWriter = require('../filewriter'); /** * Converts the includes, classes and methods in a Javascript * file into a PlantUML format file. * @private * @class * @memberof module:composer-common */ class PlantUMLGenerator { /** * @param {Object} program - the program arguments * @param {Object} file - the file instance being processed * @param {Object[]} includes - the includes (require statements) within the file * @param {Object[]} classes - the classes within the file * @param {Object[]} functions - the functions within the file */ generate(program, file, includes, classes, functions) { // generate the output if(classes.length &gt; 0 || functions.length &gt; 0) { let fileWriter = new FileWriter(program.outputDir); const umlFilename = toUMLFilename(program.inputDir, program.outputDir, file); console.log('open file: ' + umlFilename); fileWriter.openFile(umlFilename); fileWriter.writeLine(0, '@startuml'); for(let n=0; n &lt; includes.length; n++) { // only include files that exist // the file may not exist if it was empty const includeFile = program.outputDir + '/' + includes[n] + '.uml'; if (fs.existsSync(includeFile)) { fileWriter.writeLine(0, '!include ' + includeFile); } } for(let n=0; n &lt; classes.length; n++) { const clazz = classes[n]; fileWriter.writeLine(0, 'class ' + clazz.name + '{'); for(let i=0; i &lt; clazz.methods.length; i++) { const method = clazz.methods[i]; fileWriter.writeLine(1, method.visibility + ' ' + method.returnType + ' ' + method.name + paramsToString(method.methodArgs) ); } fileWriter.writeLine(0, '}'); if(clazz.superClass) { const filePath = path.parse(file); fileWriter.writeBeforeLine(0, '!include ' + filePath.dir + '/' + clazz.superClass.toLowerCase() + '.uml'); fileWriter.writeLine(0, clazz.name + ' --|&gt; ' + clazz.superClass); } } fileWriter.writeLine(0, '@enduml'); fileWriter.closeFile(); } } } /** * Converts an array of parameter types to a string * @param {string[]} paramTypes array of parameter type names * @return {string} - string representation * @private */ function paramsToString(paramTypes) { let result = '('; for(let n=0; n &lt; paramTypes.length; n++) { result += paramTypes[n]; if(n &lt; paramTypes.length-1) { result += ','; } } result += ')'; return result; } /** * @param {string} inputDir - the fully qualified input directory * @param {string} outputDir - the fully qualified output directory * @param {string} filename - the fully qualified input file name (.js) * @return {string} the UML file name to use * @private */ function toUMLFilename(inputDir, outputDir, filename) { console.log('inputDir' + inputDir); console.log('outputDir' + outputDir); console.log('filename' + filename); let index = filename.indexOf(inputDir); console.log('index ' + index); let rest = filename.substr(index + 1 + inputDir.length); // let out = outputDir + '/' + rest; let i = rest.lastIndexOf('.'); // console.log('result' + out.substr(0, i) + '.uml' ); return (i &lt; 0) ? '' : rest.substr(0, i) + '.uml'; } module.exports = PlantUMLGenerator; Ã— Search results Close "},"composer-common_lib_acl_predicate.js.html":{"id":"composer-common_lib_acl_predicate.js.html","title":"Source: composer-common/lib/acl/predicate.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/acl/predicate.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const IllegalModelException = require('../introspect/illegalmodelexception'); /** * Predicate captures a conditional Javascript expression: * anything that can legally appear within a if statement. * * @private * @class * @memberof module:composer-common */ class Predicate { /** * Create an Predicate from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {AclRule} aclRule - the AclRule for this Predicate * @param {Object} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(aclRule, ast) { if(!aclRule || !ast) { throw new IllegalModelException('Invalid AclRule or AST'); } this.expression = ast; this.aclRule = aclRule; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the AclRule that owns this ModelBinding. * * @return {AclRule} the owning AclRule */ getAclRule() { return this.aclRule; } /** * Returns the expression as a text string. * * @return {string} the operator for the predicate */ getExpression() { return this.expression; } /** * Process the AST and build the model * * @throws {InvalidModelException} * @private */ process() { } /** * Semantic validation of the structure of this ModelBinding. * * @throws {InvalidModelException} * @private */ validate() { } /** * Returns a new object representing this function declaration that is * suitable for serializing as JSON. * @return {Object} A new object suitable for serializing as JSON. */ toJSON() { let result = { expression: this.expression, }; return result; } } module.exports = Predicate; Ã— Search results Close "},"composer-common_lib_introspect_property.js.html":{"id":"composer-common_lib_introspect_property.js.html","title":"Source: composer-common/lib/introspect/property.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/introspect/property.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ModelUtil = require('../modelutil'); /** * Property representing an attribute of a class declaration, * either a Field or a Relationship. * @private * @class * @memberof module:composer-common */ class Property { /** * Create a Property. * @param {ClassDeclaration} parent - the owner of this property * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(parent, ast) { this.ast = ast; this.parent = parent; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the owner of this property * @return {ClassDeclaration} the parent class declaration */ getParent() { return this.parent; } /** * Process the AST and build the model * @throws {InvalidModelException} * @private */ process() { this.name = this.ast.id.name; if(!this.name) { throw new Error('No name for type ' + this.ast ); } if(this.ast.propertyType) { this.type = this.ast.propertyType.name; } else { this.type = null; } this.array = false; if(this.ast.array) { this.array = true; } if(this.ast.optional) { this.optional = true; } else { this.optional = false; } } /** * Validate the property * @param {ClassDeclaration} classDecl the class declaration of the property * @throws {InvalidModelException} * @private */ validate(classDecl) { if(this.type) { classDecl.getModelFile().resolveType('Property type ' + this.name, this.type); } } /** * Returns the name of a property * @return {string} the name of this field */ getName() { return this.name; } /** * Returns the type of a property * @return {string} the type of this field */ getType() { return this.type; } /** * Returns true if the field is optional * @return {boolean} true if the field is optional */ isOptional() { return this.optional; } /** * Returns the fully qualified type name of a property * @return {string} the fully qualified type of this property */ getFullyQualifiedTypeName() { if(this.isPrimitive()) { return this.type; } const parent = this.getParent(); if(!parent) { throw new Error('Property ' + this.name + ' does not have a parent.'); } const modelFile = parent.getModelFile(); if(!modelFile) { throw new Error('Parent of property ' + this.name + ' does not have a ModelFile!'); } const result = modelFile.getFullyQualifiedTypeName(this.type); if(!result) { throw new Error('Failed to find fully qualified type name for property ' + this.name + ' with type ' + this.type ); } return result; } /** * Returns the fully name of a property (ns + class name + property name) * @return {string} the fully qualified name of this property */ getFullyQualifiedName() { return this.getNamespace() + '.' + this.getParent().getName() + '.' + this.getName(); } /** * Returns the namespace of the parent of this property * @return {string} the namespace of the parent of this property */ getNamespace() { return this.getParent().getModelFile().getNamespace(); } /** * Returns true if the field is declared as an array type * @return {boolean} true if the property is an array type */ isArray() { return this.array; } /** * Returns true if the field is declared as an enumerated value * @return {boolean} true if the property is an enumerated value */ isTypeEnum() { if(this.isPrimitive()) { return false; } else { const type = this.getParent().getModelFile().getType(this.getType()); return type.isEnum(); } } /** * Returns true if this property is a primitive type. *@return {boolean} true if the property is a primitive type. */ isPrimitive() { return ModelUtil.isPrimitiveType(this.getType()); } /** * Stop serialization of this object. * @return {Object} An empty object. */ toJSON() { return {}; } } module.exports = Property; Ã— Search results Close "},"composer-common_lib_model_relationship.js.html":{"id":"composer-common_lib_model_relationship.js.html","title":"Source: composer-common/lib/model/relationship.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/model/relationship.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Identifiable = require('./identifiable'); /** * A Relationship is a typed pointer to an instance. I.e the relationship * with namespace = 'org.acme', type = 'Vehicle' and id = 'ABC' creates * a pointer that points at an instance of org.acme.Vehicle with the id * ABC. * @extends Identifiable * @see See [Identifiable]{@link module:composer-common.Identifiable} * @class * @memberof module:composer-common */ class Relationship extends Identifiable { /** * Create an asset. Use the Factory to create instances. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {string} id - The identifier of this instance. * @private */ constructor(modelManager, ns, type, id) { super(modelManager, ns, type, id); // we use this metatag to identify the instance as a relationship this.$class = 'Relationship'; } /** * Returns the string representation of this class * @return {String} the string representation of the class */ toString() { return 'Relationship {id=' + this.getFullyQualifiedIdentifier() +'}'; } /** * Determine if this identifiable is a relationship. * @return {boolean} True if this identifiable is a relationship, * false if not. */ isRelationship() { return true; } } module.exports = Relationship; Ã— Search results Close "},"composer-common_lib_introspect_relationshipdeclaration.js.html":{"id":"composer-common_lib_introspect_relationshipdeclaration.js.html","title":"Source: composer-common/lib/introspect/relationshipdeclaration.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/introspect/relationshipdeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Property = require('./property'); const IllegalModelException = require('./illegalmodelexception'); const ModelUtil = require('../modelutil'); /** * Class representing a relationship between model elements * @extends Property * @see See [Property]{@link module:composer-common.Property} * @private * @class * @memberof module:composer-common */ class RelationshipDeclaration extends Property { /** * Create a Relationship. * @param {ClassDeclaration} parent - The owner of this property * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(parent, ast) { super(parent, ast); } /** * Validate the property * @param {ClassDeclaration} classDecl the class declaration of the property * @throws {InvalidModelException} * @private */ validate(classDecl) { super.validate(classDecl); // relationship cannot point to primitive types if(!this.getType()) { throw new IllegalModelException('Relationship must have a type'); } let classDeclaration = null; // you can't have a relationship with a primitive... if(ModelUtil.isPrimitiveType(this.getType())) { throw new IllegalModelException('Relationship ' + this.getName() + ' cannot be to the primitive type ' + this.getType() ); } else { // we first try to get the type from our own model file // because during validate we have not yet been added to the model manager if(this.getParent().getModelFile().getNamespace() === ModelUtil.getNamespace(this.getFullyQualifiedTypeName())) { classDeclaration = this.getParent().getModelFile().getType(this.getType()); } else { // otherwise we have to use the modelmanager to try to load classDeclaration = this.getParent().getModelFile().getModelManager().getType(this.getFullyQualifiedTypeName()); } if(classDeclaration === null) { throw new IllegalModelException('Relationship ' + this.getName() + ' points to a missing type ' + this.getFullyQualifiedTypeName()); } if(classDeclaration.isRelationshipTarget() === false) { throw new IllegalModelException('Relationship ' + this.getName() + ' must be to an asset or participant, but is to ' + this.getFullyQualifiedTypeName()); } } } /** * Returns a string representation of this propertyÂ§ * @return {String} the string version of the property. */ toString() { return 'RelationshipDeclaration {name=' + this.name + ', type=' + this.getFullyQualifiedTypeName() + ', array=' + this.array + ', optional=' + this.optional +'}'; }} module.exports = RelationshipDeclaration; Ã— Search results Close "},"composer-common_lib_model_resource.js.html":{"id":"composer-common_lib_model_resource.js.html","title":"Source: composer-common/lib/model/resource.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/model/resource.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Identifiable = require('./identifiable'); /** * &lt;p&gt; * Resource is an instance that has a type. The type of the resource * specifies a set of properites (which themselves have types). * &lt;/p&gt; * &lt;p&gt; * Type information in Composer is used to validate the structure of * Resource instances and for serialization. * &lt;/p&gt; * &lt;p&gt; * Resources are used in Composer to represent Assets, Participants, Transactions and * other domain classes that can be serialized for long-term persistent storage. * &lt;/p&gt; * @extends Identifiable * @see See [Resource]{@link module:composer-common.Resource} * @class * @memberof module:composer-common */ class Resource extends Identifiable { /** * This constructor should not be called directly. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {string} id - The identifier of this instance. * @private */ constructor(modelManager, ns, type, id) { super(modelManager, ns, type, id); } /** * Returns the string representation of this class * @return {String} the string representation of the class */ toString() { return 'Resource {id=' + this.getFullyQualifiedIdentifier() +'}'; } /** * Determine if this identifiable is a resource. * @return {boolean} True if this identifiable is a resource, * false if not. */ isResource() { return true; } } module.exports = Resource; Ã— Search results Close "},"composer-common_lib_serializer_resourcevalidator.js.html":{"id":"composer-common_lib_serializer_resourcevalidator.js.html","title":"Source: composer-common/lib/serializer/resourcevalidator.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/serializer/resourcevalidator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('../introspect/classdeclaration'); const Field = require('../introspect/field'); const RelationshipDeclaration = require('../introspect/relationshipdeclaration'); const EnumDeclaration = require('../introspect/enumdeclaration'); const Relationship = require('../model/relationship'); const Resource = require('../model/resource'); const Concept = require('../model/concept'); const Identifiable = require('../model/identifiable'); const Util = require('../util'); const ModelUtil = require('../modelutil'); const ValidationException = require('./validationexception'); const Globalize = require('../globalize'); /** * &lt;p&gt; * Validates a Resource or Field against the models defined in the ModelManager. * This class is used with the Visitor pattern and visits the class declarations * (etc) for the model, checking that the data in a Resource / Field is consistent * with the model. * &lt;/p&gt; * The parameters for the visit method must contain the following properties: * &lt;ul&gt; * &lt;li&gt; 'stack' - the TypedStack of objects being processed. It should * start as [Resource] or [Field]&lt;/li&gt; * &lt;li&gt; 'rootResourceIdentifier' - the identifier of the resource being validated &lt;/li&gt; * &lt;li&gt; 'modelManager' - the ModelManager instance to use for type checking&lt;/li&gt; * &lt;/ul&gt; * @private * @class * @memberof module:composer-common */ class ResourceValidator { /** * Visitor design pattern. * * @param {Object} thing - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visit(thing, parameters) { const obj = parameters.stack.peek(); this.log('visit', thing.toString() + ' with value (' + obj + ')'); if (thing instanceof EnumDeclaration) { return this.visitEnumDeclaration(thing, parameters); } else if (thing instanceof ClassDeclaration) { return this.visitClassDeclaration(thing, parameters); } else if (thing instanceof RelationshipDeclaration) { return this.visitRelationshipDeclaration(thing, parameters); } else if (thing instanceof Field) { return this.visitField(thing, parameters); } } /** * Visitor design pattern * * @param {EnumDeclaration} enumDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitEnumDeclaration(enumDeclaration, parameters) { const obj = parameters.stack.pop(); // now check that obj is one of the enum values const properties = enumDeclaration.getProperties(); let found = false; for(let n=0; n &lt; properties.length; n++) { const property = properties[n]; if(property.getName() === obj) { found = true; } } if(!found) { ResourceValidator.reportInvalidEnumValue( parameters.rootResourceIdentifier, enumDeclaration, obj ); } return null; } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitClassDeclaration(classDeclaration, parameters) { const obj = parameters.stack.pop(); // are we dealing with a Resouce? if(!((obj instanceof Resource) || (obj instanceof Concept))) { ResourceValidator.reportNotResouceViolation(parameters.rootResourceIdentifier, classDeclaration, obj ); } if(obj instanceof Identifiable) { parameters.rootResourceIdentifier = obj.getFullyQualifiedIdentifier(); } const toBeAssignedClassDeclaration = parameters.modelManager.getType(obj.getFullyQualifiedType()); // is the type we are assigning to abstract? // the only way this can happen is if the type is non-abstract // and then gets redeclared as abstract if(toBeAssignedClassDeclaration.isAbstract()) { ResourceValidator.reportAbstractClass(toBeAssignedClassDeclaration); } // are there extra fields in the object? let props = Object.getOwnPropertyNames(obj); for (let n = 0; n &lt; props.length; n++) { let propName = props[n]; if(!this.isSystemProperty(propName)) { const field = toBeAssignedClassDeclaration.getProperty(propName); if (!field) { if(obj instanceof Identifiable) { ResourceValidator.reportUndeclaredField(obj.getIdentifier(), propName, toBeAssignedClassDeclaration.getFullyQualifiedName()); } else { ResourceValidator.reportUndeclaredField(this.currentIdentifier, propName, toBeAssignedClassDeclaration.getFullyQualifiedName()); } } } } if(obj instanceof Identifiable) { this.currentIdentifier = obj.getFullyQualifiedIdentifier(); } // now validate each property const properties = toBeAssignedClassDeclaration.getProperties(); for(let n=0; n &lt; properties.length; n++) { const property = properties[n]; const value = obj[property.getName()]; if(!Util.isNull(value)) { parameters.stack.push(value); property.accept(this,parameters); } else { if(!property.isOptional()) { ResourceValidator.reportMissingRequiredProperty( parameters.rootResourceIdentifier, property); } } } return null; } /** * Returns true if the property is a system property. * System properties are not declared in the model. * @param {String} propertyName - the name of the property * @return {Boolean} true if the property is a system property * @private */ isSystemProperty(propertyName) { return propertyName.charAt(0) === '$'; } /** * Visitor design pattern * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitField(field, parameters) { const obj = parameters.stack.pop(); let dataType = typeof(obj); let propName = field.getName(); if (dataType === 'undefined' || dataType === 'symbol') { ResourceValidator.reportFieldTypeViolation(parameters.rootResourceIdentifier, propName, obj, field); } if(field.isTypeEnum()) { this.checkEnum(obj, field,parameters); } else { if(field.isArray()) { this.checkArray(obj, field,parameters); } else { this.checkItem(obj, field,parameters); } } return null; } /** * Check a Field that is declared as an Array. * @param {Object} obj - the object being validated * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @private */ checkEnum(obj,field,parameters) { if(field.isArray() &amp;&amp; !(obj instanceof Array)) { ResourceValidator.reportFieldTypeViolation(parameters.rootResourceIdentifier, field.getName(), obj, field); } const enumDeclaration = field.getParent().getModelFile().getType(field.getType()); if(field.isArray()) { for(let n=0; n &lt; obj.length; n++) { const item = obj[n]; parameters.stack.push(item); enumDeclaration.accept(this, parameters); } } else { const item = obj; parameters.stack.push(item); enumDeclaration.accept(this, parameters); } } /** * Check a Field that is declared as an Array. * @param {Object} obj - the object being validated * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @private */ checkArray(obj,field,parameters) { if(!(obj instanceof Array)) { ResourceValidator.reportFieldTypeViolation(parameters.rootResourceIdentifier, field.getName(), obj, field); } for(let n=0; n &lt; obj.length; n++) { const item = obj[n]; this.checkItem(item, field, parameters); } } /** * Check a single (non-array) field. * @param {Object} obj - the object being validated * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @private */ checkItem(obj,field, parameters) { let dataType = typeof obj; let propName = field.getName(); if (dataType === 'undefined' || dataType === 'symbol') { ResourceValidator.reportFieldTypeViolation(parameters.rootResourceIdentifier, propName, obj, field); } if(field.isPrimitive()) { let invalid = false; switch(field.getType()) { case 'String': if(dataType !== 'string') { invalid = true; } break; case 'Double': case 'Long': case 'Integer': if(dataType !== 'number') { invalid = true; } break; case 'Boolean': if(dataType !== 'boolean') { invalid = true; } break; case 'DateTime': if(!(obj instanceof Date)) { invalid = true; } break; } if (invalid) { ResourceValidator.reportFieldTypeViolation(parameters.rootResourceIdentifier, propName, obj, field); } else { if(field.getValidator() !== null) { field.getValidator().validate(this.currentIdentifier, obj); } } } else { // a field that points to a transaction, asset, participant... let classDeclaration = parameters.modelManager.getType(field.getFullyQualifiedTypeName()); if(obj instanceof Identifiable) { classDeclaration = parameters.modelManager.getType(obj.getFullyQualifiedType()); if(!classDeclaration) { ResourceValidator.reportFieldTypeViolation(parameters.rootResourceIdentifier, propName, obj, field); } // is it compatible? if(!ModelUtil.isAssignableTo(classDeclaration.getModelFile(), classDeclaration.getFullyQualifiedName(), field)) { ResourceValidator.reportInvalidFieldAssignment(parameters.rootResourceIdentifier, propName, obj, field); } } // recurse parameters.stack.push(obj); classDeclaration.accept(this, parameters); } } /** * Visitor design pattern * @param {RelationshipDeclaration} relationshipDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitRelationshipDeclaration(relationshipDeclaration, parameters) { const obj = parameters.stack.pop(); if(relationshipDeclaration.isArray()) { if(!(obj instanceof Array)) { ResourceValidator.reportInvalidFieldAssignment(parameters.rootResourceIdentifier, relationshipDeclaration.getName(), obj, relationshipDeclaration); } for(let n=0; n &lt; obj.length; n++) { const item = obj[n]; this.checkRelationship(parameters, relationshipDeclaration, item); } } else { this.checkRelationship(parameters, relationshipDeclaration, obj); } return null; } /** * Check a single relationship * @param {Object} parameters - the parameter * @param {relationshipDeclaration} relationshipDeclaration - the object being visited * @param {Object} obj - the object being validated * @private */ checkRelationship(parameters, relationshipDeclaration, obj) { if(!(obj instanceof Relationship)) { ResourceValidator.reportNotRelationshipViolation(parameters.rootResourceIdentifier, relationshipDeclaration, obj); } const relationshipType = parameters.modelManager.getType(obj.getFullyQualifiedType()); if(relationshipType.isConcept()) { throw new Error('Cannot have a relationship to a concept. Relationships must be to resources.'); } if(!ModelUtil.isAssignableTo(relationshipType.getModelFile(), obj.getFullyQualifiedType(), relationshipDeclaration)) { ResourceValidator.reportInvalidFieldAssignment(parameters.rootResourceIdentifier, relationshipDeclaration.getName(), obj, relationshipDeclaration); } } /** * @param {String} callSite - the location * @param {String} message - the message to log. */ log(callSite, message) { const log = false; if(log) { if(!message) { message = ''; } console.log('[' + callSite + '] ' + message ); } } /** * Throw a new error for a model violation. * @param {string} id - the identifier of this instance. * @param {string} propName - the name of the field. * @param {*} value - the value of the field. * @param {Field} field - the field * @throws {ValidationException} the exception * @private */ static reportFieldTypeViolation(id, propName, value, field) { let isArray = field.isArray() ? '[]' : ''; let typeOfValue = typeof value; if(value instanceof Identifiable) { typeOfValue = value.getFullyQualifiedType(); value = value.getFullyQualifiedIdentifier(); } else { if(value) { try { value = JSON.stringify(value); } catch(err) { value = value.toString(); } } } let formatter = Globalize.messageFormatter('resourcevalidator-fieldtypeviolation'); throw new ValidationException(formatter({ resourceId: id, propertyName: propName, fieldType: field.getType() + isArray, value: value, typeOfValue: typeOfValue })); } /** * Throw a new error for a model violation. * @param {string} id - the identifier of this instance. * @param {classDeclaration} classDeclaration - the declaration of the classs * @param {Object} value - the value of the field. * @private */ static reportNotResouceViolation(id, classDeclaration, value) { let formatter = Globalize.messageFormatter('resourcevalidator-notresourceorconcept'); throw new ValidationException(formatter({ resourceId: id, classFQN: classDeclaration.getFullyQualifiedName(), invalidValue: value.toString() })); } /** * Throw a new error for a model violation. * @param {string} id - the identifier of this instance. * @param {RelationshipDeclaration} relationshipDeclaration - the declaration of the classs * @param {Object} value - the value of the field. * @private */ static reportNotRelationshipViolation(id, relationshipDeclaration, value) { let formatter = Globalize.messageFormatter('resourcevalidator-notrelationship'); throw new ValidationException(formatter({ resourceId: id, classFQN: relationshipDeclaration.getFullyQualifiedTypeName(), invalidValue: value.toString() })); } /** * Throw a new error for a missing, but required field. * @param {string} id - the identifier of this instance. * @param {Field} field - the field/ * @private */ static reportMissingRequiredProperty(id, field) { let formatter = Globalize.messageFormatter('resourcevalidator-missingrequiredproperty'); throw new ValidationException(formatter({ resourceId: id, fieldName: field.getName() })); } /** * Throw a new error for a missing, but required field. * @param {string} id - the identifier of this instance. * @param {Field} field - the field * @param {string} obj - the object value * @private */ static reportInvalidEnumValue(id, field, obj) { let formatter = Globalize.messageFormatter('resourcevalidator-invalidenumvalue'); throw new ValidationException(formatter({ resourceId: id, value: obj, fieldName: field.getName() })); } /** * Throw a validation exception for an abstract class * @param {ClassDeclaration} classDeclaration - the class declaration * @throws {ValidationException} the validation exception * @private */ static reportAbstractClass(classDeclaration) { let formatter = Globalize.messageFormatter('resourcevalidator-abstractclass'); throw new ValidationException(formatter({ className: classDeclaration.getFullyQualifiedName(), })); } /** * Throw a validation exception for an abstract class * @param {string} resourceId - the id of the resouce being validated * @param {string} propertyName - the name of the property that is not declared * @param {string} fullyQualifiedTypeName - the fully qualified type being validated * @throws {ValidationException} the validation exception * @private */ static reportUndeclaredField(resourceId, propertyName, fullyQualifiedTypeName ) { let formatter = Globalize.messageFormatter('resourcevalidator-undeclaredfield'); throw new ValidationException(formatter({ resourceId: resourceId, propertyName: propertyName, fullyQualifiedTypeName: fullyQualifiedTypeName })); } /** * Throw a validation exception for an invalid field assignment * @param {string} resourceId - the id of the resouce being validated * @param {string} propName - the name of the property that is being assigned * @param {*} obj - the Field * @param {Field} field - the Field * @throws {ValidationException} the validation exception * @private */ static reportInvalidFieldAssignment(resourceId, propName, obj, field) { let formatter = Globalize.messageFormatter('resourcevalidator-invalidfieldassignment'); let typeName = field.getFullyQualifiedTypeName(); if(field.isArray()) { typeName += '[]'; } throw new ValidationException(formatter({ resourceId: resourceId, propertyName: propName, objectType: obj.getFullyQualifiedType(), fieldType: typeName })); } } module.exports = ResourceValidator; Ã— Search results Close "},"composer-common_lib_introspect_script.js.html":{"id":"composer-common_lib_introspect_script.js.html","title":"Source: composer-common/lib/introspect/script.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/introspect/script.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const JavaScriptParser = require('../codegen/javascriptparser'); const FunctionDeclaration = require('../introspect/functiondeclaration'); /** * &lt;p&gt; * An executable script. * &lt;/p&gt; * @private * @class * @memberof module:composer-common */ class Script { /** * Create the Script. * &lt;p&gt; * @param {ModelManager} modelManager - The ModelManager associated with this Script * @param {string} identifier - The identifier of the script * @param {string} language - The language type of the script * @param {string} contents - The contents of the script */ constructor(modelManager, identifier, language, contents) { this.modelManager = modelManager; this.identifier = identifier; this.language = language; this.contents = contents; this.functions = []; if(!contents) { throw new Error('Empty script contents'); } const parser = new JavaScriptParser(this.contents); const functions = parser.getFunctions(); for(let n=0; n &lt; functions.length; n++) { const func = functions[n]; const functionDeclaration = new FunctionDeclaration(this.modelManager, this.language, func.name, func.visibility, func.returnType, func.throws, func.parameterNames, func.parameterTypes, func.decorators, func.functionText ); functionDeclaration.validate(); this.functions.push( functionDeclaration ); } } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the identifier of the script * @return {string} the identifier of the script */ getIdentifier() { return this.identifier; } /** * Returns the language of the script * @return {string} the identifier of the script */ getLanguage() { return this.language; } /** * Returns the contents of the script * @return {string} the identifier of the script */ getContents() { return this.contents; } /** * Returns the FunctionDeclaration for all functions that have been defined in this * Script. * * @return {FunctionDeclaration[]} The array of FunctionDeclarations */ getFunctionDeclarations() { return this.functions; } /** * Return a JSON safe representation of this object, primarily for logging. * @return {object} A JSON safe representation of this object. */ toJSON() { return { identifier: this.identifier, language: this.language }; } } module.exports = Script; Ã— Search results Close "},"composer-common_lib_scriptmanager.js.html":{"id":"composer-common_lib_scriptmanager.js.html","title":"Source: composer-common/lib/scriptmanager.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/scriptmanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Script = require('./introspect/script'); /** * &lt;p&gt; * Manages a set of scripts. * &lt;/p&gt; * @private * @class * @memberof module:composer-common */ class ScriptManager { /** * Create the ScriptManager. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkDefinition}&lt;/strong&gt; * &lt;/p&gt; * @param {ModelManager} modelManager - The ModelManager to use for this ScriptManager */ constructor(modelManager) { this.modelManager = modelManager; this.scripts = {}; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Creates a new Script from a string. * * @param {string} identifier - the identifier of the script * @param {string} language - the language identifier of the script * @param {string} contents - the contents of the script * @returns {Script} - the instantiated script */ createScript(identifier, language, contents) { return new Script(this.modelManager, identifier, language, contents ); } /** * Adds a Script to the ScriptManager * @param {Script} script - The script to add to the ScriptManager */ addScript(script) { this.scripts[script.getIdentifier()] = script; } /** * Update an existing Script in the ScriptManager * @param {Script} script - The script to add to the ScriptManager */ updateScript(script) { if (!this.scripts[script.getIdentifier()]) { throw new Error('Script file does not exist'); } this.addScript(script); } /** * Remove the Script * @param {string} identifier - The identifier of the script to remove * delete. */ deleteScript(identifier) { if (!this.scripts[identifier]) { throw new Error('Script file does not exist'); } delete this.scripts[identifier]; } /** * Get the array of Script instances * @return {Script[]} The Scripts registered * @private */ getScripts() { let keys = Object.keys(this.scripts); let result = []; for(let n=0; n &lt; keys.length;n++) { result.push(this.scripts[keys[n]]); } return result; } /** * Remove all registered Composer files */ clearScripts() { this.scripts = {}; } /** * Get the Script associated with an identifier * @param {string} identifier - the identifier of the Script * @return {Script} the Script * @private */ getScript(identifier) { return this.scripts[identifier]; } /** * Get the identifiers of all registered scripts * @return {string[]} The identifiers of all registered scripts */ getScriptIdentifiers() { return Object.keys(this.scripts); } /** * Stop serialization of this object. * @return {Object} An empty object. */ toJSON() { return {}; } } module.exports = ScriptManager; Ã— Search results Close "},"composer-common_lib_securitycontext.js.html":{"id":"composer-common_lib_securitycontext.js.html","title":"Source: composer-common/lib/securitycontext.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/securitycontext.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * SecurityContext is used to authenticate and manage * user credentials to the underlying blockchain fabric. * &lt;p&gt;&lt;a href=&quot;./diagrams/securitycontext.svg&quot;&gt;&lt;img src=&quot;./diagrams/securitycontext.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @abstract * @class * @memberof module:composer-common */ class SecurityContext { /** * Create the SecurityContext. * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances by calling {@link Composer#login login}&lt;/strong&gt; * &lt;/p&gt; * @param {Connection} connection The owning connection. * @param {string} user The user identifier. */ constructor(connection) { this.connection = connection; } /** * Get the owning connection. * @return {Connection} The owning connection. */ getConnection() { return this.connection; } /** * Get the current username. * @abstract * @return {string} The username */ getUser() { throw new Error('abstract function called'); } /** * Stop serialization of this object. * @return {Object} An empty object. */ toJSON() { return {}; } } module.exports = SecurityContext; Ã— Search results Close "},"composer-common_lib_securityexception.js.html":{"id":"composer-common_lib_securityexception.js.html","title":"Source: composer-common/lib/securityexception.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/securityexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BaseException = require('./baseexception'); /** * Class representing a security exception * &lt;p&gt;&lt;a href=&quot;./diagrams/securityexception.svg&quot;&gt;&lt;img src=&quot;./diagrams/securityexception.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends BaseException * @see See [BaseException]{@link module:composer-common.BaseException} * @class * @memberof module:composer-common */ class SecurityException extends BaseException { /** * Create the SecurityException. * @param {string} message - The exception message. */ constructor(message) { super(message); } } module.exports = SecurityException; Ã— Search results Close "},"composer-common_lib_serializer.js.html":{"id":"composer-common_lib_serializer.js.html","title":"Source: composer-common/lib/serializer.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/serializer.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Resource = require('./model/resource'); const Globalize = require('./globalize'); const JSONGenerator = require('./serializer/jsongenerator'); const JSONPopulator = require('./serializer/jsonpopulator'); const ResourceValidator = require('./serializer/resourcevalidator'); const TypedStack = require('./serializer/typedstack'); const JSONWriter = require('./codegen/jsonwriter'); /** * Serialize Resources instances to/from various formats for long-term storage * (e.g. on the blockchain). * &lt;p&gt;&lt;a href=&quot;./diagrams/serializer.svg&quot;&gt;&lt;img src=&quot;./diagrams/serializer.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @class * @memberof module:composer-common */ class Serializer { /** * Create a Serializer. * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Composer}&lt;/strong&gt; * &lt;/p&gt; * @param {Factory} factory - The Factory to use to create instances * @param {ModelManager} modelManager - The ModelManager to use for validation etc. */ constructor(factory,modelManager) { if(!factory) { throw new Error(Globalize.formatMessage('serializer-constructor-factorynull')); } else if(!modelManager) { throw new Error(Globalize.formatMessage('serializer-constructor-modelmanagernull')); } this.factory = factory; this.modelManager = modelManager; } /** * &lt;p&gt; * Convert a {@link Resource} to a JavaScript object suitable for long-term * peristent storage. * &lt;/p&gt; * @param {Resource} resource - The instance to convert to JSON * @param {Object} options - the optional serialization options. * @param {boolean} options.validate - validate the structure of the Resource * with its model prior to serialization (default to true) * @param {boolean} options.convertResourcesToRelationships - Convert resources that * are specified for relationship fields into relationships, false by default. * @param {boolean} options.permitResourcesForRelationships - Permit resources in the * place of relationships (serializing them as resources), false by default. * @return {Object} - The Javascript Object that represents the resource * @throws {Error} - throws an exception if resource is not an instance of * Resource or fails validation. */ toJSON(resource, options) { // correct instance type if(!(resource instanceof Resource)) { throw new Error(Globalize.formatMessage('serializer-tojson-notcobject')); } const parameters = {}; parameters.stack = new TypedStack(resource); parameters.modelManager = this.modelManager; parameters.seenResources = new Set(); const classDeclaration = this.modelManager.getType( resource.getFullyQualifiedType() ); if(!classDeclaration) { throw new Error( 'Failed to find type ' + resource.getFullyQualifiedType() + ' in ModelManager.' ); } // validate the resource against the model options = options || { validate: true }; if(options.validate === true) { const validator = new ResourceValidator(); classDeclaration.accept(validator, parameters); } const generator = new JSONGenerator( options.convertResourcesToRelationships === true, options.permitResourcesForRelationships === true ); const writer = new JSONWriter(); parameters.writer = writer; parameters.stack.clear(); parameters.stack.push(resource); // this writes the JSON into the parameters.writer classDeclaration.accept(generator, parameters); const jsonText = parameters.writer.getBuffer(); try { return JSON.parse(jsonText); } catch(err) { throw new Error( 'Generated invalid JSON: ' + jsonText ); } } /** * Create a {@link Resource} from a JavaScript Object representation. * The JavaScript Object should have been created by calling the * {@link Serializer#toJSON toJSON} API. * * The Resource is populated based on the JavaScript object. * * @param {Object} jsonObject The JavaScript Object for a Resource * @param {Object} options - the optional serialization options * @param {boolean} options.acceptResourcesForRelationships - handle JSON objects * in the place of strings for relationships, defaults to false. * @return {Resource} The new populated resource */ fromJSON(jsonObject, options) { if(!jsonObject.$class) { throw new Error('Invalid JSON data. Does not contain a $class type identifier.'); } const classDeclaration = this.modelManager.getType(jsonObject.$class); if(!classDeclaration) { throw new Error( 'Failed to find type ' + jsonObject.$class + ' in ModelManager.' ); } // default the options. options = options || {}; // create a new instance, using the identifier field name as the ID. let resource = this.factory.newInstance( classDeclaration.getModelFile().getNamespace(), classDeclaration.getName(), jsonObject[classDeclaration.getIdentifierFieldName()] ); // populate the resource based on the jsonObject // by walking the classDeclaration const parameters = {}; parameters.jsonStack = new TypedStack(jsonObject); parameters.resourceStack = new TypedStack(resource); parameters.modelManager = this.modelManager; parameters.factory = this.factory; const populator = new JSONPopulator(options.acceptResourcesForRelationships === true); classDeclaration.accept(populator, parameters); return resource; } } module.exports = Serializer; Ã— Search results Close "},"composer-common_lib_model_typed.js.html":{"id":"composer-common_lib_model_typed.js.html","title":"Source: composer-common/lib/model/typed.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/model/typed.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Field = require('../introspect/field'); /** * Object is an instance with a namespace and a type. * * This class is abstract. * @abstract * @class * @memberof module:composer-common */ class Typed { /** * Create an instance. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @private */ constructor(modelManager, ns, type) { this.$modelManager = modelManager; this.$namespace = ns; this.$type = type; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Get the ModelManager for this instance * @return {ModelManager} The ModelManager for this object * @private */ getModelManager() { return this.$modelManager; } /** * Get the type of the instance (a short name, not including namespace). * @return {string} The type of this object */ getType() { return this.$type; } /** * Get the fully-qualified type name of the instance (including namespace). * @return {string} The fully-qualified type name of this object */ getFullyQualifiedType() { return this.$namespace + '.' + this.$type; } /** * Get the namespace of the instance. * @return {string} The namespace of this object */ getNamespace() { return this.$namespace; } /** * Returns the class declaration for this instance object. * * @return {ClassDeclaration} - the class declaration for this instance * @throws {Error} - if the class or namespace for the instance is not declared * @private */ getClassDeclaration() { // do we have a model file? let modelFile = this.getModelManager().getModelFile(this.getNamespace()); if (!modelFile) { throw new Error('No model for namespace ' + this.getNamespace() + ' is registered with the ModelManager'); } // do we have a class? let classDeclaration = modelFile.getType(this.getType()); if (!classDeclaration) { throw new Error('The namespace ' + this.getNamespace() + ' does not contain the type ' + this.getType()); } return classDeclaration; } /** * Sets a property on this Resource * @param {string} propName - the name of the field * @param {string} value - the value of the property */ setPropertyValue(propName, value) { this[propName] = value; } /** * Adds a value to an array property on this Resource * @param {string} propName - the name of the field * @param {string} value - the value of the property */ addArrayValue(propName, value) { if(this[propName]) { this[propName].push(value); } else { this[propName] = [value]; } } /** * Sets the fields to their default values, based on the model * @private */ assignFieldDefaults() { let classDeclaration = this.getClassDeclaration(); let fields = classDeclaration.getProperties(); for (let n = 0; n &lt; fields.length; n++) { let field = fields[n]; if (field instanceof Field) { let defaultValue = field.getDefaultValue(); if (defaultValue) { if (field.getType() === 'String') { this.setPropertyValue(field.getName(), defaultValue); } else if (field.getType() === 'Integer') { this.setPropertyValue(field.getName(), parseInt(defaultValue)); } else if (field.getType() === 'Long') { this.setPropertyValue(field.getName(), parseInt(defaultValue)); } else if (field.getType() === 'Double') { this.setPropertyValue(field.getName(), parseFloat(defaultValue)); } else if (field.getType() === 'Boolean') { this.setPropertyValue(field.getName(), (defaultValue === 'true')); } else if (field.getType() === 'DateTime') { const dateTime = new Date(); dateTime.setTime(Date.parse(defaultValue)); this.setPropertyValue(field.getName(), dateTime); } } } } } /** * Overriden to prevent people accidentally converting a resource to JSON * without using the Serializer. * @private */ toJSON() { throw new Error('Use Serializer.toJSON to convert resource instances to JSON objects.'); } } module.exports = Typed; Ã— Search results Close "},"composer-common_lib_serializer_typedstack.js.html":{"id":"composer-common_lib_serializer_typedstack.js.html","title":"Source: composer-common/lib/serializer/typedstack.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/serializer/typedstack.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Util = require('../util'); /** * Tracks a stack of typed instances. The type information is used to detect * overflow / underflow bugs by the caller. It also performs basic sanity * checking on push/pop to make detecting bugs easier. * @private * @class * @memberof module:composer-common */ class TypedStack { /** * Create the Stack with the resource at the head. * @param {Object} resource - the resource to be put at the head of the stack */ constructor(resource) { this.stack = []; this.push(resource); } /** * Push a new object. * @param {Object} obj - the object being visited * @param {Object} expectedType - the expected type of the object being pushed */ push(obj, expectedType) { if(expectedType &amp;&amp; !(obj instanceof expectedType)) { throw new Error('Did not find expected type ' + expectedType.constructor.name + ' as argument to push. Found: ' + obj.toString()); } if(Util.isNull(obj)) { throw new Error('Pushing null data!'); } this.stack.push(obj); //console.log('Push depth is: ' + this.stack.length + ', contents: ' + this.stack.toString() ); } /** * Push a new object. * @param {Object} expectedType - the type that should be the result of pop * @return {Object} the result of pop */ pop(expectedType) { this.peek(expectedType); return this.stack.pop(); } /** * Peek the top of the stack * @param {Object} expectedType - the type that should be the result of pop * @return {Object} the result of peek */ peek(expectedType) { //console.log( 'pop ' ); if(this.stack.length &lt; 1) { throw new Error('Stack is empty!'); } const result = this.stack[this.stack.length-1]; if(expectedType &amp;&amp; !(result instanceof expectedType)) { throw new Error('Did not find expected type ' + expectedType + ' on head of stack. Found: ' + result); } if(Util.isNull(result)) { throw new Error('Pop returned invalid data'); } return result; } /** * Clears the stack */ clear() { this.stack = []; } } module.exports = TypedStack; Ã— Search results Close "},"composer-common_lib_util.js.html":{"id":"composer-common_lib_util.js.html","title":"Source: composer-common/lib/util.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/util.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Globalize = require('./globalize'); const SecurityContext = require('./securitycontext'); const SecurityException = require('./securityexception'); /** * Internal Utility Class * &lt;p&gt;&lt;a href=&quot;./diagrams-private/util.svg&quot;&gt;&lt;img src=&quot;./diagrams-private/util.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @private * @class * @memberof module:composer-common */ class Util { /** * Internal method to check the security context * @param {SecurityContext} securityContext - The user's security context * @throws {SecurityException} if the user context is invalid */ static securityCheck(securityContext) { if (Util.isNull(securityContext)) { throw new SecurityException(Globalize.formatMessage('util-securitycheck-novalidcontext')); } else if (!(securityContext instanceof SecurityContext)) { throw new SecurityException(Globalize.formatMessage('util-securitycheck-novalidcontext')); } } /** * Submit a query request to the chain-code * @param {SecurityContext} securityContext - The user's security context * @param {string} functionName - The name of the function to call. * @param {string[]} args - The arguments to pass to the function being called. * @return {Promise} - A promise that will be resolved with the value returned * by the chain-code function. */ static queryChainCode(securityContext, functionName, args) { Util.securityCheck(securityContext); if (!functionName) { throw new Error('functionName not specified'); } else if (!args) { throw new Error('args not specified'); } args.forEach((arg) =&gt; { if (typeof arg !== 'string') { throw new Error('invalid arg specified: ' + arg); } }); return securityContext.getConnection().queryChainCode(securityContext, functionName, args); } /** * Submit an invoke request to the chain-code * @param {SecurityContext} securityContext - The user's security context * @param {string} functionName - The name of the function to call. * @param {string[]} args - The arguments to pass to the function being called. * @return {Promise} - A promise that will be resolved with the value returned * by the chain-code function. */ static invokeChainCode(securityContext, functionName, args) { Util.securityCheck(securityContext); if (!functionName) { throw new Error('functionName not specified'); } else if (!args) { throw new Error('args not specified'); } args.forEach((arg) =&gt; { if (typeof arg !== 'string') { throw new Error('invalid arg specified: ' + arg); } }); return securityContext.getConnection().invokeChainCode(securityContext, functionName, args); } /** * Returns true if the typeof the object === 'undefined' or * the object === null. * @param {Object} obj - the object to be tested * @returns {boolean} true if the object is null or undefined */ static isNull(obj) { return(typeof(obj) === 'undefined' || obj === null); } } module.exports = Util; Ã— Search results Close "},"composer-common_lib_model_validatedconcept.js.html":{"id":"composer-common_lib_model_validatedconcept.js.html","title":"Source: composer-common/lib/model/validatedconcept.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/model/validatedconcept.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Concept = require('./concept'); const TypedStack = require('../serializer/typedstack'); /** * &lt;p&gt; * Resource is an instance that has a type. The type of the resource * specifies a set of properites (which themselves have types). * &lt;/p&gt; * &lt;p&gt; * Type information in Composer is used to validate the structure of * Resource instances and for serialization. * &lt;/p&gt; * &lt;p&gt; * Resources are used in Composer to represent Assets, Participants, Transactions and * other domain classes that can be serialized for long-term persistent storage. * &lt;/p&gt; * @extends Identifiable * @see See [Resource]{@link module:composer-common.Resource} * @class * @memberof module:composer-common */ class ValidatedConcept extends Concept { /** * This constructor should not be called directly. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {ResourceValidator} resourceValidator - The validator to use for this instance * @private */ constructor(modelManager, ns, type, resourceValidator) { super(modelManager, ns, type); this.$validator = resourceValidator; } /** * Sets a property, validating that it does not violate the model * @param {string} propName - the name of the field * @param {string} value - the value of the property * @throws {Error} if the value is not compatible with the model definition for the field */ setPropertyValue(propName, value) { let classDeclaration = this.getClassDeclaration(); let field = classDeclaration.getProperty(propName); if (!field) { throw new Error('Trying to set field ' + propName + ' which is not declared in the model.'); } // else { // this.log( 'Validating field ' + field + ' with data ' + value ); // } const parameters = {}; parameters.stack = new TypedStack(value); parameters.modelManager = this.getModelManager(); parameters.rootResourceIdentifier = 'undefined'; field.accept(this.$validator, parameters); super.setPropertyValue(propName,value); } /** * Adds an array property value, validating that it does not violate the model * @param {string} propName - the name of the field * @param {string} value - the value of the property * @throws {Error} if the value is not compatible with the model definition for the field */ addArrayValue(propName, value) { let classDeclaration = this.getClassDeclaration(); let field = classDeclaration.getProperty(propName); if (!field) { throw new Error('Trying to set field ' + propName + ' which is not declared in the model.'); } if (!field.isArray()) { throw new Error('Trying to add array item ' + propName + ' which is not declared as an array in the model.'); } const parameters = {}; let newArray = []; if(this[propName]) { newArray = this[propName].slice(0); } newArray.push(value); parameters.stack = new TypedStack(newArray); parameters.modelManager = this.getModelManager(); parameters.rootResourceIdentifier = 'undefined'; field.accept(this.$validator, parameters); super.addArrayValue(propName, value); } /** * Validates the instance against its model. * * @throws {Error} - if the instance if invalid with respect to the model */ validate() { const classDeclaration = this.getClassDeclaration(); const parameters = {}; parameters.stack = new TypedStack(this); parameters.modelManager = this.getModelManager(); parameters.rootResourceIdentifier = 'undefined'; classDeclaration.accept(this.$validator, parameters); } } module.exports = ValidatedConcept; Ã— Search results Close "},"composer-common_lib_model_validatedresource.js.html":{"id":"composer-common_lib_model_validatedresource.js.html","title":"Source: composer-common/lib/model/validatedresource.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/model/validatedresource.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const TypedStack = require('../serializer/typedstack'); const Resource = require('./resource'); /** * ValidatedResource is a Resource that can validate that property * changes (or the whole instance) do not violate the structure of * the type information associated with the instance. * @extends Resource * @see See [Resource]{@link module:composer-common.Resource} * @class * @memberof module:composer-common */ class ValidatedResource extends Resource { /** * This constructor should not be called directly. * Use the Factory class to create instances. * * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {string} id - The identifier of this instance. * @param {ResourceValidator} resourceValidator - The validator to use for this instance * @private */ constructor(modelManager, ns, type, id,resourceValidator) { super(modelManager, ns, type, id); this.$validator = resourceValidator; } /** * Sets a property, validating that it does not violate the model * @param {string} propName - the name of the field * @param {string} value - the value of the property * @throws {Error} if the value is not compatible with the model definition for the field */ setPropertyValue(propName, value) { let classDeclaration = this.getClassDeclaration(); let field = classDeclaration.getProperty(propName); if (!field) { throw new Error('The instance with id ' + this.getIdentifier() + ' trying to set field ' + propName + ' which is not declared in the model.'); } // else { // this.log( 'Validating field ' + field + ' with data ' + value ); // } const parameters = {}; parameters.stack = new TypedStack(value); parameters.modelManager = this.getModelManager(); parameters.rootResourceIdentifier = this.getFullyQualifiedIdentifier(); field.accept(this.$validator, parameters); super.setPropertyValue(propName,value); } /** * Adds an array property value, validating that it does not violate the model * @param {string} propName - the name of the field * @param {string} value - the value of the property * @throws {Error} if the value is not compatible with the model definition for the field */ addArrayValue(propName, value) { let classDeclaration = this.getClassDeclaration(); let field = classDeclaration.getProperty(propName); if (!field) { throw new Error('The instance with id ' + this.getIdentifier() + ' trying to set field ' + propName + ' which is not declared in the model.'); } if (!field.isArray()) { throw new Error('The instance with id ' + this.getIdentifier() + ' trying to add array item ' + propName + ' which is not declared as an array in the model.'); } const parameters = {}; let newArray = []; if(this[propName]) { newArray = this[propName].slice(0); } newArray.push(value); parameters.stack = new TypedStack(newArray); parameters.modelManager = this.getModelManager(); parameters.rootResourceIdentifier = this.getFullyQualifiedIdentifier(); field.accept(this.$validator, parameters); super.addArrayValue(propName, value); } /** * Validates the instance against its model. * * @throws {Error} - if the instance if invalid with respect to the model */ validate() { const classDeclaration = this.getClassDeclaration(); const parameters = {}; parameters.stack = new TypedStack(this); parameters.modelManager = this.getModelManager(); parameters.rootResourceIdentifier = this.getFullyQualifiedIdentifier(); classDeclaration.accept(this.$validator, parameters); } } module.exports = ValidatedResource; Ã— Search results Close "},"composer-common_lib_serializer_validationexception.js.html":{"id":"composer-common_lib_serializer_validationexception.js.html","title":"Source: composer-common/lib/serializer/validationexception.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/serializer/validationexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BaseException = require('../baseexception'); /** * Exception thrown when a resource fails to model against the model * @extends BaseException * @see See [BaseException]{@link module:composer-common.BaseException} * @class * @memberof module:composer-common */ class ValidationException extends BaseException { /** * Create an ParseException * @param {string} message - the message for the exception */ constructor(message) { super(message); } } module.exports = ValidationException; Ã— Search results Close "},"composer-common_lib_introspect_validator.js.html":{"id":"composer-common_lib_introspect_validator.js.html","title":"Source: composer-common/lib/introspect/validator.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/introspect/validator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * An Abstract field validator. Extend this class and override the * validate method. * @private * @class * @abstract * @memberof module:composer-common */ class Validator { /** * Create a Property. * @param {Field} field - the field this validator is attached to * @param {Object} validator - The validation string * @throws {InvalidModelException} */ constructor(field, validator) { this.validator = validator; this.field = field; } /** * @param {string} id the identifier of the instance * @param {string} msg the exception message * @throws {Error} throws an error to report the message */ reportError(id, msg) { throw new Error( 'Invalid validator for field ' + id + ' ' + this.getField().getFullyQualifiedName() + ': ' + msg ); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the field that this validator applies to * @return {Field} the field */ getField() { return this.field; } /** * Validate the property against a value * @param {string} identifier the identifier of the instance being validated * @param {Object} value the value to validate * @throws {InvalidModelException} * @private */ validate(identifier, value) { } } module.exports = Validator; Ã— Search results Close "},"composer-common_lib_tools_versionchecker.js.html":{"id":"composer-common_lib_tools_versionchecker.js.html","title":"Source: composer-common/lib/tools/versionchecker.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/tools/versionchecker.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const crypto = require('crypto'); const semver = require('semver'); /** * Checks that a change log file takes into account * the signature of a public API (tracks API breakage) * and that the version number in package.json is in sync * with the contents of the changelog. * @private * @class * @memberof module:composer-common */ class VersionChecker { /** * @param {string} changelog - the text of a changelog file * @param {string} publicApi - the text of a public API description * @param {string} packageJson - the text of a package.json file * @returns {boolean} true if the version check passes * @throws {Error} if there is an issue with the version check */ static check(changelog, publicApi, packageJson) { const changelogLines = changelog.split('\\n'); const digest = VersionChecker.getDigest(publicApi); let result = false; for (let n = 0; n &lt; changelogLines.length; n++) { const line = changelogLines[n]; if (!line.startsWith('#')) { // find the first instance of 'Version' const versionIndex = line.indexOf('Version'); if (versionIndex &gt;= 0) { // find the version number const openBraceIndex = line.indexOf('{', versionIndex); if (openBraceIndex &lt; 0) { throw new Error('Invalid changelog, failed to find { in line ' + line); } const version = line.substring(versionIndex + 'Version'.length, openBraceIndex).trim(); // check the version in package.json is up to date const packageObj = JSON.parse(packageJson); if (!semver.lte(version, packageObj.version)) { throw new Error(`The version in the changelog file &quot;${version}&quot; is not less than or equal to the version in package.json &quot;${packageObj.version}&quot;.`); } // get MD5 const closeBraceIndex = line.indexOf('}', openBraceIndex); if (closeBraceIndex &lt; 0) { throw new Error('Invalid changelog, failed to find } in line ' + line); } const md5 = line.substring(openBraceIndex + 1, closeBraceIndex).trim(); if (digest !== md5) { throw new Error('Computed public API digest did not match the digest in the changelog for the most recent version. ' + 'Increment the version number and add a new entry to the changelog (explaining your public API change) using the digest ' + digest + '. Run \\'git diff api.txt\\' to understand the pubic API changes.'); } // we're done here... result = true; break; } } } if (!result) { throw new Error('Did not find any version in changelog'); } else { console.log('SUCCESS: validated public API against package.json and changelog.txt.'); } return true; } /** * Gets the digest (hash) for an input string * @param {string} data - the data to hash * @returns {string} the hash in hex format */ static getDigest(data) { return crypto.createHash('md5').update(data).digest('hex'); } } module.exports = VersionChecker; Ã— Search results Close "},"composer-common_lib_codegen_writer.js.html":{"id":"composer-common_lib_codegen_writer.js.html","title":"Source: composer-common/lib/codegen/writer.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/codegen/writer.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Writer buffers text to be written in memory. It handles simple * indentation and tracks the number of lines written. * @private * @class * @memberof module:composer-common */ class Writer { /** * Create a FileWriter. * */ constructor() { this.beforeBuffer = ''; this.buffer = ''; this.linesWritten = 0; } /** * Writes text to the start of the buffer * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeBeforeLine(tabs,text) { for(let n=0; n &lt; tabs; n++) { this.beforeBuffer += ' '; } this.beforeBuffer += text; this.beforeBuffer += '\\n'; this.linesWritten++; } /** * Append text to the buffer * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeLine(tabs,text) { for(let n=0; n &lt; tabs; n++) { this.write(' '); } this.write(text); this.write('\\n'); this.linesWritten++; } /** * Returns the number of lines that have been written to the buffer. * @return {int} the number of lines written to the buffer. */ getLineCount() { return this.linesWritten; } /** * Append text to the buffer, prepending tabs * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeIndented(tabs,text) { for(let n=0; n &lt; tabs; n++) { this.write(' '); } this.write(text); } /** * Append text to the buffer (no automatic newline). The * text may contain newline, and these will increment the linesWritten * counter. * @param {string} msg - the text to write */ write(msg) { if(typeof msg !== 'string' ) { throw new Error('Can only append strings. Argument ' + msg + ' has type ' + typeof msg); } this.buffer += msg; this.linesWritten += msg.split(/\\r\\n|\\r|\\n/).length; } /** * Returns the text that has been buffered in this Writer. * @return {string} the buffered text. */ getBuffer() { return this.beforeBuffer + this.buffer; } /** * Empties the underyling buffer and resets the line count. */ clearBuffer() { this.beforeBuffer = ''; this.buffer = ''; this.linesWritten = 0; } } module.exports = Writer; Ã— Search results Close "},"composer-runtime_index.js.html":{"id":"composer-runtime_index.js.html","title":"Source: composer-runtime/index.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/index.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * The runtime module provides the API that is made available to transaction * processing functions. * @module composer-runtime */ module.exports.Container = require('./lib/container'); module.exports.Context = require('./lib/context'); module.exports.DataCollection = require('./lib/datacollection'); module.exports.DataService = require('./lib/dataservice'); module.exports.Engine = require('./lib/engine'); module.exports.IdentityService = require('./lib/identityservice'); module.exports.JSTransactionExecutor = require('./lib/jstransactionexecutor'); module.exports.LoggingService = require('./lib/loggingservice'); module.exports.TransactionExecutor = require('./lib/transactionexecutor'); Ã— Search results Close "},"composer-runtime_lib_accesscontroller.js.html":{"id":"composer-runtime_lib_accesscontroller.js.html","title":"Source: composer-runtime/lib/accesscontroller.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/accesscontroller.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AccessException = require('./accessexception'); const Logger = require('composer-common').Logger; const LOG = Logger.getLog('AccessController'); /** * A class that manages access to registries and resources by processing * the access control list(s) in a business network definition. * @private * @class * @memberof module:composer-runtime */ class AccessController { /** * Constructor. * @param {AclManager} aclManager The ACL manager to use. */ constructor(aclManager) { const method = 'constructor'; LOG.entry(method, aclManager); this.aclManager = aclManager; this.participant = null; LOG.exit(method); } /** * Get the current participant. * @return {Resource} The current participant. */ getParticipant() { return this.participant; } /** * Set the current participant. * @param {Resource} participant The current participant. */ setParticipant(participant) { this.participant = participant; } /** * Check that the specified participant has the specified * level of access to the specified resource. * @param {Resource} resource The resource. * @param {string} access The level of access. * @param {Resource} participant The participant. * @throws {AccessException} If the specified participant * does not have the specified level of access to the specified * resource. */ check(resource, access) { const method = 'check'; LOG.entry(method, resource.getFullyQualifiedIdentifier(), access); try { // Check to see if a participant has been set. If not, then ACL // enforcement is not enabled. let participant = this.participant; if (!participant) { LOG.debug(method, 'No participant'); LOG.exit(method); return; } // Check to see if an ACL file was supplied. If not, then ACL // enforcement is not enabled. if (!this.aclManager.getAclFile()) { LOG.debug(method, 'No ACL file'); LOG.exit(method); return; } // Iterate over the ACL rules in order, but stop at the first rule // that permits the action. let aclRules = this.aclManager.getAclRules(); let result = aclRules.some((aclRule) =&gt; { LOG.debug(method, 'Processing rule', aclRule); let value = this.checkRule(resource, access, participant, aclRule); LOG.debug(method, 'Processed rule', value); return value; }); // If a ACL rule permitted the action, return. if (result) { LOG.exit(method); return; } // Otherwise no ACL rule permitted the action. throw new AccessException(resource, access, participant); } catch (e) { LOG.error(method, e); throw e; } } /** * Check the specified ACL rule permits the specified level * of access to the specified resource. * @param {Resource} resource The resource. * @param {string} access The level of access. * @param {Resource} participant The participant. * @param {AclRule} aclRule The ACL rule. * @returns {boolean} True if the specified ACL rule permits * the specified level of access to the specified resource. */ checkRule(resource, access, participant, aclRule) { const method = 'checkRule'; LOG.entry(method, participant.getFullyQualifiedIdentifier(), resource, access, participant, aclRule); // Is the ACL rule relevant to the specified noun? if (!this.matchNoun(resource, aclRule)) { LOG.debug(method, 'Noun does not match'); LOG.exit(method, false); return false; } // Is the ACL rule relevant to the specified verb? if (!this.matchVerb(access, aclRule)) { LOG.debug(method, 'Verb does not match'); LOG.exit(method, false); return false; } // Is the ACL rule relevant to the specified participant? if (!this.matchParticipant(participant, aclRule)) { LOG.debug(method, 'Participant does not match'); LOG.exit(method, false); return false; } // Is the predicate met? if (!this.matchPredicate(resource, access, participant, aclRule)) { LOG.debug(method, 'Predicate does not match'); LOG.exit(method, false); return false; } // Yes, is this an allow or deny rule? if (aclRule.getAction() === 'ALLOW') { LOG.exit(method, true); return true; } // This must be an explicit deny rule, so throw. let e = new AccessException(resource, access, participant); LOG.error(method, e); throw e; } /** * Check that the specified participant has the specified * level of access to the specified resource. * @param {Resource} resource The resource. * @param {AclRule} aclRule The ACL rule. * @returns {boolean} True if the specified ACL rule permits * the specified level of access to the specified resource. */ matchNoun(resource, aclRule) { const method = 'matchNoun'; LOG.entry(method, resource.getFullyQualifiedIdentifier(), aclRule); // Determine the input fully qualified name and ID. let fqn = resource.getFullyQualifiedType(); let ns = resource.getNamespace(); let id = resource.getIdentifier(); // Check the namespace and type of the ACL rule. let noun = aclRule.getNoun(); // Check to see if the fully qualified name matches. let reqFQN = noun.getFullyQualifiedName(); if (fqn === reqFQN) { // Noun is matching fully qualified type. } else if (ns === reqFQN) { // Noun is matching namespace. } else { // Noun does not match. LOG.exit(method, false); return false; } // Check to see if the identifier matches (if specified). let reqID = noun.getInstanceIdentifier(); if (reqID) { if (id === reqID) { // Noun is matching identifier. } else { // Noun does not match. LOG.exit(method, false); return false; } } else { // Noun does not specify identifier. } LOG.exit(method, true); return true; } /** * Check that the specified participant has the specified * level of access to the specified resource. * @param {string} access The level of access. * @param {AclRule} aclRule The ACL rule. * @returns {boolean} True if the specified ACL rule permits * the specified level of access to the specified resource. */ matchVerb(access, aclRule) { const method = 'matchVerb'; LOG.entry(method, access, aclRule); // Check to see if the access matches the verb of the ACL rule. // Verb can be one of: // 'CREATE' / 'READ' / 'UPDATE' / 'ALL' / 'DELETE' let result = false; let verb = aclRule.getVerb(); if (verb === 'ALL' || access === verb) { result = true; } LOG.exit(method, result); return result; } /** * Check that the specified participant has the specified * level of access to the specified resource. * @param {Resource} participant The participant. * @param {AclRule} aclRule The ACL rule. * @returns {boolean} True if the specified ACL rule permits * the specified level of access to the specified resource. */ matchParticipant(participant, aclRule) { const method = 'matchParticipant'; LOG.entry(method, participant.getFullyQualifiedIdentifier(), aclRule); // Is a participant specified in the ACL rule? let reqParticipant = aclRule.getParticipant(); if (!reqParticipant) { LOG.exit(method, true); return true; } // Determine the input fully qualified name and ID. let ns = participant.getNamespace(); let fqn = participant.getFullyQualifiedType(); let id = participant.getIdentifier(); // Check to see if the fully qualified name matches. let reqFQN = reqParticipant.getFullyQualifiedName(); if (fqn === reqFQN) { // Participant is matching fully qualified type. } else if (ns === reqFQN) { // Participant is matching namespace. } else { // Participant does not match. LOG.exit(method, false); return false; } // Check to see if the identifier matches (if specified). let reqID = reqParticipant.getInstanceIdentifier(); if (reqID) { if (id === reqID) { // Participant is matching identifier. } else { // Participant does not match. LOG.exit(method, false); return false; } } else { // Participant does not specify identifier. } LOG.exit(method, true); return true; } /** * Check that the specified participant has the specified * level of access to the specified resource. * @param {Resource} resource The resource. * @param {string} access The level of access. * @param {Resource} participant The participant. * @param {AclRule} aclRule The ACL rule. * @returns {boolean} True if the specified ACL rule permits * the specified level of access to the specified resource. */ matchPredicate(resource, access, participant, aclRule) { const method = 'matchPredicate'; LOG.entry(method, resource.getFullyQualifiedIdentifier(), access, participant.getFullyQualifiedIdentifier(), aclRule); // Get the predicate from the rule. let predicate = aclRule.getPredicate().getExpression(); // We can fast track the simple boolean predicates. if (predicate === 'true') { LOG.exit(method, true); return true; } else if (predicate === 'false') { LOG.exit(method, false); return false; } // Otherwise we need to build a function. let source = `return (${predicate});`; let argNames = []; let argValues = []; // Check to see if the resource needs to be bound. let resourceVar = aclRule.getNoun().getVariableName(); if (resourceVar) { argNames.push(resourceVar); argValues.push(resource); } // Check to see if the participant needs to be bound. let reqParticipant = aclRule.getParticipant(); if (reqParticipant) { let participantVar = aclRule.getParticipant().getVariableName(); if (participantVar) { argNames.push(participantVar); argValues.push(participant); } } // Compile and execute the function. let result; try { LOG.debug(method, 'Compiling and executing function', source, argNames, argValues); let func = new Function(argNames.join(','), source); result = func.apply(null, argValues); } catch (e) { LOG.error(method, e); throw new AccessException(resource, access, participant); } // Convert the result into a boolean before returning it. result = !!result; LOG.exit(method, result); return result; } } module.exports = AccessController; Ã— Search results Close "},"composer-runtime_lib_accessexception.js.html":{"id":"composer-runtime_lib_accessexception.js.html","title":"Source: composer-runtime/lib/accessexception.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/accessexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BaseException = require('composer-common').BaseException; /** * Class representing an access exception * &lt;p&gt;&lt;a href=&quot;./diagrams/accessexception.svg&quot;&gt;&lt;img src=&quot;./diagrams/accessexception.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends BaseException * @see See [BaseException]{@link module:composer-common.BaseException} * @class * @memberof module:composer-runtime */ class AccessException extends BaseException { /** * Generate the exception message. * @param {Resource} resource The resource. * @param {string} access The level of access. * @param {Resource} participant The participant. * @return {string} The exception message. */ static generateMessage(resource, access, participant) { let resourceId = resource.getFullyQualifiedIdentifier(); let participantId = participant.getFullyQualifiedIdentifier(); return `Participant '${participantId}' does not have '${access}' access to resource '${resourceId}'`; } /** * Constructor. * @param {Resource} resource The resource. * @param {string} access The level of access. * @param {Resource} participant The participant. */ constructor(resource, access, participant) { super(AccessException.generateMessage(resource, access, participant)); } } module.exports = AccessException; Ã— Search results Close "},"composer-runtime_lib_api_assetregistry.js.html":{"id":"composer-runtime_lib_api_assetregistry.js.html","title":"Source: composer-runtime/lib/api/assetregistry.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/api/assetregistry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const LOG = Logger.getLog('AssetRegistry'); /** * Do not attempt to create an instance of this class.&lt;br&gt; * You must use the {@link module:composer-runtime#getAssetRegistry getAssetRegistry} * method instead. * * @class AssetRegistry * @classdesc An asset registry manages a set of assets. * @memberof module:composer-runtime * @public */ /** * A class that represents an asset registry in the transaction processor API. The * transaction processor API should expose no internal properties or internal * methods which could be accessed or misused. * @private */ class AssetRegistry { /** * Constructor. * @param {Registry} registry The registry to use. * @private */ constructor(registry) { const method = 'constructor'; LOG.entry(method, registry); /** * Get a list of all of the existing assets in this asset registry. * @example * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get all of the vehicles in the vehicle asset registry. * return assetRegistry.getAll(); * }) * .then(function (vehicles) { * // Process the array of vehicle objects. * vehicles.forEach(function (vehicle) { * console.log(vehicle.vehicleId); * }); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#getAll * @return {Promise} A promise. The promise is resolved with an array of * {@link Resource} instances representing all of the assets stored in this * asset registry. If the asset registry does not exist, or the current * user does not have access to the asset registry, then the promise will * be rejected with an error that describes the problem. */ this.getAll = function getAll() { return registry.getAll(); }; /** * Get the specified asset in this asset registry using the unique identifier * of the asset. * @example * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get the specific vehicle from the vehicle asset registry. * return assetRegistry.get('VEHICLE_1'); * }) * .then(function (vehicle) { * // Process the the vehicle object. * console.log(vehicle.vehicleId); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#get * @param {string} id The ID of the asset. * @return {Promise} A promise. The promise is resolved with a {@link Resource} * instance representing the specified asset in this asset registry. If the * specified asset does not exist, or the current user does not have access * to the specified asset, then the promise will be rejected with an error * that describes the problem. */ this.get = function get(id) { return registry.get(id); }; /** * Add all of the specified assets to this asset registry. * @example * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get the factory for creating new asset instances. * var factory = getFactory(); * // Create the first vehicle. * var vehicle1 = factory.newInstance('org.acme', 'Vehicle', 'VEHICLE_1'); * vehicle1.colour = 'BLUE'; * // Create the second vehicle. * var vehicle2 = factory.newInstance('org.acme', 'Vehicle', 'VEHICLE_2'); * vehicle2.colour = 'GREEN'; * // Add the vehicles to the vehicle asset registry. * return vehicleAssetRegistry.addAll([vehicle1, vehicle2]); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#addAll * @param {Resource[]} assets The assets to add to this asset registry. * @return {Promise} A promise. The promise is resolved when all of the * assets have been added to this asset registry. If the assets cannot be * added to this asset registry, or if the assets already exist in the * asset registry, then the promise will be rejected with an error * that describes the problem. */ this.addAll = function addAll(assets) { return registry.addAll(assets, { convertResourcesToRelationships: true }); }; /** * Add the specified asset to this asset registry. * @example * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get the factory for creating new asset instances. * var factory = getFactory(); * // Create the vehicle. * var vehicle = factory.newInstance('org.acme', 'Vehicle', 'VEHICLE_1'); * vehicle.colour = 'BLUE'; * // Add the vehicle to the vehicle asset registry. * return vehicleAssetRegistry.add(vehicle); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#add * @param {Resource} asset The assets to add to this asset registry. * @return {Promise} A promise. The promise is resolved when the asset has * been added to this asset registry. If the asset cannot be added to this * asset registry, or if the asset already exists in the asset registry, * then the promise will be rejected with an error that describes the problem. */ this.add = function add(asset) { return registry.add(asset, { convertResourcesToRelationships: true }); }; /** * Update all of the specified assets in this asset registry. * @example * // The existing vehicles that have come from elsewhere. * var vehicle1; * var vehicle2; * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get the factory for creating new asset instances. * var factory = getFactory(); * // Modify the properties of the first vehicle. * vehicle1.colour = 'PURPLE'; * // Modify the properties of the second vehicle. * vehicle2.colour = 'ORANGE'; * // Update the vehicles in the vehicle asset registry. * return vehicleAssetRegistry.updateAll([vehicle1, vehicle2]); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#updateAll * @param {Resource[]} assets The assets to update in this asset registry. * @return {Promise} A promise. The promise is resolved when all of the * assets have been updated in this asset registry. If the assets cannot be * updated in this asset registry, or if the assets do not exist in the * asset registry, then the promise will be rejected with an error that * describes the problem. */ this.updateAll = function updateAll(assets) { return registry.updateAll(assets, { convertResourcesToRelationships: true }); }; /** * Update the specified asset in this asset registry. * @example * // The existing vehicle that has come from elsewhere. * var vehicle; * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get the factory for creating new asset instances. * var factory = getFactory(); * // Modify the properties of the vehicle. * vehicle.colour = 'PURPLE'; * // Update the vehicle in the vehicle asset registry. * return vehicleAssetRegistry.update(vehicle); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#update * @param {Resource} asset The asset to update in this asset registry. * @return {Promise} A promise. The promise is resolved when the asset * have been updated in this asset registry. If the asset cannot be * updated in this asset registry, or if the asset does not exist in the * asset registry, then the promise will be rejected with an error that * describes the problem. */ this.update = function update(asset) { return registry.update(asset, { convertResourcesToRelationships: true }); }; /** * Remove all of the specified assets from this asset registry. * @example * // The existing vehicles that have come from elsewhere. * var vehicle1; * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get the factory for creating new asset instances. * var factory = getFactory(); * // Remove the vehicles from the vehicle asset registry. Note that * // one vehicle is specified as a vehicle instance, and the other * // vehicle is specified by the ID of the vehicle. * return vehicleAssetRegistry.removeAll([vehicle1, 'VEHICLE_2']); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#removeAll * @param {string[]|Resource[]} assets The assets, or the IDs of the assets, * to remove from this asset registry. * @return {Promise} A promise. The promise is resolved when all of the * assets have been removed from this asset registry. If the assets cannot be * removed from this asset registry, or if the assets do not exist in the * asset registry, then the promise will be rejected with an error that * describes the problem. */ this.removeAll = function removeAll(assets) { return registry.removeAll(assets); }; /** * Remove the specified asset from this asset registry. * @example * // The existing vehicle that has come from elsewhere. * var vehicle; * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get the factory for creating new asset instances. * var factory = getFactory(); * // Remove the vehicle from the vehicle asset registry. * return vehicleAssetRegistry.remove(vehicle); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#remove * @param {string|Resource} asset The asset, or ID of the asset, to remove * from this asset registry. * @return {Promise} A promise. The promise is resolved when the asset * has been removed from this asset registry. If the asset cannot be * removed from this asset registry, or if the asset does not exist in the * asset registry, then the promise will be rejected with an error that * describes the problem. */ this.remove = function remove(asset) { return registry.remove(asset); }; Object.freeze(this); LOG.exit(method); } } module.exports = AssetRegistry; Ã— Search results Close "},"composer-runtime_lib_container.js.html":{"id":"composer-runtime_lib_container.js.html","title":"Source: composer-runtime/lib/container.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/container.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * A class representing the chaincode container hosting the JavaScript engine. * @protected * @abstract * @memberof module:composer-runtime */ class Container { /** * Get the version of the chaincode container. * @abstract * @return {string} The version of the chaincode container. */ getVersion() { throw new Error('abstract function called'); } /** * Get the logging service provided by the chaincode container. * @abstract * @return {LoggingService} The logging service provided by the chaincode container. */ getLoggingService() { throw new Error('abstract function called'); } /** * Stop serialization of this object. * @return {Object} An empty object. */ toJSON() { return {}; } } module.exports = Container; Ã— Search results Close "},"composer-runtime_lib_context.js.html":{"id":"composer-runtime_lib_context.js.html","title":"Source: composer-runtime/lib/context.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/context.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AccessController = require('./accesscontroller'); const Api = require('./api'); const BusinessNetworkDefinition = require('composer-common').BusinessNetworkDefinition; const IdentityManager = require('./identitymanager'); const JSTransactionExecutor = require('./jstransactionexecutor'); const Logger = require('composer-common').Logger; const LRU = require('lru-cache'); const QueryExecutor = require('./queryexecutor'); const RegistryManager = require('./registrymanager'); const Resolver = require('./resolver'); const TransactionLogger = require('./transactionlogger'); const LOG = Logger.getLog('Context'); const businessNetworkCache = LRU(8); /** * A class representing the current request being handled by the JavaScript engine. * @protected * @abstract * @memberof module:composer-runtime */ class Context { /** * Store a business network in the cache. * @param {string} businessNetworkHash The hash of the business network definition. * @param {BusinessNetworkDefinition} businessNetworkDefinition The business network definition. */ static cacheBusinessNetwork(businessNetworkHash, businessNetworkDefinition) { const method = 'cacheBusinessNetwork'; LOG.entry(method, businessNetworkHash, businessNetworkDefinition); businessNetworkCache.set(businessNetworkHash, businessNetworkDefinition); LOG.exit(method); } /** * Constructor. * @param {Engine} engine The chaincode engine that owns this context. */ constructor(engine) { this.engine = engine; this.businessNetworkDefinition = null; this.registryManager = null; this.resolver = null; this.api = null; this.queryExecutor = null; this.identityManager = null; this.participant = null; this.transaction = null; this.transactionExecutors = []; this.accessController = null; } /** * Initialize the context for use. * @param {boolean} [reinitialize] Set to true if being reinitialized as a result * of an upgrade to the business network, falsey value if not. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ initialize(reinitialize) { const method = 'initialize'; LOG.entry(method, !!reinitialize); // Load the business network from the archive. LOG.debug(method, 'Getting $sysdata collection'); return this.getDataService().getCollection('$sysdata') .then((collection) =&gt; { // check if the network has been undeployed first. if is has throw exception. if (collection.undeployed){ throw new Error('Network has already been undeployed'); } LOG.debug(method, 'Getting business network archive from the $sysdata collection'); return collection.get('businessnetwork'); }) .then((object) =&gt; { LOG.debug(method, 'Looking in cache for business network', object.hash); let businessNetworkDefinition = businessNetworkCache.get(object.hash); if (businessNetworkDefinition) { LOG.debug(method, 'Business network is in cache'); return businessNetworkDefinition; } LOG.debug(method, 'Business network is not in cache, loading'); let businessNetworkArchive = Buffer.from(object.data, 'base64'); return BusinessNetworkDefinition.fromArchive(businessNetworkArchive) .then((businessNetworkDefinition) =&gt; { Context.cacheBusinessNetwork(object.hash, businessNetworkDefinition); return businessNetworkDefinition; }); }) .then((businessNetworkDefinition) =&gt; { LOG.debug(method, 'Loaded business network archive'); this.businessNetworkDefinition = businessNetworkDefinition; let currentUserID = this.getIdentityService().getCurrentUserID(); LOG.debug(method, 'Got current user ID', currentUserID); if (currentUserID) { return this.getIdentityManager().getParticipant(currentUserID) .then((participant) =&gt; { LOG.debug(method, 'Found current participant', participant.getFullyQualifiedIdentifier()); if (!reinitialize) { this.setParticipant(participant); } else { LOG.debug(method, 'Not setting current participant as we are reinitializing'); } }) .catch((error) =&gt; { LOG.error(method, 'Could not find current participant', error); throw new Error(`Could not determine the participant for identity '${currentUserID}'. The identity may be invalid or may have been revoked.`); }); } else { // TODO: this is temporary whilst we migrate to requiring all // users to have identities that are mapped to participants. LOG.debug(method, 'Could not determine current user ID'); } }) .then(() =&gt; { LOG.debug(method, 'Installing default JavaScript transaction executor'); this.addTransactionExecutor(new JSTransactionExecutor()); }) .then(() =&gt; { LOG.exit(method); }); } /** * Get the data service provided by the chaincode container. * @abstract * @return {DataService} The data service provided by the chaincode container. */ getDataService() { throw new Error('abstract function called'); } /** * Get the identity service provided by the chaincode container. * @abstract * @return {IdentityService} The identity service provided by the chaincode container. */ getIdentityService() { throw new Error('abstract function called'); } /** * Get the model manager. * @return {ModelManager} The model manager. */ getModelManager() { if (!this.businessNetworkDefinition) { throw new Error('must call initialize before calling this function'); } return this.businessNetworkDefinition.getModelManager(); } /** * Get the script manager. * @return {ScriptManager} The script manager. */ getScriptManager() { if (!this.businessNetworkDefinition) { throw new Error('must call initialize before calling this function'); } return this.businessNetworkDefinition.getScriptManager(); } /** * Get the ACL manager. * @return {AclManager} The ACL manager. */ getAclManager() { if (!this.businessNetworkDefinition) { throw new Error('must call initialize before calling this function'); } return this.businessNetworkDefinition.getAclManager(); } /** * Get the factory. * @return {Factory} The factory. */ getFactory() { if (!this.businessNetworkDefinition) { throw new Error('must call initialize before calling this function'); } return this.businessNetworkDefinition.getFactory(); } /** * Get the serializer. * @return {Serializer} The serializer. */ getSerializer() { if (!this.businessNetworkDefinition) { throw new Error('must call initialize before calling this function'); } return this.businessNetworkDefinition.getSerializer(); } /** * Get the introspector. * @return {Introspector} The serializer. */ getIntrospector() { if (!this.businessNetworkDefinition) { throw new Error('must call initialize before calling this function'); } return this.businessNetworkDefinition.getIntrospector(); } /** * Get the registry manager. * @return {RegistryManager} The registry manager. */ getRegistryManager() { if (!this.registryManager) { this.registryManager = new RegistryManager(this.getDataService(), this.getIntrospector(), this.getSerializer(), this.getAccessController()); } return this.registryManager; } /** * Get the resolver. * @return {Resolver} The resolver. */ getResolver() { if (!this.resolver) { this.resolver = new Resolver(this.getIntrospector(), this.getRegistryManager()); } return this.resolver; } /** * Get the API. * @return {Api} The API. */ getApi() { if (!this.api) { this.api = new Api(this.getFactory(), this.getParticipant(), this.getRegistryManager()); } return this.api; } /** * Get the query executor. * @return {QueryExecutor} The query executor. */ getQueryExecutor() { if (!this.queryExecutor) { this.queryExecutor = new QueryExecutor(this.getResolver()); } return this.queryExecutor; } /** * Get the identity manager. * @return {IdentityManager} The identity manager. */ getIdentityManager() { if (!this.identityManager) { this.identityManager = new IdentityManager(this.getDataService(), this.getRegistryManager()); } return this.identityManager; } /** * Get the current participant. * @return {Resource} the current participant. */ getParticipant() { return this.participant; } /** * Set the current participant. * @param {Resource} participant the current participant. */ setParticipant(participant) { if (this.participant) { throw new Error('A current participant has already been specified'); } this.participant = participant; this.getAccessController().setParticipant(participant); } /** * Get the current transaction. * @return {Resource} the current transaction. */ getTransaction() { return this.transaction; } /** * Set the current transaction. * @param {Resource} transaction the current transaction. */ setTransaction(transaction) { if (this.transaction) { throw new Error('A current transaction has already been specified'); } this.transaction = transaction; this.transactionLogger = new TransactionLogger(this.transaction, this.getRegistryManager(), this.getSerializer()); } /** * Add a transaction executor. * @param {TransactionExecutor} transactionExecutor The transaction executor. */ addTransactionExecutor(transactionExecutor) { const method = 'addTransactionExecutor'; LOG.entry(method, transactionExecutor); let replaced = this.transactionExecutors.some((existingTransactionExecutor, index) =&gt; { if (transactionExecutor.getType() === existingTransactionExecutor.getType()) { LOG.debug(method, 'Found existing executor for type, replacing', transactionExecutor.getType()); this.transactionExecutors[index] = transactionExecutor; return true; } else { return false; } }); if (!replaced) { LOG.debug(method, 'Did not replace executor, adding to end of list', transactionExecutor.getType()); this.transactionExecutors.push(transactionExecutor); } LOG.exit(method); } /** * Get the list of transaction executors. * @return {TransactionExecutor[]} The list of transaction executors. */ getTransactionExecutors() { return this.transactionExecutors; } /** * Get the access controller. * @return {AccessController} The access controller. */ getAccessController() { if (!this.accessController) { this.accessController = new AccessController(this.getAclManager()); } return this.accessController; } /** * Stop serialization of this object. * @return {Object} An empty object. */ toJSON() { return {}; } } module.exports = Context; Ã— Search results Close "},"composer-runtime_lib_datacollection.js.html":{"id":"composer-runtime_lib_datacollection.js.html","title":"Source: composer-runtime/lib/datacollection.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/datacollection.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Base class representing a data collection provided by a {@link DataService}. * @protected * @abstract * @memberof module:composer-runtime */ class DataCollection { /** * Constructor. * @param {DataService} dataService The owning data service. */ constructor(dataService) { this.dataService = dataService; } /** * Get all of the objects in this collection. * @abstract * @return {Promise} A promise that will be resolved with an array of objects, * or rejected with an error. */ getAll() { return new Promise((resolve, reject) =&gt; { this._getAll((error, result) =&gt; { if (error) { return reject(error); } return resolve(result); }); }); } /** * @callback getAllCallback * @protected * @param {Error} error The error if any. * @param {Object[]} objects The objects in the collection. */ /** * Get all of the objects in this collection. * @abstract * @private * @param {getAllCallback} callback The callback function to call when complete. */ _getAll(callback) { throw new Error('abstract function called'); } /** * Get the specified object in this collection. * @abstract * @param {string} id The ID of the object. * @return {Promise} A promise that will be resolved with an object, or rejected * with an error. */ get(id) { return new Promise((resolve, reject) =&gt; { this._get(id, (error, result) =&gt; { if (error) { return reject(error); } return resolve(result); }); }); } /** * @callback getCallback * @protected * @param {Error} error The error if any. * @param {Object} object The object in the collection. */ /** * Get the specified object in this collection. * @abstract * @private * @param {string} id The ID of the object. * @param {getCallback} callback The callback function to call when complete. */ _get(id, callback) { throw new Error('abstract function called'); } /** * Check to see if the specified object exists in this collection. * @abstract * @param {string} id The ID of the object. * @return {Promise} A promise that will be resolved with an boolean which will * be true if the specified object exists in this collection, or rejected with * an error. */ exists(id) { return new Promise((resolve, reject) =&gt; { this._exists(id, (error, result) =&gt; { if (error) { return reject(error); } return resolve(result); }); }); } /** * @callback existsCallback * @protected * @param {Error} error The error if any. * @param {boolean} exists Whether or not the object exists in the collection. */ /** * Check to see if the specified object exists in this collection. * @abstract * @private * @param {string} id The ID of the object. * @param {existsCallback} callback The callback function to call when complete. */ _exists(id, callback) { throw new Error('abstract function called'); } /** * Add an object to the collection. * @abstract * @param {string} id The ID of the object. * @param {Object} object The object. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ add(id, object) { return new Promise((resolve, reject) =&gt; { this._add(id, object, (error, result) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback addCallback * @protected * @param {Error} error The error if any. */ /** * Add an object to the collection. * @abstract * @private * @param {string} id The ID of the object. * @param {Object} object The object. * @param {addCallback} callback The callback function to call when complete. */ _add(id, object, callback) { throw new Error('abstract function called'); } /** * Add an object to the collection. * @abstract * @param {string} id The ID of the object. * @param {Object} object The object. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ update(id, object) { return new Promise((resolve, reject) =&gt; { this._update(id, object, (error, result) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback updateCallback * @protected * @param {Error} error The error if any. */ /** * Update an object in the collection. * @abstract * @private * @param {string} id The ID of the object. * @param {Object} object The object. * @param {updateCallback} callback The callback function to call when complete. */ _update(id, object, callback) { throw new Error('abstract function called'); } /** * Remove an object from the collection. * @abstract * @param {string} id The ID of the object. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ remove(id) { return new Promise((resolve, reject) =&gt; { this._remove(id, (error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback removeCallback * @protected * @param {Error} error The error if any. */ /** * Remove an object from the collection. * @abstract * @private * @param {string} id The ID of the object. * @param {removeCallback} callback The callback function to call when complete. */ _remove(id, callback) { throw new Error('abstract function called'); } /** * Stop serialization of this object. * @return {Object} An empty object. */ toJSON() { return {}; } } module.exports = DataCollection; Ã— Search results Close "},"composer-runtime_lib_dataservice.js.html":{"id":"composer-runtime_lib_dataservice.js.html","title":"Source: composer-runtime/lib/dataservice.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/dataservice.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Base class representing the data service provided by a {@link Container}. * @protected * @abstract * @memberof module:composer-runtime */ class DataService { /** * Create a collection with the specified ID. * @abstract * @param {string} id The ID of the collection. * @return {Promise} A promise that will be resolved with a {@link DataCollection} * when complete, or rejected with an error. */ createCollection(id) { return new Promise((resolve, reject) =&gt; { this._createCollection(id, (error, dataCollection) =&gt; { if (error) { return reject(error); } return resolve(dataCollection); }); }); } /** * @callback createCollectionCallback * @protected * @param {Error} error The error if any. * @param {DataCollection} dataCollection The data collection. */ /** * Create a collection with the specified ID. * @abstract * @private * @param {string} id The ID of the collection. * @param {createCollectionCallback} callback The callback function to call when complete. */ _createCollection(id, callback) { throw new Error('abstract function called'); } /** * Delete a collection with the specified ID. * @abstract * @param {string} id The ID of the collection. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ deleteCollection(id) { return new Promise((resolve, reject) =&gt; { this._deleteCollection(id, (error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback deleteCollectionCallback * @protected * @param {Error} error The error if any. */ /** * Delete a collection with the specified ID. * @abstract * @private * @param {string} id The ID of the collection. * @param {deleteCollectionCallback} callback The callback function to call when complete. */ _deleteCollection(id, callback) { throw new Error('abstract function called'); } /** * Get the collection with the specified ID. * @abstract * @param {string} id The ID of the collection. * @return {Promise} A promise that will be resolved with a {@link DataCollection} * when complete, or rejected with an error. */ getCollection(id) { return new Promise((resolve, reject) =&gt; { this._getCollection(id, (error, dataCollection) =&gt; { if (error) { return reject(error); } return resolve(dataCollection); }); }); } /** * @callback getCollectionCallback * @protected * @param {Error} error The error if any. * @param {DataCollection} dataCollection The data collection. */ /** * Get the collection with the specified ID. * @abstract * @private * @param {string} id The ID of the collection. * @param {getCollectionCallback} callback The callback function to call when complete. */ _getCollection(id, callback) { throw new Error('abstract function called'); } /** * Determine whether the collection with the specified ID exists. * @abstract * @param {string} id The ID of the collection. * @return {Promise} A promise that will be resolved with a boolean * indicating whether the collection exists. */ existsCollection(id) { return new Promise((resolve, reject) =&gt; { this._existsCollection(id, (error, exists) =&gt; { if (error) { return reject(error); } return resolve(exists); }); }); } /** * @callback getCollectionCallback * @protected * @param {Error} error The error if any. * @param {DataCollection} dataCollection The data collection. */ /** * Determine whether the collection with the specified ID exists. * @abstract * @private * @param {string} id The ID of the collection. * @param {getCollectionCallback} callback The callback function to call when complete. */ _existsCollection(id, callback) { throw new Error('abstract function called'); } /** * Stop serialization of this object. * @return {Object} An empty object. */ toJSON() { return {}; } } module.exports = DataService; Ã— Search results Close "},"composer-runtime_lib_engine.js.html":{"id":"composer-runtime_lib_engine.js.html","title":"Source: composer-runtime/lib/engine.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/engine.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BusinessNetworkDefinition = require('composer-common').BusinessNetworkDefinition; const Context = require('./context'); const createHash = require('sha.js'); const Logger = require('composer-common').Logger; const util = require('util'); const LOG = Logger.getLog('Engine'); /** * The JavaScript engine responsible for processing chaincode commands. * @protected * @memberof module:composer-runtime */ class Engine { /** * Constructor. * @param {Container} container The chaincode container hosting this engine. */ constructor(container) { this.container = container; this.installLogger(); const method = 'constructor'; LOG.entry(method); LOG.exit(method); } /** * Get the chaincode container hosting this engine. * @return {Container} The chaincode container hosting this engine. */ getContainer() { return this.container; } /** * Install the runtime logger into the common module. */ installLogger() { let loggingService = this.container.getLoggingService(); let loggingProxy = { log: (level, method, msg, args) =&gt; { args = args || []; let formattedArguments = args.map((arg) =&gt; { if (arg === Object(arg)) { // It's an object, array, or function, so serialize it as JSON. try { return JSON.stringify(arg); } catch (e) { return arg; } } else { return arg; } }).join(', '); switch (level) { case 'debug': return loggingService.logDebug(util.format('@JS : %s %s %s', method, msg, formattedArguments)); case 'warn': return loggingService.logWarning(util.format('@JS : %s %s %s', method, msg, formattedArguments)); case 'info': return loggingService.logInfo(util.format('@JS : %s %s %s', method, msg, formattedArguments)); case 'verbose': return loggingService.logDebug(util.format('@JS : %s %s %s', method, msg, formattedArguments)); case 'error': return loggingService.logError(util.format('@JS : %s %s %s', method, msg, formattedArguments)); } } }; Logger.setFunctionalLogger(loggingProxy); Logger._envDebug = 'concerto:*'; } /** * Handle an initialisation (deploy) request. * @param {Context} context The request context. * @param {string} fcn The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ init(context, fcn, args) { const method = 'init'; LOG.entry(method, context, fcn, args); if (fcn !== 'init') { throw new Error(util.format('Unsupported function &quot;%s&quot; with arguments &quot;%j&quot;', fcn, args)); } else if (args.length !== 1) { throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'init', ['businessNetworkArchive'])); } let dataService = context.getDataService(); return Promise.resolve() .then(() =&gt; { // Create the $sysdata collection if it does not exist. return dataService .getCollection('$sysdata') .then((sysdata) =&gt; { LOG.debug(method, 'The $sysdata collection already exists'); return sysdata; }) .catch((error) =&gt; { LOG.debug(method, 'The $sysdata collection does not exist, creating'); return dataService.createCollection('$sysdata'); }); }) .then((sysdata) =&gt; { // Validate the business network archive and store it. let businessNetworkBase64 = args[0]; let businessNetworkArchive = Buffer.from(businessNetworkBase64, 'base64'); let sha256 = createHash('sha256'); let businessNetworkHash = sha256.update(businessNetworkBase64, 'utf8').digest('hex'); return BusinessNetworkDefinition.fromArchive(businessNetworkArchive) .then((businessNetworkDefinition) =&gt; { LOG.debug(method, 'Loaded business network definition, storing in cache'); Context.cacheBusinessNetwork(businessNetworkHash, businessNetworkDefinition); LOG.debug(method, 'Loaded business network definition, storing in $sysdata collection'); return sysdata.add('businessnetwork', { data: businessNetworkBase64, hash: businessNetworkHash }); }); }) .then(() =&gt; { // Initialize the context. LOG.debug(method, 'Initializing context'); return context.initialize(); }) .then(() =&gt; { // Create the other system collections if they do not exist. let systemRegistries = ['$sysidentities', '$sysregistries']; return systemRegistries.reduce((result, systemRegistry) =&gt; { return result.then(() =&gt; { return dataService .getCollection(systemRegistry) .then((sysdata) =&gt; { LOG.debug(method, `The ${systemRegistry} collection already exists`); return sysdata; }) .catch((error) =&gt; { LOG.debug(method, `The ${systemRegistry} collection does not exist, creating`); return dataService.createCollection(systemRegistry); }); }); }, Promise.resolve()); }) .then(() =&gt; { // Create all the default registries for each asset and participant type. LOG.debug(method, 'Creating default registries'); let registryManager = context.getRegistryManager(); return registryManager.createDefaults(); }) .then(() =&gt; { // Create the default transaction registry if it does not exist. let registryManager = context.getRegistryManager(); return registryManager .get('Transaction', 'default') .then(() =&gt; { LOG.debug(method, 'The default transaction registry already exists'); }) .catch((error) =&gt; { LOG.debug(method, 'The default transaction registry does not exist, creating'); return registryManager.add('Transaction', 'default', 'Default Transaction Registry'); }); }) .catch((error) =&gt; { LOG.error(method, 'Caught error, rethrowing', error); throw error; }) .then(() =&gt; { LOG.exit(method); }); } /** * Handle an initialisation (deploy) request. * @private * @param {Context} context The request context. * @param {string} fcn The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @param {function} callback The callback function to call when complete. */ _init(context, fcn, args, callback) { this.init(context, fcn, args) .then((result) =&gt; { callback(null, result); }) .catch((error) =&gt; { callback(error, null); }); } /** * Handle an invoke request. * @param {Context} context The request context. * @param {string} fcn The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ invoke(context, fcn, args) { const method = 'invoke_m'; LOG.entry(method, context, fcn, args); if (this[fcn]) { LOG.debug(method, 'Initializing context'); return context.initialize() .then(() =&gt; { LOG.debug(method, 'Calling engine function', fcn); return this[fcn](context, args); }) .catch((error) =&gt; { LOG.error(method, 'Caught error, rethrowing', error); throw error; }) .then(() =&gt; { LOG.exit(method); }); } else { LOG.error(method, 'Unsupported function', fcn, args); throw new Error(util.format('Unsupported function &quot;%s&quot; with arguments &quot;%j&quot;', fcn, args)); } } /** * Handle an invoke request. * @private * @param {Context} context The request context. * @param {string} fcn The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @param {function} callback The callback function to call when complete. */ _invoke(context, fcn, args, callback) { this.invoke(context, fcn, args) .then((result) =&gt; { callback(null, result); }) .catch((error) =&gt; { callback(error, null); }); } /** * Handle a query request. * @param {Context} context The request context. * @param {string} fcn The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ query(context, fcn, args) { const method = 'query'; LOG.entry(method, context, fcn, args); if (this[fcn]) { LOG.debug(method, 'Initializing context'); return context.initialize() .then(() =&gt; { LOG.debug(method, 'Calling engine function', fcn); return this[fcn](context, args); }) .catch((error) =&gt; { LOG.error(method, 'Caught error, rethrowing', error); throw error; }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } else { LOG.error(method, 'Unsupported function', fcn, args); throw new Error(util.format('Unsupported function &quot;%s&quot; with arguments &quot;%j&quot;', fcn, args)); } } /** * Handle a query request. * @private * @param {Context} context The request context. * @param {string} fcn The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @param {function} callback The callback function to call when complete. */ _query(context, fcn, args, callback) { this.query(context, fcn, args) .then((result) =&gt; { callback(null, result); }) .catch((error) =&gt; { callback(error, null); }); } /** * Handle a ping request. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ ping(context, args) { const method = 'ping'; LOG.entry(method, context, args); if (args.length !== 0) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'ping', [])); } let participantFQI = null; let participant = context.getParticipant(); if (participant) { participantFQI = participant.getFullyQualifiedIdentifier(); } let result = { version: this.container.getVersion(), participant: participantFQI }; LOG.exit(method, result); return Promise.resolve(result); } /** * Stop serialization of this object. * @return {Object} An empty object. */ toJSON() { return {}; } } /** * Add all of the methods of the source class to the engine class. * @private * @param {Object} sourceClass The source class to copy methods from. */ function mixin(sourceClass) { Object.getOwnPropertyNames(sourceClass.prototype).forEach((method) =&gt; { if (method !== 'constructor') { Engine.prototype[method] = sourceClass.prototype[method]; } }); } mixin(require('./engine.businessnetworks')); mixin(require('./engine.identities')); mixin(require('./engine.registries')); mixin(require('./engine.resources')); mixin(require('./engine.transactions')); module.exports = Engine; Ã— Search results Close "},"composer-runtime_lib_engine.businessnetworks.js.html":{"id":"composer-runtime_lib_engine.businessnetworks.js.html","title":"Source: composer-runtime/lib/engine.businessnetworks.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/engine.businessnetworks.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BusinessNetworkDefinition = require('composer-common').BusinessNetworkDefinition; const Context = require('./context'); const createHash = require('sha.js'); const Logger = require('composer-common').Logger; const util = require('util'); const LOG = Logger.getLog('EngineBusinessNetworks'); /** * The JavaScript engine responsible for processing chaincode commands. * @protected * @memberof module:composer-runtime */ class EngineBusinessNetworks { /** * Get the business network archive. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ getBusinessNetwork(context, args) { const method = 'getBusinessNetwork'; LOG.entry(method, context, args); if (args.length !== 0) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'getBusinessNetwork', [])); } let dataService = context.getDataService(); return dataService.getCollection('$sysdata') .then((sysdata) =&gt; { return sysdata.get('businessnetwork'); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Undeploy the business network; * Doesn't actually undeploy the nework but merely puts it beyond use. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ undeploy(context, args){ const method = 'undeploy'; LOG.entry(method, context, args); if (args.length !== 1) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'undeploy', ['businessNetworkArchive'])); } let dataService = context.getDataService(); return dataService.getCollection('$sysdata') .then((sysdata) =&gt; { // set flag in the sysdata to say that this has been undeployed sysdata.undeployed=true; // Validate the business network archive and store it. return sysdata.get('businessnetwork'); }) .then((object)=&gt; { let businessNetworkArchive = Buffer.from(object.data, 'base64'); return BusinessNetworkDefinition.fromArchive(businessNetworkArchive);}) .then((businessNetworkDefinition) =&gt; { // Reinitialize the context to reload the business network. LOG.debug(method, businessNetworkDefinition.getIdentifier()+' has been undeployed'); LOG.exit(method); }); } /** * Update the business network archive. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ updateBusinessNetwork(context, args) { const method = 'updateBusinessNetwork'; LOG.entry(method, context, args); if (args.length !== 1) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'updateBusinessNetwork', ['businessNetworkArchive'])); } let dataService = context.getDataService(); return dataService.getCollection('$sysdata') .then((sysdata) =&gt; { // Validate the business network archive and store it. let businessNetworkBase64 = args[0]; let businessNetworkArchive = Buffer.from(businessNetworkBase64, 'base64'); let sha256 = createHash('sha256'); let businessNetworkHash = sha256.update(businessNetworkBase64, 'utf8').digest('hex'); return BusinessNetworkDefinition.fromArchive(businessNetworkArchive) .then((businessNetworkDefinition) =&gt; { LOG.debug(method, 'Loaded business network definition, storing in cache'); Context.cacheBusinessNetwork(businessNetworkHash, businessNetworkDefinition); LOG.debug(method, 'Loaded business network definition, storing in $sysdata collection'); return sysdata.update('businessnetwork', { data: businessNetworkBase64, hash: businessNetworkHash }); }); }) .then(() =&gt; { // Reinitialize the context to reload the business network. LOG.debug(method, 'Reinitializing context'); return context.initialize(true); }) .then(() =&gt; { // Create all other default registries. LOG.debug(method, 'Creating default registries'); let registryManager = context.getRegistryManager(); return registryManager.createDefaults(); }) .then(() =&gt; { LOG.exit(method); }); } /** * Reset the business network by clearing all data. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ resetBusinessNetwork(context, args) { const method = 'resetBusinessNetwork'; LOG.entry(method, context, args); if (args.length !== 0) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'resetBusinessNetwork', [])); } let dataService = context.getDataService(); return dataService.getCollection('$sysregistries') .then((sysregistries) =&gt; { return sysregistries.getAll() .then((registries) =&gt; { return registries.reduce((cur, next) =&gt; { return cur.then(() =&gt; { let registryType = next.type; let registryId = next.id; LOG.debug(method, 'Deleting collection', registryType, registryId); return dataService.deleteCollection(registryType + ':' + registryId) .then(() =&gt; { LOG.debug(method, 'Deleting record of collection from $sysregistries', registryType, registryId); return sysregistries.remove(registryType + ':' + registryId); }); }); }, Promise.resolve()); }); }) .then(() =&gt; { // Create the default transaction registry if it does not exist. let registryManager = context.getRegistryManager(); return registryManager .get('Transaction', 'default') .catch((error) =&gt; { LOG.debug(method, 'The default transaction registry does not exist, creating'); return registryManager.add('Transaction', 'default', 'Default Transaction Registry'); }); }) .then(() =&gt; { // Create all other default registries. LOG.debug(method, 'Creating default registries'); let registryManager = context.getRegistryManager(); return registryManager.createDefaults(); }) .then(() =&gt; { LOG.exit(method); }); } } module.exports = EngineBusinessNetworks; Ã— Search results Close "},"composer-runtime_lib_engine.identities.js.html":{"id":"composer-runtime_lib_engine.identities.js.html","title":"Source: composer-runtime/lib/engine.identities.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/engine.identities.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const util = require('util'); const LOG = Logger.getLog('EngineIdentities'); /** * The JavaScript engine responsible for processing chaincode commands. * @protected * @memberof module:composer-runtime */ class EngineIdentities { /** * Add a mapping from the specified identity, or user ID, to the specified * participant. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ addParticipantIdentity(context, args) { const method = 'addParticipantIdentity'; LOG.entry(method, context, args); if (args.length !== 2) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'addParticipantIdentity', ['participantId', 'userId'])); } let participantId = args[0]; let userId = args[1]; let identityManager = context.getIdentityManager(); return identityManager.addIdentityMapping(participantId, userId) .then(() =&gt; { LOG.exit(method); }); } /** * Remove any mapping for the specified identity, or user ID. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ removeIdentity(context, args) { const method = 'removeIdentity'; LOG.entry(method, context, args); if (args.length !== 1) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'removeIdentity', ['userId'])); } let userId = args[0]; let identityManager = context.getIdentityManager(); return identityManager.removeIdentityMapping(userId) .then(() =&gt; { LOG.exit(method); }); } } module.exports = EngineIdentities; Ã— Search results Close "},"composer-runtime_lib_engine.registries.js.html":{"id":"composer-runtime_lib_engine.registries.js.html","title":"Source: composer-runtime/lib/engine.registries.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/engine.registries.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const util = require('util'); const LOG = Logger.getLog('EngineRegistries'); /** * The JavaScript engine responsible for processing chaincode commands. * @protected * @memberof module:composer-runtime */ class EngineRegistries { /** * Get all registries. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ getAllRegistries(context, args) { const method = 'getAllRegistries'; LOG.entry(method, context, args); if (args.length !== 1) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'getAllRegistries', ['registryType'])); } let registryType = args[0]; return context.getRegistryManager().getAll(registryType) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Get the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ getRegistry(context, args) { const method = 'getRegistry'; LOG.entry(method, context, args); if (args.length !== 2) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'getRegistry', ['registryType', 'registryId'])); } let registryType = args[0]; let registryId = args[1]; return context.getRegistryManager().get(registryType, registryId) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Determine whether an asset registry exists. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved with a boolean indicating * whether the asset registry exists. */ existsRegistry(context, args) { const method = 'existsRegistry'; LOG.entry(method, context, args); if (args.length !== 2) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'existsRegistry', ['registryType', 'registryId'])); } let registryType = args[0]; let registryId = args[1]; return context.getRegistryManager().exists(registryType, registryId) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Add a new registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ addRegistry(context, args) { const method = 'addRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'addRegistry', ['registryType', 'registryId', 'registryName'])); } let registryType = args[0]; let registryId = args[1]; let registryName = args[2]; return context.getRegistryManager().add(registryType, registryId, registryName) .then(() =&gt; { LOG.exit(method); }); } } module.exports = EngineRegistries; Ã— Search results Close "},"composer-runtime_lib_engine.resources.js.html":{"id":"composer-runtime_lib_engine.resources.js.html","title":"Source: composer-runtime/lib/engine.resources.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/engine.resources.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const util = require('util'); const LOG = Logger.getLog('EngineResources'); /** * The JavaScript engine responsible for processing chaincode commands. * @protected * @memberof module:composer-runtime */ class EngineResources { /** * Get all resources in the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ getAllResourcesInRegistry(context, args) { const method = 'getAllResourcesInRegistry'; LOG.entry(method, context, args); if (args.length !== 2) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'getAllResourcesInRegistry', ['registryType', 'registryId'])); } let registryType = args[0]; let registryId = args[1]; return context.getRegistryManager().get(registryType, registryId) .then((registryManager) =&gt; { return registryManager.getAll(); }) .then((resources) =&gt; { return resources.map((resource) =&gt; { return context.getSerializer().toJSON(resource); }); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Get the specified resource in the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ getResourceInRegistry(context, args) { const method = 'getResourceInRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'getResourceInRegistry', ['registryType', 'registryId', 'resourceId'])); } let registryType = args[0]; let registryId = args[1]; let resourceId = args[2]; return context.getRegistryManager().get(registryType, registryId) .then((registry) =&gt; { return registry.get(resourceId); }) .then((resource) =&gt; { return context.getSerializer().toJSON(resource); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Determine whether the specified resource exists in the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved with a boolean indicating whether * the resource exists in the registry. */ existsResourceInRegistry(context, args) { const method = 'existsResourceInRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'existsResourceInRegistry', ['registryType', 'registryId', 'resourceId'])); } let registryType = args[0]; let registryId = args[1]; let resourceId = args[2]; return context.getRegistryManager().get(registryType, registryId) .then((registry) =&gt; { return registry.exists(resourceId); }); } /** * Add an array of resources to the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ addAllResourcesToRegistry(context, args) { const method = 'addAllResourcesToRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'addAllResourcesToRegistry', ['registryType', 'registryId', 'serializedResources'])); } let registryType = args[0]; let registryId = args[1]; let serializedResources = JSON.parse(args[2]); let resources = serializedResources.map((serializedResource) =&gt; { return context.getSerializer().fromJSON(serializedResource); }); return context.getRegistryManager().get(registryType, registryId) .then((registry) =&gt; { return registry.addAll(resources); }) .then(() =&gt; { LOG.exit(method); }); } /** * Add a resource to the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ addResourceToRegistry(context, args) { const method = 'addResourceToRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'addResourceToRegistry', ['registryType', 'registryId', 'serializedResource'])); } let registryType = args[0]; let registryId = args[1]; let serializedResource = JSON.parse(args[2]); let resource = context.getSerializer().fromJSON(serializedResource); return context.getRegistryManager().get(registryType, registryId) .then((registry) =&gt; { return registry.add(resource); }) .then(() =&gt; { LOG.exit(method); }); } /** * Update an array of resources in the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ updateAllResourcesInRegistry(context, args) { const method = 'updateAllResourcesInRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'updateAllResourcesInRegistry', ['registryType', 'registryId', 'serializedResources'])); } let registryType = args[0]; let registryId = args[1]; let serializedResources = JSON.parse(args[2]); let resources = serializedResources.map((serializedResource) =&gt; { return context.getSerializer().fromJSON(serializedResource); }); return context.getRegistryManager().get(registryType, registryId) .then((registry) =&gt; { return registry.updateAll(resources); }) .then(() =&gt; { LOG.exit(method); }); } /** * Update a resource in the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ updateResourceInRegistry(context, args) { const method = 'updateResourceInRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'updateResourceInRegistry', ['registryType', 'registryId', 'serializedResource'])); } let registryType = args[0]; let registryId = args[1]; let serializedResource = JSON.parse(args[2]); let resource = context.getSerializer().fromJSON(serializedResource); return context.getRegistryManager().get(registryType, registryId) .then((registry) =&gt; { return registry.update(resource); }) .then(() =&gt; { LOG.exit(method); }); } /** * Remove an array of resources from the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ removeAllResourcesFromRegistry(context, args) { const method = 'removeAllResourcesFromRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'removeAllResourcesFromRegistry', ['registryType', 'registryId', 'resourceIds'])); } let registryType = args[0]; let registryId = args[1]; let resourceIds = JSON.parse(args[2]); return context.getRegistryManager().get(registryType, registryId) .then((registry) =&gt; { return registry.removeAll(resourceIds); }) .then(() =&gt; { LOG.exit(method); }); } /** * Remove a resource from the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ removeResourceFromRegistry(context, args) { const method = 'removeResourceFromRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'removeResourceFromRegistry', ['registryType', 'registryId', 'resourceId'])); } let registryType = args[0]; let registryId = args[1]; let resourceId = args[2]; return context.getRegistryManager().get(registryType, registryId) .then((registry) =&gt; { return registry.remove(resourceId); }) .then(() =&gt; { LOG.exit(method); }); } /** * Get all resources in the specified registry, and recursively resolve all * their relationships to other resources. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ resolveAllResourcesInRegistry(context, args) { const method = 'resolveAllResourcesInRegistry'; LOG.entry(method, context, args); if (args.length !== 2) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'resolveAllResourcesInRegistry', ['registryType', 'registryId'])); } let registryType = args[0]; let registryId = args[1]; return context.getRegistryManager().get(registryType, registryId) .then((registryManager) =&gt; { return registryManager.getAll(); }) .then((resources) =&gt; { let resolver = context.getResolver(); return resources.reduce((result, resource) =&gt; { return result.then(() =&gt; { LOG.debug(method, 'Resolving resource', resource.getFullyQualifiedIdentifier()); return resolver.resolve(resource); }); }, Promise.resolve()) .then(() =&gt; { LOG.debug(method, 'Resolved all resources', resources.length); return resources; }); }) .then((resources) =&gt; { return resources.map((resource) =&gt; { return context.getSerializer().toJSON(resource, { permitResourcesForRelationships: true }); }); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Get the specified resource in the specified registry, and recursively resolve * all its relationships to other resources. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ resolveResourceInRegistry(context, args) { const method = 'resolveResourceInRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'resolveResourceInRegistry', ['registryType', 'registryId', 'resourceId'])); } let registryType = args[0]; let registryId = args[1]; let resourceId = args[2]; return context.getRegistryManager().get(registryType, registryId) .then((registry) =&gt; { return registry.get(resourceId); }) .then((resource) =&gt; { let resolver = context.getResolver(); LOG.debug(method, 'Resolving resource', resource.getFullyQualifiedIdentifier()); return resolver.resolve(resource); }) .then((resource) =&gt; { return context.getSerializer().toJSON(resource, { permitResourcesForRelationships: true }); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Query all of the the resources in the specified registry using the given * expression, and return all of the resources for which the expression returns * a truthy value. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ findResourcesInRegistry(context, args) { const method = 'findResourcesInRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'findResourcesInRegistry', ['registryType', 'registryId', 'expression'])); } let registryType = args[0]; let registryId = args[1]; let expression = args[2]; return context.getRegistryManager().get(registryType, registryId) .then((registryManager) =&gt; { return registryManager.getAll(); }) .then((resources) =&gt; { let queryExecutor = context.getQueryExecutor(); return queryExecutor.queryAll(expression, resources) .then((queryResults) =&gt; { let result = []; queryResults.forEach((queryResult, index) =&gt; { let resource = resources[index]; LOG.debug(method, 'Checking query results for resource', resource.getFullyQualifiedIdentifier()); if (queryResult) { LOG.debug(method, 'Query returned truthy value for resource'); result.push(context.getSerializer().toJSON(resource, { convertResourcesToRelationships: true })); } else { LOG.debug(method, 'Query returned falsey value for resource'); } }); LOG.exit(method, result); return result; }); }); } /** * Query all of the the resources in the specified registry using the given * expression, and return all of the truthy results. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ queryResourcesInRegistry(context, args) { const method = 'queryResourcesInRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'queryResourcesInRegistry', ['registryType', 'registryId', 'expression'])); } let registryType = args[0]; let registryId = args[1]; let expression = args[2]; return context.getRegistryManager().get(registryType, registryId) .then((registryManager) =&gt; { return registryManager.getAll(); }) .then((resources) =&gt; { let queryExecutor = context.getQueryExecutor(); return queryExecutor.queryAll(expression, resources) .then((queryResults) =&gt; { let result = queryResults.filter((queryResult, index) =&gt; { let resource = resources[index]; LOG.debug(method, 'Checking query results for resource', resource.getFullyQualifiedIdentifier()); if (queryResult) { LOG.debug(method, 'Query returned truthy value for resource'); return true; } else { LOG.debug(method, 'Query returned falsey value for resource'); return false; } }); LOG.exit(method, result); return result; }); }); } } module.exports = EngineResources; Ã— Search results Close "},"composer-runtime_lib_engine.transactions.js.html":{"id":"composer-runtime_lib_engine.transactions.js.html","title":"Source: composer-runtime/lib/engine.transactions.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/engine.transactions.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const util = require('util'); const LOG = Logger.getLog('EngineTransactions'); /** * The JavaScript engine responsible for processing chaincode commands. * @protected * @memberof module:composer-runtime */ class EngineTransactions { /** * Submit a transaction for execution. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ submitTransaction(context, args) { const method = 'submitTransaction'; LOG.entry(method, context, args); if (args.length !== 2) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'submitTransaction', ['registryId', 'serializedResource'])); } // Find the default transaction registry. let registryManager = context.getRegistryManager(); let transaction = null, resolvedTransaction = null; // Parse the transaction from the JSON string.. LOG.debug(method, 'Parsing transaction from JSON'); let transactionData = JSON.parse(args[1]); // Now we need to convert the JavaScript object into a transaction resource. LOG.debug(method, 'Parsing transaction from parsed JSON object'); // First we parse *our* copy, that is not resolved. This is the copy that gets added to the // transaction registry, and is the one in the context (for adding log entries). transaction = context.getSerializer().fromJSON(transactionData); // Then we parse the *users* copy, that is resolved, and they can modify to their hearts content. // This is only given to the user, and is discarded afterwards. resolvedTransaction = context.getSerializer().fromJSON(transactionData); // Store the transaction in the context. context.setTransaction(transaction); // Resolve the users copy of the transaction. LOG.debug(method, 'Parsed transaction, resolving it', resolvedTransaction); return context.getResolver().resolve(resolvedTransaction) .then(() =&gt; { // Get the list of transaction executors. let transactionExecutors = context.getTransactionExecutors(); let api = context.getApi(); let scriptManager = context.getScriptManager(); // Let each one process the transaction in turn. return transactionExecutors.reduce((result, transactionExecutor) =&gt; { return result.then(() =&gt; { LOG.debug(method, 'Calling transaction executor', transactionExecutor.getType()); return transactionExecutor.execute(api, scriptManager, transaction, resolvedTransaction); }); }, Promise.resolve()); }) .then(() =&gt; { // Get the default transaction registry. LOG.debug(method, 'Getting default transaction registry'); return registryManager.get('Transaction', 'default'); }) .then((transactionRegistry) =&gt; { // Store the transaction in the transaction registry. LOG.debug(method, 'Storing executed transaction in transaction registry'); return transactionRegistry.add(transaction); }); } } module.exports = EngineTransactions; Ã— Search results Close "},"composer-runtime_lib_api_factory.js.html":{"id":"composer-runtime_lib_api_factory.js.html","title":"Source: composer-runtime/lib/api/factory.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/api/factory.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const LOG = Logger.getLog('Factory'); /** * Do not attempt to create an instance of this class.&lt;br&gt; * You must use the {@link module:composer-runtime#getFactory getFactory} * method instead. * * @class Factory * @classdesc A factory creates new instances of assets, participants, transactions, * and relationships. * @memberof module:composer-runtime * @public */ /** * A class that represents a factory in the transaction processor API. The * transaction processor API should expose no internal properties or internal * methods which could be accessed or misused. * @private */ class Factory { /** * Constructor. * @param {Factory} factory The factory to use. * @private */ constructor(factory) { const method = 'constructor'; LOG.entry(method, factory); /** * Create a new instance of an asset, participant, or transaction. The * properties of the new instance should be set as standard JavaScript * object properties. The new instance can then be stored in a registry * using the appropriate registry APIs, for example {@link * module:composer-runtime.AssetRegistry AssetRegistry}. * @example * // Get the factory. * var factory = getFactory(); * // Create a new vehicle. * var vehicle = factory.newInstance('org.acme', 'Vehicle', 'VEHICLE_1'); * // Set the properties of the new vehicle. * vehicle.colour = 'BLUE'; * vehicle.manufacturer = 'Toyota'; * @public * @method module:composer-runtime.Factory#newInstance * @param {string} ns The namespace of the resource to create. * @param {string} type The type of the resource to create. * @param {string} id The identifier of the new resource. * @return {Resource} The new instance of the resource. * @throws {Error} If the specified type (specified by the namespace and * type) is not defined in the current version of the business network. */ this.newInstance = function newInstance(ns, type, id) { return factory.newInstance(ns, type, id); }; /** * Create a new relationship with a given namespace, type, and identifier. * A relationship is a typed pointer to an instance. For example, a new * relationship with namespace 'org.acme', type 'Vehicle' and identifier * 'VEHICLE_1' creates` a pointer that points at an existing instance of * org.acme.Vehicle with the identifier 'VEHICLE_1'. * @example * // The existing driver of the vehicle. * var driver; * // Get the factory. * var factory = getFactory(); * // Create a new relationship to the vehicle. * var vehicle = factory.newRelationship('org.acme', 'Vehicle', 'VEHICLE_1'); * // Set the relationship as the value of the vehicle property of the driver. * driver.vehicle = vehicle; * @public * @method module:composer-runtime.Factory#newRelationship * @param {string} ns The namespace of the resource referenced by the relationship. * @param {string} type The type of the resource referenced by the relationship. * @param {string} id The identifier of the resource referenced by the relationship. * @return {Relationship} The new instance of the relationship. * @throws {Error} If the specified type (specified by the namespace and * type) is not defined in the current version of the business network. */ this.newRelationship = function newRelationship(ns, type, id) { return factory.newRelationship(ns, type, id); }; /** * Create a new concept with a given namespace, type, and identifier. * A concept is an advanced data structure * @example * // The existing driver of the vehicle. * var person; * // Get the factory. * var factory = getFactory(); * // Create a new relationship to the vehicle. * var record = factory.newConcept('org.acme', 'Record', 'RECORD_1'); * // Add the record to the persons array of records. * person.records.push(record); * @public * @method module:composer-runtime.Factory#newConcept * @param {string} ns The namespace of the concept. * @param {string} type The type of the concept. * @return {Concept} The new instance of the concept. * @throws {Error} If the specified type (specified by the namespace and * type) is not defined in the current version of the business network. */ this.newConcept = function newConcept(ns, type) { return factory.newConcept(ns, type); }; Object.freeze(this); LOG.exit(method); } } module.exports = Factory; Ã— Search results Close "},"composer-runtime_lib_identityservice.js.html":{"id":"composer-runtime_lib_identityservice.js.html","title":"Source: composer-runtime/lib/identityservice.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/identityservice.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Base class representing the identity service provided by a {@link Container}. * @protected * @abstract * @memberof module:composer-runtime */ class IdentityService { /** * Retrieve the current user ID. * @abstract * @return {string} The current user ID, or null if the current user ID cannot * be determined or has not been specified. */ getCurrentUserID() { throw new Error('abstract function called'); } /** * Stop serialization of this object. * @return {Object} An empty object. */ toJSON() { return {}; } } module.exports = IdentityService; Ã— Search results Close "},"composer-runtime_lib_loggingservice.js.html":{"id":"composer-runtime_lib_loggingservice.js.html","title":"Source: composer-runtime/lib/loggingservice.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/loggingservice.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Base class representing the logging service provided by a {@link Container}. * @protected * @abstract * @memberof module:composer-runtime */ class LoggingService { /** * Write a critical message to the log. * @abstract * @param {string} message The message to write to the log. */ logCritical(message) { throw new Error('abstract function called'); } /** * Write a debug message to the log. * @abstract * @param {string} message The message to write to the log. */ logDebug(message) { throw new Error('abstract function called'); } /** * Write an error message to the log. * @abstract * @param {string} message The message to write to the log. */ logError(message) { throw new Error('abstract function called'); } /** * Write a informational message to the log. * @abstract * @param {string} message The message to write to the log. */ logInfo(message) { throw new Error('abstract function called'); } /** * Write a notice message to the log. * @abstract * @param {string} message The message to write to the log. */ logNotice(message) { throw new Error('abstract function called'); } /** * Write a warning message to the log. * @abstract * @param {string} message The message to write to the log. */ logWarning(message) { throw new Error('abstract function called'); } /** * Stop serialization of this object. * @return {Object} An empty object. */ toJSON() { return {}; } } module.exports = LoggingService; Ã— Search results Close "},"composer-runtime_lib_api_participantregistry.js.html":{"id":"composer-runtime_lib_api_participantregistry.js.html","title":"Source: composer-runtime/lib/api/participantregistry.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/api/participantregistry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const LOG = Logger.getLog('ParticipantRegistry'); /** * Do not attempt to create an instance of this class.&lt;br&gt; * You must use the {@link module:composer-runtime#getParticipantRegistry getParticipantRegistry} * method instead. * * @class ParticipantRegistry * @classdesc An participant registry manages a set of participants. * @memberof module:composer-runtime * @public */ /** * A class that represents an participant registry in the transaction processor API. The * transaction processor API should expose no internal properties or internal * methods which could be accessed or misused. * @private */ class ParticipantRegistry { /** * Constructor. * @param {Registry} registry The registry to use. * @private */ constructor(registry) { const method = 'constructor'; LOG.entry(method, registry); /** * Get a list of all of the existing participants in this participant registry. * @example * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (driverParticipantRegistry) { * // Get all of the drivers in the driver participant registry. * return participantRegistry.getAll(); * }) * .then(function (drivers) { * // Process the array of driver objects. * drivers.forEach(function (driver) { * console.log(driver.driverId); * }); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#getAll * @return {Promise} A promise. The promise is resolved with an array of * {@link Resource} instances representing all of the participants stored in this * participant registry. If the participant registry does not exist, or the current * user does not have access to the participant registry, then the promise will * be rejected with an error that describes the problem. */ this.getAll = function getAll() { return registry.getAll(); }; /** * Get the specified participant in this participant registry using the unique identifier * of the participant. * @example * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (driverParticipantRegistry) { * // Get the specific driver from the driver participant registry. * return participantRegistry.get('VEHICLE_1'); * }) * .then(function (driver) { * // Process the the driver object. * console.log(driver.driverId); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#get * @param {string} id The ID of the participant. * @return {Promise} A promise. The promise is resolved with a {@link Resource} * instance representing the specified participant in this participant registry. If the * specified participant does not exist, or the current user does not have access * to the specified participant, then the promise will be rejected with an error * that describes the problem. */ this.get = function get(id) { return registry.get(id); }; /** * Add all of the specified participants to this participant registry. * @example * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (driverParticipantRegistry) { * // Get the factory for creating new participant instances. * var factory = getFactory(); * // Create the first driver. * var driver1 = factory.newInstance('org.acme', 'Driver', 'VEHICLE_1'); * driver1.location = 'Southampton'; * // Create the second driver. * var driver2 = factory.newInstance('org.acme', 'Driver', 'VEHICLE_2'); * driver2.location = 'GREEN'; * // Add the drivers to the driver participant registry. * return driverParticipantRegistry.addAll([driver1, driver2]); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#addAll * @param {Resource[]} participants The participants to add to this participant registry. * @return {Promise} A promise. The promise is resolved when all of the * participants have been added to this participant registry. If the participants cannot be * added to this participant registry, or if the participants already exist in the * participant registry, then the promise will be rejected with an error * that describes the problem. */ this.addAll = function addAll(participants) { return registry.addAll(participants, { convertResourcesToRelationships: true }); }; /** * Add the specified participant to this participant registry. * @example * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (driverParticipantRegistry) { * // Get the factory for creating new participant instances. * var factory = getFactory(); * // Create the driver. * var driver = factory.newInstance('org.acme', 'Driver', 'VEHICLE_1'); * driver.location = 'Southampton'; * // Add the driver to the driver participant registry. * return driverParticipantRegistry.add(driver); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#add * @param {Resource} participant The participants to add to this participant registry. * @return {Promise} A promise. The promise is resolved when the participant has * been added to this participant registry. If the participant cannot be added to this * participant registry, or if the participant already exists in the participant registry, * then the promise will be rejected with an error that describes the problem. */ this.add = function add(participant) { return registry.add(participant, { convertResourcesToRelationships: true }); }; /** * Update all of the specified participants in this participant registry. * @example * // The existing drivers that have come from elsewhere. * var driver1; * var driver2; * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (driverParticipantRegistry) { * // Get the factory for creating new participant instances. * var factory = getFactory(); * // Modify the properties of the first driver. * driver1.location = 'Hursley'; * // Modify the properties of the second driver. * driver2.location = 'London'; * // Update the drivers in the driver participant registry. * return driverParticipantRegistry.updateAll([driver1, driver2]); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#updateAll * @param {Resource[]} participants The participants to update in this participant registry. * @return {Promise} A promise. The promise is resolved when all of the * participants have been updated in this participant registry. If the participants cannot be * updated in this participant registry, or if the participants do not exist in the * participant registry, then the promise will be rejected with an error that * describes the problem. */ this.updateAll = function updateAll(participants) { return registry.updateAll(participants, { convertResourcesToRelationships: true }); }; /** * Update the specified participant in this participant registry. * @example * // The existing driver that has come from elsewhere. * var driver; * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (driverParticipantRegistry) { * // Get the factory for creating new participant instances. * var factory = getFactory(); * // Modify the properties of the driver. * driver.location = 'Hursley'; * // Update the driver in the driver participant registry. * return driverParticipantRegistry.update(driver); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#update * @param {Resource} participant The participant to update in this participant registry. * @return {Promise} A promise. The promise is resolved when the participant * have been updated in this participant registry. If the participant cannot be * updated in this participant registry, or if the participant does not exist in the * participant registry, then the promise will be rejected with an error that * describes the problem. */ this.update = function update(participant) { return registry.update(participant, { convertResourcesToRelationships: true }); }; /** * Remove all of the specified participants from this participant registry. * @example * // The existing drivers that have come from elsewhere. * var driver1; * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (driverParticipantRegistry) { * // Get the factory for creating new participant instances. * var factory = getFactory(); * // Remove the drivers from the driver participant registry. Note that * // one driver is specified as a driver instance, and the other * // driver is specified by the ID of the driver. * return driverParticipantRegistry.removeAll([driver1, 'VEHICLE_2']); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#removeAll * @param {string[]|Resource[]} participants The participants, or the IDs of the participants, * to remove from this participant registry. * @return {Promise} A promise. The promise is resolved when all of the * participants have been removed from this participant registry. If the participants cannot be * removed from this participant registry, or if the participants do not exist in the * participant registry, then the promise will be rejected with an error that * describes the problem. */ this.removeAll = function removeAll(participants) { return registry.removeAll(participants); }; /** * Remove the specified participant from this participant registry. * @example * // The existing driver that has come from elsewhere. * var driver; * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (driverParticipantRegistry) { * // Get the factory for creating new participant instances. * var factory = getFactory(); * // Remove the driver from the driver participant registry. * return driverParticipantRegistry.remove(driver); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#remove * @param {string|Resource} participant The participant, or ID of the participant, to remove * from this participant registry. * @return {Promise} A promise. The promise is resolved when the participant * has been removed from this participant registry. If the participant cannot be * removed from this participant registry, or if the participant does not exist in the * participant registry, then the promise will be rejected with an error that * describes the problem. */ this.remove = function remove(participant) { return registry.remove(participant); }; Object.freeze(this); LOG.exit(method); } } module.exports = ParticipantRegistry; Ã— Search results Close "},"composer-runtime_lib_resolver.js.html":{"id":"composer-runtime_lib_resolver.js.html","title":"Source: composer-runtime/lib/resolver.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/resolver.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AssetDeclaration = require('composer-common').AssetDeclaration; const Logger = require('composer-common').Logger; const ParticipantDeclaration = require('composer-common').ParticipantDeclaration; const Relationship = require('composer-common').Relationship; const Resource = require('composer-common').Resource; const TransactionDeclaration = require('composer-common').TransactionDeclaration; const LOG = Logger.getLog('Context'); /** * A class for resolving resources and their relationships to other resources. * @protected * @abstract * @memberof module:composer-runtime */ class Resolver { /** * Constructor. * @param {Introspector} introspector The introspector to use. * @param {RegistryManager} registryManager The registry manager to use. */ constructor(introspector, registryManager) { const method = 'constructor'; LOG.entry(method, registryManager); this.introspector = introspector; this.registryManager = registryManager; LOG.exit(method); } /** * Resolve the specified resource or relationship and all of its relationships. * @param {Resource|Relationship} identifiable The identifiable to resolve. * @return {Promise} A promise that is resolved with the resolved {@link Resource} * object when the resource is resolved, or rejected with an error. */ resolve(identifiable) { const method = 'resolve'; LOG.entry(method, identifiable.toString()); let resolveState = { cachedResources: new Map() }; if (identifiable instanceof Resource) { resolveState.cachedResources.set(identifiable.getFullyQualifiedIdentifier(), identifiable); return this.resolveResource(identifiable, resolveState) .then((result) =&gt; { LOG.exit(method, result.toString()); return result; }); } else if (identifiable instanceof Relationship) { return this.resolveRelationship(identifiable, resolveState) .then((result) =&gt; { LOG.exit(method, result.toString()); return result; }); } else { LOG.error(method, 'unsupported type for identifiable'); throw new Error('unsupported type for identifiable'); } } /** * Resolve the specified resource. * @private * @param {Resource} resource The resource to resolve. * @param {Object} resolveState The current resolve state. * @param {Map} resolveState.cachedResources The cache of resolved resources. * @return {Promise} A promise that is resolved with a {@link Resource} object, * or rejected with an error. */ resolveResource(resource, resolveState) { const method = 'resolveResource'; LOG.entry(method, resource.toString(), resolveState); let classDeclaration = resource.getClassDeclaration(); return classDeclaration.getProperties().reduce((result, property) =&gt; { // Get the property value. LOG.debug(method, 'Looking at property', property.getName()); let value = resource[property.getName()]; if (value instanceof Resource) { // Replace the property value with the resolved resource. LOG.debug(method, 'Property value is a resource, resolving', value.toString()); return result.then(() =&gt; { return this.resolveResource(value, resolveState); }).then((newValue) =&gt; { resource[property.getName()] = newValue; }); } else if (value instanceof Relationship) { // Replace the property value with the resolved relationship. LOG.debug(method, 'Property value is a relationship, resolving', value.toString()); return result.then(() =&gt; { return this.resolveRelationship(value, resolveState); }).then((newValue) =&gt; { resource[property.getName()] = newValue; }); } else if (Array.isArray(value)) { // Go through each item in the array. LOG.debug(method, 'Property value is an array, iterating over values', value.length); return value.reduce((result, item, index) =&gt; { // Handle the array item. if (item instanceof Resource) { // Replace the property value with the resolved resource. LOG.debug(method, 'Array item is a resource, resolving', item.toString()); return result.then(() =&gt; { return this.resolveResource(item, resolveState); }).then((newItem) =&gt; { value[index] = newItem; }); } else if (item instanceof Relationship) { // Replace the property value with the resolved relationship. LOG.debug(method, 'Property value is a relationship, resolving', item.toString()); return result.then(() =&gt; { return this.resolveRelationship(item, resolveState); }).then((newItem) =&gt; { value[index] = newItem; }); } else { LOG.debug(method, 'Array item is neither a resource or a relationship, ignoring', item); return result; } }, Promise.resolve()); } else { LOG.debug(method, 'Property value is neither a resource or a relationship, ignoring', value); return result; } }, Promise.resolve()) .then(() =&gt; { LOG.exit(method, resource.toString()); return resource; }); } /** * Resolve the specified relationship. * @private * @param {Relationship} relationship The relationship to resolve. * @param {Object} resolveState The current resolve state. * @param {Map} resolveState.cachedResources The cache of resolved resources. * @param {boolean} [resolveState.skipRecursion] Set to true to skip resolving the resolved resource. * @return {Promise} A promise that is resolved with a {@link Resource} object, * or rejected with an error. */ resolveRelationship(relationship, resolveState) { const method = 'resolveRelationship'; LOG.entry(method, relationship.toString(), resolveState); let fqi = relationship.getFullyQualifiedIdentifier(); if (resolveState.cachedResources.has(fqi)) { LOG.debug(method, 'Target resource is already present in cache', fqi); let resource = resolveState.cachedResources.get(fqi); LOG.exit(method, resource.toString()); return Promise.resolve(resource); } let registryId = relationship.getFullyQualifiedType(); let classDeclaration = this.introspector.getClassDeclaration(registryId); LOG.debug(method, 'Got class declaration', classDeclaration); let classType; if (classDeclaration instanceof AssetDeclaration) { classType = 'Asset'; } else if (classDeclaration instanceof ParticipantDeclaration) { classType = 'Participant'; } else if (classDeclaration instanceof TransactionDeclaration) { classType = 'Transaction'; // Special case for this one! registryId = 'default'; } else { throw new Error('Unsupported class declaration type ' + classDeclaration.toString()); } LOG.debug(method, 'Getting registry', registryId); return this.registryManager.get(classType, registryId) .then((registry) =&gt; { let resourceId = relationship.getIdentifier(); LOG.debug(method, 'Getting resource in registry', resourceId); return registry.get(resourceId); }) .then((resource) =&gt; { LOG.debug(method, 'Got resource from registry, adding to cache'); resolveState.cachedResources.set(fqi, resource); if (resolveState.skipRecursion) { LOG.debug(method, 'Got resource from registry, but skipping resolve'); return resource; } else { LOG.debug(method, 'Got resource from registry, resolving'); return this.resolveResource(resource, resolveState); } }) .then((resource) =&gt; { LOG.exit(method, resource.toString()); return resource; }); } /** * Stop serialization of this object. * @return {Object} An empty object. */ toJSON() { return {}; } } module.exports = Resolver; Ã— Search results Close "},"composer-runtime_lib_transactionlogger.js.html":{"id":"composer-runtime_lib_transactionlogger.js.html","title":"Source: composer-runtime/lib/transactionlogger.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/transactionlogger.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const jsonpatch = require('fast-json-patch'); const Logger = require('composer-common').Logger; const LOG = Logger.getLog('TransactionLogger'); /** * A class for logging the changes made by a transaction. * @protected * @abstract * @memberof module:composer-runtime */ class TransactionLogger { /** * Create a logger for the specified transaction. * @param {Resource} transaction The transaction. * @param {RegistryManager} registryManager The registry manager. * @param {Serializer} serializer The serializer. */ constructor(transaction, registryManager, serializer) { const method = 'constructor'; LOG.entry(method, transaction, registryManager, serializer); this.transaction = transaction; this.registryManager = registryManager; this.serializer = serializer; registryManager.on('resourceadded', this.onResourceAdded.bind(this)); registryManager.on('resourceupdated', this.onResourceUpdated.bind(this)); registryManager.on('resourceremoved', this.onResourceRemoved.bind(this)); LOG.exit(method); } /** * Handle a resource being added to a registry. * @param {Registry#resourceadded} event The resource added event. */ onResourceAdded(event) { const method = 'onResourceAdded'; LOG.entry(method, event); LOG.exit(); } /** * Handle a resource being added to a registry. * @param {Registry#resourceupdated} event The resource added event. */ onResourceUpdated(event) { const method = 'onResourceUpdated'; LOG.entry(method, event); // Serialize both the old and new resources. let oldJSON = this.serializer.toJSON(event.oldResource, { convertResourcesToRelationships: true }); LOG.debug(method, 'Serialized old resource'); let newJSON = this.serializer.toJSON(event.newResource, { convertResourcesToRelationships: true }); LOG.debug(method, 'Serialized new resource'); // Generate a JSON Patch from the two resources. let patches = jsonpatch.compare(oldJSON, newJSON); LOG.debug(method, 'Generated JSON Patch', patches); LOG.exit(); } /** * Handle a resource being added to a registry. * @param {Registry#resourceremoved} event The resource added event. */ onResourceRemoved(event) { const method = 'onResourceRemoved'; LOG.entry(method, event); LOG.exit(); } } module.exports = TransactionLogger; Ã— Search results Close "},"composer-runtime_lib_api.js.html":{"id":"composer-runtime_lib_api.js.html","title":"Source: composer-runtime/lib/api.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/api.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AssetRegistry = require('./api/assetregistry'); const Factory = require('./api/factory'); const Logger = require('composer-common').Logger; const ParticipantRegistry = require('./api/participantregistry'); const LOG = Logger.getLog('Api'); /** * A class that contains the root of the transaction processor API. Methods in this * class are made available as global functions which can be called by transaction * processor functions. The transaction processor API should expose no internal * properties or internal methods which could be accessed or misused. * @private * @class * @memberof module:composer-runtime */ class Api { /** * Constructor. * @param {Factory} factory The factory to use. * @param {Resource} participant The current participant. * @param {RegistryManager} registryManager The registry manager to use. * @private */ constructor(factory, participant, registryManager) { const method = 'constructor'; LOG.entry(method, factory, participant, registryManager); /** * Get the factory. The factory can be used to create new instances of * assets, participants, and transactions for storing in registries. The * factory can also be used for creating relationships to assets, particpants, * and transactions. * @example * // Get the factory. * var factory = getFactory(); * @method module:composer-runtime#getFactory * @public * @return {module:composer-runtime.Factory} The factory. */ this.getFactory = function getFactory() { const method = 'getFactory'; LOG.entry(method); let result = new Factory(factory); LOG.exit(method, result); return result; }; /** * Get an existing asset registry using the unique identifier of the asset * registry. An asset registry can be used to retrieve, update, or delete * existing assets, or create new assets. * @example * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Call methods on the vehicle asset registry. * }) * .catch(function (error) { * // Add optional error handling here. * }); * @method module:composer-runtime#getAssetRegistry * @public * @param {string} id The ID of the asset registry. * @return {Promise} A promise. The promise is resolved with an {@link * module:composer-runtime.AssetRegistry AssetRegistry} instance * representing the asset registry if it exists. If the asset registry * does not exist, or the current user does not have access to the asset * registry, then the promise will be rejected with an error that describes * the problem. */ this.getAssetRegistry = function getAssetRegistry(id) { const method = 'getAssetRegistry'; LOG.entry(method, id); return registryManager.get('Asset', id) .then((registry) =&gt; { let result = new AssetRegistry(registry); LOG.exit(method, result); return result; }); }; /** * Get an existing participant registry using the unique identifier of the participant * registry. An participant registry can be used to retrieve, update, or delete * existing participants, or create new participants. * @example * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (driverParticipantRegistry) { * // Call methods on the driver participant registry. * }) * .catch(function (error) { * // Add optional error handling here. * }); * @method module:composer-runtime#getParticipantRegistry * @public * @param {string} id The ID of the participant registry. * @return {Promise} A promise. The promise is resolved with an {@link * module:composer-runtime.ParticipantRegistry ParticipantRegistry} instance * representing the participant registry if it exists. If the participant registry * does not exist, or the current user does not have access to the participant * registry, then the promise will be rejected with an error that describes * the problem. */ this.getParticipantRegistry = function getParticipantRegistry(id) { const method = 'getParticipantRegistry'; LOG.entry(method, id); return registryManager.get('Participant', id) .then((registry) =&gt; { let result = new ParticipantRegistry(registry); LOG.exit(method, result); return result; }); }; /** * Get the current participant. The current participant is determined by * the identity that was used to submit the current transaction. * @example * // Get the current participant. * var currentParticipant = getCurrentParticipant(); * // Check to see if the current participant is a driver. * if (currentParticipant.getFullyQualifiedType() !== 'org.acme.Driver') { * // Throw an error as the current participant is not a driver. * throw new Error('Current participant is not a driver'); * } * // Check to see if the current participant is the first driver. * if (currentParticipant.getFullyQualifiedIdentifier() !== 'org.acme.Driver#DRIVER_1') { * // Throw an error as the current participant is not a driver. * throw new Error('Current participant is not the first driver'); * } * @method module:composer-runtime#getCurrentParticipant * @public * @return {module:composer-common.Resource} The current participant, * or null if the transaction was submitted using an identity that does * not map to a participant. */ this.getCurrentParticipant = function getCurrentParticipant() { const method = 'getCurrentParticipant'; LOG.entry(method); let result = participant; LOG.exit(method, result); return result; }; Object.freeze(this); LOG.exit(method); } } module.exports = Api; Ã— Search results Close "},"composer-runtime_lib_queryexecutor.js.html":{"id":"composer-runtime_lib_queryexecutor.js.html","title":"Source: composer-runtime/lib/queryexecutor.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/queryexecutor.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const jsonata = require('jsonata'); const Logger = require('composer-common').Logger; const Relationship = require('composer-common').Relationship; const Resource = require('composer-common').Resource; const LOG = Logger.getLog('QueryEngine'); /** * Design documentation: * * The aim of this class to execute queries (currently JSONata expressions) on a * resource or a set of resources. In order for this query support to be useful, * the queries must be able to navigate relationships between resources. For example, * I might want to execute a query of &quot;find all the animals which are in a field, * where that field is owned by a business, where that business is run by a farmer * with the email address alice@farmers.com&quot;. * * We do not want to eagerly resolve all visible relationships, as this is slow. * Most business networks are large and complex, with many relationships between * resources, and additionally those relationships can be circular. * * Ideally, we would only resolve relationships that are needed in order to * successfully execute the query. We can do this by creating &quot;special&quot; properties * on the relationship object for each of the properties that should exist on the * target resource. When the &quot;special&quot; property is accessed by the query, a function * can be executed to resolve that relationship and replace it with the target * resource. * * Unfortunately, resolving a relationship is an asynchronous operation, because * we have to perform network I/O. JSONata (our expression runtime) does not, at * the time of writing, have any support for handling asynchronous values or * promises that will be resolved with values. * * The code below attempts to work around this by executing the following algorithm: * * 1) An empty array of accessed relationships is created. * * 2) The resource or resources being queried are modified so that all of their * relationships are augmented with &quot;special&quot; properties. These properties * execute a function when they are read. That function then adds the properties * owning relationship to the array defined in 1). * * 3) The JSONata expression is evaluated against the resource or resources. The * evaluation will return a value. * * 4) If the array defined in 1) is empty, no relationships were accessed, and * we can safely return the result of 3) and stop processing. * * 5) If the array defined in 1) is not empty, then we must iterate over that array. * For each accessed relationship in the array: * * 5a) The relationship is resolved to its target resource. * * 5b) The resolved resource is modified as per 2) so that any relationships in the * resolved resource are also augumented with &quot;special&quot; properties. * * 5c) The relationship is replaced with the resolved resource. * * 5d) The accessed relationship is removed from the array defined in 1). * * 6) Now that all accessed relationships have been resolved, we repeat step 3). * Note that new relationships may be accessed, so we may repeat steps 3) to * 6) multiple times until we can return in 4). * * This is inefficient as we may have to evaluate the JSONata expression multiple * times until all required relationships are resolved. Currently, the resolver * uses a cache of resources to save on expensive registry lookups. A future * improvement to this algorithm could be to keep a cache of queries and a list * of the relationships that had to be resolved in order to process each query. * Those relationships could then be eagerly resolved upfront for any subsequent * executions of the same query. */ /** * A class for executing queries using JSONata expressions against resources. * @protected */ class QueryExecutor { /** * Constructor. * @param {Resolver} resolver The resolver to use. */ constructor(resolver) { const method = 'constructor'; LOG.entry(method, resolver); this.resolver = resolver; LOG.exit(method); } /** * Query all of the specified resources using the given JSONata expression. * @param {string} expression The JSONata expression. * @param {Resource[]} resources The resource to query. * @return {Promise} A promise that will be resolved with the results of the * query, or rejected with an error. */ queryAll(expression, resources) { const method = 'queryAll'; LOG.entry(method, expression, resources); // Compile the expression. LOG.debug(method, 'Compiling JSONata expression'); const compiledExpression = jsonata(expression); LOG.debug(method, 'Compiled JSONata expression'); // Prepare the root resources. let accessedRelationships = []; let cachedResources = new Map(); resources.forEach((resource) =&gt; { LOG.debug(method, 'Preparing resource', resource.getFullyQualifiedIdentifier()); let fqi = resource.getFullyQualifiedIdentifier(); cachedResources.set(fqi, resource); this.prepareResource(resource, accessedRelationships); }); // Process the query by calling the recursive method that does the bulk of the work. let promise = Promise.resolve(); let result = []; resources.forEach((resource) =&gt; { promise = promise.then(() =&gt; { LOG.debug(method, 'Executing query on resource', resource.getFullyQualifiedIdentifier()); return this.queryInternal(compiledExpression, resource, accessedRelationships, cachedResources) .then((thisResult) =&gt; { LOG.debug(method, 'Executed query, adding result to list'); result.push(thisResult); }); }); }); return promise .then(() =&gt; { LOG.exit(method, result); return result; }); } /** * Query the specified resource using the given JSONata expression. * @param {string} expression The JSONata expression. * @param {Resource} resource The resource to query. * @return {Promise} A promise that will be resolved with the results of the * query, or rejected with an error. */ query(expression, resource) { const method = 'query'; LOG.entry(method, expression, resource.toString()); // Compile the expression. LOG.debug(method, 'Compiling JSONata expression'); const compiledExpression = jsonata(expression); LOG.debug(method, 'Compiled JSONata expression'); // Prepare the root resource. let accessedRelationships = []; let cachedResources = new Map(); let fqi = resource.getFullyQualifiedIdentifier(); cachedResources.set(fqi, resource); this.prepareResource(resource, accessedRelationships); // Process the query by calling the recursive method that does the bulk of the work. return this.queryInternal(compiledExpression, resource, accessedRelationships, cachedResources) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * @private * @typedef {Object} FoundRelationship * @property {Relationship} relationship The relationship. * @property {function} resolve The function to set the resolved value. */ /** * Query the specified resource using the given JSONata expression. * @private * @param {Object} compiledExpression The compiled JSONata expression. * @param {Resource} resource The resource to query. * @param {FoundRelationship[]} accessedRelationships The working array of accessed relationships. * @param {Map} cachedResources The cache of resources. * @return {Promise} A promise that will be resolved with the results of the * query, or rejected with an error. */ queryInternal(compiledExpression, resource, accessedRelationships, cachedResources) { const method = 'queryInternal'; LOG.entry(method, compiledExpression, resource, accessedRelationships, cachedResources); // Evaluate the expression. LOG.debug(method, 'Evaluating JSONata expression'); let result = compiledExpression.evaluate(resource); LOG.debug(method, 'Evaluated JSONata expression', result); // Did we hit any relationships? if (accessedRelationships.length === 0) { // The result is safe to use. LOG.debug(method, 'No relationships were accessed'); LOG.exit(method, result); return Promise.resolve(result); } // The result will be a promise chain of resolves and a retry. result = Promise.resolve(); // Resolve all accessed relationships. while (accessedRelationships.length !== 0) { let accessedRelationship = accessedRelationships.shift(); result = result.then(() =&gt; { LOG.debug(method, 'Resolving accessed relationship', accessedRelationship.relationship.toString()); return this.resolver.resolveRelationship(accessedRelationship.relationship, { cachedResources: new Map(), skipRecursion: true }) .then((resolvedResource) =&gt; { LOG.debug(method, 'Resolved accessed relationship', accessedRelationship.relationship.toString()); this.prepareResource(resolvedResource, accessedRelationships); accessedRelationship.resolve(resolvedResource); }); }); } // Try again. return result.then(() =&gt; { LOG.debug(method, 'Relationships were accessed and resolved, trying again'); LOG.exit(method); return this.queryInternal(compiledExpression, resource, accessedRelationships, cachedResources); }); } /** * Find all of the relationships in the specified resource. * @private * @param {Resource} resource The resource to resolve. * @return {FoundRelationship[]} The relationships in the specified resource. */ findRelationships(resource) { const method = 'findRelationships'; LOG.entry(method, resource.toString()); let classDeclaration = resource.getClassDeclaration(); let result = []; classDeclaration.getProperties().forEach((property) =&gt; { LOG.debug(method, 'Looking at property', property.getName()); let value = resource[property.getName()]; if (value instanceof Resource) { LOG.debug(method, 'Found resource property, recursing'); result.concat(this.findRelationships(value)); } else if (value instanceof Relationship) { LOG.debug(method, 'Found relationship property'); result.push({ relationship: value, resolve: (newValue) =&gt; { resource[property.getName()] = newValue; } }); } else if (Array.isArray(value)) { LOG.debug(method, 'Found array property, iterating'); value.forEach((item, index) =&gt; { if (item instanceof Resource) { LOG.debug(method, 'Found array resource property, recursing'); result.concat(this.findRelationships(item)); } else if (item instanceof Relationship) { LOG.debug(method, 'Found array relationship property'); result.push({ relationship: item, resolve: (newValue) =&gt; { resource[property.getName()][index] = newValue; } }); } else { LOG.debug(method, 'Found array primitive value, ignoring'); } }); } else { LOG.debug(method, 'Found primitive value, ignoring'); } }); LOG.exit(method, result); return result; } /** * Modify the specified relationship so that for every property on the target * resource, a &quot;special&quot; property is added to the relationship with the same * name, which when accessed calls the specified callback. * @private * @param {Relationship} relationship The relationship to modify. * @param {function} callback The function to call when the &quot;special&quot; properties * are accessed. */ modifyRelationship(relationship, callback) { const method = 'modifyRelationship'; LOG.entry(method, relationship.toString()); LOG.debug(method, 'Adding hidden $resolved property'); Object.defineProperty(relationship, '$resolved', { enumerable: false, configurable: false, value: false, writable: true }); let classDeclaration = relationship.getClassDeclaration(); classDeclaration.getProperties().forEach((property) =&gt; { LOG.debug(method, 'Adding special property', property.getName()); Object.defineProperty(relationship, property.getName(), { enumerable: true, configurable: false, get: () =&gt; { if (!relationship.$resolved) { callback(); relationship.$resolved = true; } return undefined; } }); }); LOG.exit(method); } /** * Prepare the specified resource so that every relationship in the resource * is modified so that if the relationship is accessed, it adds itself to the * list of accessed relationships. * @private * @param {Resource} resource The resource to prepare. * @param {FoundRelationship[]} accessedRelationships The working array of accessed relationships. */ prepareResource(resource, accessedRelationships) { const method = 'prepareResource'; LOG.entry(method, resource.toString(), accessedRelationships); // Don't prepare an already prepared resource. if (resource.hasOwnProperty('$prepared')) { LOG.exit(method); return; } Object.defineProperty(resource, '$prepared', { enumerable: false, configurable: false, value: true, writable: true }); // Find all the relationships in this resource. const foundRelationships = this.findRelationships(resource); // Add properties to each relationship. foundRelationships.forEach((foundRelationship) =&gt; { LOG.debug(method, 'Found relationship object', foundRelationship.relationship.toString()); this.modifyRelationship(foundRelationship.relationship, () =&gt; { accessedRelationships.push(foundRelationship); }); }); LOG.exit(method); } } module.exports = QueryExecutor; Ã— Search results Close "},"composer-runtime_lib_registrymanager.js.html":{"id":"composer-runtime_lib_registrymanager.js.html","title":"Source: composer-runtime/lib/registrymanager.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/registrymanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AssetDeclaration = require('composer-common').AssetDeclaration; const EventEmitter = require('events'); const ParticipantDeclaration = require('composer-common').ParticipantDeclaration; const Registry = require('./registry'); /** * A class for managing and persisting registries. * @protected */ class RegistryManager extends EventEmitter { /** * Constructor. * @param {DataService} dataService The data service to use. * @param {Introspector} introspector The introspector to use. * @param {Serializer} serializer The serializer to use. * @param {AccessController} accessController The access controller to use. */ constructor(dataService, introspector, serializer, accessController) { super(); this.dataService = dataService; this.introspector = introspector; this.serializer = serializer; this.accessController = accessController; } /** * Create a new registry instance and subscribe to its events. * @private * @param {DataCollection} dataCollection The data collection. * @param {Serializer} serializer The serializer. * @param {AccessController} accessController The access controller. * @param {string} type The type. * @param {string} id The ID. * @param {string} name The name. * @return {Registry} The new registry instance. */ createRegistry(dataCollection, serializer, accessController, type, id, name) { let registry = new Registry(dataCollection, serializer, accessController, type, id, name); ['resourceadded', 'resourceupdated', 'resourceremoved'].forEach((event) =&gt; { registry.on(event, (data) =&gt; { this.emit(event, data); }); }); return registry; } /** * Ensure that the default registries exist. * @returns {Promise} A promise that is resolved once all default registries * have been created, or rejected with an error. */ createDefaults() { let assetDeclarations = this.introspector.getClassDeclarations().filter((classDeclaration) =&gt; { if (classDeclaration.isAbstract()) { return false; } return (classDeclaration instanceof AssetDeclaration); }); let participantDeclarations = this.introspector.getClassDeclarations().filter((classDeclaration) =&gt; { if (classDeclaration.isAbstract()) { return false; } return (classDeclaration instanceof ParticipantDeclaration); }); return Promise.resolve() .then(() =&gt; { return assetDeclarations.reduce((result, assetDeclaration) =&gt; { let fqn = assetDeclaration.getFullyQualifiedName(); return this.get('Asset', fqn) .catch(() =&gt; { return this.add('Asset', fqn, `Asset registry for ${fqn}`); }); }, Promise.resolve()); }) .then(() =&gt; { return participantDeclarations.reduce((result, participantDeclaration) =&gt; { let fqn = participantDeclaration.getFullyQualifiedName(); return this.get('Participant', fqn) .catch(() =&gt; { return this.add('Participant', fqn, `Participant registry for ${fqn}`); }); }, Promise.resolve()); }); } /** * Get all of the registries. * @param {string} type The type of the registry. * @return {Promise} A promise that is resolved with an array of {@link Registry} * objects when complete, or rejected with an error. */ getAll(type) { return this.dataService.getCollection('$sysregistries') .then((sysregistries) =&gt; { return sysregistries.getAll(); }) .then((registries) =&gt; { registries = registries.filter((registry) =&gt; { return registry.type === type; }); return registries.reduce((prev, registry) =&gt; { let collectionID = registry.type + ':' + registry.id; return prev.then((result) =&gt; { return this.dataService.getCollection(collectionID) .then((dataCollection) =&gt; { result.push(this.createRegistry(dataCollection, this.serializer, this.accessController, registry.type, registry.id, registry.name)); return result; }); }); }, Promise.resolve([])); }); } /** * Get a registry with the specified type, and ID. * @param {string} type The type of the registry. * @param {string} id The ID of the registry. * @return {Promise} A promise that is resolved with a {@link Registry} * objects when complete, or rejected with an error. */ get(type, id) { let collectionID = type + ':' + id; return this.dataService.getCollection('$sysregistries') .then((sysregistries) =&gt; { return sysregistries.get(collectionID); }) .then((registry) =&gt; { return this.dataService.getCollection(collectionID) .then((dataCollection) =&gt; { return this.createRegistry(dataCollection, this.serializer, this.accessController, registry.type, registry.id, registry.name); }); }); } /** * Determine whether a registry with the specified type and ID exists. * @param {string} type The type of the registry. * @param {string} id The ID of the registry. * @return {Promise} A promise that is resolved with a boolean indicating * whether the registry exists. */ exists(type, id) { let collectionID = type + ':' + id; return this.dataService.getCollection('$sysregistries') .then((sysregistries) =&gt; { return sysregistries.exists(collectionID); }) .then((exists) =&gt; { return exists; }); } /** * An event signalling that a registry has been added. * @event RegistryManager#registryadded * @protected * @type {object} * @param {Registry} registry The registry. * @param {string} registryType The type of the registry. * @param {string} registryID The ID of the registry. * @param {string} registryName The name of the registry. */ /** * Add a new registry with the specified type, ID, and name. * @param {string} type The type of the registry. * @param {string} id The ID of the registry. * @param {string} name The name of the registry. * @return {Promise} A promise that is resolved when complete, or rejected * with an error. */ add(type, id, name) { let collectionID = type + ':' + id; return this.dataService.getCollection('$sysregistries') .then((sysregistries) =&gt; { return sysregistries.add(collectionID, { type: type, id: id, name: name }); }) .then(() =&gt; { return this.dataService.createCollection(collectionID); }) .then((dataCollection) =&gt; { let result = this.createRegistry(dataCollection, this.serializer, this.accessController, type, id, name); this.emit('registryadded', { registry: result, registryType: type, registryID: id, registryName: name }); return result; }); } } module.exports = RegistryManager; Ã— Search results Close "},"composer-common_lib_wallet.js.html":{"id":"composer-common_lib_wallet.js.html","title":"Source: composer-common/lib/wallet.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-common/lib/wallet.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Currently we have a wallet singleton, but this is temporary until * we decide how wallets fit into the administrative and client APIs. */ let theWallet = null; /** * Base class representing a wallet (a container of credentials). * @protected * @abstract */ class Wallet { /** * Get the wallet singleton. * @return {Wallet} The wallet singleton, or null if one * has not been specified. */ static getWallet() { return theWallet; } /** * Set the wallet singleton. * @param {Wallet} wallet The new wallet singleton. */ static setWallet(wallet) { theWallet = wallet; } /** * List all of the credentials in the wallet. * @abstract * @return {Promise} A promise that is resolved with * an array of credential names, or rejected with an * error. */ list() { throw new Error('abstract function called'); } /** * Check to see if the named credentials are in * the wallet. * @abstract * @param {string} name The name of the credentials. * @return {Promise} A promise that is resolved with * a boolean; true if the named credentials are in the * wallet, false otherwise. */ contains(name) { throw new Error('abstract function called'); } /** * Get the named credentials from the wallet. * @abstract * @param {string} name The name of the credentials. * @return {Promise} A promise that is resolved with * the named credentials, or rejected with an error. */ get(name) { throw new Error('abstract function called'); } /** * Add a new credential to the wallet. * @abstract * @param {string} name The name of the credentials. * @param {string} value The credentials. * @return {Promise} A promise that is resolved when * complete, or rejected with an error. */ add(name, value) { throw new Error('abstract function called'); } /** * Update existing credentials in the wallet. * @abstract * @param {string} name The name of the credentials. * @param {string} value The credentials. * @return {Promise} A promise that is resolved when * complete, or rejected with an error. */ update(name, value) { throw new Error('abstract function called'); } /** * Remove existing credentials from the wallet. * @abstract * @param {string} name The name of the credentials. * @return {Promise} A promise that is resolved when * complete, or rejected with an error. */ remove(name) { throw new Error('abstract function called'); } } module.exports = Wallet; Ã— Search results Close "},"composer-runtime_lib_transactionexecutor.js.html":{"id":"composer-runtime_lib_transactionexecutor.js.html","title":"Source: composer-runtime/lib/transactionexecutor.js","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Source: composer-runtime/lib/transactionexecutor.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * A class for executing transaction processor functions. * @protected */ class TransactionExecutor { /** * Get the type of this transaction executor. * @abstract * @return {string} The type of this transaction executor. */ getType() { throw new Error('abstract function called'); } /** * Execute the specified transaction. * @abstract * @param {Api} api The API to use. * @param {ScriptManager} scriptManager The script manager to use. * @param {Resource} transaction The transaction to execute. * @param {Resource} resolvedTransaction The resolved transaction to execute. * @return {Promise} A promise that is resolved when the transaction has been * executed, or rejected with an error. */ execute(api, scriptManager, transaction, resolvedTransaction) { return Promise.reject(new Error('abstract function called')); } /** * Stop serialization of this object. * @return {Object} An empty object. */ toJSON() { return {}; } } module.exports = TransactionExecutor; Ã— Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Global Members theWallet Currently we have a wallet singleton, but this is temporary untilwe decide how wallets fit into the administrative and client APIs. Source: composer-common/lib/wallet.js, line 21 Ã— Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Modules Classes AdminConnection AssetRegistry BusinessNetworkConnection ParticipantRegistry Registry TransactionRegistry BaseException BusinessNetworkDefinition Concept Factory Identifiable IllegalModelException Introspector ParseException Relationship Resource SecurityContext SecurityException Serializer Typed ValidatedConcept ValidatedResource ValidationException AccessException AssetRegistry Factory ParticipantRegistry Ã— Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Classes Classes AdminConnection AssetRegistry BusinessNetworkConnection ParticipantRegistry Registry TransactionRegistry BaseException BusinessNetworkDefinition Concept Factory Identifiable IllegalModelException Introspector ParseException Relationship Resource SecurityContext SecurityException Serializer Typed ValidatedConcept ValidatedResource ValidationException AccessException AssetRegistry Factory ParticipantRegistry Ã— Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Fabric Composer APIFabric Composer is an application development framework for building blockchain applications based on Hyperledger. This is the API JSDoc for the Fabric Composer Client, Admin and Runtime Javascript APIs. OverviewThe major components of Fabric Composer are: The Fabric Composer language for describing the structure of resources (assets, participantsand transactions) that participate in a blockchain backed business network. Javascript APIs to query, create, update and delete resources and submit transactionsfrom client applications. Fabric Composer resources are stored on the blockchain. Javascript transaction processor functions that runs on Hyperledger when transactions aresubmitted for processing. These functions may update the state of resourcesstored on the blockchain via server-side Fabric Composer APIs. Resources Documentation npm modules github repositories ContributingTo read more about the community and guidelines for submitting pull requests,please read the Contributing document. Ã— Search results Close "},"module-composer-admin.html":{"id":"module-composer-admin.html","title":"Module: composer-admin","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Module: composer-admin The composer-admin module. Defines the administration API for Fabric Composer.Fabric Composer is a framework for creating blockchain backed digital networks andexchanging assets between participants via processing transactions. Source: composer-admin/index.js, line 25 Classes AdminConnection Ã— Search results Close "},"module-composer-admin.AdminConnection.html":{"id":"module-composer-admin.AdminConnection.html","title":"Class: AdminConnection","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: AdminConnection composer-admin. AdminConnection This class creates an administration connection to a Fabric Composer runtime. Theconnection can then be used to: Deploy BusinessNetworkDefinitionsUndeploy BusinessNetworkDefinitionsUpdate BusinessNetworkDefinitionsSend a ping message to the runtime to ensure it is running andcorrectly configured.Store a connection profile document in the connection profile store new AdminConnection( [options]) Create an instance of the AdminConnection class. Parameters: Name Type Argument Description options Object &lt;optional&gt; an optional set of options to configure the instance. Properties Name Type Argument Description fs Object &lt;optional&gt; specify an fs implementation to use. Source: composer-admin/lib/adminconnection.js, line 38 Methods connect(connectionProfile, enrollmentID, enrollmentSecret, businessNetworkIdentifier) Connects and logs in to the Hyperledger Fabric using a named connectionprofile. The connection profile must exist in the profile store. Parameters: Name Type Description connectionProfile string The name of the connection profile enrollmentID string the enrollment ID of the user enrollmentSecret string the enrollment secret of the user businessNetworkIdentifier string the id of the network (for update) or null Source: composer-admin/lib/adminconnection.js, line 72 Returns: A promise that indicates the connection is complete Type Promise Example // Connect to Hyperledger Fabric var adminConnection = new AdminConnection(); adminConnection.connect('testprofile', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(){ // Connected. }) .catch(function(error){ // Add optional error handling here. }); createProfile(connectionProfile, data) Stores a connection profile into the profile store being used by thisAdminConnection. Parameters: Name Type Description connectionProfile string The name of the connection profile data Object The connection profile data Source: composer-admin/lib/adminconnection.js, line 108 Returns: A promise that indicates that the connection profile is deployed Type Promise Example // Create a connection profile var adminConnection = new AdminConnection(); var adminOptions = { type: 'hlf', keyValStore: '/tmp/keyValStore', membershipServicesURL: 'grpc://membersrvc:7054', peerURL: 'grpc://vp0:7051', eventHubURL: 'grpc://vp0:7053' }; return adminConnection.createProfile('testprofile', adminOptions) .then(function(){ // Created profile }) .catch(function(error){ // Add optional error handling here. }); deleteProfile(connectionProfile) Deletes the specified connection profile from the profile store being used by thisAdminConnection. Parameters: Name Type Description connectionProfile string The name of the connection profile Source: composer-admin/lib/adminconnection.js, line 128 Returns: A promise that indicates that the connection profile is deployed Type Promise Example // Delete a connection profile var adminConnection = new AdminConnection(); return adminConnection.deleteProfile('testprofile') .then(function(){ // Deleted profile }) .catch(function(error){ // Add optional error handling here. }); deploy(businessNetworkDefinition) Deploys a new BusinessNetworkDefinition to the fabric. The connection mustbe connected for this method to succeed. Parameters: Name Type Description businessNetworkDefinition BusinessNetworkDefinition The business network to deploy Source: composer-admin/lib/adminconnection.js, line 213 Returns: A promise that will be fufilled when the business network has beendeployed. Type Promise Example // Deploy a Business Network Definition var adminConnection = new AdminConnection(); var businessNetworkDefinition = BusinessNetworkDefinition.fromArchive(myArchive); return adminConnection.deploy(businessNetworkDefinition) .then(function(){ // Business network definition deployed }) .catch(function(error){ // Add optional error handling here. }); disconnect() Disconnects this connection. Source: composer-admin/lib/adminconnection.js, line 184 Returns: A promise that will be resolved when the connection isterminated. Type Promise Example // Disconnect from a Business Network var adminConnection = new AdminConnection(); return adminConnection.disconnect() .then(function(){ // Disconnected. }) .catch(function(error){ // Add optional error handling here. }); getAllProfiles() Retrieve all connection profiles from the profile store being used by thisAdminConnection. Source: composer-admin/lib/adminconnection.js, line 165 Returns: A promise that is resolved with the connection profile data. Type Promise Example // Retrieve all the connection profiles. const adminConnection = new AdminConnection(); return adminConnection.getAllProfiles() .then((profiles) =&gt; { // Retrieved profiles for (let profile in profiles) { console.log(profile, profiles[profile]); } }); getProfile(connectionProfile) Retrieve the specified connection profile from the profile store beingused by this AdminConnection. Parameters: Name Type Description connectionProfile string The name of the connection profile Source: composer-admin/lib/adminconnection.js, line 146 Returns: A promise that is resolved with the connection profile data. Type Promise Example // Retrieve the connection profile. const adminConnection = new AdminConnection(); return adminConnection.getProfile('testprofile') .then((profile) =&gt; { // Retrieved profile console.log(profile); }); list() List all of the deployed business networks. The connection mustbe connected for this method to succeed. Source: composer-admin/lib/adminconnection.js, line 303 Returns: A promise that will be resolved with an array ofbusiness network identifiers, or rejected with an error. Type Promise Example // List all of the deployed business networks. var adminConnection = new AdminConnection(); return adminConnection.list() .then((businessNetworks) =&gt; { // Connection has been tested return businessNetworks.forEach((businessNetwork) =&gt; { console.log('Deployed business network', businessNetwork); }); }) .catch(function(error){ // Add optional error handling here. }); ping() Test the connection to the runtime and verify that the version of theruntime is compatible with this level of the node.js module. Source: composer-admin/lib/adminconnection.js, line 279 Returns: A promise that will be fufilled when the connection hasbeen tested. The promise will be rejected if the version is incompatible. Type Promise Example // Test the connection to the runtime var adminConnection = new AdminConnection(); return adminConnection.ping() .then(function(){ // Connection has been tested }) .catch(function(error){ // Add optional error handling here. }); undeploy(businessNetworkIdentifier) Undeploys a BusinessNetworkDefinition from the fabric. The business network will nolonger be able to process transactions. Parameters: Name Type Description businessNetworkIdentifier string The identifier of the network to undeploy Source: composer-admin/lib/adminconnection.js, line 235 Returns: A promise that will be fufilled when the business network has beenundeployed. Type Promise Example // Undeploy a Business Network Definition var adminConnection = new AdminConnection(); return adminConnection.undeploy('identifier') .then(function(){ // Undeployed Business Network Definition }) .catch(function(error){ // Add optional error handling here. }) update(businessNetworkDefinition) Updates an existing BusinessNetworkDefinition on the fabric. The BusinessNetworkDefinitionmust have been previously deployed. Parameters: Name Type Description businessNetworkDefinition BusinessNetworkDefinition The new BusinessNetworkDefinition Source: composer-admin/lib/adminconnection.js, line 258 Returns: A promise that will be fufilled when the business network has beenupdated. Type Promise Example // Updates a Business Network Definition var adminConnection = new AdminConnection(); var businessNetworkDefinition = BusinessNetworkDefinition.fromArchive(myArchive); return adminConnection.update(businessNetworkDefinition) .then(function(){ // Business network definition updated }) .catch(function(error){ // Add optional error handling here. }); Ã— Search results Close "},"module-composer-client.html":{"id":"module-composer-client.html","title":"Module: composer-client","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Module: composer-client The composer-client module. Defines the client API for Composer.Composer is a framework for creating blockchain backed digital networks andexchanging assets between participants via processing transactions.Applications interact with the framework by instantiating the BusinessNetworkConnectionclass. Source: composer-client/index.js, line 26 Classes AssetRegistry BusinessNetworkConnection ParticipantRegistry Registry TransactionRegistry Ã— Search results Close "},"module-composer-client.AssetRegistry.html":{"id":"module-composer-client.AssetRegistry.html","title":"Class: AssetRegistry","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: AssetRegistry composer-client. AssetRegistry The AssetRegistry is used to manage a set of assets stored on the blockchain. new AssetRegistry(id, name, securityContext, modelManager, factory, serializer) Create an asset registry. Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkConnection Parameters: Name Type Description id string The unique identifier of the asset registry. name string The display name for the asset registry. securityContext SecurityContext The security context to use for this asset registry. modelManager ModelManager The ModelManager to use for this asset registry. factory Factory The factory to use for this asset registry. serializer Serializer The Serializer to use for this asset registry. Source: composer-client/lib/assetregistry.js, line 30 See: See Registry Extends Registry Methods add(resource [, options]) Add the specified resource to this registry. Parameters: Name Type Argument Description resource Resource The resource to add to this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. Inherited From: Registry#add Source: composer-runtime/lib/registry.js, line 148 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise addAll(resources [, options]) Add all of the specified resources to this registry. Parameters: Name Type Argument Description resources Array.&lt;Resource&gt; The resources to add to this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. Inherited From: Registry#addAll Source: composer-runtime/lib/registry.js, line 130 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise exists(id) Determine whether the specified resource exists in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#exists Source: composer-runtime/lib/registry.js, line 94 Returns: A promise that will be resolved with a booleanindicating whether the asset exists. Type Promise get(id) Get the specified resource in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#get Source: composer-runtime/lib/registry.js, line 72 Returns: A promise that will be resolved with a Resourceobject when complete, or rejected with an error. Type Promise getAll() Get all the resources in this registry. Inherited From: Registry#getAll Source: composer-runtime/lib/registry.js, line 50 Returns: A promise that will be resolved with an array of {@linkResource} objects when complete, or rejected with an error. Type Promise remove(resource) Remove the specified resource from this registry. Parameters: Name Type Description resource string | Resource The resource to remove from this registry. Inherited From: Registry#remove Source: composer-runtime/lib/registry.js, line 254 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise removeAll(resources) Remove all of the specified resources from this registry. Parameters: Name Type Description resources Array.&lt;string&gt; | Array.&lt;Resource&gt; The resources to remove from this registry. Inherited From: Registry#removeAll Source: composer-runtime/lib/registry.js, line 240 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise toJSON() Return an object suitable for serialization. Inherited From: Registry#toJSON Source: composer-runtime/lib/registry.js, line 287 Returns: An object suitable for serialization. Type Object update(resource [, options]) Update the specified resource in this registry. Parameters: Name Type Argument Description resource Resource The resource to update in this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. Inherited From: Registry#update Source: composer-runtime/lib/registry.js, line 201 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise updateAll(resources [, options]) Update all of the specified resources in this registry. Parameters: Name Type Argument Description resources Array.&lt;Resource&gt; The resources to update in this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. Inherited From: Registry#updateAll Source: composer-runtime/lib/registry.js, line 183 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise Ã— Search results Close "},"module-composer-client.BusinessNetworkConnection.html":{"id":"module-composer-client.BusinessNetworkConnection.html","title":"Class: BusinessNetworkConnection","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: BusinessNetworkConnection composer-client. BusinessNetworkConnection Use this class to connect to and then interact with a deployed BusinessNetworkDefinition.Use the AdminConnection class in the composer-admin module to deploy BusinessNetworksDefinitions. new BusinessNetworkConnection( [options]) Create an instance of the BusinessNetworkConnection class.must be called to connect to a deployed BusinessNetworkDefinition. Parameters: Name Type Argument Description options Object &lt;optional&gt; an optional set of options to configure the instance. Properties Name Type Argument Description fs Object &lt;optional&gt; specify an fs implementation to use. developmentMode boolean &lt;optional&gt; specify whether or not the instanceis in development mode. Use only for testing purposes! Source: composer-client/lib/businessnetworkconnection.js, line 41 See: See EventEmitter Extends EventEmitter Methods addAssetRegistry(id, name) Add a new asset registry. Parameters: Name Type Description id string The unique identifier of the asset registry name string The name of the asset registry Source: composer-client/lib/businessnetworkconnection.js, line 163 Returns: A promise that will be resolved with the new assetregistry after it has been added. Type Promise Example // Add a new asset registry var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.addAssetRegistry('registryId','registryName'); }); addParticipantRegistry(id, name) Add a new participant registry. Parameters: Name Type Description id string The unique identifier of the participant registry name string The name of the participant registry Source: composer-client/lib/businessnetworkconnection.js, line 224 Returns: A promise that will be resolved with the new participantregistry after it has been added. Type Promise Example // Add a new participant registry var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.addParticipantRegistry('registryId','registryName'); }); connect(connectionProfile, businessNetwork, enrollmentID, enrollmentSecret) Connects to a business network using a connection profile, and authenticates to the Hyperledger Fabric. Parameters: Name Type Description connectionProfile string The name of the connection profile businessNetwork string The identifier of the business network enrollmentID string the enrollment ID of the user enrollmentSecret string the enrollment secret of the user Source: composer-client/lib/businessnetworkconnection.js, line 271 Returns: A promise to a BusinessNetworkDefinition that indicates the connection is complete Type Promise Example // Connect and log in to HLF var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ // Connected }); disconnect() Disconnects from the Hyperledger Fabric. Source: composer-client/lib/businessnetworkconnection.js, line 310 Returns: A promise that will be resolved when the connection isterminated. Type Promise Example // Disconnects from HLF var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.disconnect(); }) .then(function(){ // Disconnected. }); existsAssetRegistry(id) Determine whether a asset registry exists. Parameters: Name Type Description id string The unique identifier of the asset registry Source: composer-client/lib/businessnetworkconnection.js, line 144 Returns: A promise that will be resolved with a boolean indicating whether the assetregistry exists. Type Promise Example // Determine whether an asset registry exists var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.existsAssetRegistry('businessNetworkIdentifier.registryId'); }) .then(function(exists){ // if (exists === true) { // logic here... //} }); getAllAssetRegistries(securityContext) Get a list of all existing asset registries. Parameters: Name Type Description securityContext SecurityContext The user's security context Source: composer-client/lib/businessnetworkconnection.js, line 100 Returns: A promise that will be resolved with a list of existingasset registries Type Promise Example // Get all asset registries var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.getAllAssetRegistries(); }) .then(function(assetRegistries){ // Retrieved Asset Registries }); getAllParticipantRegistries(securityContext) Get a list of all existing participant registries. Parameters: Name Type Description securityContext SecurityContext The user's security context Source: composer-client/lib/businessnetworkconnection.js, line 184 Returns: A promise that will be resolved with a list of existingparticipant registries Type Promise Example // Get all participant registries var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.getAllParticipantRegistries(); }) .then(function(participantRegistries){ // Retrieved Participant Registries }); getAssetRegistry(id) Get an existing asset registry. Parameters: Name Type Description id string The unique identifier of the asset registry Source: composer-client/lib/businessnetworkconnection.js, line 121 Returns: A promise that will be resolved with the existing assetregistry, or rejected if the asset registry does not exist. Type Promise Example // Get a asset registry var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.getAssetRegistry('businessNetworkIdentifier.registryId'); }) .then(function(assetRegistry){ // Retrieved Asset Registry }); getBusinessNetwork() Returns the currently connected BusinessNetworkDefinition Source: composer-client/lib/businessnetworkconnection.js, line 80 Returns: the business network Type BusinessNetworkDefinition Example // Get the Business Network Definition var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.getBusinessNetwork(); }) .then(function(BusinessNetworkDefinition){ // Retrieved Business Network Definition }); getParticipantRegistry(id) Get an existing participant registry. Parameters: Name Type Description id string The unique identifier of the participant registry Source: composer-client/lib/businessnetworkconnection.js, line 205 Returns: A promise that will be resolved with the existing participantregistry, or rejected if the participant registry does not exist. Type Promise Example // Get a participant registry var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.getParticipantRegistry('businessNetworkIdentifier.registryId'); }) .then(function(participantRegistry){ // Retrieved Participant Registry }); getTransactionRegistry() Get the transaction registry. Source: composer-client/lib/businessnetworkconnection.js, line 243 Returns: A promise that will be resolved to the TransactionRegistry Type Promise Example // Get the transaction registry var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.getTransactionRegistry(); }) .then(function(transactionRegistry){ // Retrieved Transaction Registry }); issueIdentity(participant, userID [, options]) Issue an identity with the specified user ID and map it to the specifiedparticipant. Parameters: Name Type Argument Description participant Resource | string The participant, or the fully qualifiedidentifier of the participant. The participant must already exist. userID string The user ID for the identity. options object &lt;optional&gt; Options for the new identity. Properties Name Type Argument Description issuer boolean &lt;optional&gt; Whether or not the new identity should havepermissions to create additional new identities. False by default. Source: composer-client/lib/businessnetworkconnection.js, line 402 Returns: A promise that will be fulfilled when the identity hasbeen added to the specified participant. The promise will be rejected ifthe participant does not exist, or if the identity is already mapped toanother participant. Type Promise ping() Test the connection to the runtime and verify that the version of theruntime is compatible with this level of the client node.js module. Source: composer-client/lib/businessnetworkconnection.js, line 383 Returns: A promise that will be fufilled when the connection hasbeen tested. The promise will be rejected if the version is incompatible. Type Promise Example // Test the connection to the runtime var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.ping(); }) .then(function(){ // Connection tested. }); revokeIdentity(identity) Revoke the specified identity by removing any existing mapping to a participant. Parameters: Name Type Description identity string The identity, for example the enrollment ID. Source: composer-client/lib/businessnetworkconnection.js, line 435 Returns: A promise that will be fulfilled when the identity hasbeen removed from the specified participant. The promise will be rejected ifthe participant does not exist, or if the identity is not mapped to theparticipant. Type Promise submitTransaction(transaction) Submit a transaction for processing by the currently connected business network. Parameters: Name Type Description transaction Resource The transaction to submit. Use {@linkFactory#newTransaction newTransaction} to create this object. Source: composer-client/lib/businessnetworkconnection.js, line 341 Returns: A promise that will be fulfilled when the transaction hasbeen processed. Type Promise Example // Submits a transaction var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ var factory = businessNetworkDefinition.getBusinessNetwork().getFactory(); var transaction = factory.newTransaction('network.transactions', 'TransactionType'); return businessNetworkDefinition.submitTransaction(transaction); }) .then(function(){ // Submitted a transaction. }); Ã— Search results Close "},"module-composer-client.ParticipantRegistry.html":{"id":"module-composer-client.ParticipantRegistry.html","title":"Class: ParticipantRegistry","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: ParticipantRegistry composer-client. ParticipantRegistry The ParticipantRegistry is used to manage a set of participants stored on the blockchain. new ParticipantRegistry(id, name, securityContext, modelManager, factory, serializer) Create an participant registry. Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkConnection Parameters: Name Type Description id string The unique identifier of the participant registry. name string The display name for the participant registry. securityContext SecurityContext The security context to use for this participant registry. modelManager ModelManager The ModelManager to use for this participant registry. factory Factory The factory to use for this participant registry. serializer Serializer The Serializer to use for this participant registry. Source: composer-client/lib/participantregistry.js, line 30 See: See Registry Extends Registry Methods add(resource [, options]) Add the specified resource to this registry. Parameters: Name Type Argument Description resource Resource The resource to add to this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. Inherited From: Registry#add Source: composer-runtime/lib/registry.js, line 148 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise addAll(resources [, options]) Add all of the specified resources to this registry. Parameters: Name Type Argument Description resources Array.&lt;Resource&gt; The resources to add to this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. Inherited From: Registry#addAll Source: composer-runtime/lib/registry.js, line 130 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise exists(id) Determine whether the specified resource exists in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#exists Source: composer-runtime/lib/registry.js, line 94 Returns: A promise that will be resolved with a booleanindicating whether the asset exists. Type Promise get(id) Get the specified resource in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#get Source: composer-runtime/lib/registry.js, line 72 Returns: A promise that will be resolved with a Resourceobject when complete, or rejected with an error. Type Promise getAll() Get all the resources in this registry. Inherited From: Registry#getAll Source: composer-runtime/lib/registry.js, line 50 Returns: A promise that will be resolved with an array of {@linkResource} objects when complete, or rejected with an error. Type Promise remove(resource) Remove the specified resource from this registry. Parameters: Name Type Description resource string | Resource The resource to remove from this registry. Inherited From: Registry#remove Source: composer-runtime/lib/registry.js, line 254 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise removeAll(resources) Remove all of the specified resources from this registry. Parameters: Name Type Description resources Array.&lt;string&gt; | Array.&lt;Resource&gt; The resources to remove from this registry. Inherited From: Registry#removeAll Source: composer-runtime/lib/registry.js, line 240 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise toJSON() Return an object suitable for serialization. Inherited From: Registry#toJSON Source: composer-runtime/lib/registry.js, line 287 Returns: An object suitable for serialization. Type Object update(resource [, options]) Update the specified resource in this registry. Parameters: Name Type Argument Description resource Resource The resource to update in this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. Inherited From: Registry#update Source: composer-runtime/lib/registry.js, line 201 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise updateAll(resources [, options]) Update all of the specified resources in this registry. Parameters: Name Type Argument Description resources Array.&lt;Resource&gt; The resources to update in this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. Inherited From: Registry#updateAll Source: composer-runtime/lib/registry.js, line 183 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise Ã— Search results Close "},"module-composer-client.Registry.html":{"id":"module-composer-client.Registry.html","title":"Class: Registry","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: Registry composer-client. Registry Class representing an Abstract Registry. &lt;abstract&gt; new Registry(registryType, id, name, securityContext, modelManager, factory, serializer) Create a registry. Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkConnection Parameters: Name Type Description registryType string The type of this registry. id string The unique identifier of the registry. name string The display name for the registry. securityContext SecurityContext The users security context. modelManager ModelManager The ModelManager to use for this registry. factory Factory The factory to use for this registry. serializer Serializer The Serializer to use for this registry. Source: composer-client/lib/registry.js, line 27 Methods add(resource) Adds a new resource to the registry. Parameters: Name Type Description resource Resource The resource to be added to the registry. Source: composer-client/lib/registry.js, line 189 Returns: A promise that will be resolved when the resource isadded to the registry. Type Promise addAll(resources) Adds a list of new resources to the registry. Parameters: Name Type Description resources Array.&lt;Resource&gt; The resources to be added to the registry. Source: composer-client/lib/registry.js, line 171 Returns: A promise that will be resolved when the resource isadded to the registry. Type Promise exists(id) Determines whether a specific resource exists in the registry. Parameters: Name Type Description id string The unique identifier of the resource. Source: composer-client/lib/registry.js, line 321 Returns: A promise that will be resolved with true/false depending on whether the resource exists. Type Promise find(expression) Find resources in the registry that match the specified JSONata expression.The JSONata expression is applied to each resource in the registry, andresources are returned if the JSONata expression returns a truthy value for thatresource. Parameters: Name Type Description expression string The JSONata expression. Source: composer-client/lib/registry.js, line 343 Returns: A promise that will be resolved with an array of {@linkResource} instances representing the assets that match the query. Type Promise get(id) Get a specific resource in the registry. Parameters: Name Type Description id string The unique identifier of the resource. Source: composer-client/lib/registry.js, line 301 Returns: A promise that will be resolved with a JSON objectrepresenting the resource. Type Promise getAll() Get all of the resources in the registry. Source: composer-client/lib/registry.js, line 281 Returns: A promise that will be resolved with an array of JSONobjects representing the resources. Type Promise query(expression) Execute a query against all resources in the registry. The JSONataexpression is applied to each resource in the registry, and the resultof the JSONata expression is returned if the result is truthy. The resultis a JavaScript object, and should only be used for visualizationpurposes. You cannot use the add or update functions withdata returned by this function. Parameters: Name Type Description expression string The JSONata expression. Source: composer-client/lib/registry.js, line 371 Returns: A promise that will be resolved with an array of JavaScriptobjects representing the resources and all of their resolved relationships. Type Promise remove(resource) Remove an asset with a given type and id from the registry. Parameters: Name Type Description resource Resource | string The resource, or the unique identifier of the resource. Source: composer-client/lib/registry.js, line 261 Returns: A promise that will be resolved when the resource isremoved from the registry. Type Promise removeAll(resources) Removes a list of resources from the registry. Parameters: Name Type Description resources Array.&lt;Resource&gt; | Array.&lt;string&gt; The resources, or the unique identifiers of the resources. Source: composer-client/lib/registry.js, line 239 Returns: A promise that will be resolved when the resource isadded to the registry. Type Promise resolve(id) Get a specific resource in the registry, and resolve all of its relationshipsto other assets, participants, and transactions. The result is a JavaScriptobject, and should only be used for visualization purposes. You cannot usethe add or update functions with a resolved resource. Parameters: Name Type Description id string The unique identifier of the asset. Source: composer-client/lib/registry.js, line 409 Returns: A promise that will be resolved with a JavaScript objectrepresenting the resource and all of its resolved relationships. Type Promise resolveAll() Get all of the resources in the registry, and resolve all of their relationshipsto other assets, participants, and transactions. The result is a JavaScriptobject, and should only be used for visualization purposes. You cannot usethe add or update functions with a resolved resource. Source: composer-client/lib/registry.js, line 391 Returns: A promise that will be resolved with an array of JavaScriptobjects representing the resources and all of their resolved relationships. Type Promise update(resource) Updates a resource in the registry. Parameters: Name Type Description resource Resource The resource to be updated in the registry. Source: composer-client/lib/registry.js, line 223 Returns: A promise that will be resolved when the resource isupdated in the registry. Type Promise updateAll(resources) Updates a list of resources in the registry. Parameters: Name Type Description resources Array.&lt;Resource&gt; The resources to be updated in the asset registry. Source: composer-client/lib/registry.js, line 205 Returns: A promise that will be resolved when the resource isadded to the registry. Type Promise Ã— Search results Close "},"module-composer-client.TransactionRegistry.html":{"id":"module-composer-client.TransactionRegistry.html","title":"Class: TransactionRegistry","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: TransactionRegistry composer-client. TransactionRegistry The TransactionRegistry is used to store a set of transactions on the blockchain. new TransactionRegistry(id, name, securityContext, modelManager, factory, serializer) Create an transaction registry.Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkConnection Parameters: Name Type Description id string The unique identifier of the transaction registry. name string The display name for the transaction registry. securityContext SecurityContext The security context to use for this asset registry. modelManager ModelManager The ModelManager to use for this transaction registry. factory Factory The factory to use for this transaction registry. serializer Serializer The Serializer to use for this transaction registry. Source: composer-client/lib/transactionregistry.js, line 30 See: See Registry Extends Registry Methods add(resource, data) Unsupported operation; you cannot add a transaction to a transactionregistry. Call BusinessNetworkConnection.submitTransaction to submit a transaction. Parameters: Name Type Description resource Resource The resource to be added to the registry. data string The data for the resource. Overrides: Registry#add Source: composer-client/lib/transactionregistry.js, line 146 addAll(resources) Unsupported operation; you cannot add a transaction to a transactionregistry. Call BusinessNetworkConnection.submitTransaction to submit a transaction. Parameters: Name Type Description resources Array.&lt;Resource&gt; The resources to be added to the registry. Overrides: Registry#addAll Source: composer-client/lib/transactionregistry.js, line 156 exists(id) Determine whether the specified resource exists in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#exists Source: composer-runtime/lib/registry.js, line 94 Returns: A promise that will be resolved with a booleanindicating whether the asset exists. Type Promise get(id) Get the specified resource in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#get Source: composer-runtime/lib/registry.js, line 72 Returns: A promise that will be resolved with a Resourceobject when complete, or rejected with an error. Type Promise getAll() Get all the resources in this registry. Inherited From: Registry#getAll Source: composer-runtime/lib/registry.js, line 50 Returns: A promise that will be resolved with an array of {@linkResource} objects when complete, or rejected with an error. Type Promise remove(resource) Unsupported operation; you cannot remove a transaction from a transactionregistry. This method will always throw an exception when called. Parameters: Name Type Description resource Resource | string The resource, or the unique identifier of the resource. Overrides: Registry#remove Source: composer-client/lib/transactionregistry.js, line 186 removeAll(resources) Unsupported operation; you cannot remove a transaction from a transactionregistry. This method will always throw an exception when called. Parameters: Name Type Description resources Array.&lt;Resource&gt; | Array.&lt;string&gt; The resources, or the unique identifiers of the resources. Overrides: Registry#removeAll Source: composer-client/lib/transactionregistry.js, line 196 toJSON() Return an object suitable for serialization. Inherited From: Registry#toJSON Source: composer-runtime/lib/registry.js, line 287 Returns: An object suitable for serialization. Type Object update(resource) Unsupported operation; you cannot update a transaction in a transactionregistry. This method will always throw an exception when called. Parameters: Name Type Description resource Resource The resource to be updated in the registry. Overrides: Registry#update Source: composer-client/lib/transactionregistry.js, line 166 updateAll(resources) Unsupported operation; you cannot update a transaction in a transactionregistry. Call BusinessNetworkConnection.submitTransaction to submit a transaction. Parameters: Name Type Description resources Array.&lt;Resource&gt; The resources to be updated in the asset registry. Overrides: Registry#updateAll Source: composer-client/lib/transactionregistry.js, line 176 Ã— Search results Close "},"module-composer-common.html":{"id":"module-composer-common.html","title":"Module: composer-common","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Module: composer-common Fabric-Composer module. Fabric-Composer is a framework for creatingblockchain backed digital networks and exchanging assets between participantsvia processing transactions. Source: composer-common/index.js, line 17 Classes BaseException BusinessNetworkDefinition Concept Factory Identifiable IllegalModelException Introspector ParseException Relationship Resource SecurityContext SecurityException Serializer Typed ValidatedConcept ValidatedResource ValidationException Methods &lt;inner&gt; nodeHasNewBufferVersion() Check whether we're running in a version of node which has the updated Buffer implementationUsed above to fall back to the old version if needed. Source: composer-common/index.js, line 41 Returns: whether the new version is supported Type boolean Ã— Search results Close "},"module-composer-common.BaseException.html":{"id":"module-composer-common.BaseException.html","title":"Class: BaseException","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: BaseException composer-common. BaseException A base class for all Composer exceptions new BaseException(message) Create the BaseException. Parameters: Name Type Description message string The exception message. Source: composer-common/lib/baseexception.js, line 24 Extends Error Ã— Search results Close "},"module-composer-common.BusinessNetworkDefinition.html":{"id":"module-composer-common.BusinessNetworkDefinition.html","title":"Class: BusinessNetworkDefinition","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: BusinessNetworkDefinition composer-common. BusinessNetworkDefinition A BusinessNetworkDefinition defines a set of Participants that exchange Assets bysending Transactions. This class manages the metadata and domain-specific types forthe network as well as a set of executable scripts. new BusinessNetworkDefinition(identifier, description) Create the BusinessNetworkDefinition. Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkDefinition.fromArchive Parameters: Name Type Description identifier String the identifier of the business network. Theidentifier is formed from a business network name + '@' + version. Theversion is a semver valid version string. description String the description of the business network Source: composer-common/lib/businessnetworkdefinition.js, line 43 Methods &lt;static&gt; fromArchive(Buffer) Create a BusinessNetworkDefinition from an archive. Parameters: Name Type Description Buffer Buffer the Buffer to a zip archive Source: composer-common/lib/businessnetworkdefinition.js, line 123 Returns: a Promise to the instantiated business network Type Promise &lt;static&gt; fromDirectory(path [, options]) Builds a BusinessNetworkDefintion from the contents of a directory.The directory must include a package.json in the root (used to specifythe name, version and description of the business network). This methodis designed to work with business networks that refer to external modelsusing npm dependencies as well as business networks that staticallypackage their model files. If package.json contains a dependencies property then this method will search formodel (CTO) files under the node_modules directory for each dependency thatpasses the options.dependencyGlob pattern.In addition all model files will be added that are not under node_modulesand that pass the options.modelFileGlob pattern. By default you should putmodel files under a directory called 'models'.All script (js) files will be added that are not under node_modules andthat pass the options.scriptGlob pattern. By default you should put Javascriptfiles under the 'lib' directory. Parameters: Name Type Argument Description path String to a local directory options Object &lt;optional&gt; an optional set of options to configure the instance. Properties Name Type Argument Description dependencyGlob Object &lt;optional&gt; specify the glob pattern used to matchthe npm dependencies to process. Defaults to ** modelFileGlob boolean &lt;optional&gt; specify the glob pattern used to matchthe model files to include. Defaults to \\/models/\\/*.cto scriptGlob boolean &lt;optional&gt; specify the glob pattern used to matchthe script files to include. Defaults to \\/lib/\\/*.js Source: composer-common/lib/businessnetworkdefinition.js, line 293 Returns: a Promise to the instantiated business network Type Promise getDescription() Returns the description for this business network Source: composer-common/lib/businessnetworkdefinition.js, line 114 Returns: the description of this business network Type String getFactory() Provides access to the Factory for this business network. The Factoryis used to create the types defined in this business network. Source: composer-common/lib/businessnetworkdefinition.js, line 528 Returns: the Factory for this business network Type Factory getIdentifier() Returns the identifier for this business network Source: composer-common/lib/businessnetworkdefinition.js, line 88 Returns: the identifier of this business network Type String getIntrospector() Provides access to the Introspector for this business network. The Introspectoris used to reflect on the types defined within this business network. Source: composer-common/lib/businessnetworkdefinition.js, line 519 Returns: the Introspector for this business network Type Introspector getName() Returns the name for this business network Source: composer-common/lib/businessnetworkdefinition.js, line 96 Returns: the name of this business network Type String getSerializer() Provides access to the Serializer for this business network. The Serializeris used to serialize instances of the types defined within this business network. Source: composer-common/lib/businessnetworkdefinition.js, line 537 Returns: the Serializer for this business network Type Serializer getVersion() Returns the version for this business network Source: composer-common/lib/businessnetworkdefinition.js, line 105 Returns: the version of this business network. Use semver moduleto parse. Type String toArchive() Store a BusinessNetworkDefinition as an archive. Source: composer-common/lib/businessnetworkdefinition.js, line 218 Returns: buffer - the zlib buffer Type Buffer Ã— Search results Close "},"module-composer-common.Concept.html":{"id":"module-composer-common.Concept.html","title":"Class: Concept","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: Concept composer-common. Concept Resource is an instance that has a type. The type of the resourcespecifies a set of properites (which themselves have types).Type information in Composer is used to validate the structure ofResource instances and for serialization.Resources are used in Composer to represent Assets, Participants, Transactions andother domain classes that can be serialized for long-term persistent storage. new Concept(modelManager, ns, type) This constructor should not be called directly. Note: Only to be called by framework code. Applications shouldretrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. Source: composer-common/lib/model/concept.js, line 38 See: See Resource Extends Identifiable Methods isConcept() Determine if this typed is a concept. Source: composer-common/lib/model/concept.js, line 61 Returns: True if this typed is a concept,false if not. Type boolean Ã— Search results Close "},"module-composer-common.Factory.html":{"id":"module-composer-common.Factory.html","title":"Class: Factory","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: Factory composer-common. Factory Use the Factory to create instances of Resource: transactions, participantsand assets. new Factory(modelManager) Create the factory. Note: Only to be called by framework code. Applications shouldretrieve instances from Fabric-Composer Parameters: Name Type Description modelManager ModelManager The ModelManager to use for this registry Source: composer-common/lib/factory.js, line 40 Methods newConcept(ns, type [, options]) Create a new Resource with a given namespace, type name and id Parameters: Name Type Argument Description ns string the namespace of the Resource type string the type of the Resource options Object &lt;optional&gt; an optional set of options Properties Name Type Argument Description disableValidation boolean &lt;optional&gt; pass true if you want the factory toreturn a Resource instead of a ValidatedResource. Defaults to false. generate boolean &lt;optional&gt; pass true if you want the factory to return aresource instance with generated sample data. Source: composer-common/lib/factory.js, line 151 Throws: if the type is not registered with the ModelManager Type ModelException Returns: the new instance Type Resource newInstance(ns, type, id [, options]) Create a new Resource with a given namespace, type name and id Parameters: Name Type Argument Description ns string the namespace of the Resource type string the type of the Resource id string the identifier options Object &lt;optional&gt; an optional set of options Properties Name Type Argument Description disableValidation boolean &lt;optional&gt; pass true if you want the factory toreturn a Resource instead of a ValidatedResource. Defaults to false. generate boolean &lt;optional&gt; pass true if you want the factory to return aresource instance with generated sample data. Deprecated: - use newResource instead Source: composer-common/lib/factory.js, line 68 Throws: if the type is not registered with the ModelManager Type ModelException Returns: the new instance Type Resource newRelationship(ns, type, id) Create a new Relationship with a given namespace, type and identifier.* A relationship is a typed pointer to an instance. I.e the relationship with namespace = 'org.acme', type = 'Vehicle' and id = 'ABC' createsa pointer that points at an instance of org.acme.Vehicle with the idABC. Parameters: Name Type Description ns string the namespace of the Resource type string the type of the Resource id string the identifier Source: composer-common/lib/factory.js, line 212 Throws: if the type is not registered with the ModelManager Type ModelException Returns: the new relationship instance Type Relationship newResource(ns, type, id [, options]) Create a new Resource with a given namespace, type name and id Parameters: Name Type Argument Description ns string the namespace of the Resource type string the type of the Resource id string the identifier options Object &lt;optional&gt; an optional set of options Properties Name Type Argument Description disableValidation boolean &lt;optional&gt; pass true if you want the factory toreturn a Resource instead of a ValidatedResource. Defaults to false. generate boolean &lt;optional&gt; pass true if you want the factory to return aresource instance with generated sample data. Source: composer-common/lib/factory.js, line 85 Throws: if the type is not registered with the ModelManager Type ModelException Returns: the new instance Type Resource newTransaction(ns, type [, id] [, options]) Create a new transaction object. The identifier of the transaction isset to a UUID. Parameters: Name Type Argument Description ns string the namespace of the transaction. type string the type of the transaction. id string &lt;optional&gt; an optional identifier for the transaction; if you do not specifyone then an identifier will be automatically generated. options Object &lt;optional&gt; an optional set of options Properties Name Type Argument Description generate boolean &lt;optional&gt; pass true if you want the factory to return aresource instance with generated sample data. Source: composer-common/lib/factory.js, line 247 Returns: A resource for the new transaction. Type Resource toJSON() Stop serialization of this object. Source: composer-common/lib/factory.js, line 271 Returns: An empty object. Type Object Ã— Search results Close "},"module-composer-common.Identifiable.html":{"id":"module-composer-common.Identifiable.html","title":"Class: Identifiable","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: Identifiable composer-common. Identifiable Identifiable is an entity with a namespace, type and an identifier. This class is abstract. &lt;abstract&gt; new Identifiable(modelManager, ns, type, id) Create an instance. Note: Only to be called by framework code. Applications shouldretrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. id string The identifier of this instance. Source: composer-common/lib/model/identifiable.js, line 27 Methods getFullyQualifiedIdentifier() Get the fully qualified identifier of this instance.(namespace '.' type '#' identifier). Source: composer-common/lib/model/identifiable.js, line 71 Returns: the fully qualified identifier of this instance Type string getIdentifier() Get the identifier of this instance Source: composer-common/lib/model/identifiable.js, line 50 Returns: The identifier for this object Type string isRelationship() Determine if this identifiable is a relationship. Source: composer-common/lib/model/identifiable.js, line 88 Returns: True if this identifiable is a relationship,false if not. Type boolean isResource() Determine if this identifiable is a resource. Source: composer-common/lib/model/identifiable.js, line 97 Returns: True if this identifiable is a resource,false if not. Type boolean setIdentifier(id) Set the identifier of this instance Parameters: Name Type Description id string the new identifier for this object Source: composer-common/lib/model/identifiable.js, line 58 toString() Returns the string representation of this class Source: composer-common/lib/model/identifiable.js, line 79 Returns: the string representation of the class Type String Ã— Search results Close "},"module-composer-common.IllegalModelException.html":{"id":"module-composer-common.IllegalModelException.html","title":"Class: IllegalModelException","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: IllegalModelException composer-common. IllegalModelException Exception throws when a composer file is semantically invalid new IllegalModelException(message) Create an IllegalModelException Parameters: Name Type Description message string the message for the exception Source: composer-common/lib/introspect/illegalmodelexception.js, line 26 See: See BaseException Extends BaseException Ã— Search results Close "},"module-composer-common.Introspector.html":{"id":"module-composer-common.Introspector.html","title":"Class: Introspector","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: Introspector composer-common. Introspector Provides access to the structure of transactions, assets and participants. new Introspector(modelManager) Create the Introspector. Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkDefinition Parameters: Name Type Description modelManager ModelManager the ModelManager that backs this Introspector Source: composer-common/lib/introspect/introspector.js, line 24 Methods getClassDeclaration(fullyQualifiedTypeName) Returns the class declaration with the given fully qualified name.Throws an error if the class declaration does not exist. Parameters: Name Type Description fullyQualifiedTypeName String the fully qualified name of the type Source: composer-common/lib/introspect/introspector.js, line 69 Throws: if the class declaration does not exist Type Error Returns: the class declaration Type ClassDeclaration getClassDeclarations() Returns all the class declarations for the business network. Source: composer-common/lib/introspect/introspector.js, line 52 Returns: the array of class declarations Type Array.&lt;ClassDeclaration&gt; Ã— Search results Close "},"module-composer-common.ParseException.html":{"id":"module-composer-common.ParseException.html","title":"Class: ParseException","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: ParseException composer-common. ParseException Exception throws when a Composer file is syntactically invalid new ParseException(message) Create an ParseException Parameters: Name Type Description message string the message for the exception Source: composer-common/lib/introspect/parseexception.js, line 26 See: See BaseException Extends BaseException Ã— Search results Close "},"module-composer-common.Relationship.html":{"id":"module-composer-common.Relationship.html","title":"Class: Relationship","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: Relationship composer-common. Relationship A Relationship is a typed pointer to an instance. I.e the relationshipwith namespace = 'org.acme', type = 'Vehicle' and id = 'ABC' createsa pointer that points at an instance of org.acme.Vehicle with the idABC. new Relationship(modelManager, ns, type, id) Create an asset. Use the Factory to create instances. Note: Only to be called by framework code. Applications shouldretrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. id string The identifier of this instance. Source: composer-common/lib/model/relationship.js, line 29 See: See Identifiable Extends Identifiable Methods isRelationship() Determine if this identifiable is a relationship. Source: composer-common/lib/model/relationship.js, line 62 Returns: True if this identifiable is a relationship,false if not. Type boolean toString() Returns the string representation of this class Source: composer-common/lib/model/relationship.js, line 53 Returns: the string representation of the class Type String Ã— Search results Close "},"module-composer-common.Resource.html":{"id":"module-composer-common.Resource.html","title":"Class: Resource","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: Resource composer-common. Resource Resource is an instance that has a type. The type of the resourcespecifies a set of properites (which themselves have types).Type information in Composer is used to validate the structure ofResource instances and for serialization.Resources are used in Composer to represent Assets, Participants, Transactions andother domain classes that can be serialized for long-term persistent storage. new Resource(modelManager, ns, type, id) This constructor should not be called directly. Note: Only to be called by framework code. Applications shouldretrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. id string The identifier of this instance. Source: composer-common/lib/model/resource.js, line 37 See: See Resource Extends Identifiable Methods isResource() Determine if this identifiable is a resource. Source: composer-common/lib/model/resource.js, line 68 Returns: True if this identifiable is a resource,false if not. Type boolean toString() Returns the string representation of this class Source: composer-common/lib/model/resource.js, line 59 Returns: the string representation of the class Type String Ã— Search results Close "},"module-composer-common.SecurityContext.html":{"id":"module-composer-common.SecurityContext.html","title":"Class: SecurityContext","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: SecurityContext composer-common. SecurityContext SecurityContext is used to authenticate and manageuser credentials to the underlying blockchain fabric. &lt;abstract&gt; new SecurityContext(connection, user) Create the SecurityContext.Note: Only to be called by framework code. Applications shouldretrieve instances by calling login Parameters: Name Type Description connection Connection The owning connection. user string The user identifier. Source: composer-common/lib/securitycontext.js, line 25 Methods getConnection() Get the owning connection. Source: composer-common/lib/securitycontext.js, line 43 Returns: The owning connection. Type Connection &lt;abstract&gt; getUser() Get the current username. Source: composer-common/lib/securitycontext.js, line 52 Returns: The username Type string toJSON() Stop serialization of this object. Source: composer-common/lib/securitycontext.js, line 60 Returns: An empty object. Type Object Ã— Search results Close "},"module-composer-common.SecurityException.html":{"id":"module-composer-common.SecurityException.html","title":"Class: SecurityException","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: SecurityException composer-common. SecurityException Class representing a security exception new SecurityException(message) Create the SecurityException. Parameters: Name Type Description message string The exception message. Source: composer-common/lib/securityexception.js, line 27 See: See BaseException Extends BaseException Ã— Search results Close "},"module-composer-common.Serializer.html":{"id":"module-composer-common.Serializer.html","title":"Class: Serializer","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: Serializer composer-common. Serializer Serialize Resources instances to/from various formats for long-term storage(e.g. on the blockchain). new Serializer(factory, modelManager) Create a Serializer.Note: Only to be called by framework code. Applications shouldretrieve instances from Composer Parameters: Name Type Description factory Factory The Factory to use to create instances modelManager ModelManager The ModelManager to use for validation etc. Source: composer-common/lib/serializer.js, line 32 Methods fromJSON(jsonObject, options) Create a Resource from a JavaScript Object representation.The JavaScript Object should have been created by calling thetoJSON API. The Resource is populated based on the JavaScript object. Parameters: Name Type Description jsonObject Object The JavaScript Object for a Resource options Object the optional serialization options Properties Name Type Description acceptResourcesForRelationships boolean handle JSON objectsin the place of strings for relationships, defaults to false. Source: composer-common/lib/serializer.js, line 126 Returns: The new populated resource Type Resource toJSON(resource, options) Convert a Resource to a JavaScript object suitable for long-termperistent storage. Parameters: Name Type Description resource Resource The instance to convert to JSON options Object the optional serialization options. Properties Name Type Description validate boolean validate the structure of the Resourcewith its model prior to serialization (default to true) convertResourcesToRelationships boolean Convert resources thatare specified for relationship fields into relationships, false by default. permitResourcesForRelationships boolean Permit resources in theplace of relationships (serializing them as resources), false by default. Source: composer-common/lib/serializer.js, line 70 Throws: throws an exception if resource is not an instance ofResource or fails validation. Type Error Returns: The Javascript Object that represents the resource Type Object Ã— Search results Close "},"module-composer-common.Typed.html":{"id":"module-composer-common.Typed.html","title":"Class: Typed","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: Typed composer-common. Typed Object is an instance with a namespace and a type. This class is abstract. &lt;abstract&gt; new Typed(modelManager, ns, type) Create an instance. Note: Only to be called by framework code. Applications shouldretrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. Source: composer-common/lib/model/typed.js, line 27 Methods addArrayValue(propName, value) Adds a value to an array property on this Resource Parameters: Name Type Description propName string the name of the field value string the value of the property Source: composer-common/lib/model/typed.js, line 129 getFullyQualifiedType() Get the fully-qualified type name of the instance (including namespace). Source: composer-common/lib/model/typed.js, line 78 Returns: The fully-qualified type name of this object Type string getNamespace() Get the namespace of the instance. Source: composer-common/lib/model/typed.js, line 86 Returns: The namespace of this object Type string getType() Get the type of the instance (a short name, not including namespace). Source: composer-common/lib/model/typed.js, line 70 Returns: The type of this object Type string setPropertyValue(propName, value) Sets a property on this Resource Parameters: Name Type Description propName string the name of the field value string the value of the property Source: composer-common/lib/model/typed.js, line 120 Ã— Search results Close "},"module-composer-common.ValidatedConcept.html":{"id":"module-composer-common.ValidatedConcept.html","title":"Class: ValidatedConcept","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: ValidatedConcept composer-common. ValidatedConcept Resource is an instance that has a type. The type of the resourcespecifies a set of properites (which themselves have types).Type information in Composer is used to validate the structure ofResource instances and for serialization.Resources are used in Composer to represent Assets, Participants, Transactions andother domain classes that can be serialized for long-term persistent storage. new ValidatedConcept(modelManager, ns, type, resourceValidator) This constructor should not be called directly. Note: Only to be called by framework code. Applications shouldretrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. resourceValidator ResourceValidator The validator to use for this instance Source: composer-common/lib/model/validatedconcept.js, line 38 See: See Resource Extends Identifiable Methods addArrayValue(propName, value) Adds an array property value, validating that it does not violate the model Parameters: Name Type Description propName string the name of the field value string the value of the property Source: composer-common/lib/model/validatedconcept.js, line 89 Throws: if the value is not compatible with the model definition for the field Type Error setPropertyValue(propName, value) Sets a property, validating that it does not violate the model Parameters: Name Type Description propName string the name of the field value string the value of the property Source: composer-common/lib/model/validatedconcept.js, line 63 Throws: if the value is not compatible with the model definition for the field Type Error validate() Validates the instance against its model. Source: composer-common/lib/model/validatedconcept.js, line 121 Throws: if the instance if invalid with respect to the model Type Error Ã— Search results Close "},"module-composer-common.ValidatedResource.html":{"id":"module-composer-common.ValidatedResource.html","title":"Class: ValidatedResource","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: ValidatedResource composer-common. ValidatedResource ValidatedResource is a Resource that can validate that propertychanges (or the whole instance) do not violate the structure ofthe type information associated with the instance. new ValidatedResource(modelManager, ns, type, id, resourceValidator) This constructor should not be called directly.Use the Factory class to create instances. Note: Only to be called by framework code. Applications shouldretrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. id string The identifier of this instance. resourceValidator ResourceValidator The validator to use for this instance Source: composer-common/lib/model/validatedresource.js, line 29 See: See Resource Extends Resource Methods addArrayValue(propName, value) Adds an array property value, validating that it does not violate the model Parameters: Name Type Description propName string the name of the field value string the value of the property Source: composer-common/lib/model/validatedresource.js, line 83 Throws: if the value is not compatible with the model definition for the field Type Error setPropertyValue(propName, value) Sets a property, validating that it does not violate the model Parameters: Name Type Description propName string the name of the field value string the value of the property Source: composer-common/lib/model/validatedresource.js, line 56 Throws: if the value is not compatible with the model definition for the field Type Error validate() Validates the instance against its model. Source: composer-common/lib/model/validatedresource.js, line 117 Throws: if the instance if invalid with respect to the model Type Error Ã— Search results Close "},"module-composer-common.ValidationException.html":{"id":"module-composer-common.ValidationException.html","title":"Class: ValidationException","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: ValidationException composer-common. ValidationException Exception thrown when a resource fails to model against the model new ValidationException(message) Create an ParseException Parameters: Name Type Description message string the message for the exception Source: composer-common/lib/serializer/validationexception.js, line 26 See: See BaseException Extends BaseException Ã— Search results Close "},"module-composer-runtime.html":{"id":"module-composer-runtime.html","title":"Module: composer-runtime","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Module: composer-runtime The runtime module provides the API that is made available to transactionprocessing functions. Source: composer-runtime/index.js, line 17 Classes AccessException AssetRegistry Factory ParticipantRegistry Methods getAssetRegistry(id) Get an existing asset registry using the unique identifier of the assetregistry. An asset registry can be used to retrieve, update, or deleteexisting assets, or create new assets. Parameters: Name Type Description id string The ID of the asset registry. Source: composer-runtime/lib/api.js, line 66 Returns: A promise. The promise is resolved with an {@linkmodule:composer-runtime.AssetRegistry AssetRegistry} instancerepresenting the asset registry if it exists. If the asset registrydoes not exist, or the current user does not have access to the assetregistry, then the promise will be rejected with an error that describesthe problem. Type Promise Example // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Call methods on the vehicle asset registry. }) .catch(function (error) { // Add optional error handling here. }); getCurrentParticipant() Get the current participant. The current participant is determined bythe identity that was used to submit the current transaction. Source: composer-runtime/lib/api.js, line 134 Returns: The current participant,or null if the transaction was submitted using an identity that doesnot map to a participant. Type module:composer-common.Resource Example // Get the current participant. var currentParticipant = getCurrentParticipant(); // Check to see if the current participant is a driver. if (currentParticipant.getFullyQualifiedType() !== 'org.acme.Driver') { // Throw an error as the current participant is not a driver. throw new Error('Current participant is not a driver'); } // Check to see if the current participant is the first driver. if (currentParticipant.getFullyQualifiedIdentifier() !== 'org.acme.Driver#DRIVER_1') { // Throw an error as the current participant is not a driver. throw new Error('Current participant is not the first driver'); } getFactory() Get the factory. The factory can be used to create new instances ofassets, participants, and transactions for storing in registries. Thefactory can also be used for creating relationships to assets, particpants,and transactions. Source: composer-runtime/lib/api.js, line 46 Returns: The factory. Type module:composer-runtime.Factory Example // Get the factory. var factory = getFactory(); getParticipantRegistry(id) Get an existing participant registry using the unique identifier of the participantregistry. An participant registry can be used to retrieve, update, or deleteexisting participants, or create new participants. Parameters: Name Type Description id string The ID of the participant registry. Source: composer-runtime/lib/api.js, line 100 Returns: A promise. The promise is resolved with an {@linkmodule:composer-runtime.ParticipantRegistry ParticipantRegistry} instancerepresenting the participant registry if it exists. If the participant registrydoes not exist, or the current user does not have access to the participantregistry, then the promise will be rejected with an error that describesthe problem. Type Promise Example // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (driverParticipantRegistry) { // Call methods on the driver participant registry. }) .catch(function (error) { // Add optional error handling here. }); Ã— Search results Close "},"module-composer-runtime.AccessException.html":{"id":"module-composer-runtime.AccessException.html","title":"Class: AccessException","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: AccessException composer-runtime. AccessException Class representing an access exception new AccessException(resource, access, participant) Constructor. Parameters: Name Type Description resource Resource The resource. access string The level of access. participant Resource The participant. Source: composer-runtime/lib/accessexception.js, line 27 See: See BaseException Extends BaseException Methods &lt;static&gt; generateMessage(resource, access, participant) Generate the exception message. Parameters: Name Type Description resource Resource The resource. access string The level of access. participant Resource The participant. Source: composer-runtime/lib/accessexception.js, line 36 Returns: The exception message. Type string Ã— Search results Close "},"module-composer-runtime.AssetRegistry.html":{"id":"module-composer-runtime.AssetRegistry.html","title":"Class: AssetRegistry","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: AssetRegistry composer-runtime. AssetRegistry An asset registry manages a set of assets. new AssetRegistry() Do not attempt to create an instance of this class.You must use the getAssetRegistrymethod instead. Source: composer-runtime/lib/api/assetregistry.js, line 21 Methods add(asset) Add the specified asset to this asset registry. Parameters: Name Type Description asset Resource The assets to add to this asset registry. Source: composer-runtime/lib/api/assetregistry.js, line 142 Returns: A promise. The promise is resolved when the asset hasbeen added to this asset registry. If the asset cannot be added to thisasset registry, or if the asset already exists in the asset registry,then the promise will be rejected with an error that describes the problem. Type Promise Example // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get the factory for creating new asset instances. var factory = getFactory(); // Create the vehicle. var vehicle = factory.newInstance('org.acme', 'Vehicle', 'VEHICLE_1'); vehicle.colour = 'BLUE'; // Add the vehicle to the vehicle asset registry. return vehicleAssetRegistry.add(vehicle); }) .catch(function (error) { // Add optional error handling here. }); addAll(assets) Add all of the specified assets to this asset registry. Parameters: Name Type Description assets Array.&lt;Resource&gt; The assets to add to this asset registry. Source: composer-runtime/lib/api/assetregistry.js, line 109 Returns: A promise. The promise is resolved when all of theassets have been added to this asset registry. If the assets cannot beadded to this asset registry, or if the assets already exist in theasset registry, then the promise will be rejected with an errorthat describes the problem. Type Promise Example // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get the factory for creating new asset instances. var factory = getFactory(); // Create the first vehicle. var vehicle1 = factory.newInstance('org.acme', 'Vehicle', 'VEHICLE_1'); vehicle1.colour = 'BLUE'; // Create the second vehicle. var vehicle2 = factory.newInstance('org.acme', 'Vehicle', 'VEHICLE_2'); vehicle2.colour = 'GREEN'; // Add the vehicles to the vehicle asset registry. return vehicleAssetRegistry.addAll([vehicle1, vehicle2]); }) .catch(function (error) { // Add optional error handling here. }); get(id) Get the specified asset in this asset registry using the unique identifierof the asset. Parameters: Name Type Description id string The ID of the asset. Source: composer-runtime/lib/api/assetregistry.js, line 79 Returns: A promise. The promise is resolved with a Resourceinstance representing the specified asset in this asset registry. If thespecified asset does not exist, or the current user does not have accessto the specified asset, then the promise will be rejected with an errorthat describes the problem. Type Promise Example // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get the specific vehicle from the vehicle asset registry. return assetRegistry.get('VEHICLE_1'); }) .then(function (vehicle) { // Process the the vehicle object. console.log(vehicle.vehicleId); }) .catch(function (error) { // Add optional error handling here. }); getAll() Get a list of all of the existing assets in this asset registry. Source: composer-runtime/lib/api/assetregistry.js, line 49 Returns: A promise. The promise is resolved with an array ofResource instances representing all of the assets stored in thisasset registry. If the asset registry does not exist, or the currentuser does not have access to the asset registry, then the promise willbe rejected with an error that describes the problem. Type Promise Example // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get all of the vehicles in the vehicle asset registry. return assetRegistry.getAll(); }) .then(function (vehicles) { // Process the array of vehicle objects. vehicles.forEach(function (vehicle) { console.log(vehicle.vehicleId); }); }) .catch(function (error) { // Add optional error handling here. }); remove(asset) Remove the specified asset from this asset registry. Parameters: Name Type Description asset string | Resource The asset, or ID of the asset, to removefrom this asset registry. Source: composer-runtime/lib/api/assetregistry.js, line 268 Returns: A promise. The promise is resolved when the assethas been removed from this asset registry. If the asset cannot beremoved from this asset registry, or if the asset does not exist in theasset registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing vehicle that has come from elsewhere. var vehicle; // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get the factory for creating new asset instances. var factory = getFactory(); // Remove the vehicle from the vehicle asset registry. return vehicleAssetRegistry.remove(vehicle); }) .catch(function (error) { // Add optional error handling here. }); removeAll(assets) Remove all of the specified assets from this asset registry. Parameters: Name Type Description assets Array.&lt;string&gt; | Array.&lt;Resource&gt; The assets, or the IDs of the assets,to remove from this asset registry. Source: composer-runtime/lib/api/assetregistry.js, line 236 Returns: A promise. The promise is resolved when all of theassets have been removed from this asset registry. If the assets cannot beremoved from this asset registry, or if the assets do not exist in theasset registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing vehicles that have come from elsewhere. var vehicle1; // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get the factory for creating new asset instances. var factory = getFactory(); // Remove the vehicles from the vehicle asset registry. Note that // one vehicle is specified as a vehicle instance, and the other // vehicle is specified by the ID of the vehicle. return vehicleAssetRegistry.removeAll([vehicle1, 'VEHICLE_2']); }) .catch(function (error) { // Add optional error handling here. }); update(asset) Update the specified asset in this asset registry. Parameters: Name Type Description asset Resource The asset to update in this asset registry. Source: composer-runtime/lib/api/assetregistry.js, line 205 Returns: A promise. The promise is resolved when the assethave been updated in this asset registry. If the asset cannot beupdated in this asset registry, or if the asset does not exist in theasset registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing vehicle that has come from elsewhere. var vehicle; // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get the factory for creating new asset instances. var factory = getFactory(); // Modify the properties of the vehicle. vehicle.colour = 'PURPLE'; // Update the vehicle in the vehicle asset registry. return vehicleAssetRegistry.update(vehicle); }) .catch(function (error) { // Add optional error handling here. }); updateAll(assets) Update all of the specified assets in this asset registry. Parameters: Name Type Description assets Array.&lt;Resource&gt; The assets to update in this asset registry. Source: composer-runtime/lib/api/assetregistry.js, line 171 Returns: A promise. The promise is resolved when all of theassets have been updated in this asset registry. If the assets cannot beupdated in this asset registry, or if the assets do not exist in theasset registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing vehicles that have come from elsewhere. var vehicle1; var vehicle2; // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get the factory for creating new asset instances. var factory = getFactory(); // Modify the properties of the first vehicle. vehicle1.colour = 'PURPLE'; // Modify the properties of the second vehicle. vehicle2.colour = 'ORANGE'; // Update the vehicles in the vehicle asset registry. return vehicleAssetRegistry.updateAll([vehicle1, vehicle2]); }) .catch(function (error) { // Add optional error handling here. }); Ã— Search results Close "},"module-composer-runtime.Factory.html":{"id":"module-composer-runtime.Factory.html","title":"Class: Factory","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: Factory composer-runtime. Factory A factory creates new instances of assets, participants, transactions,and relationships. new Factory() Do not attempt to create an instance of this class.You must use the getFactorymethod instead. Source: composer-runtime/lib/api/factory.js, line 21 Methods newConcept(ns, type) Create a new concept with a given namespace, type, and identifier.A concept is an advanced data structure Parameters: Name Type Description ns string The namespace of the concept. type string The type of the concept. Source: composer-runtime/lib/api/factory.js, line 105 Throws: If the specified type (specified by the namespace andtype) is not defined in the current version of the business network. Type Error Returns: The new instance of the concept. Type Concept Example // The existing driver of the vehicle. var person; // Get the factory. var factory = getFactory(); // Create a new relationship to the vehicle. var record = factory.newConcept('org.acme', 'Record', 'RECORD_1'); // Add the record to the persons array of records. person.records.push(record); newInstance(ns, type, id) Create a new instance of an asset, participant, or transaction. Theproperties of the new instance should be set as standard JavaScriptobject properties. The new instance can then be stored in a registryusing the appropriate registry APIs, for example {@linkmodule:composer-runtime.AssetRegistry AssetRegistry}. Parameters: Name Type Description ns string The namespace of the resource to create. type string The type of the resource to create. id string The identifier of the new resource. Source: composer-runtime/lib/api/factory.js, line 50 Throws: If the specified type (specified by the namespace andtype) is not defined in the current version of the business network. Type Error Returns: The new instance of the resource. Type Resource Example // Get the factory. var factory = getFactory(); // Create a new vehicle. var vehicle = factory.newInstance('org.acme', 'Vehicle', 'VEHICLE_1'); // Set the properties of the new vehicle. vehicle.colour = 'BLUE'; vehicle.manufacturer = 'Toyota'; newRelationship(ns, type, id) Create a new relationship with a given namespace, type, and identifier.A relationship is a typed pointer to an instance. For example, a newrelationship with namespace 'org.acme', type 'Vehicle' and identifier'VEHICLE_1' creates` a pointer that points at an existing instance oforg.acme.Vehicle with the identifier 'VEHICLE_1'. Parameters: Name Type Description ns string The namespace of the resource referenced by the relationship. type string The type of the resource referenced by the relationship. id string The identifier of the resource referenced by the relationship. Source: composer-runtime/lib/api/factory.js, line 77 Throws: If the specified type (specified by the namespace andtype) is not defined in the current version of the business network. Type Error Returns: The new instance of the relationship. Type Relationship Example // The existing driver of the vehicle. var driver; // Get the factory. var factory = getFactory(); // Create a new relationship to the vehicle. var vehicle = factory.newRelationship('org.acme', 'Vehicle', 'VEHICLE_1'); // Set the relationship as the value of the vehicle property of the driver. driver.vehicle = vehicle; Ã— Search results Close "},"module-composer-runtime.ParticipantRegistry.html":{"id":"module-composer-runtime.ParticipantRegistry.html","title":"Class: ParticipantRegistry","body":" Fabric Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes composer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AccessExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistry Global theWallet Class: ParticipantRegistry composer-runtime. ParticipantRegistry An participant registry manages a set of participants. new ParticipantRegistry() Do not attempt to create an instance of this class.You must use the getParticipantRegistrymethod instead. Source: composer-runtime/lib/api/participantregistry.js, line 21 Methods add(participant) Add the specified participant to this participant registry. Parameters: Name Type Description participant Resource The participants to add to this participant registry. Source: composer-runtime/lib/api/participantregistry.js, line 142 Returns: A promise. The promise is resolved when the participant hasbeen added to this participant registry. If the participant cannot be added to thisparticipant registry, or if the participant already exists in the participant registry,then the promise will be rejected with an error that describes the problem. Type Promise Example // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (driverParticipantRegistry) { // Get the factory for creating new participant instances. var factory = getFactory(); // Create the driver. var driver = factory.newInstance('org.acme', 'Driver', 'VEHICLE_1'); driver.location = 'Southampton'; // Add the driver to the driver participant registry. return driverParticipantRegistry.add(driver); }) .catch(function (error) { // Add optional error handling here. }); addAll(participants) Add all of the specified participants to this participant registry. Parameters: Name Type Description participants Array.&lt;Resource&gt; The participants to add to this participant registry. Source: composer-runtime/lib/api/participantregistry.js, line 109 Returns: A promise. The promise is resolved when all of theparticipants have been added to this participant registry. If the participants cannot beadded to this participant registry, or if the participants already exist in theparticipant registry, then the promise will be rejected with an errorthat describes the problem. Type Promise Example // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (driverParticipantRegistry) { // Get the factory for creating new participant instances. var factory = getFactory(); // Create the first driver. var driver1 = factory.newInstance('org.acme', 'Driver', 'VEHICLE_1'); driver1.location = 'Southampton'; // Create the second driver. var driver2 = factory.newInstance('org.acme', 'Driver', 'VEHICLE_2'); driver2.location = 'GREEN'; // Add the drivers to the driver participant registry. return driverParticipantRegistry.addAll([driver1, driver2]); }) .catch(function (error) { // Add optional error handling here. }); get(id) Get the specified participant in this participant registry using the unique identifierof the participant. Parameters: Name Type Description id string The ID of the participant. Source: composer-runtime/lib/api/participantregistry.js, line 79 Returns: A promise. The promise is resolved with a Resourceinstance representing the specified participant in this participant registry. If thespecified participant does not exist, or the current user does not have accessto the specified participant, then the promise will be rejected with an errorthat describes the problem. Type Promise Example // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (driverParticipantRegistry) { // Get the specific driver from the driver participant registry. return participantRegistry.get('VEHICLE_1'); }) .then(function (driver) { // Process the the driver object. console.log(driver.driverId); }) .catch(function (error) { // Add optional error handling here. }); getAll() Get a list of all of the existing participants in this participant registry. Source: composer-runtime/lib/api/participantregistry.js, line 49 Returns: A promise. The promise is resolved with an array ofResource instances representing all of the participants stored in thisparticipant registry. If the participant registry does not exist, or the currentuser does not have access to the participant registry, then the promise willbe rejected with an error that describes the problem. Type Promise Example // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (driverParticipantRegistry) { // Get all of the drivers in the driver participant registry. return participantRegistry.getAll(); }) .then(function (drivers) { // Process the array of driver objects. drivers.forEach(function (driver) { console.log(driver.driverId); }); }) .catch(function (error) { // Add optional error handling here. }); remove(participant) Remove the specified participant from this participant registry. Parameters: Name Type Description participant string | Resource The participant, or ID of the participant, to removefrom this participant registry. Source: composer-runtime/lib/api/participantregistry.js, line 268 Returns: A promise. The promise is resolved when the participanthas been removed from this participant registry. If the participant cannot beremoved from this participant registry, or if the participant does not exist in theparticipant registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing driver that has come from elsewhere. var driver; // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (driverParticipantRegistry) { // Get the factory for creating new participant instances. var factory = getFactory(); // Remove the driver from the driver participant registry. return driverParticipantRegistry.remove(driver); }) .catch(function (error) { // Add optional error handling here. }); removeAll(participants) Remove all of the specified participants from this participant registry. Parameters: Name Type Description participants Array.&lt;string&gt; | Array.&lt;Resource&gt; The participants, or the IDs of the participants,to remove from this participant registry. Source: composer-runtime/lib/api/participantregistry.js, line 236 Returns: A promise. The promise is resolved when all of theparticipants have been removed from this participant registry. If the participants cannot beremoved from this participant registry, or if the participants do not exist in theparticipant registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing drivers that have come from elsewhere. var driver1; // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (driverParticipantRegistry) { // Get the factory for creating new participant instances. var factory = getFactory(); // Remove the drivers from the driver participant registry. Note that // one driver is specified as a driver instance, and the other // driver is specified by the ID of the driver. return driverParticipantRegistry.removeAll([driver1, 'VEHICLE_2']); }) .catch(function (error) { // Add optional error handling here. }); update(participant) Update the specified participant in this participant registry. Parameters: Name Type Description participant Resource The participant to update in this participant registry. Source: composer-runtime/lib/api/participantregistry.js, line 205 Returns: A promise. The promise is resolved when the participanthave been updated in this participant registry. If the participant cannot beupdated in this participant registry, or if the participant does not exist in theparticipant registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing driver that has come from elsewhere. var driver; // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (driverParticipantRegistry) { // Get the factory for creating new participant instances. var factory = getFactory(); // Modify the properties of the driver. driver.location = 'Hursley'; // Update the driver in the driver participant registry. return driverParticipantRegistry.update(driver); }) .catch(function (error) { // Add optional error handling here. }); updateAll(participants) Update all of the specified participants in this participant registry. Parameters: Name Type Description participants Array.&lt;Resource&gt; The participants to update in this participant registry. Source: composer-runtime/lib/api/participantregistry.js, line 171 Returns: A promise. The promise is resolved when all of theparticipants have been updated in this participant registry. If the participants cannot beupdated in this participant registry, or if the participants do not exist in theparticipant registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing drivers that have come from elsewhere. var driver1; var driver2; // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (driverParticipantRegistry) { // Get the factory for creating new participant instances. var factory = getFactory(); // Modify the properties of the first driver. driver1.location = 'Hursley'; // Modify the properties of the second driver. driver2.location = 'London'; // Update the drivers in the driver participant registry. return driverParticipantRegistry.updateAll([driver1, driver2]); }) .catch(function (error) { // Add optional error handling here. }); Ã— Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
