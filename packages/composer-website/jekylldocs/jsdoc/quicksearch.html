<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"composer-runtime_lib_aclcompiler.js.html":{"id":"composer-runtime_lib_aclcompiler.js.html","title":"Source: composer-runtime/lib/aclcompiler.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/aclcompiler.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Api = require('./api'); const assert = require('assert'); const CompiledAclBundle = require('./compiledaclbundle'); const Logger = require('composer-common').Logger; const SourceMapConsumer = require('source-map').SourceMapConsumer; const SourceMapGenerator = require('source-map').SourceMapGenerator; const SourceNode = require('source-map').SourceNode; const LOG = Logger.getLog('AclCompiler'); /** * An ACL compiler compiles all ACLs in a ACL manager into a compiled * ACL bundle that can easily be called by the runtime. * @protected */ class AclCompiler { /** * Compile all the ACL in the specified ACL manager into a compiled * ACL bundle for use by the runtime. * @param {AclManager} aclManager The ACL manager to process. * @param {ScriptManager} scriptManager The script manager to process. * @return {CompiledAclBundle} The compiled script bundle. */ compile(aclManager, scriptManager) { const method = 'compile'; LOG.entry(method, aclManager, scriptManager); // Create the compiler context. const rootNode = new SourceNode(null, null, null); const aclRules = []; const context = { rootNode: rootNode, aclRules: aclRules }; // Define the globals. const globals = { assert: assert }; // Add the start section. rootNode.add('function __generator(__globals) {\\n'); Object.keys(globals).forEach((globalName) =&gt; { LOG.debug(method, 'Adding global', globalName); rootNode.add(` var ${globalName} = __globals.${globalName};\\n`); }); rootNode.add(' function __api_disabled() { throw new Error(\\'The runtime API is not available\\'); }\\n'); Api.getMethodNames().forEach((methodName) =&gt; { LOG.debug(method, 'Adding API method', methodName); rootNode.add(` var ${methodName} = __api_disabled;\\n`); }); rootNode.add(' __globals = __api_disabled = null;\\n'); // Process the script manager. this.processScriptManager(context, scriptManager); // Process the ACL manager. this.processAclManager(context, aclManager); // Add the end section. rootNode.add(' return {\\n'); context.aclRules.forEach((aclRule) =&gt; { LOG.debug(method, 'Adding ACL rule', aclRule.getName()); rootNode.add(` '${aclRule.getName()}': ${aclRule.getName()},\\n`); }); rootNode.add(' };'); rootNode.add('}\\n'); rootNode.add('__generator;\\n'); // Generate the combined source code and source map. const combined = rootNode.toStringWithSourceMap(); const sourceCode = combined.code; const sourceMap = combined.map; // Serialize the source map as base64. const sourceMapBase64 = Buffer.from(sourceMap.toString()).toString('base64'); // Combine the source code and the serialized source map. const finalSourceCode = sourceCode + '\\n//# sourceMappingURL=data:application/json;base64,' + sourceMapBase64; // Compile the source code into a generator function. // The &quot;new Function('return eval')&quot; hack stops the generator function getting access // to all our local variables. We could just use &quot;new Function&quot;, but that screws up // the source maps so they all need to be offset by 2. let generatorFunction = new Function('__generatorSource', 'return eval(__generatorSource)')(finalSourceCode); generatorFunction = generatorFunction.bind(null, globals); let result = new CompiledAclBundle(aclRules, generatorFunction); LOG.exit(method, result); return result; } /** * Process the specified script manager by processing the scripts in the script manager. * @param {Object} context The compiler context. * @param {ScriptManager} scriptManager The script manager to process. */ processScriptManager(context, scriptManager) { const method = 'processScriptManager'; LOG.entry(method, context, scriptManager); // Process all of the scripts in the script manager. scriptManager.getScripts().forEach((script) =&gt; { LOG.debug(method, 'Processing script', script.getIdentifier()); this.processScript(context, script); }); LOG.exit(method); } /** * Process the specified script by processing the function declarations in the script, * then convert the script into a script node and add it to the root node. * @param {Object} context The compiler context. * @param {Script} script The script to process. */ processScript(context, script) { const method = 'processScript'; LOG.entry(method, context, script); // Convert the script into a script node, and add it to the root node. const scriptNode = this.convertScriptToScriptNode(context, script); context.rootNode.add(scriptNode); LOG.exit(method); } /** * Process the specified ACL manager by processing the ACL rules in the ACL manager. * @param {Object} context The compiler context. * @param {AclManager} aclManager The ACL manager to process. */ processAclManager(context, aclManager) { const method = 'processAclManager'; LOG.entry(method, context, aclManager); // Process all of the scripts in the script manager. aclManager.getAclRules().forEach((aclRule) =&gt; { LOG.debug(method, 'Processing ACL rule', aclRule.getName()); this.processAclRule(context, aclRule); }); LOG.exit(method); } /** * Process the specified ACL rule by compiling the predicate expression, * if one exists in the ACL rule. * @param {Object} context The compiler context. * @param {AclRule} aclRule The ACL rule to process. */ processAclRule(context, aclRule) { const method = 'processAclRule'; LOG.entry(method, context, aclRule); // Get the expression from the ACL rule. context.aclRules.push(aclRule); const name = aclRule.getName(); const predicate = aclRule.getPredicate(); const expression = predicate.getExpression(); // Check to see if the resource needs to be bound. let resourceVarName = '__resource'; let resourceVar = aclRule.getNoun().getVariableName(); if (resourceVar) { resourceVarName = resourceVar; } // Check to see if the participant needs to be bound. let participantVarName = '__participant'; let reqParticipant = aclRule.getParticipant(); if (reqParticipant) { let participantVar = aclRule.getParticipant().getVariableName(); if (participantVar) { participantVarName = participantVar; } } // Check to see if the transaction needs to be bound. let transactionVarName = '__transaction'; let reqTransaction = aclRule.getTransaction(); if (reqTransaction) { let transactionVar = aclRule.getTransaction().getVariableName(); if (transactionVar) { transactionVarName = transactionVar; } } // Create a function for the ACL rule. const argNames = [resourceVarName, participantVarName, transactionVarName]; const joinedArgNames = argNames.join(','); context.rootNode.add(`function ${name}(${joinedArgNames}) {\\n`); context.rootNode.add(` return (${expression});\\n`); context.rootNode.add('}\\n'); LOG.exit(method); } /** * Convert the specified script into a source map. * @param {Object} context The compiler context. * @param {Script} script The function declaration to process. * @return {String} The source map. */ convertScriptToSourceMap(context, script) { const method = 'convertScriptToSourceMap'; LOG.entry(method, context, script); // Create a new source map generator. const sourceMapGenerator = new SourceMapGenerator({ file: script.getIdentifier(), sourceRoot: process.cwd() }); // Get the parser tokens for the script. const tokens = script.getTokens(); // Add mappings for all of the tokens into the source map. tokens.forEach((token) =&gt; { sourceMapGenerator.addMapping({ source: script.getIdentifier(), original: token.loc.start, generated: token.loc.start }); }); // Inline the contents of the script into the source map. sourceMapGenerator.setSourceContent(script.getIdentifier(), script.getContents()); // Return the source map. const result = sourceMapGenerator.toString(); LOG.exit(method, result); return result; } /** * Convert the specified script into a script node with a source map. * @param {Object} context The compiler context. * @param {Script} script The function declaration to process. * @return {SourceNode} The script node. */ convertScriptToScriptNode(context, script) { const method = 'convertScriptToScriptNode'; LOG.entry(method, context, script); // Convert the script into a source map. let sourceFileName = script.getIdentifier(); let sourceCode = script.getContents(); let sourceMap = this.convertScriptToSourceMap(context, script); // Allow someone else to post-process the converted script. const transformedScript = this.transformScript(sourceFileName, sourceCode, sourceMap); sourceFileName = transformedScript.sourceFileName; sourceCode = transformedScript.sourceCode; sourceMap = transformedScript.sourceMap; // Create a new source node from the script contents and source map const sourceMapConsumer = new SourceMapConsumer(sourceMap); const result = SourceNode.fromStringWithSourceMap(sourceCode, sourceMapConsumer); LOG.exit(method, result); return result; } /** * Optional hook to transform a script into another format, for example * by using a code coverage instrumenter. * @param {String} sourceFileName The file name for the script. * @param {String} sourceCode The source code for the script. * @param {String} sourceMap The source map for the script. * @return {Object} The transformed script. */ transformScript(sourceFileName, sourceCode, sourceMap) { const method = 'transformScript'; LOG.entry(method, sourceFileName, sourceCode, sourceMap); const result = { sourceFileName: sourceFileName, sourceCode: sourceCode, sourceMap: sourceMap }; LOG.exit(method, result); return result; } } module.exports = AclCompiler; × Search results Close "},"composer-admin_lib_adminconnection.js.html":{"id":"composer-admin_lib_adminconnection.js.html","title":"Source: composer-admin/lib/adminconnection.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-admin/lib/adminconnection.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ComboConnectionProfileStore = require('composer-common').ComboConnectionProfileStore; const ConnectionProfileManager = require('composer-common').ConnectionProfileManager; const EnvConnectionProfileStore = require('composer-common').EnvConnectionProfileStore; const fs = require('fs'); const FSConnectionProfileStore = require('composer-common').FSConnectionProfileStore; const Logger = require('composer-common').Logger; const Util = require('composer-common').Util; const uuid = require('uuid'); const LOG = Logger.getLog('AdminConnection'); /** * This class creates an administration connection to a Hyperledger Composer runtime. The * connection can then be used to: * &lt;ul&gt; * &lt;li&gt;Deploy BusinessNetworkDefinitions&lt;/li&gt; * &lt;li&gt;Undeploy BusinessNetworkDefinitions&lt;/li&gt; * &lt;li&gt;Update BusinessNetworkDefinitions&lt;/li&gt; * &lt;li&gt;Send a ping message to the runtime to ensure it is running and * correctly configured.&lt;/li&gt; * &lt;li&gt;Store a connection profile document in the connection profile store&lt;/li&gt; * &lt;/ul&gt; * Note: that the methods on this class take the 'businessNetworkIdentifier'; this has to match * the name given on the create call. An AdminConnection that has been connected to network-A can * only be used to adminster network-A. * * Instances of AdminConnections can be reused for different networks. Call disconnect(..) then connect(..). * Calling an api after disconnect and before connect will give an error. * @class * @memberof module:composer-admin */ class AdminConnection { /** * Create an instance of the AdminConnection class. * @param {Object} [options] - an optional set of options to configure the instance. * @param {ConnectionProfileStore} [options.connectionProfileStore] - specify a connection profile store to use. * @param {Object} [options.fs] - specify an fs implementation to use. */ constructor(options) { const method = 'constructor'; LOG.entry(method, options); options = options || {}; let connectionProfileStore; if (options.connectionProfileStore) { LOG.debug(method, 'Using connection profile store from options'); connectionProfileStore = options.connectionProfileStore; } else { LOG.debug(method, 'Creating new file system connection profile store'); connectionProfileStore = new FSConnectionProfileStore(options.fs || fs); } if (process.env.COMPOSER_CONFIG) { LOG.debug(method, 'Enabling environment connection profile store'); const envConnectionProfileStore = new EnvConnectionProfileStore(); connectionProfileStore = new ComboConnectionProfileStore( connectionProfileStore, envConnectionProfileStore ); } this.connectionProfileStore = connectionProfileStore; this.connectionProfileManager = new ConnectionProfileManager(this.connectionProfileStore); this.connection = null; this.securityContext = null; LOG.exit(method); } // ---- connection profile methods that will be replaced by business network card support /** * Stores a connection profile into the profile store being used by this * AdminConnection. * @example * // Create a connection profile * var adminConnection = new AdminConnection(); * var adminOptions = { * type: 'hlf', * keyValStore: '/tmp/keyValStore', * membershipServicesURL: 'grpc://membersrvc:7054', * peerURL: 'grpc://vp0:7051', * eventHubURL: 'grpc://vp0:7053' * }; * return adminConnection.createProfile('testprofile', adminOptions) * .then(function(){ * // Created profile * }) * .catch(function(error){ * // Add optional error handling here. * }); * @param {string} connectionProfile - The name of the connection profile * @param {Object} data - The connection profile data * @return {Promise} A promise that indicates that the connection profile is deployed */ createProfile(connectionProfile, data) { return this.connectionProfileManager.getConnectionProfileStore().save(connectionProfile, data); } /** * Deletes the specified connection profile from the profile store being used by this * AdminConnection. * @example * // Delete a connection profile * var adminConnection = new AdminConnection(); * return adminConnection.deleteProfile('testprofile') * .then(function(){ * // Deleted profile * }) * .catch(function(error){ * // Add optional error handling here. * }); * @param {string} connectionProfile - The name of the connection profile * @return {Promise} A promise that indicates that the connection profile is deployed */ deleteProfile(connectionProfile) { return this.connectionProfileManager.getConnectionProfileStore().delete(connectionProfile); } /** * Retrieve the specified connection profile from the profile store being * used by this AdminConnection. * @example * // Retrieve the connection profile. * const adminConnection = new AdminConnection(); * return adminConnection.getProfile('testprofile') * .then((profile) =&gt; { * // Retrieved profile * console.log(profile); * }); * @param {string} connectionProfile - The name of the connection profile * @return {Promise} A promise that is resolved with the connection profile data. */ getProfile(connectionProfile) { return this.connectionProfileManager.getConnectionProfileStore().load(connectionProfile); } /** * Retrieve all connection profiles from the profile store being used by this * AdminConnection. * @example * // Retrieve all the connection profiles. * const adminConnection = new AdminConnection(); * return adminConnection.getAllProfiles() * .then((profiles) =&gt; { * // Retrieved profiles * for (let profile in profiles) { * console.log(profile, profiles[profile]); * } * }); * @return {Promise} A promise that is resolved with the connection profile data. */ getAllProfiles() { return this.connectionProfileManager.getConnectionProfileStore().loadAll(); } // admin connection methods... /** * Connects and logs in to the Hyperledger Fabric using a named connection * profile. * * The connection profile must exist in the profile store. * @example * // Connect to Hyperledger Fabric * var adminConnection = new AdminConnection(); * adminConnection.connect('testprofile', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(){ * // Connected. * }) * .catch(function(error){ * // Add optional error handling here. * }); * @param {string} connectionProfile - The name of the connection profile * @param {string} enrollmentID the enrollment ID of the user * @param {string} enrollmentSecret the enrollment secret of the user * @param {string} businessNetworkIdentifier the id of the network (for update) or null * @return {Promise} A promise that indicates the connection is complete */ connect(connectionProfile, enrollmentID, enrollmentSecret, businessNetworkIdentifier) { return this.connectionProfileManager.connect(connectionProfile, businessNetworkIdentifier) .then((connection) =&gt; { this.connection = connection; return connection.login(enrollmentID, enrollmentSecret); }) .then((securityContext) =&gt; { this.securityContext = securityContext; if (businessNetworkIdentifier) { return this.ping(this.securityContext); } }); } /** * Disconnects this connection.securityContext * @example * // Disconnect from a Business Network * var adminConnection = new AdminConnection(); * return adminConnection.disconnect() * .then(function(){ * // Disconnected. * }) * .catch(function(error){ * // Add optional error handling here. * }); * @return {Promise} A promise that will be resolved when the connection is * terminated. */ disconnect() { if (!this.connection) { return Promise.resolve(); } return this.connection.disconnect() .then(() =&gt; { this.connection = null; this.securityContext = null; }); } /** * Installs the Hyperledger Composer runtime to the Hyperledger Fabric in preparation * for the business network to be started. The connection mustbe connected for this method to succeed. * You must pass the name of the business network that is defined in your archive that this * runtime will be started with. * @example * // Install the Hyperledger Composer runtime * var adminConnection = new AdminConnection(); * var businessNetworkDefinition = BusinessNetworkDefinition.fromArchive(myArchive); * return adminConnection.install(businessNetworkDefinition.getName()) * .then(function(){ * // Business network definition installed * }) * .catch(function(error){ * // Add optional error handling here. * }); * @param {BusinessNetworkIdentifier} businessNetworkIdentifier - The name of business network which will be used to start this runtime. * @param {Object} installOptions connector specific install options * @return {Promise} A promise that will be fufilled when the business network has been * deployed. */ install(businessNetworkIdentifier, installOptions) { return Promise.resolve().then(()=&gt;{ Util.securityCheck(this.securityContext); return this.connection.install(this.securityContext, businessNetworkIdentifier, installOptions); }); } /** * Get the current identity. * @private * @return {Promise} A promise that will be fufilled with the current identity. */ _getCurrentIdentity() { const method = '_getCurrentIdentity'; LOG.entry(method); let identityName = this.securityContext.getUser(); LOG.debug(method, 'Current identity name', identityName); return this.exportIdentity(this.connection.connectionProfile, identityName) .then((identity) =&gt; { LOG.exit(method, identity); return identity; }); } /** * Generate an array of bootstrap transactions for the business network. * @private * @param {Factory} factory The factory to use. * @param {string} identityName The name of the current identity. * @param {string} identityCertificate The certificate for the current identity. * @return {Resource[]} An array of bootstrap transactions for the business network. */ _generateBootstrapTransactions(factory, identityName, identityCertificate) { const method = '_generateBootstrapTransactions'; LOG.entry(method); const participant = factory.newResource('org.hyperledger.composer.system', 'NetworkAdmin', identityName); const targetRegistry = factory.newRelationship('org.hyperledger.composer.system', 'ParticipantRegistry', participant.getFullyQualifiedType()); const addParticipantTransaction = factory.newTransaction('org.hyperledger.composer.system', 'AddParticipant'); Object.assign(addParticipantTransaction, { resources: [ participant ], targetRegistry }); LOG.debug(method, 'Created bootstrap transaction to add participant', addParticipantTransaction); const bindIdentityTransaction = factory.newTransaction('org.hyperledger.composer.system', 'BindIdentity'); Object.assign(bindIdentityTransaction, { participant: factory.newRelationship('org.hyperledger.composer.system', 'NetworkAdmin', identityName), certificate: identityCertificate }); LOG.debug(method, 'Created bootstrap transaction to bind identity', bindIdentityTransaction); const result = [ addParticipantTransaction, bindIdentityTransaction ]; LOG.exit(method, result); return result; } /** * Build the JSON for the start transaction. * @private * @param {BusinessNetworkDefinition} businessNetworkDefinition The business network definition. * @param {Object} [startOptions] The options for starting the business network. * @return {Promise} A promise that will be fufilled with the JSON for the start transaction. */ _buildStartTransaction(businessNetworkDefinition, startOptions = {}) { const method = '_buildStartTransaction'; LOG.entry(method, businessNetworkDefinition, startOptions); // Get the current identity - we may need it to bind the // identity to a network admin participant. let identityName, identityCertificate; return this._getCurrentIdentity() .then((identity) =&gt; { // Extract the current identity name and certificate. identityName = this.securityContext.getUser(); identityCertificate = identity.certificate; // Now serialize the business network archive. return businessNetworkDefinition.toArchive(); }) .then((businessNetworkArchive) =&gt; { // Create a new instance of a start transaction. const factory = businessNetworkDefinition.getFactory(); const serializer = businessNetworkDefinition.getSerializer(); const startTransaction = factory.newTransaction('org.hyperledger.composer.system', 'StartBusinessNetwork'); const classDeclaration = startTransaction.getClassDeclaration(); startTransaction.businessNetworkArchive = businessNetworkArchive.toString('base64'); // If the user has not supplied any bootstrap transactions, then we need // to add some: // 1) Create a NetworkAdmin participant for the current identity. // 2) Bind the current identity to the new NetworkAdmin participant. if (!startOptions.bootstrapTransactions || startOptions.bootstrapTransactions.length === 0) { LOG.debug(method, 'No bootstrap transactions specified'); startTransaction.bootstrapTransactions = this._generateBootstrapTransactions(factory, identityName, identityCertificate); delete startOptions.bootstrapTransactions; } // Otherwise, parse all of the supplied bootstrap transactions. if (startOptions.bootstrapTransactions) { startTransaction.bootstrapTransactions = startOptions.bootstrapTransactions.map((bootstrapTransactionJSON) =&gt; { return serializer.fromJSON(bootstrapTransactionJSON); }); delete startOptions.bootstrapTransactions; } // Now handle the rest of the properties in the start options. Object.keys(startOptions).forEach((key) =&gt; { LOG.debug(method, 'Checking start option', key); if (classDeclaration.getProperty(key)) { const value = startOptions[key]; LOG.debug(method, 'Start option is a property of the start transaction', key, value); startTransaction[key] = value; delete startOptions[key]; } }); // Now we can start the business network. const startTransactionJSON = serializer.toJSON(startTransaction); LOG.exit(method, startTransactionJSON); return startTransactionJSON; }); } /** * Starts a business network within the runtime previously installed to the Hyperledger Fabric with * the same name as the business network to be started. The connection must be connected for this * method to succeed. * @example * // Start a Business Network Definition * var adminConnection = new AdminConnection(); * var businessNetworkDefinition = BusinessNetworkDefinition.fromArchive(myArchive); * return adminConnection.start(businessNetworkDefinition) * .then(function(){ * // Business network definition is started * }) * .catch(function(error){ * // Add optional error handling here. * }); * @param {BusinessNetworkDefinition} businessNetworkDefinition - The business network to start * @param {Object} [startOptions] connector specific start options * @return {Promise} A promise that will be fufilled when the business network has been * deployed. */ start(businessNetworkDefinition, startOptions = {}) { const method = 'start'; LOG.entry(method, businessNetworkDefinition, startOptions); Util.securityCheck(this.securityContext); // Build the start transaction. return this._buildStartTransaction(businessNetworkDefinition, startOptions) .then((startTransactionJSON) =&gt; { // Now we can start the business network. return this.connection.start(this.securityContext, businessNetworkDefinition.getName(), JSON.stringify(startTransactionJSON), startOptions); }) .then(() =&gt; { LOG.exit(method); }); } /** * Deploys a new BusinessNetworkDefinition to the Hyperledger Fabric. The connection must * be connected for this method to succeed. * @example * // Deploy a Business Network Definition * var adminConnection = new AdminConnection(); * var businessNetworkDefinition = BusinessNetworkDefinition.fromArchive(myArchive); * return adminConnection.deploy(businessNetworkDefinition) * .then(function(){ * // Business network definition deployed * }) * .catch(function(error){ * // Add optional error handling here. * }); * @param {BusinessNetworkDefinition} businessNetworkDefinition - The business network to deploy * @param {Object} deployOptions connector specific deployment options * @return {Promise} A promise that will be fufilled when the business network has been * deployed. */ deploy(businessNetworkDefinition, deployOptions = {}) { const method = 'deploy'; LOG.entry(method, businessNetworkDefinition, deployOptions); Util.securityCheck(this.securityContext); // Build the start transaction. return this._buildStartTransaction(businessNetworkDefinition, deployOptions) .then((startTransactionJSON) =&gt; { // Now we can deploy the business network. return this.connection.deploy(this.securityContext, businessNetworkDefinition.getName(), JSON.stringify(startTransactionJSON), deployOptions); }) .then(() =&gt; { LOG.exit(method); }); } /** * Undeploys a BusinessNetworkDefinition from the Hyperledger Fabric. The business network will no * longer be able to process transactions. * @example * // Undeploy a Business Network Definition * var adminConnection = new AdminConnection(); * return adminConnection.undeploy('identifier') * .then(function(){ * // Undeployed Business Network Definition * }) * .catch(function(error){ * // Add optional error handling here. * }) * @param {BusinessNetworkIdentifier} businessNetworkIdentifier - The name of business network that will be used to start this runtime. * @return {Promise} A promise that will be fufilled when the business network has been * undeployed. */ undeploy(businessNetworkIdentifier) { return Promise.resolve().then(()=&gt;{ Util.securityCheck(this.securityContext); return this.connection.undeploy(this.securityContext,businessNetworkIdentifier); }); } /** * Updates an existing BusinessNetworkDefinition on the Hyperledger Fabric. The BusinessNetworkDefinition * must have been previously deployed. * @example * // Updates a Business Network Definition * var adminConnection = new AdminConnection(); * var businessNetworkDefinition = BusinessNetworkDefinition.fromArchive(myArchive); * return adminConnection.update(businessNetworkDefinition) * .then(function(){ * // Business network definition updated * }) * .catch(function(error){ * // Add optional error handling here. * }); * @param {BusinessNetworkDefinition} businessNetworkDefinition - The new BusinessNetworkDefinition * @return {Promise} A promise that will be fufilled when the business network has been * updated. */ update(businessNetworkDefinition) { return Promise.resolve().then(()=&gt;{ Util.securityCheck(this.securityContext); return this.connection.update(this.securityContext, businessNetworkDefinition); }); } /** * Resets an existing BusinessNetworkDefinition on the Hyperledger Fabric. The BusinessNetworkDefinition * must have been previously deployed. * * Note this will remove ALL the contents of the network registries, but not any system registries * * @example * // Updates a Business Network Definition * var adminConnection = new AdminConnection(); * var businessNetworkDefinition = BusinessNetworkDefinition.fromArchive(myArchive); * return adminConnection.reset(businessNetworkDefinition) * .then(function(){ * // Business network definition updated * }) * .catch(function(error){ * // Add optional error handling here. * }); * @param {BusinessNetworkIdentifier} businessNetworkIdentifier - The name of business network that will be reset * @return {Promise} A promise that will be fufilled when the business network has been * updated. */ reset(businessNetworkIdentifier){ return Promise.resolve().then(()=&gt;{ Util.securityCheck(this.securityContext); return this.connection.reset(this.securityContext,businessNetworkIdentifier); }); } /** * Upgrades an existing business network's composer runtime to a later level. * The connection must be connected specifying the business network identifier as part of the * connection for this method to succeed. * @return {Promise} A promise that will be fufilled when the composer runtime has been upgraded, * or rejected otherwise. * @example * // Upgrade the Hyperledger Composer runtime * var adminConnection = new AdminConnection(); * var businessNetworkDefinition = BusinessNetworkDefinition.fromArchive(myArchive); * return adminConnection.connect(connectionProfileName, upgradeId, upgradeSecret, businessNetworkDefinition.getName()) * .then(() =&gt; { * return adminConnection.upgrade(); * }) * .then(() =&gt; { * // Business network definition upgraded * }) * .catch((error) =&gt; { * // Add optional error handling here. * }); * @memberof AdminConnection */ upgrade() { return Promise.resolve().then(()=&gt;{ Util.securityCheck(this.securityContext); return this.connection.upgrade(this.securityContext); }); } /** * Test the connection to the runtime and verify that the version of the * runtime is compatible with this level of the node.js module. * @example * // Test the connection to the runtime * var adminConnection = new AdminConnection(); * return adminConnection.ping() * .then(function(){ * // Connection has been tested * }) * .catch(function(error){ * // Add optional error handling here. * }); * @return {Promise} A promise that will be fufilled when the connection has * been tested. The promise will be rejected if the version is incompatible. */ ping() { const method = 'ping'; LOG.entry(method); return this.pingInner() .catch((error) =&gt; { if (error.message.match(/ACTIVATION_REQUIRED/)) { LOG.debug(method, 'Activation required, activating ...'); return this.activate() .then(() =&gt; { return this.pingInner(); }); } throw error; }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Test the connection to the runtime and verify that the version of the * runtime is compatible with this level of the client node.js module. * @private * @return {Promise} A promise that will be fufilled when the connection has * been tested. The promise will be rejected if the version is incompatible. */ pingInner() { const method = 'pingInner'; LOG.entry(method); return Promise.resolve().then(()=&gt;{ Util.securityCheck(this.securityContext); return this.connection.ping(this.securityContext); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Activate the current identity on the currently connected business network. * @private * @return {Promise} A promise that will be fufilled when the connection has * been tested. The promise will be rejected if the version is incompatible. */ activate() { const method = 'activate'; LOG.entry(method); const json = { $class: 'org.hyperledger.composer.system.ActivateCurrentIdentity', transactionId: uuid.v4(), timestamp: new Date().toISOString() }; return Util.invokeChainCode(this.securityContext, 'submitTransaction', [JSON.stringify(json)]) .then(() =&gt; { LOG.exit(method); }); } /** * Set the logging level of a business network. The connection must * be connected for this method to succeed. * @example * // Set the logging level of a business network. * var adminConnection = new AdminConnection(); * return adminConnection.setLogLevel('DEBUG') * .then(() =&gt; { * console.log('log level set to DEBUG'); * }) * .catch(function(error){ * // Add optional error handling here. * }); * * @param {any} newLogLevel new logging level * @returns {Promise} A promise that resolves if successful. * @memberof AdminConnection */ setLogLevel(newLogLevel) { return Promise.resolve().then(()=&gt;{ Util.securityCheck(this.securityContext); return this.connection.setLogLevel(this.securityContext, newLogLevel); }); } /** * Get the current logging level of a business network. The connection must * be connected for this method to succeed. * @example * // Get the current logging level of a business network. * var adminConnection = new AdminConnection(); * return adminConnection.getLogLevel() * .then((currentLogLevel) =&gt; { * console.log('current log level is ' + currentLogLevel); * }) * .catch(function(error){ * // Add optional error handling here. * }); * * @returns {Promise} A promise that resolves with the current logging level if successful. * @memberof AdminConnection */ getLogLevel() { return Promise.resolve().then(()=&gt;{ Util.securityCheck(this.securityContext); return this.connection.queryChainCode(this.securityContext, 'getLogLevel', []); }) .then((response) =&gt; { console.log(response.toString()); return Promise.resolve(JSON.parse(response)); }); } /** * List all of the deployed business networks. The connection must * be connected for this method to succeed. * @example * // List all of the deployed business networks. * var adminConnection = new AdminConnection(); * return adminConnection.list() * .then((businessNetworks) =&gt; { * // Connection has been tested * return businessNetworks.forEach((businessNetwork) =&gt; { * console.log('Deployed business network', businessNetwork); * }); * }) * .catch(function(error){ * // Add optional error handling here. * }); * @return {Promise} A promise that will be resolved with an array of * business network identifiers, or rejected with an error. */ list() { return Promise.resolve().then(()=&gt;{ Util.securityCheck(this.securityContext); return this.connection.list(this.securityContext); }); } /** * Import an identity into a profiles' wallet. No connection needs to be established * for this method to succeed. * @example * // Import an identity into a profiles' wallet * var adminConnection = new AdminConnection(); * return adminConnection.importIdentity('hlfv1', 'PeerAdmin', certificate, privateKey) * .then(() =&gt; { * // Identity imported * console.log('identity imported successfully'); * }) * .catch(function(error){ * // Add optional error handling here. * }); * * @param {string} connectionProfile Name of the connection profile * @param {string} id The id to associate with this identity * @param {string} certificate The signer cert in PEM format * @param {string} privateKey The private key in PEM format * @returns {Promise} A promise which is resolved when the identity is imported */ importIdentity(connectionProfile, id, certificate, privateKey) { let savedConnectionManager; return this.connectionProfileManager.getConnectionManager(connectionProfile) .then((connectionManager) =&gt; { savedConnectionManager = connectionManager; return this.getProfile(connectionProfile); }) .then((profileData) =&gt; { return savedConnectionManager.importIdentity(connectionProfile, profileData, id, certificate, privateKey); }) .catch((error) =&gt; { throw new Error('failed to import identity. ' + error.message); }); } /** * Request the certificates for an identity. No connection needs to be established * for this method to succeed. * @example * // Request the cryptographic material for am identity of a hlf v1 environment. * var adminConnection = new AdminConnection(); * return adminConnection.requestIdentity('hlfv1', 'admin', 'adminpw') * .then((response) =&gt; { * // Identity returned * console.log('public signing certificate:'); * console.log(response.certificate); * console.log('private key:'); * console.log(response.key); * console.log('ca root certificate:'); * console.log(response.rootCertificate); * }) * .catch(function(error){ * // Add optional error handling here. * }); * * @param {string} connectionProfile Name of the connection profile * @param {string} enrollmentID The ID to enroll * @param {string} enrollmentSecret The secret for the ID * @returns {Promise} A promise which is resolved when the identity is imported */ requestIdentity(connectionProfile, enrollmentID, enrollmentSecret) { let savedConnectionManager; return this.connectionProfileManager.getConnectionManager(connectionProfile) .then((connectionManager) =&gt; { savedConnectionManager = connectionManager; return this.getProfile(connectionProfile); }) .then((profileData) =&gt; { return savedConnectionManager.requestIdentity(connectionProfile, profileData, enrollmentID, enrollmentSecret); }) .catch((error) =&gt; { throw new Error('failed to request identity. ' + error.message); }); } /** * Obtain the credentials associated with a given identity. * @param {String} connectionProfileName Name of the connection profile. * @param {String} id Name of the identity. * @return {Promise} Resolves to credentials in the form &lt;em&gt;{ certificate: String, privateKey: String }&lt;/em&gt;. */ exportIdentity(connectionProfileName, id) { let savedConnectionManager; return this.connectionProfileManager.getConnectionManager(connectionProfileName) .then((connectionManager) =&gt; { savedConnectionManager = connectionManager; return this.getProfile(connectionProfileName); }) .then((profileData) =&gt; { return savedConnectionManager.exportIdentity(connectionProfileName, profileData, id); }) .catch((cause) =&gt; { const error = new Error(`Failed to obtain credentials for ${id}: ${cause.message}`); error.cause = cause; throw error; }); } } module.exports = AdminConnection; × Search results Close "},"composer-runtime_lib_compiledaclbundle.js.html":{"id":"composer-runtime_lib_compiledaclbundle.js.html","title":"Source: composer-runtime/lib/compiledaclbundle.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/compiledaclbundle.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const LOG = Logger.getLog('CompiledAclBundle'); /** * A script compiler compiles all scripts in a script manager into a compiled * script bundle that can easily be called by the runtime. * @protected */ class CompiledAclBundle { /** * Constructor. * @param {AclRule[]} aclRules The ACL rules to use. * @param {Function} generatorFunction The generator function to use. */ constructor(aclRules, generatorFunction) { this.aclRules = aclRules; this.generatorFunction = generatorFunction; } /** * Execute the specified ACL rule. * @param {AclRule} aclRule The ACL rule to execute. * @param {Resource} resource The resource being accessed. * @param {Resource} participant The participant attempting the operation. * @param {Resource} transaction The transaction, if any, that is currently executing. * @return {Promise} A promise that is resolved when the transaction has been * executed, or rejected with an error. */ execute(aclRule, resource, participant, transaction) { const method = 'execute'; LOG.entry(method, aclRule, resource, participant, transaction); // Check to see that the ACL rule is present. const exists = this.aclRules.find((thisAclRule) =&gt; { return thisAclRule.getName() === aclRule.getName(); }); if (!exists) { throw new Error(`The ACL rule ${aclRule.getName()} does not exist`); } // Generate an instance of the compiled ACL bundle. const bundle = this.generatorFunction(); // Execute the function. const functionName = aclRule.getName(); const func = bundle[functionName]; let funcResult; try { LOG.debug(method, 'Executing function', functionName); funcResult = func(resource, participant, transaction); LOG.debug(method, 'Function returned', funcResult); } catch (e) { LOG.debug(method, 'Function threw error', e); } // Force the result to be a boolean. const result = !!funcResult; LOG.exit(method, result); return result; } } module.exports = CompiledAclBundle; × Search results Close "},"composer-runtime_lib_compiledquerybundle.js.html":{"id":"composer-runtime_lib_compiledquerybundle.js.html","title":"Source: composer-runtime/lib/compiledquerybundle.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/compiledquerybundle.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const createHash = require('sha.js'); const Logger = require('composer-common').Logger; const LOG = Logger.getLog('CompiledQueryBundle'); /** * A script compiler compiles all scripts in a script manager into a compiled * script bundle that can easily be called by the runtime. * @protected */ class CompiledQueryBundle { /** * Constructor. * @param {QueryCompiler} queryCompiler The query compiler to use. * @param {QueryManager} queryManager The query manager to use. * @param {Object[]} compiledQueries The compiled queries to use. */ constructor(queryCompiler, queryManager, compiledQueries) { const method = 'constructor'; LOG.entry(method, queryCompiler, queryManager, compiledQueries); this.queryCompiler = queryCompiler; this.queryManager = queryManager; this.compiledQueries = compiledQueries; this.compiledQueriesByName = {}; compiledQueries.forEach((compiledQuery) =&gt; { this.compiledQueriesByName[compiledQuery.name] = compiledQuery; this.compiledQueriesByName[compiledQuery.hash] = compiledQuery; }); this.dynamicQueryFile = queryManager.createQueryFile('$dynamic_queries.qry', ''); LOG.exit(method); } /** * Build and compile a query for use at a later time. * @param {string} query The query string. * @return {string} An identifier for the query. */ buildQuery(query) { const method = 'buildQuery'; LOG.entry(method, query); // Hash the query string. const sha256 = createHash('sha256'); const hash = sha256.update(query, 'utf8').digest('hex'); LOG.debug(method, 'Calculated query hash', hash); // Check to see if the query exists by name. let compiledQuery = this.compiledQueriesByName[hash]; if (compiledQuery) { LOG.debug(method, 'Compiled query already exists'); LOG.exit(method, hash); return hash; } else { LOG.debug(method, 'Compiled query does not exist, compiling'); } // Create a new query. const newQuery = this.dynamicQueryFile.buildQuery(hash, 'Dynamic query ' + hash, query); compiledQuery = newQuery.accept(this.queryCompiler, {}); // Store the query for later. this.compiledQueriesByName[compiledQuery.name] = compiledQuery; LOG.exit(method, hash); return hash; } /** * Execute the specified query. * @param {DataService} dataService The data service to use. * @param {string} query The name of the query, or the query itself. * @param {Object} [parameters] The parameters provided for the query. * @return {Promise} A promise that is resolved with the results of the * query, or rejected with an error. */ execute(dataService, query, parameters) { const method = 'execute'; LOG.entry(method, dataService, query, parameters); // Check to see if the query exists by name. let compiledQuery = this.compiledQueriesByName[query]; if (!compiledQuery) { throw new Error('The specified query does not exist'); } // Return the results of executing the query. LOG.debug(method, 'Found query by name lookup'); return this.executeInternal(dataService, compiledQuery, parameters) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Execute the specified query. * @param {DataService} dataService The data service to use. * @param {Object} compiledQuery The compiled query. * @param {Object} [parameters] The parameters provided for the query. * @return {Promise} A promise that is resolved with the results of the * query, or rejected with an error. */ executeInternal(dataService, compiledQuery, parameters) { const method = 'executeInternal'; LOG.entry(method, dataService, compiledQuery, parameters); // Set the parameters if not provided. parameters = parameters || {}; // Get the compiled query string. const compiledQueryString = compiledQuery.generator(parameters); // Execute the compiled query string. return dataService.executeQuery(compiledQueryString) .then((result) =&gt; { LOG.exit(method, result); return result; }); } } module.exports = CompiledQueryBundle; × Search results Close "},"composer-runtime_lib_compiledscriptbundle.js.html":{"id":"composer-runtime_lib_compiledscriptbundle.js.html","title":"Source: composer-runtime/lib/compiledscriptbundle.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/compiledscriptbundle.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const LOG = Logger.getLog('CompiledScriptBundle'); /** * A script compiler compiles all scripts in a script manager into a compiled * script bundle that can easily be called by the runtime. * @protected */ class CompiledScriptBundle { /** * Constructor. * @param {FunctionDeclaration[]} functionDeclarations The function declarations to use. * @param {Function} generatorFunction The generator function to use. */ constructor(functionDeclarations, generatorFunction) { this.functionDeclarations = functionDeclarations; this.generatorFunction = generatorFunction; } /** * Execute the specified transaction. * @param {Api} api The API to use. * @param {Resource} resolvedTransaction The resolved transaction to execute. * @return {Promise} A promise that is resolved when the transaction has been * executed, or rejected with an error. */ execute(api, resolvedTransaction) { const method = 'execute'; LOG.entry(method, api, resolvedTransaction); // Find all of the function names. const functionNames = this.findFunctionNames(resolvedTransaction); // Generate an instance of the compiled script bundle. const bundle = this.generatorFunction(api); // Execute each function for the transaction. return functionNames.reduce((result, functionName) =&gt; { return result.then(() =&gt; { LOG.debug(method, 'Executing function', functionName); const func = bundle[functionName]; const funcResult = func(resolvedTransaction); if (funcResult &amp;&amp; typeof funcResult.then === 'function') { return funcResult.then(() =&gt; { LOG.debug(method, 'Function executed (returned promise)'); }); } else { LOG.debug(method, 'Function executed'); } }); }, Promise.resolve()) .then(() =&gt; { LOG.exit(method, functionNames.length); return functionNames.length; }); } /** * Find all of the function names that should be executed. * @param {Resource} transaction The transaction to execute. * @return {string[]} All function names to execute. */ findFunctionNames(transaction) { const method = 'findFunctionNames'; LOG.entry(method, transaction); // Look at all the functions. const functionNames = []; this.functionDeclarations.forEach((functionDeclaration) =&gt; { // Is this function annotated with @transaction? LOG.debug(method, 'Looking at function declaration', functionDeclaration.getName()); if (functionDeclaration.getDecorators().indexOf('transaction') !== -1) { // Yes - is the type of the only parameter (validated elsewhere) // the same type as the transaction? LOG.debug(method, 'Function is annotated with @transaction'); if (functionDeclaration.getParameterTypes()[0] === transaction.getFullyQualifiedType()) { LOG.debug(method, 'Function parameter type matches transaction'); functionNames.push(functionDeclaration.getName()); } else { LOG.debug(method, 'Function parameter type does not match transaction'); } // It's not annotated with @transaction, does it start with on&lt;transactionType&gt;? // This is to keep supporting the original transaction processor function format // which went by naming conventions rather than annotations. } else if (functionDeclaration.getTransactionDeclarationName() === transaction.getType()) { LOG.debug(method, 'Function name matches on&lt;transactionType&gt;'); functionNames.push(functionDeclaration.getName()); // Must be a query or utility function. } else { LOG.debug(method, 'Function is query or utility function'); } }); LOG.exit(method, functionNames); return functionNames; } } module.exports = CompiledScriptBundle; × Search results Close "},"composer-common_lib_log_consolelogger.js.html":{"id":"composer-common_lib_log_consolelogger.js.html","title":"Source: composer-common/lib/log/consolelogger.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/log/consolelogger.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const util = require('util'); /** * A functional logger implementation that simply writes to the console. */ class ConsoleLogger { /** * Called to format. * @param {string} method The method. * @param {string} msg The message. * @param {*} [args] The arguments. * @returns {string} The formatted message. */ format(method, msg, args) { if (!args) { return util.format('%s %s', method, msg); } let formattedArguments = args.map((arg) =&gt; { if (typeof(arg) === 'function') { return '&lt;function&gt;'; } else if (arg === Object(arg)) { // It's an object, array, or function, so serialize it as JSON. try { return JSON.stringify(arg); } catch (e) { return arg; } } else { return String(arg); } }).join(', '); return util.format('%s %s %s', method, msg, formattedArguments); } /** * Called to log. * @param {string} level The logging level. * @param {string} method The method. * @param {string} msg The message. * @param {*} [args] The arguments. */ log(level, method, msg, args) { const formattedMessage = this.format(method, msg, args); switch (level) { case 'debug': console.log(formattedMessage); break; case 'warn': console.warn(formattedMessage); break; case 'info': console.info(formattedMessage); break; case 'verbose': console.log(formattedMessage); break; case 'error': console.error(formattedMessage); break; } } } module.exports = ConsoleLogger; × Search results Close "},"composer-common_lib_serializer_valuegenerator.js.html":{"id":"composer-common_lib_serializer_valuegenerator.js.html","title":"Source: composer-common/lib/serializer/valuegenerator.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/serializer/valuegenerator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const loremIpsum = require('lorem-ipsum'); /** * Factory providing static methods to create ValueGenerator instances. * @private */ class ValueGeneratorFactory { /** * Create a value generator that supplies empty values. * @return {ValueGenerator} a value generator. */ static empty() { return new EmptyValueGenerator(); } /** * Create a value generator that supplies randomly generated sample values. * @return {ValueGenerator} a value generator. */ static sample() { return new SampleValueGenerator(); } } /** * Empty value generator. * @private */ class EmptyValueGenerator { /** * This constructor should not be called directly. * @private */ constructor() { this.currentDate = new Date(); } /** * Get a default DateTime value. * @return {Date} a date value. */ getDateTime() { return this.currentDate; } /** * Get a default Integer value. * @return {number} an Integer value. */ getInteger() { return 0; } /** * Get a default Long value. * @return {number} a Long value. */ getLong() { return 0; } /** * Get a default Double value. * @return {number} a Double value. */ getDouble() { return 0.000; } /** * Get a default Boolean value. * @return {boolean} a Boolean value. */ getBoolean() { return false; } /** * Get a default String value. * @return {string} a String value. */ getString() { return ''; } /** * Get the first enum value from the supplied array. * @param {Array} enumValues Array of possible enum values. * @return {*} an enum value. */ getEnum(enumValues) { return enumValues[0]; } /** * Get an array using the supplied callback to obtain array values. * @param {Function} valueSupplier - callback to obtain values. * @return {Array} an array */ getArray(valueSupplier) { return []; } } /** * Sample data value generator. * @private */ class SampleValueGenerator extends EmptyValueGenerator { /** * This constructor should not be called directly. * @private */ constructor() { super(); } /** * Get a randomly generated sample Integer value. * @return {number} an Integer value. */ getInteger() { return Math.round(Math.random() * Math.pow(2, 16)); } /** * Get a randomly generated sample Long value. * @return {number} a Long value. */ getLong() { return Math.round(Math.random() * Math.pow(2, 32)); } /** * Get a randomly generated sample Double value. * @return {number} a Double value. */ getDouble() { return Number((Math.random() * Math.pow(2, 8)).toFixed(3)); } /** * Get a randomly generated sample Boolean value. * @return {boolean} a Boolean value. */ getBoolean() { return Math.round(Math.random()) === 1; } /** * Get a randomly generated sample String value. * @return {string} a String value. */ getString() { return loremIpsum({ count: 1 // Number of words, sentences, or paragraphs to generate. , units: 'sentences' // Generate words, sentences, or paragraphs. , sentenceLowerBound: 1 // Minimum words per sentence. , sentenceUpperBound: 5 // Maximum words per sentence. }); } /** * Get a randomly selected enum value from the supplied array. * @param {Array} enumValues Array of possible enum values. * @return {*} an enum value. */ getEnum(enumValues) { return enumValues[Math.floor(Math.random() * enumValues.length)]; } /** * Get an array using the supplied callback to obtain array values. * @param {Function} valueSupplier - callback to obtain values. * @return {Array} an array */ getArray(valueSupplier) { return [valueSupplier()]; } } module.exports = ValueGeneratorFactory; × Search results Close "},"composer-common_lib_filewallet.js.html":{"id":"composer-common_lib_filewallet.js.html","title":"Source: composer-common/lib/filewallet.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/filewallet.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const fs = require('fs'); const homedir = require('homedir'); const Logger = require('./log/logger'); const mkdirp = require('mkdirp'); const path = require('path'); const thenify = require('thenify'); const thenifyAll = require('thenify-all'); const Wallet = require('./wallet'); const LOG = Logger.getLog('FileWallet'); /** * Class implementing a wallet (a container of credentials) that * stores the credentials on the file system. * @protected */ class FileWallet extends Wallet { /** * Get the current home directory. * @return {string} The current home directory. */ static getHomeDirectory() { return homedir(); } /** * Constructor. * @param {Object} [options] The options to use. * @param {string} [options.directory] The directory to store * credentials in. * @param {Object} [fs] The file system implementation to use. */ constructor(options) { super(); const method = 'constructor'; LOG.entry(method, options); // Generate the directory if not specified in the options. options = options || {}; this.directory = options.directory; if (!this.directory) { let h = FileWallet.getHomeDirectory(); if (h) { this.directory = path.resolve(h, '.composer-credentials'); } else { this.directory = path.resolve('/', '.composer-credentials'); } LOG.debug(method, 'Generated directory', this.directory); } // Use the default fs implementation if one is not specified. let theFS = options.fs; if (!theFS) { theFS = fs; } // Promisify all of the APIs that we want to use. this.fs = thenifyAll(theFS, {}); this.mkdirp = thenify((dir, cb) =&gt; { return mkdirp(dir, { fs: theFS }, cb); }); LOG.exit(method); } /** * List all of the credentials in the wallet. * @return {Promise} A promise that is resolved with * an array of credential names, or rejected with an * error. */ list() { const method = 'list'; LOG.entry(method); const result = []; return this.fs.readdir(this.directory) .then((files) =&gt; { files.forEach((file) =&gt; { LOG.debug(method, 'Found file', file); result.push(file); }); result.sort(); }) .catch((error) =&gt; { // Ignore any errors. LOG.debug(method, 'Ignoring error', error); }) .then(() =&gt; { LOG.exit(method, result); return result; }); } /** * Check to see if the named credentials are in * the wallet. * @param {string} name The name of the credentials. * @return {Promise} A promise that is resolved with * a boolean; true if the named credentials are in the * wallet, false otherwise. */ contains(name) { const method = 'contains'; LOG.entry(method, name); let result = false; const file = path.resolve(this.directory, name); return this.fs.readFile(file, 'utf8') .then((value) =&gt; { LOG.debug(method, 'Read file successfully'); result = true; }) .catch((error) =&gt; { // Ignore any errors. LOG.debug(method, 'Ignoring error', error); }) .then(() =&gt; { LOG.exit(method, result); return result; }); } /** * Get the named credentials from the wallet. * @abstract * @param {string} name The name of the credentials. * @return {Promise} A promise that is resolved with * the named credentials, or rejected with an error. */ get(name) { const method = 'get'; LOG.entry(method, name); const file = path.resolve(this.directory, name); return this.fs.readFile(file, 'utf8') .then((value) =&gt; { LOG.debug(method, 'Read file successfully'); LOG.exit(method, value); return value; }) .catch((error) =&gt; { LOG.error(method, error); throw error; }); } /** * Add a new credential to the wallet. * @abstract * @param {string} name The name of the credentials. * @param {string} value The credentials. * @return {Promise} A promise that is resolved when * complete, or rejected with an error. */ add(name, value) { const method = 'add'; LOG.entry(method, name, value); const file = path.resolve(this.directory, name); return this.mkdirp(this.directory) .then(() =&gt; { return this.fs.writeFile(file, value, { flag: 'wx', mode: 0o600 }); }) .then((value) =&gt; { LOG.debug(method, 'Wrote file successfully'); LOG.exit(method); }) .catch((error) =&gt; { LOG.error(method, error); throw error; }); } /** * Update existing credentials in the wallet. * @abstract * @param {string} name The name of the credentials. * @param {string} value The credentials. * @return {Promise} A promise that is resolved when * complete, or rejected with an error. */ update(name, value) { const method = 'update'; LOG.entry(method, name, value); const file = path.resolve(this.directory, name); return this.fs.readFile(file, 'utf8') .then(() =&gt; { LOG.debug(method, 'Read file successfully'); return this.fs.writeFile(file, value, { mode: 0o600 }); }) .then((value) =&gt; { LOG.debug(method, 'Wrote file successfully'); LOG.exit(method); }) .catch((error) =&gt; { LOG.error(method, error); throw error; }); } /** * Remove existing credentials from the wallet. * @abstract * @param {string} name The name of the credentials. * @return {Promise} A promise that is resolved when * complete, or rejected with an error. */ remove(name) { const method = 'remove'; LOG.entry(method, name); const file = path.resolve(this.directory, name); return this.fs.unlink(file) .then((value) =&gt; { LOG.debug(method, 'Removed file successfully'); LOG.exit(method); }) .catch((error) =&gt; { LOG.error(method, error); throw error; }); } } module.exports = FileWallet; × Search results Close "},"composer-common_lib_log_winstonInjector.js.html":{"id":"composer-common_lib_log_winstonInjector.js.html","title":"Source: composer-common/lib/log/winstonInjector.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/log/winstonInjector.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const fs = require('fs-extra'); const winston = require('winston'); const sprintf = require('sprintf-js').sprintf; /** * This the default core logger that is used for Hyperledger-Composer. This function * setups up the Winston logging for both file and console output. * * @param {Object} config JSON structure with specific configuration information * @param {Array} configElements JSON struction with the DEBUG env variables for composer * * @returns {Object} object that is the logger to use */ exports.getLogger = function (config,configElements){ let consoleLevel; let fileLevel; // if the length of the configured elements are 0 then put this into a default // only mode. if (configElements.debug.length === 0){ consoleLevel=config.console.alwaysLevel; fileLevel=config.file.alwaysLevel; } else { fileLevel=config.file.enabledLevel; consoleLevel=config.console.enabledLevel; } // setup the formatter functions let formatterFn = function(options) { // Return string will be passed to logger. return sprintf('%s %-7s %-20s %s' ,options.timestamp() ,options.level.toUpperCase() ,options.message ,(JSON.stringify(options.meta,null,'') +'$') ); }; // setup the time stamp function let timestampFn = function() { return new Date(Date.now()).toISOString(); }; // process the file name and make sure the directory has been created let resolvedFilename = config.file.filename.replace(/PID/g, process.pid); // process the filename and get the timestampe replaced let d = new Date(); let timestamp = sprintf('%d%02d%02d-%02d%02d%02d-%03d',d.getUTCFullYear(),d.getUTCMonth()+1,d.getUTCDate()+1,d.getHours(),d.getMinutes(),d.getSeconds(),d.getMilliseconds()); resolvedFilename = resolvedFilename.replace(/TIMESTAMP/g, timestamp); let dir = './composer-logs'; fs.ensureDirSync(dir); // create the Winston logger with the two transports. let newWinstonLogger = { transports: [ new(winston.transports.Console)({ name: 'info-file', timestamp: timestampFn, formatter: formatterFn , level: consoleLevel }), new(winston.transports.File)({ name:'debug-file', json:false, filename: dir+ '/' + resolvedFilename, timestamp: timestampFn, formatter: formatterFn , level: fileLevel }) ] }; // add to the winnston system and return winston.loggers.add('Hyperledger-Composer',newWinstonLogger); return winston.loggers.get('Hyperledger-Composer'); }; × Search results Close "},"composer-runtime_lib_identitymanager.js.html":{"id":"composer-runtime_lib_identitymanager.js.html","title":"Source: composer-runtime/lib/identitymanager.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/identitymanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const createHash = require('sha.js'); const Logger = require('composer-common').Logger; const TransactionHandler = require('./transactionhandler'); const LOG = Logger.getLog('IdentityManager'); /** * A class for managing and persisting identities. * @protected */ class IdentityManager extends TransactionHandler { /** * Constructor. * @param {Context} context The request context. */ constructor(context) { super(); this.identityService = context.getIdentityService(); this.registryManager = context.getRegistryManager(); this.factory = context.getFactory(); this.bind('org.hyperledger.composer.system.IssueIdentity', this.issueIdentity); this.bind('org.hyperledger.composer.system.BindIdentity', this.bindIdentity); this.bind('org.hyperledger.composer.system.ActivateCurrentIdentity', this.activateCurrentIdentity); this.bind('org.hyperledger.composer.system.RevokeIdentity', this.revokeIdentity); } /** * Get the identity registry. * @return {Promise} A promise that will be resolved with an {@link Registry} * when complete, or rejected with an error. */ getIdentityRegistry() { const method = 'getIdentityRegistry'; LOG.entry(method); return this.registryManager.get('Asset', 'org.hyperledger.composer.system.Identity') .then((identityRegistry) =&gt; { LOG.exit(method, identityRegistry); return identityRegistry; }); } /** * Find the identity in the identity registry that maps to the certificate that * was used to sign and submit the current transaction. * @return {Promise} A promise that will be resolved with a {@link Resource} * when complete, or rejected with an error. */ getIdentity() { const method = 'getIdentity'; LOG.entry(method); let identityRegistry, identifier, identityName; return this.getIdentityRegistry() .then((identityRegistry_) =&gt; { // Check to see if the identity exists. identityRegistry = identityRegistry_; identifier = this.identityService.getIdentifier(); identityName = this.identityService.getName(); return identityRegistry.exists(identifier); }) .then((exists) =&gt; { // If it doesn't exist, then try again with the temporary identifier, which is hash(name, issuer). if (!exists) { const sha256 = createHash('sha256'); const name = this.identityService.getName(); const issuer = this.identityService.getIssuer(); sha256.update(name, 'utf8'); sha256.update(issuer, 'utf8'); identifier = sha256.digest('hex'); return identityRegistry.exists(identifier); } else { return exists; } }) .then((exists) =&gt; { // If it still doesn't exist, throw! if (!exists) { const error = new Error('The current identity has not been registered: '+identityName); error.identityName=identityName; LOG.error(method, error); throw error; } // Get the identity. return identityRegistry.get(identifier); }) .then((identity) =&gt; { LOG.exit(method, identity); return identity; }); } /** * Validate the specified identity to confirm that it is valid for use with the * business network. We validate that the identity is not revoked, pending activation, * or in an invalid state. * @param {Resource} identity The identity to validate. */ validateIdentity(identity) { const method = 'validateIdentity'; LOG.entry(method, identity); // Check for a revoked identity. if (identity.state === 'REVOKED') { const error = new Error('The current identity has been revoked'); LOG.error(method, error); throw error; } // Check for an issued or bound identity, in which case activation is required. if (identity.state === 'ISSUED' || identity.state === 'BOUND') { const error = new Error('The current identity must be activated (ACTIVATION_REQUIRED)'); error.activationRequired = true; LOG.error(method, error); throw error; } // Ensure that the identity is activated. if (identity.state !== 'ACTIVATED') { const error = new Error('The current identity is in an unknown state: ' + identity.state); LOG.error(method, error); throw error; } LOG.exit(method); } /** * Find the participant for the specified identity. * @param {Resource} identity The identity to find the participant for. * @return {Promise} A promise that will be resolved with a {@link Resource} * when complete, or rejected with an error. */ getParticipant(identity) { const method = 'getParticipant'; LOG.entry(method); const participant = identity.participant; const participantFQT = participant.getFullyQualifiedType(); return this.registryManager.get('Participant', participantFQT) .then((participantRegistry) =&gt; { return participantRegistry.get(participant.getIdentifier()); }) .then((participant) =&gt; { LOG.exit(method, participant); return participant; }) .catch(() =&gt; { const error = new Error('The current identity is bound to a participant that does not exist'); LOG.error(method, error); throw error; }); } /** * Issue a new identity to a participant in the business network. * @param {Api} api The API to use. * @param {org.hyperledger.composer.system.IssueIdentity} transaction The transaction. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ issueIdentity(api, transaction) { const method = 'issueIdentity'; LOG.entry(method, api, transaction); return this.getIdentityRegistry() .then((identityRegistry) =&gt; { // Create the temporary identifier, which is hash(name, issuer) const sha256 = createHash('sha256'); const issuer = this.identityService.getIssuer(); sha256.update(transaction.identityName, 'utf8'); sha256.update(issuer, 'utf8'); const identifier = sha256.digest('hex'); // Create the new identity and add it to the identity registry. const identity = this.factory.newResource('org.hyperledger.composer.system', 'Identity', identifier); Object.assign(identity, { name: transaction.identityName, issuer, certificate: '', state: 'ISSUED', participant: transaction.participant }); return identityRegistry.add(identity, { convertResourcesToRelationships: true }); }) .then(() =&gt; { LOG.exit(method); }); } /** * Bind an existing identity to a participant in the business network. * @param {Api} api The API to use. * @param {org.hyperledger.composer.system.BindIdentity} transaction The transaction. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ bindIdentity(api, transaction) { const method = 'bindIdentity'; LOG.entry(method, api, transaction); return this.getIdentityRegistry() .then((identityRegistry) =&gt; { // Parse the certificate into a byte array. const bytes = transaction.certificate .replace(/-----BEGIN CERTIFICATE-----/, '') .replace(/-----END CERTIFICATE-----/, '') .replace(/[\\r\\n]+/g, ''); const buffer = Buffer.from(bytes, 'base64'); const sha256 = createHash('sha256'); const identityId = sha256.update(buffer).digest('hex'); // Create the new identity and add it to the identity registry. const identity = this.factory.newResource('org.hyperledger.composer.system', 'Identity', identityId); Object.assign(identity, { name: '', issuer: '', certificate: transaction.certificate, state: 'BOUND', participant: transaction.participant }); return identityRegistry.add(identity, { convertResourcesToRelationships: true }); }) .then(() =&gt; { LOG.exit(method); }); } /** * Activate the current identity in the business network. * @param {Api} api The API to use. * @param {org.hyperledger.composer.system.ActivateCurrentIdentity} transaction The transaction. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ activateCurrentIdentity(api, transaction) { const method = 'activateCurrentIdentity'; LOG.entry(method, api, transaction); let identityRegistry; return this.getIdentityRegistry() .then((identityRegistry_) =&gt; { identityRegistry = identityRegistry_; return this.getIdentity(); }) .then((identity) =&gt; { // If the identity has been issued, we must delete it and then create a new one. if (identity.state === 'ISSUED') { return this.activateIssuedIdentity(identityRegistry, identity); } // If the identity has been bound, then we can update it. if (identity.state === 'BOUND') { return this.activateBoundIdentity(identityRegistry, identity); } // Shouldn't get here. throw new Error('The current identity cannot be activated because it is in an unknown state: ' + identity.state); }) .then(() =&gt; { LOG.exit(method); }); } /** * Activate the specified identity (in the ISSUED state) in the business network. * @param {Registry} identityRegistry The identity registry. * @param {Resource} identity The identity to activate. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ activateIssuedIdentity(identityRegistry, identity) { const method = 'activateIssuedIdentity'; LOG.entry(method, identityRegistry, identity); // Grab information from the certificate. const identifier = this.identityService.getIdentifier(); const name = this.identityService.getName(); const issuer = this.identityService.getIssuer(); const certificate = this.identityService.getCertificate(); // Validate the issuer to check it matches the issuer of the identity. if (identity.issuer !== issuer) { throw new Error('The current identity cannot be activated because the issuer is invalid'); } // Create the new identity. const newIdentity = this.factory.newResource('org.hyperledger.composer.system', 'Identity', identifier); Object.assign(newIdentity, { name, issuer, certificate, state: 'ACTIVATED', participant: identity.participant }); // Remove the old identity and add the new identity into the identity registry. return identityRegistry.remove((identity)) .then(() =&gt; { return identityRegistry.add(newIdentity); }) .then(() =&gt; { LOG.exit(method); }); } /** * Activate the specified identity (in the BOUND state) in the business network. * @param {Registry} identityRegistry The identity registry. * @param {Resource} identity The identity to activate. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ activateBoundIdentity(identityRegistry, identity) { const method = 'activateBoundIdentity'; LOG.entry(method, identityRegistry, identity); // Grab information from the certificate. const name = this.identityService.getName(); const issuer = this.identityService.getIssuer(); // Update the identity and update it in the identity registry. Object.assign(identity, { name, issuer, state: 'ACTIVATED' }); return identityRegistry.update(identity) .then(() =&gt; { LOG.exit(method); }); } /** * Revoke an identity in the business network. * @param {Api} api The API to use. * @param {org.hyperledger.composer.system.RevokeIdentity} transaction The transaction. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ revokeIdentity(api, transaction) { const method = 'revokeIdentity'; LOG.entry(method, api, transaction); return this.getIdentityRegistry() .then((identityRegistry) =&gt; { // Ensure the identity is not already revoked. if (transaction.identity.state === 'REVOKED') { throw new Error('The specified identity has already been revoked'); } // Revoke the identity and update it in the identity registry. Object.assign(transaction.identity, { state: 'REVOKED' }); return identityRegistry.update(transaction.identity, { convertResourcesToRelationships: true }); }) .then(() =&gt; { LOG.exit(method); }); } } module.exports = IdentityManager; × Search results Close "},"composer-admin_index.js.html":{"id":"composer-admin_index.js.html","title":"Source: composer-admin/index.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-admin/index.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * The composer-common module cannot load connector modules from parent modules * when the dependencies are linked together using npm link or lerna. To work * around this, the packages that require the connectors register themselves as * modules that can load connection managers. */ require('composer-common').ConnectionProfileManager.registerConnectionManagerLoader(module); /** * &lt;p&gt; * The composer-admin module. Defines the administration API for Hyperledger Composer. * &lt;/p&gt; * &lt;p&gt; * Hyperledger Composer is a framework for creating blockchain backed digital networks and * exchanging assets between participants via processing transactions. * &lt;/p&gt; * @module composer-admin */ module.exports.AdminConnection = require('./lib/adminconnection'); /** * Expose key composer-common classes to simplify client application dependencies * @ignore */ module.exports.BusinessNetworkDefinition = require('composer-common').BusinessNetworkDefinition; module.exports.Logger = require('composer-common').Logger; module.exports.version = require('./package.json'); × Search results Close "},"composer-client_index.js.html":{"id":"composer-client_index.js.html","title":"Source: composer-client/index.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-client/index.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * The composer-common module cannot load connector modules from parent modules * when the dependencies are linked together using npm link or lerna. To work * around this, the packages that require the connectors register themselves as * modules that can load connection managers. */ require('composer-common').ConnectionProfileManager.registerConnectionManagerLoader(module); /** * &lt;p&gt; * The composer-client module. Defines the client API for Composer. * &lt;/p&gt; * &lt;p&gt; * Composer is a framework for creating blockchain backed digital networks and * exchanging assets between participants via processing transactions. * &lt;/p&gt; * &lt;p&gt; * Applications interact with the framework by instantiating the {@link BusinessNetworkConnection} * class. * &lt;/p&gt; * @module composer-client */ module.exports.AssetRegistry = require('./lib/assetregistry'); module.exports.BusinessNetworkConnection = require('./lib/businessnetworkconnection'); module.exports.Historian = require('./lib/historian'); module.exports.IdentityRegistry = require('./lib/identityregistry'); module.exports.ParticipantRegisty = require('./lib/participantregistry'); module.exports.TransactionRegistry = require('./lib/transactionregistry'); /** * Expose key composer-common classes to simplify client application dependencies * @ignore */ module.exports.Logger = require('composer-common').Logger; module.exports.version = require('./package.json'); × Search results Close "},"composer-client_lib_assetregistry.js.html":{"id":"composer-client_lib_assetregistry.js.html","title":"Source: composer-client/lib/assetregistry.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-client/lib/assetregistry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Registry = require('./registry'); const Util = require('composer-common').Util; const REGISTRY_TYPE = 'Asset'; /** * The AssetRegistry is used to manage a set of assets stored on the Blockchain. * &lt;p&gt;&lt;a href=&quot;./diagrams/assetregistry.svg&quot;&gt;&lt;img src=&quot;./diagrams/assetregistry.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends Registry * @see See [Registry]{@link module:composer-client.Registry} * @class * @memberof module:composer-client */ class AssetRegistry extends Registry { /** * Get a list of all existing asset registries. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @param {BusinessNetworkConnection} bnc Instance of the BusinessNetworkConnection * @param {Boolean} [includeSystem] Should system registries be included? (defaults to false) * @return {Promise} A promise that will be resolved with a list of {@link AssetRegistry} * instances representing the asset registries. */ static getAllAssetRegistries(securityContext, modelManager, factory, serializer,bnc,includeSystem) { Util.securityCheck(securityContext); if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getAllRegistries(securityContext, REGISTRY_TYPE,includeSystem) .then((assetRegistries) =&gt; { return assetRegistries.map((assetRegistry) =&gt; { return new AssetRegistry(assetRegistry.id, assetRegistry.name, securityContext, modelManager, factory, serializer, bnc); }); }); } /** * Get an existing asset registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the asset registry. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @param {BusinessNetworkConnection} bnc Instance of the BusinessNetworkConnection * @return {Promise} A promise that will be resolved with a {@link AssetRegistry} * instance representing the asset registry. */ static getAssetRegistry(securityContext, id, modelManager, factory, serializer,bnc) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getRegistry(securityContext, REGISTRY_TYPE, id) .then((registry) =&gt; { return new AssetRegistry(registry.id, registry.name, securityContext, modelManager, factory, serializer, bnc); }); } /** * Determine whether an registry exists. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the asset registry. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @return {Promise} A promise that will be resolved with a boolean indicating whether the asset registry exists */ static assetRegistryExists(securityContext, id, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.existsRegistry(securityContext, REGISTRY_TYPE, id); } /** * Add a new asset registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the asset registry. * @param {string} name The name of the asset registry. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @param {BusinessNetworkConnection} bnc Instance of the BusinessNetworkConnection * @return {Promise} A promise that will be resolved with a {@link AssetRegistry} * instance representing the new asset registry. */ static addAssetRegistry(securityContext, id, name, modelManager, factory, serializer,bnc) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.addRegistry(securityContext, REGISTRY_TYPE, id, name) .then(() =&gt; { return new AssetRegistry(id, name, securityContext, modelManager, factory, serializer, bnc); }); } /** * Create an asset registry. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkConnection}&lt;/strong&gt; * &lt;/p&gt; * @protected * @param {string} id The unique identifier of the asset registry. * @param {string} name The display name for the asset registry. * @param {SecurityContext} securityContext The security context to use for this asset registry. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @param {BusinessNetworkConnection} bnc Instance of the BusinessNetworkConnection */ constructor(id, name, securityContext, modelManager, factory, serializer, bnc) { super(REGISTRY_TYPE, id, name, securityContext, modelManager, factory, serializer, bnc); } } module.exports = AssetRegistry; × Search results Close "},"composer-runtime_lib_registry.js.html":{"id":"composer-runtime_lib_registry.js.html","title":"Source: composer-runtime/lib/registry.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/registry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const EventEmitter = require('events'); const Resource = require('composer-common').Resource; /** * A class for managing and persisting resources. * @protected */ class Registry extends EventEmitter { /** * Remove any internal properties to the specified JSON object before * reinflating it back into a resource. * @param {Object} json The JSON object. * @return {Object} The JSON object. */ static removeInternalProperties(json) { if (!json || typeof json !== 'object' || Array.isArray(json)) { throw new Error('Can only add properties to JSON objects'); } delete json.$registryType; delete json.$registryId; return json; } /** * Constructor. * @param {string} dataCollection The data collection to use. * @param {Serializer} serializer The serializer to use. * @param {AccessController} accessController The access controller to use. * @param {string} type The type of the registry. * @param {string} id The ID of the registry. * @param {string} name The name of the registry. * @param {boolean} system True if the registry is for a system type, false otherwise. */ constructor(dataCollection, serializer, accessController, type, id, name, system) { super(); this.dataCollection = dataCollection; this.serializer = serializer; this.accessController = accessController; this.type = type; this.id = id; this.name = name; this.system = system; } /** * Get all the resources in this registry. * @return {Promise} A promise that will be resolved with an array of {@link * Resource} objects when complete, or rejected with an error. */ getAll() { return this.dataCollection.getAll() .then((objects) =&gt; { return objects.map((object) =&gt; { object = Registry.removeInternalProperties(object); return this.serializer.fromJSON(object); }).reduce((promise, resource) =&gt; { return promise.then((resources) =&gt; { return this.accessController.check(resource, 'READ') .then(() =&gt; { resources.push(resource); return resources; }) .catch((error) =&gt; { return resources; }); }); }, Promise.resolve([])); }); } /** * Get the specified resource in this registry. * @param {string} id The ID of the resource. * @return {Promise} A promise that will be resolved with a {@link Resource} * object when complete, or rejected with an error. */ get(id) { return this.dataCollection.get(id) .then((object) =&gt; { object = Registry.removeInternalProperties(object); let result = this.serializer.fromJSON(object); return this.accessController.check(result, 'READ') .then(() =&gt; { return result; }) .catch((error) =&gt; { throw new Error(`Object with ID '${id}' in collection with ID '${this.type}:${this.id}' does not exist`); }); }); } /** * Determine whether the specified resource exists in this registry. * @param {string} id The ID of the resource. * @return {Promise} A promise that will be resolved with a boolean * indicating whether the asset exists. */ exists(id) { return this.dataCollection.exists(id) .then((exists) =&gt; { if (!exists) { return false; } return this.dataCollection.get(id) .then((object) =&gt; { object = Registry.removeInternalProperties(object); let result = this.serializer.fromJSON(object); return this.accessController.check(result, 'READ'); }) .then(() =&gt; { return true; }) .catch((error) =&gt; { return false; }); }); } /** * An event signalling that a resource has been added to this registry. * @event Registry#resourceadded * @protected * @type {object} * @param {Registry} registry The registry. * @param {Resource} resource The resource. */ /** * Add all of the specified resources to this registry. * @param {Resource[]} resources The resources to add to this registry. * @param {Object} [options] Options for processing the resources. * @param {boolean} [options.convertResourcesToRelationships] Permit resources * in the place of relationships, defaults to false. * @param {boolean} [options.forceAdd] Forces adding the object even if it present (default to false) * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ addAll(resources, options) { options = options || { forceAdd : false }; return resources.reduce((result, resource) =&gt; { return result.then(() =&gt; { return this.add(resource, options); }); }, Promise.resolve()); } /** * Add the specified resource to this registry. * @param {Resource} resource The resource to add to this registry. * @param {Object} [options] Options for processing the resources. * @param {boolean} [options.convertResourcesToRelationships] Permit resources * in the place of relationships, defaults to false. * @param {boolean} [options.forceAdd] Forces adding the object even if it present (default to false) * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ add(resource, options) { return this.accessController.check(resource, 'CREATE') .then(() =&gt; { options = options || { forceAdd : false }; let id = resource.getIdentifier(); let object = this.serializer.toJSON(resource, { convertResourcesToRelationships: options.convertResourcesToRelationships }); object = this.addInternalProperties(object); return this.dataCollection.add(id, object, options.forceAdd); }) .then(() =&gt; { this.emit('resourceadded', { registry: this, resource: resource }); }); } /** * An event signalling that a resource has been updated in this registry. * @event Registry#resourceupdated * @protected * @type {object} * @param {Registry} registry The registry. * @param {Resource} oldResource The old version of the resource. * @param {Resource} newResource The new version of the resource. */ /** * Update all of the specified resources in this registry. * @param {Resource[]} resources The resources to update in this registry. * @param {Object} [options] Options for processing the resources. * @param {boolean} [options.convertResourcesToRelationships] Permit resources * in the place of relationships, defaults to false. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ updateAll(resources, options) { options = options || {}; return resources.reduce((result, resource) =&gt; { return result.then(() =&gt; { return this.update(resource, options); }); }, Promise.resolve()); } /** * Update the specified resource in this registry. * @param {Resource} resource The resource to update in this registry. * @param {Object} [options] Options for processing the resources. * @param {boolean} [options.convertResourcesToRelationships] Permit resources * in the place of relationships, defaults to false. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ update(resource, options) { options = options || {}; let id = resource.getIdentifier(); let object = this.serializer.toJSON(resource, { convertResourcesToRelationships: options.convertResourcesToRelationships }); object = this.addInternalProperties(object); return this.dataCollection.get(id) .then((oldResource) =&gt; { return this.serializer.fromJSON(oldResource); }) .then((oldResource) =&gt; { // We must perform access control checks on the old version of the resource! return this.accessController.check(oldResource, 'UPDATE') .then(() =&gt; { return this.dataCollection.update(id, object); }) .then(() =&gt; { this.emit('resourceupdated', { registry: this, oldResource: oldResource, newResource: resource }); }); }); } /** * An event signalling that a resource has been removed from this registry. * @event Registry#resourceremoved * @protected * @type {object} * @param {Registry} registry The registry. * @param {string} resourceID The ID of the resource. */ /** * Remove all of the specified resources from this registry. * @param {string[]|Resource[]} resources The resources to remove from this registry. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ removeAll(resources) { return resources.reduce((result, resource) =&gt; { return result.then(() =&gt; { return this.remove(resource); }); }, Promise.resolve()); } /** * Remove the specified resource from this registry. * @param {string|Resource} resource The resource to remove from this registry. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ remove(resource) { return Promise.resolve() .then(() =&gt; { // If the resource is a string, then we need to retrieve // the resource using its ID from the registry. We need to // do this to figure out the type of the resource for // access control. if (resource instanceof Resource) { return resource; } else { return this.dataCollection.get(resource) .then((object) =&gt; { object = Registry.removeInternalProperties(object); return this.serializer.fromJSON(object); }); } }) .then((resource) =&gt; { let id = resource.getIdentifier(); return this.accessController.check(resource, 'DELETE') .then(() =&gt; { return this.dataCollection.remove(id); }) .then(() =&gt; { this.emit('resourceremoved', { registry: this, resourceID: id }); }); }); } /** * Add any internal properties to the specified JSON object before * persisting it into a data collection. * @param {Object} json The JSON object. * @return {Object} The JSON object. */ addInternalProperties(json) { if (!json || typeof json !== 'object' || Array.isArray(json)) { throw new Error('Can only add properties to JSON objects'); } json.$registryType = this.type; json.$registryId = this.id; return json; } /** * Return an object suitable for serialization. * @return {Object} An object suitable for serialization. */ toJSON() { return { type: this.type, id: this.id, name: this.name }; } } module.exports = Registry; × Search results Close "},"composer-client_lib_businessnetworkconnection.js.html":{"id":"composer-client_lib_businessnetworkconnection.js.html","title":"Source: composer-client/lib/businessnetworkconnection.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-client/lib/businessnetworkconnection.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AssetRegistry = require('./assetregistry'); const BusinessNetworkDefinition = require('composer-common').BusinessNetworkDefinition; const ComboConnectionProfileStore = require('composer-common').ComboConnectionProfileStore; const ConnectionProfileManager = require('composer-common').ConnectionProfileManager; const EnvConnectionProfileStore = require('composer-common').EnvConnectionProfileStore; const EventEmitter = require('events'); const fs = require('fs'); const FSConnectionProfileStore = require('composer-common').FSConnectionProfileStore; const Historian = require('./historian'); const IdentityRegistry = require('./identityregistry'); const Logger = require('composer-common').Logger; const ParticipantRegistry = require('./participantregistry'); const Query = require('./query'); const Relationship = require('composer-common').Relationship; const Resource = require('composer-common').Resource; const TransactionDeclaration = require('composer-common').TransactionDeclaration; const TransactionRegistry = require('./transactionregistry'); const Util = require('composer-common').Util; const uuid = require('uuid'); const Registry = require('./registry'); const LOG = Logger.getLog('BusinessNetworkConnection'); /** * Use this class to connect to and then interact with a deployed BusinessNetworkDefinition. * Use the AdminConnection class in the composer-admin module to deploy BusinessNetworksDefinitions. * @extends EventEmitter * @class * @memberof module:composer-client */ class BusinessNetworkConnection extends EventEmitter { /** * Create an instance of the BusinessNetworkConnection class. * must be called to connect to a deployed BusinessNetworkDefinition. * @param {Object} [options] - an optional set of options to configure the instance. * @param {ConnectionProfileStore} [options.connectionProfileStore] - specify a connection profile store to use. * @param {Object} [options.fs] - specify an fs implementation to use. */ constructor(options) { super(); const method = 'constructor'; LOG.entry(method, options); options = options || {}; let connectionProfileStore; if (options.connectionProfileStore) { LOG.debug(method, 'Using connection profile store from options'); connectionProfileStore = options.connectionProfileStore; } else { LOG.debug(method, 'Creating new file system connection profile store'); connectionProfileStore = new FSConnectionProfileStore(options.fs || fs); } if (process.env.COMPOSER_CONFIG) { LOG.debug(method, 'Enabling environment connection profile store'); const envConnectionProfileStore = new EnvConnectionProfileStore(); connectionProfileStore = new ComboConnectionProfileStore( connectionProfileStore, envConnectionProfileStore ); } this.connectionProfileStore = connectionProfileStore; this.connectionProfileManager = new ConnectionProfileManager(this.connectionProfileStore); this.connection = null; this.securityContext = null; this.businessNetwork = null; this.dynamicQueryFile = null; } /** * Returns the currently connected BusinessNetworkDefinition * @example * // Get the Business Network Definition * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.getBusinessNetwork(); * }) * .then(function(BusinessNetworkDefinition){ * // Retrieved Business Network Definition * }); * @returns {BusinessNetworkDefinition} the business network */ getBusinessNetwork() { return this.businessNetwork; } /** * Get a list of all existing asset registries. * @example * // Get all asset registries * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.getAllAssetRegistries(); * }) * .then(function(assetRegistries){ * // Retrieved Asset Registries * }); * @return {Promise} - A promise that will be resolved with a list of existing * asset registries * @param {boolean} [includeSystem] if true the returned list will include the system transaction registries (optional, default to false) */ getAllAssetRegistries(includeSystem) { Util.securityCheck(this.securityContext); let sysReg = includeSystem || false; return AssetRegistry.getAllAssetRegistries(this.securityContext, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(),this,sysReg); } /** * Get an existing asset registry. * @example * // Get a asset registry * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.getAssetRegistry('businessNetworkIdentifier.registryId'); * }) * .then(function(assetRegistry){ * // Retrieved Asset Registry * }); * @param {string} id - The unique identifier of the asset registry * @return {Promise} - A promise that will be resolved with the existing asset * registry, or rejected if the asset registry does not exist. */ getAssetRegistry(id) { Util.securityCheck(this.securityContext); return AssetRegistry.getAssetRegistry(this.securityContext, id, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(),this); } /** * Determine whether a asset registry exists. * @example * // Determine whether an asset registry exists * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.assetRegistryExists('businessNetworkIdentifier.registryId'); * }) * .then(function(exists){ * // if (exists === true) { * // logic here... * //} * }); * @param {string} id - The unique identifier of the asset registry * @return {Promise} - A promise that will be resolved with a boolean indicating whether the asset * registry exists. */ assetRegistryExists(id) { Util.securityCheck(this.securityContext); return AssetRegistry.assetRegistryExists(this.securityContext, id, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(),this); } /** * Add a new asset registry. * @example * // Add a new asset registry * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.addAssetRegistry('registryId','registryName'); * }); * @param {string} id - The unique identifier of the asset registry * @param {string} name - The name of the asset registry * @return {Promise} - A promise that will be resolved with the new asset * registry after it has been added. */ addAssetRegistry(id, name) { Util.securityCheck(this.securityContext); return AssetRegistry.addAssetRegistry(this.securityContext, id, name, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(),this); } /** * Get a list of all existing participant registries. * @example * // Get all participant registries * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.getAllParticipantRegistries(); * }) * .then(function(participantRegistries){ * // Retrieved Participant Registries * }); * * @return {Promise} - A promise that will be resolved with a list of existing * participant registries * @param {boolean} [includeSystem] if true the returned list will include the system transaction registries (optional, default to false) */ getAllParticipantRegistries(includeSystem) { Util.securityCheck(this.securityContext); let sysReg = includeSystem || false; return ParticipantRegistry.getAllParticipantRegistries(this.securityContext, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(),this,sysReg); } /** * Get an existing participant registry. * @example * // Get a participant registry * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.getParticipantRegistry('businessNetworkIdentifier.registryId'); * }) * .then(function(participantRegistry){ * // Retrieved Participant Registry * }); * @param {string} id - The unique identifier of the participant registry * @return {Promise} - A promise that will be resolved with the existing participant * registry, or rejected if the participant registry does not exist. */ getParticipantRegistry(id) { Util.securityCheck(this.securityContext); return ParticipantRegistry.getParticipantRegistry(this.securityContext, id, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(),this); } /** * Determine whether a participant registry exists. * @example * // Determine whether an asset registry exists * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.participantRegistryExists('businessNetworkIdentifier.registryId'); * }) * .then(function(exists){ * // if (exists === true) { * // logic here... * //} * }); * @param {string} id - The unique identifier of the participant registry * @return {Promise} - A promise that will be resolved with a boolean indicating whether the participant * registry exists. */ participantRegistryExists(id) { Util.securityCheck(this.securityContext); return ParticipantRegistry.participantRegistryExists(this.securityContext, id, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(),this); } /** * Add a new participant registry. * @example * // Add a new participant registry * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.addParticipantRegistry('registryId','registryName'); * }); * @param {string} id - The unique identifier of the participant registry * @param {string} name - The name of the participant registry * @return {Promise} - A promise that will be resolved with the new participant * registry after it has been added. */ addParticipantRegistry(id, name) { Util.securityCheck(this.securityContext); return ParticipantRegistry.addParticipantRegistry(this.securityContext, id, name, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(),this); } /** * Get the transaction registry. * @example * // Get the transaction registry * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.getTransactionRegistry('org.acme.exampleTransaction'); * }) * .then(function(transactionRegistry){ * // Retrieved transaction registry. * }); * @param {string} id - The unique identifier of the transaction registry * @return {Promise} - A promise that will be resolved to the {@link TransactionRegistry} */ getTransactionRegistry(id) { Util.securityCheck(this.securityContext); return TransactionRegistry.getTransactionRegistry(this.securityContext, id, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(),this); } /** * Get all transaction registries. * @example * // Get the transaction registry * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.getAllTransactionRegistries(); * }) * .then(function(transactionRegistries){ * // Retrieved transaction Registries * }); * @param {boolean} [includeSystem] if true the returned list will include the system transaction registries (optional, default to false) * @return {Promise} - A promise that will be resolved to the {@link TransactionRegistry} */ getAllTransactionRegistries(includeSystem) { Util.securityCheck(this.securityContext); let sysReg = includeSystem || false; return TransactionRegistry.getAllTransactionRegistries(this.securityContext, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(),this,sysReg); } /** * Determine whether a transaction registry exists. * @example * // Determine whether an transaction registry exists * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetwork){ * return businessNetwork.transactionRegistryExists('businessNetworkIdentifier.registryId'); * }) * .then(function(exists){ * // if (exists === true) { * // logic here... * //} * }); * @param {string} id - The unique identifier of the transaction registry * @return {Promise} - A promise that will be resolved with a boolean indicating whether the transaction * registry exists. */ transactionRegistryExists(id) { Util.securityCheck(this.securityContext); return TransactionRegistry.transactionRegistryExists(this.securityContext, id, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(),this); } /** * Get the historian * @example * // Get the historian * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.getHistorian(); * }) * .then(function(historian){ * // Retrieved historian * }); * @return {Promise} - A promise that will be resolved to the {@link Historian} */ getHistorian() { Util.securityCheck(this.securityContext); return Historian .getHistorian(this.securityContext, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer()) .then((historian) =&gt; { if (historian) { return historian; } else { throw new Error('Failed to find the historian'); } }); } /** * Get the identity registry. * @example * // Get the identity registry * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.getIdentityRegistry(); * }) * .then(function(identityRegistry){ * // Retrieved identity registry * }); * @return {Promise} - A promise that will be resolved to the {@link IdentityRegistry} */ getIdentityRegistry() { Util.securityCheck(this.securityContext); return IdentityRegistry .getIdentityRegistry(this.securityContext, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer()) .then((identityRegistry) =&gt; { if (identityRegistry) { return identityRegistry; } else { throw new Error('Failed to find the identity registry'); } }); } /** * Connects to a business network using a connection profile, and authenticates to the Hyperledger Fabric. * @example * // Connect and log in to HLF * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * // Connected * }); * @param {string} connectionProfile - The name of the connection profile * @param {string} businessNetwork - The identifier of the business network * @param {string} enrollmentID the enrolment ID of the user * @param {string} enrollmentSecret the enrolment secret of the user * @param {Object} [additionalConnectOptions] Additional configuration options supplied * at runtime that override options set in the connection profile. * which will override those in the specified connection profile. * @return {Promise} A promise to a BusinessNetworkDefinition that indicates the connection is complete */ connect(connectionProfile, businessNetwork, enrollmentID, enrollmentSecret, additionalConnectOptions) { const method = 'connect'; LOG.entry(method, connectionProfile, businessNetwork, enrollmentID, enrollmentSecret, additionalConnectOptions); return this.connectionProfileManager.connect(connectionProfile, businessNetwork, additionalConnectOptions) .then((connection) =&gt; { connection.on('events', (events) =&gt; { events.forEach((event) =&gt; { let serializedEvent = this.getBusinessNetwork().getSerializer().fromJSON(event); this.emit('event', serializedEvent); }); }); this.connection = connection; return connection.login(enrollmentID, enrollmentSecret); }) .then((securityContext) =&gt; { this.securityContext = securityContext; return this.ping(); }) .then(() =&gt; { return Util.queryChainCode(this.securityContext, 'getBusinessNetwork', []); }) .then((buffer) =&gt; { let businessNetworkJSON = JSON.parse(buffer.toString()); let businessNetworkArchive = Buffer.from(businessNetworkJSON.data, 'base64'); return BusinessNetworkDefinition.fromArchive(businessNetworkArchive); }) .then((businessNetwork) =&gt; { this.businessNetwork = businessNetwork; this.dynamicQueryFile = this.businessNetwork.getQueryManager().createQueryFile('$dynamic_queries.qry', ''); LOG.exit(method); return this.businessNetwork; }); } /** * Given a fully qualified name, works out and looks up the registry that this resource will be found in. * This only gives back the default registry - it does not look in any application defined registry. * @example * // Locate the registry for a fully qualififed name * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetwork){ * var sampleAssetRegistry = businessNetwork.getRegistry('org.acme.sampleAsset'); * var sampleTransactionRegistry = businessNetwork.getRegistry('org.acme.sampleTransaction'); * var sampleParticipantRegistry = businessNetwork.getRegistry('org.acme.sampleParticipant'); * }); * @param {String} fullyQualifiedName The fully qualified name of the resources * @return {Promise} resolved with the registry that this fqn could be found in by default */ getRegistry(fullyQualifiedName) { Util.securityCheck(this.securityContext); let businessNetwork= this.getBusinessNetwork(); let type = businessNetwork.getModelManager().getType(fullyQualifiedName).getSystemType(); return Registry.getRegistry(this.securityContext, type, fullyQualifiedName) .then((registry) =&gt; { switch (type) { case 'Transaction': return new TransactionRegistry(registry.id, registry.name, this.securityContext, businessNetwork.getModelManager(), businessNetwork.getFactory(), businessNetwork.getSerializer()); case 'Asset': return new AssetRegistry(registry.id, registry.name, this.securityContext, businessNetwork.getModelManager(), businessNetwork.getFactory(), businessNetwork.getSerializer()); case 'Participant': return new ParticipantRegistry(registry.id, registry.name, this.securityContext, businessNetwork.getModelManager(), businessNetwork.getFactory(), businessNetwork.getSerializer()); } }); } /** * Disconnects from the Hyperledger Fabric. * @example * // Disconnects from HLF * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.disconnect(); * }) * .then(function(){ * // Disconnected. * }); * @return {Promise} A promise that will be resolved when the connection is * terminated. */ disconnect() { const method = 'disconnect'; LOG.entry(method); if (!this.connection) { return Promise.resolve(); } return this.connection.disconnect() .then(() =&gt; { this.connection.removeListener('events', () =&gt; { LOG.debug(method, 'removeListener'); }); this.connection = null; this.securityContext = null; this.businessNetwork = null; this.dynamicQueryFile = null; LOG.exit(method); }); } /** * Submit a transaction for processing by the currently connected business network. * @example * // Submits a transaction * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * var factory = businessNetworkDefinition.getBusinessNetwork().getFactory(); * var transaction = factory.newTransaction('network.transactions', 'TransactionType'); * return businessNetworkDefinition.submitTransaction(transaction); * }) * .then(function(){ * // Submitted a transaction. * }); * @param {Resource} transaction - The transaction to submit. Use {@link * Factory#newTransaction newTransaction} to create this object. * @return {Promise} A promise that will be fulfilled when the transaction has * been processed. */ submitTransaction(transaction) { Util.securityCheck(this.securityContext); if (!transaction) { throw new Error('transaction not specified'); } let classDeclaration = transaction.getClassDeclaration(); if (!(classDeclaration instanceof TransactionDeclaration)) { throw new Error(classDeclaration.getFullyQualifiedName() + ' is not a transaction'); } return Util.createTransactionId(this.securityContext) .then ((id)=&gt;{ transaction.setIdentifier(id.idStr); let timestamp = transaction.timestamp; if (timestamp === null || timestamp === undefined) { timestamp = transaction.timestamp = new Date(); } let data = this.getBusinessNetwork().getSerializer().toJSON(transaction); return Util.invokeChainCode(this.securityContext, 'submitTransaction', [JSON.stringify(data)], {transactionId:id.id}); }); } /** * Build a query ready for later execution. The specified query string must be written * in the Composer query language. * * This functionality is Blockchain platform dependent. For example, when a Composer * business network is deployed to Hyperledger Fabric v1.0, Hyperledger Fabric must be * configured with the CouchDB database for the world state. * @example * // Build and execute a query. * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function () { * var query = businessNetwork.buildQuery('SELECT org.acme.sample.SampleAsset WHERE (value == _$inputValue)'); * return businessNetwork.query(query, { inputValue: 'blue' }) * }) * .then(function (assets) { * assets.forEach(function (asset) { * // Process each asset. * }); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @param {string} query The query string, written using the Composer query language. * @return {Query} The built query, which can be passed in a call to query. */ buildQuery(query) { const method = 'buildQuery'; LOG.entry(method, query); const builtQuery = this.dynamicQueryFile.buildQuery('Dynamic query', 'Dynamic query', query); builtQuery.validate(); const result = new Query(query); LOG.exit(method, result); return result; } /** * Execute a query defined in a Composer query file, or execute a query built with buildQuery. * * This functionality is Blockchain platform dependent. For example, when a Composer * business network is deployed to Hyperledger Fabric v1.0, Hyperledger Fabric must be * configured with the CouchDB database for the world state. * @example * // Execute the query. * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function () { * return query('Q1', { inputValue: 'blue' }) * }) * .then(function (assets) { * assets.forEach(function (asset) { * // Process each asset. * }); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @param {string|Query} query The name of the query, or a built query. * @param {Object} [parameters] The parameters for the query. * @return {Promise} A promise that will be resolved with an array of * {@link module:composer-common.Resource Resource} representing the * resources returned by the query. */ query(query, parameters) { const method = 'query'; LOG.entry(method, query, parameters); let queryType, identifier; if (query instanceof Query) { queryType = 'build'; identifier = query.getIdentifier(); } else if (typeof query === 'string') { queryType = 'named'; identifier = query; } else { throw new Error('Invalid query; expecting a built query or the name of a query'); } parameters = parameters || {}; return Util.queryChainCode(this.securityContext, 'executeQuery', [queryType, identifier, JSON.stringify(parameters)]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }) .then((resources) =&gt; { const result = resources.map((resource) =&gt; { return this.getBusinessNetwork().getSerializer().fromJSON(resource); }); LOG.exit(method, result); return result; }); } /** * Test the connection to the runtime and verify that the version of the * runtime is compatible with this level of the client node.js module. * @example * // Test the connection to the runtime * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetwork.ping(); * }) * .then(function(){ * // Connection tested. * }); * @return {Promise} A promise that will be fulfilled when the connection has * been tested. The promise will be rejected if the version is incompatible. */ ping() { const method = 'ping'; LOG.entry(method); return this.pingInner() .catch((error) =&gt; { if (error.message.match(/ACTIVATION_REQUIRED/)) { LOG.debug(method, 'Activation required, activating ...'); return this.activate() .then(() =&gt; { return this.pingInner(); }); } throw error; }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Test the connection to the runtime and verify that the version of the * runtime is compatible with this level of the client node.js module. * @private * @return {Promise} A promise that will be fulfilled when the connection has * been tested. The promise will be rejected if the version is incompatible. */ pingInner() { const method = 'pingInner'; LOG.entry(method); Util.securityCheck(this.securityContext); return this.connection.ping(this.securityContext) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Activate the current identity on the currently connected business network. * @private * @return {Promise} A promise that will be fulfilled when the connection has * been tested. The promise will be rejected if the version is incompatible. */ activate() { const method = 'activate'; LOG.entry(method); const json = { $class: 'org.hyperledger.composer.system.ActivateCurrentIdentity', transactionId: uuid.v4(), timestamp: new Date().toISOString() }; return Util.invokeChainCode(this.securityContext, 'submitTransaction', [JSON.stringify(json)]) .then(() =&gt; { LOG.exit(method); }); } /** * Issue an identity with the specified name and map it to the specified * participant. * @param {Resource|Relationship|string} participant The participant, a * relationship to the participant, or the fully qualified identifier of * the participant. The participant must already exist. * @param {string} identityName The name for the new identity. * @param {object} [options] Options for the new identity. * @param {boolean} [options.issuer] Whether or not the new identity should have * permissions to create additional new identities. False by default. * @return {Promise} A promise that will be fulfilled when the identity has * been added to the specified participant. The promise will be rejected if * the participant does not exist, or if the identity is already mapped to * another participant. */ issueIdentity(participant, identityName, options) { const method = 'issueIdentity'; LOG.entry(method, participant, identityName); if (!participant) { throw new Error('participant not specified'); } else if (!identityName) { throw new Error('identityName not specified'); } const factory = this.getBusinessNetwork().getFactory(); if (participant instanceof Resource) { participant = factory.newRelationship(participant.getNamespace(), participant.getType(), participant.getIdentifier()); } else if (participant instanceof Relationship) { // This is OK! } else { participant = Relationship.fromURI(this.getBusinessNetwork().getModelManager(), participant); } const transaction = factory.newTransaction('org.hyperledger.composer.system', 'IssueIdentity'); Object.assign(transaction, { participant, identityName }); return this.getParticipantRegistry(participant.getFullyQualifiedType()) .then((participantRegistry) =&gt; { return participantRegistry.exists(participant.getIdentifier()); }) .then((exists) =&gt; { if (exists) { return this.connection.createIdentity(this.securityContext, identityName, options); } else { throw new Error(`Participant '${participant.getFullyQualifiedIdentifier()}' does not exist `); } }) .then((identity) =&gt; { return this.submitTransaction(transaction) .then(() =&gt; { LOG.exit(method, identity); return identity; }); }); } /** * Bind an existing identity to the specified participant. * @param {Resource|string} participant The participant, or the fully qualified * identifier of the participant. The participant must already exist. * @param {string} certificate The certificate for the existing identity. * @return {Promise} A promise that will be fulfilled when the identity has * been added to the specified participant. The promise will be rejected if * the participant does not exist, or if the identity is already mapped to * another participant. */ bindIdentity(participant, certificate) { const method = 'bindIdentity'; LOG.entry(method, participant, certificate); if (!participant) { throw new Error('participant not specified'); } else if (!certificate) { throw new Error('certificate not specified'); } const factory = this.getBusinessNetwork().getFactory(); if (participant instanceof Resource) { participant = factory.newRelationship(participant.getNamespace(), participant.getType(), participant.getIdentifier()); } else if (participant instanceof Relationship) { // This is OK! } else { participant = Relationship.fromURI(this.getBusinessNetwork().getModelManager(), participant); } const transaction = factory.newTransaction('org.hyperledger.composer.system', 'BindIdentity'); Object.assign(transaction, { participant, certificate }); return this.submitTransaction(transaction) .then(() =&gt; { LOG.exit(method); }); } /** * Revoke the specified identity by removing any existing mapping to a participant. * @param {Resource|string} identity The identity, or the identifier of the identity. * @return {Promise} A promise that will be fulfilled when the identity has * been removed from the specified participant. The promise will be rejected if * the participant does not exist, or if the identity is not mapped to the * participant. */ revokeIdentity(identity) { const method = 'revokeIdentity'; LOG.entry(method, identity); if (!identity) { throw new Error('identity not specified'); } const factory = this.getBusinessNetwork().getFactory(); if (identity instanceof Resource) { identity = factory.newRelationship(identity.getNamespace(), identity.getType(), identity.getIdentifier()); } else if (identity instanceof Relationship) { // This is OK! } else { identity = Relationship.fromURI(this.getBusinessNetwork().getModelManager(), identity, 'org.hyperledger.composer.system', 'Identity'); } const transaction = factory.newTransaction('org.hyperledger.composer.system', 'RevokeIdentity'); Object.assign(transaction, { identity }); // It is not currently possible to revoke the certificate, so we just call // the runtime to remove the mapping. return this.submitTransaction(transaction) .then(() =&gt; { LOG.exit(method); }); } } module.exports = BusinessNetworkConnection; × Search results Close "},"composer-client_lib_historian.js.html":{"id":"composer-client_lib_historian.js.html","title":"Source: composer-client/lib/historian.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-client/lib/historian.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Registry = require('./registry'); const Util = require('composer-common').Util; const REGISTRY_TYPE = 'Asset'; /** * The Historian records the history of actions taken using Composer. * It is a registry that stores HistorianRecords; each record is created in response * to a transaction being executred. * * As well as the transactions that are defined in the Network model other actions such * as adding assets are treated as transactions so are therefore recorded. * * Details of these are in the system model. * @extends Registry * @see See [Registry]{@link module:composer-client.Registry} * @class * @memberof module:composer-client */ class Historian extends Registry { /** * Get an existing historian. * * @param {SecurityContext} securityContext The user's security context. * @param {ModelManager} modelManager The ModelManager to use for this historian. * @param {Factory} factory The factory to use for this historian. * @param {Serializer} serializer The Serializer to use for this historian. * @return {Promise} A promise that will be resolved with a {@link IdentityRegistry} * instance representing the historian. */ static getHistorian(securityContext, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getRegistry(securityContext, REGISTRY_TYPE, 'org.hyperledger.composer.system.HistorianRecord') .then((registry) =&gt; { // Hardcoded name for display purposes. return new Historian(registry.id, 'Historian', securityContext, modelManager, factory, serializer); }); } /** * Create a historian. * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkConnection}&lt;/strong&gt; * &lt;/p&gt; * * @param {string} id The unique identifier of the transaction registry. * @param {string} name The display name for the transaction registry. * @param {SecurityContext} securityContext The security context to use for this asset registry. * @param {ModelManager} modelManager The ModelManager to use for this transaction registry. * @param {Factory} factory The factory to use for this transaction registry. * @param {Serializer} serializer The Serializer to use for this transaction registry. * @private */ constructor(id, name, securityContext, modelManager, factory, serializer) { super(REGISTRY_TYPE, id, name, securityContext, modelManager, factory, serializer); } /** * Unsupported operation; you cannot add a historian record to the historian. * This method will always throw an exception when called. * * @param {Resource} resource The resource to be added to the registry. * @param {string} data The data for the resource. * @private */ add(resource) { throw new Error('cannot add historian records to the historian'); } /** * Unsupported operation; you cannot add a historian record to the historian. * This method will always throw an exception when called. * * @param {Resource[]} resources The resources to be added to the registry. * @private */ addAll(resources) { throw new Error('cannot add historian records to the historian'); } /** * Unsupported operation; you cannot update a historian record in the historian. * This method will always throw an exception when called. * * @param {Resource} resource The resource to be updated in the registry. * @private */ update(resource) { throw new Error('cannot update historian records in the historian'); } /** * Unsupported operation; you cannot update a historian record in the historian. * This method will always throw an exception when called. * * @param {Resource[]} resources The resources to be updated in the asset registry. * @private */ updateAll(resources) { throw new Error('cannot update historian records in the historian'); } /** * Unsupported operation; you cannot remove a historian record from the historian. * This method will always throw an exception when called. * * @param {(Resource|string)} resource The resource, or the unique identifier of the resource. * @private */ remove(resource) { throw new Error('cannot remove historian records from the historian'); } /** * Unsupported operation; you cannot remove a historian record from the historian. * This method will always throw an exception when called. * * @param {(Resource[]|string[])} resources The resources, or the unique identifiers of the resources. * @private */ removeAll(resources) { throw new Error('cannot remove historian records from the historian'); } } module.exports = Historian; × Search results Close "},"composer-client_lib_identityregistry.js.html":{"id":"composer-client_lib_identityregistry.js.html","title":"Source: composer-client/lib/identityregistry.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-client/lib/identityregistry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Registry = require('./registry'); const Util = require('composer-common').Util; const REGISTRY_TYPE = 'Asset'; /** * The IdentityRegistry is used to store a set of identities on the blockchain. * &lt;p&gt;&lt;a href=&quot;./diagrams/identityregistry.svg&quot;&gt;&lt;img src=&quot;./diagrams/identityregistry.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends Registry * @see See [Registry]{@link module:composer-client.Registry} * @class * @memberof module:composer-client */ class IdentityRegistry extends Registry { /** * Get an existing identity registry. * * @param {SecurityContext} securityContext The user's security context. * @param {ModelManager} modelManager The ModelManager to use for this identity registry. * @param {Factory} factory The factory to use for this identity registry. * @param {Serializer} serializer The Serializer to use for this identity registry. * @return {Promise} A promise that will be resolved with a {@link IdentityRegistry} * instance representing the identity registry. */ static getIdentityRegistry(securityContext, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getRegistry(securityContext, REGISTRY_TYPE, 'org.hyperledger.composer.system.Identity') .then((registry) =&gt; { return new IdentityRegistry(registry.id, registry.name, securityContext, modelManager, factory, serializer); }); } /** * Create an identity registry. * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkConnection}&lt;/strong&gt; * &lt;/p&gt; * * @param {string} id The unique identifier of the identity registry. * @param {string} name The display name for the identity registry. * @param {SecurityContext} securityContext The security context to use for this asset registry. * @param {ModelManager} modelManager The ModelManager to use for this identity registry. * @param {Factory} factory The factory to use for this identity registry. * @param {Serializer} serializer The Serializer to use for this identity registry. * @private */ constructor(id, name, securityContext, modelManager, factory, serializer) { super(REGISTRY_TYPE, id, name, securityContext, modelManager, factory, serializer); } /** * Unsupported operation; you cannot add an identity to an identity * registry. * * @param {Resource} resource The resource to be added to the registry. * @param {string} data The data for the resource. * @private */ add(resource) { throw new Error('cannot add identity to an identity registry'); } /** * Unsupported operation; you cannot add an identity to an identity * registry. * * @param {Resource[]} resources The resources to be added to the registry. * @private */ addAll(resources) { throw new Error('cannot add identities to a identity registry'); } /** * Unsupported operation; you cannot update an identity in an identity * registry. This method will always throw an exception when called. * * @param {Resource} resource The resource to be updated in the registry. * @private */ update(resource) { throw new Error('cannot update identities in an identity registry'); } /** * Unsupported operation; you cannot update an identity in an identity * registry. * * @param {Resource[]} resources The resources to be updated in the asset registry. * @private */ updateAll(resources) { throw new Error('cannot update identities in an identity registry'); } /** * Unsupported operation; you cannot remove an identity from an identity * registry. This method will always throw an exception when called. * * @param {(Resource|string)} resource The resource, or the unique identifier of the resource. * @private */ remove(resource) { throw new Error('cannot remove identities from an identity registry'); } /** * Unsupported operation; you cannot remove an identity from an identity * registry. This method will always throw an exception when called. * * @param {(Resource[]|string[])} resources The resources, or the unique identifiers of the resources. * @private */ removeAll(resources) { throw new Error('cannot remove identities from an identity registry'); } } module.exports = IdentityRegistry; × Search results Close "},"composer-client_lib_participantregistry.js.html":{"id":"composer-client_lib_participantregistry.js.html","title":"Source: composer-client/lib/participantregistry.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-client/lib/participantregistry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Registry = require('./registry'); const Util = require('composer-common').Util; const REGISTRY_TYPE = 'Participant'; /** * The ParticipantRegistry is used to manage a set of participants stored on the blockchain. * &lt;p&gt;&lt;a href=&quot;./diagrams/participantregistry.svg&quot;&gt;&lt;img src=&quot;./diagrams/participantregistry.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends Registry * @see See [Registry]{@link module:composer-client.Registry} * @class * @memberof module:composer-client */ class ParticipantRegistry extends Registry { /** * Get a list of all existing participant registries. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {ModelManager} modelManager The ModelManager to use for this participant registry. * @param {Factory} factory The factory to use for this participant registry. * @param {Serializer} serializer The Serializer to use for this participant registry. * @param {BusinessNetworkConnection} bnc BusinessNetworkConnection to use * @param {Boolean} [includeSystem] Should system registries be included? (optional, default to false) * @return {Promise} A promise that will be resolved with a list of {@link ParticipantRegistry} * instances representing the participant registries. */ static getAllParticipantRegistries(securityContext, modelManager, factory, serializer, bnc, includeSystem) { Util.securityCheck(securityContext); if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getAllRegistries(securityContext, REGISTRY_TYPE,includeSystem) .then((participantRegistries) =&gt; { return participantRegistries.map((participantRegistry) =&gt; { return new ParticipantRegistry(participantRegistry.id, participantRegistry.name, securityContext, modelManager, factory, serializer, bnc); }); }); } /** * Get an existing participant registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the participant registry. * @param {ModelManager} modelManager The ModelManager to use for this participant registry. * @param {Factory} factory The factory to use for this participant registry. * @param {Serializer} serializer The Serializer to use for this participant registry. * @param {BusinessNetworkConnection} bnc BusinessNetworkConnection to use * @return {Promise} A promise that will be resolved with a {@link ParticipantRegistry} * instance representing the participant registry. */ static getParticipantRegistry(securityContext, id, modelManager, factory, serializer, bnc) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getRegistry(securityContext, REGISTRY_TYPE, id) .then((registry) =&gt; { return new ParticipantRegistry(registry.id, registry.name, securityContext, modelManager, factory, serializer, bnc); }); } /** * Determine whether a participant registry exists. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the asset registry. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @param {BusinessNetworkConnection} bnc BusinessNetworkConnection to use * @return {Promise} A promise that will be resolved with a boolean indicating whether the asset registry exists */ static participantRegistryExists(securityContext, id, modelManager, factory, serializer, bnc) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.existsRegistry(securityContext, REGISTRY_TYPE, id); } /** * Add a new participant registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the participant registry. * @param {string} name The name of the participant registry. * @param {ModelManager} modelManager The ModelManager to use for this participant registry. * @param {Factory} factory The factory to use for this participant registry. * @param {Serializer} serializer The Serializer to use for this participant registry. * @param {BusinessNetworkConnection} bnc BusinessNetworkConnection to use * @return {Promise} A promise that will be resolved with a {@link ParticipantRegistry} * instance representing the new participant registry. */ static addParticipantRegistry(securityContext, id, name, modelManager, factory, serializer, bnc) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.addRegistry(securityContext, REGISTRY_TYPE, id, name) .then(() =&gt; { return new ParticipantRegistry(id, name, securityContext, modelManager, factory, serializer, bnc); }); } /** * Create an participant registry. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkConnection}&lt;/strong&gt; * &lt;/p&gt; * @protected * @param {string} id The unique identifier of the participant registry. * @param {string} name The display name for the participant registry. * @param {SecurityContext} securityContext The security context to use for this participant registry. * @param {ModelManager} modelManager The ModelManager to use for this participant registry. * @param {Factory} factory The factory to use for this participant registry. * @param {Serializer} serializer The Serializer to use for this participant registry. * @param {BusinessNetworkConnection} bnc BusinessNetworkConnection to use */ constructor(id, name, securityContext, modelManager, factory, serializer,bnc) { super(REGISTRY_TYPE, id, name, securityContext, modelManager, factory, serializer, bnc); } } module.exports = ParticipantRegistry; × Search results Close "},"composer-client_lib_query.js.html":{"id":"composer-client_lib_query.js.html","title":"Source: composer-client/lib/query.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-client/lib/query.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const LOG = Logger.getLog('Query'); /** * Do not attempt to create an instance of this class.&lt;br&gt; * You must use the {@link module:composer-client#BusinessNetworkConnection.buildQuery buildQuery} * method instead. * * @class Query * @classdesc A query represents a built query. * @memberof module:composer-client * @public */ /** * The Query class represents a built query. A built query has been parsed and validated. * Do not attempt to create an instance of this class. * You must use the {@link module:composer-client#BusinessNetworkConnection.buildQuery buildQuery} * method instead. * @class * @memberof module:composer-client */ class Query { /** * Constructor. * @param {string} identifier The identifier of the built query. * @private */ constructor(identifier) { const method = 'constructor'; LOG.entry(method, identifier); this.identifier = identifier; LOG.exit(method); } /** * Get the identifier for this built query. * @private * @return {string} The identifier for this built query. */ getIdentifier() { return this.identifier; } } module.exports = Query; × Search results Close "},"composer-client_lib_registry.js.html":{"id":"composer-client_lib_registry.js.html","title":"Source: composer-client/lib/registry.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-client/lib/registry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Resource = require('composer-common').Resource; const Util = require('composer-common').Util; /** * Class representing an Abstract Registry. * &lt;p&gt;&lt;a href=&quot;./diagrams/registry.svg&quot;&gt;&lt;img src=&quot;./diagrams/registry.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @abstract * @class * @memberof module:composer-client */ class Registry { /** * Get a list of all existing registries. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} registryType The type of this registry. * @param {boolean} [includeSystem] True if system registries should be included (optional default is false) * @return {Promise} A promise that will be resolved with an array of JSON * objects representing the registries. */ static getAllRegistries(securityContext, registryType, includeSystem) { Util.securityCheck(securityContext); includeSystem = includeSystem || false; if (!registryType) { throw new Error('registryType not specified'); } return Util.queryChainCode(securityContext, 'getAllRegistries', [registryType,includeSystem]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }); } /** * Get an existing registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} registryType The type of this registry. * @param {string} id The unique identifier of the registry. * @return {Promise} A promise that will be resolved with a JSON object * representing the registry. */ static getRegistry(securityContext, registryType, id) { Util.securityCheck(securityContext); if (!registryType) { throw new Error('registryType not specified'); } else if (!id) { throw new Error('id not specified'); } return Util.queryChainCode(securityContext, 'getRegistry', [registryType, id]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }); } /** * Determines whether a registry exists. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} registryType The type of this registry. * @param {string} id The unique identifier of the registry. * @return {Promise} A promise that will be resolved with true/false depending on whether the registry exists */ static existsRegistry(securityContext, registryType, id) { Util.securityCheck(securityContext); if (!registryType) { throw new Error('registryType not specified'); } else if (!id) { throw new Error('id not specified'); } return Util.queryChainCode(securityContext, 'existsRegistry', [registryType, id]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }); } /** * Add a new asset registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} registryType The type of this registry. * @param {string} id The unique identifier of the registry. * @param {string} name The name of the registry. * @return {Promise} A promise that will be resolved with a JSON object * representing the registry. */ static addRegistry(securityContext, registryType, id, name) { Util.securityCheck(securityContext); if (!registryType) { throw new Error('registryType not specified'); } else if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } return Util.invokeChainCode(securityContext, 'addRegistry', [registryType, id, name]) .then(() =&gt; { return { id: id, name: name }; }); } /** * Create a registry. * * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkConnection}&lt;/strong&gt; * &lt;/p&gt; * * @protected * @param {string} registryType The type of this registry. * @param {string} id The unique identifier of the registry. * @param {string} name The display name for the registry. * @param {SecurityContext} securityContext The users security context. * @param {ModelManager} modelManager The ModelManager to use for this registry. * @param {Factory} factory The factory to use for this registry. * @param {Serializer} serializer The Serializer to use for this registry. * @param {BusinessNetworkConnection} bnc Instance of the BusinessNetworkConnection * TODO: Rationalize the bnc with the other objects - as the bnc contains these other arguments */ constructor(registryType, id, name, securityContext, modelManager, factory, serializer,bnc) { if (!registryType) { throw new Error('registryType not specified'); } else if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } else if (!securityContext) { throw new Error('securityContext not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } this.registryType = registryType; this.id = id; this.name = name; this.securityContext = securityContext; this.modelManager = modelManager; this.factory = factory; this.serializer = serializer; this.bnc = bnc; } /** * Adds a list of new resources to the registry. * * @param {Resource[]} resources The resources to be added to the registry. * @return {Promise} A promise that will be resolved when the resource is * added to the registry. */ addAll(resources) { Util.securityCheck(this.securityContext); if (!resources) { throw new Error('resources not specified'); } let txName = 'Add'+this.registryType; // create the new system transaction to add the resources const transaction = this.factory.newTransaction('org.hyperledger.composer.system',txName); // target registry is the registry that this the client 'shadow' of transaction.targetRegistry = this.factory.newRelationship('org.hyperledger.composer.system',this.registryType+'Registry', this.id); transaction.resources = resources; return this.bnc.submitTransaction(transaction); } /** * Adds a new resource to the registry. * * @param {Resource} resource The resource to be added to the registry. * @return {Promise} A promise that will be resolved when the resource is * added to the registry. */ add(resource) { Util.securityCheck(this.securityContext); if (!resource) { throw new Error('resource not specified'); } return this.addAll([resource]); } /** * Updates a list of resources in the registry. * * @param {Resource[]} resources The resources to be updated in the asset registry. * @return {Promise} A promise that will be resolved when the resource is * added to the registry. */ updateAll(resources) { Util.securityCheck(this.securityContext); if (!resources) { throw new Error('resources not specified'); } let txName = 'Update'+this.registryType; const transaction = this.factory.newTransaction('org.hyperledger.composer.system',txName); // target registry is the registry that this the client 'shadow' of transaction.targetRegistry = this.factory.newRelationship('org.hyperledger.composer.system',this.registryType+'Registry', this.id); transaction.resources = resources; return this.bnc.submitTransaction(transaction); } /** * Updates a resource in the registry. * * @param {Resource} resource The resource to be updated in the registry. * @return {Promise} A promise that will be resolved when the resource is * updated in the registry. */ update(resource) { Util.securityCheck(this.securityContext); if (!resource) { throw new Error('resource not specified'); } return this.updateAll([resource]); } /** * Removes a list of resources from the registry. * * @param {(Resource[]|string[])} resources The resources, or the unique identifiers of the resources. * @return {Promise} A promise that will be resolved when the resource is * added to the registry. */ removeAll(resources) { Util.securityCheck(this.securityContext); if (!resources) { throw new Error('resources not specified'); } let txName = 'Remove'+this.registryType; const transaction = this.factory.newTransaction('org.hyperledger.composer.system',txName); transaction.resources = []; // target registry is the registry that this the client 'shadow' of transaction.targetRegistry = this.factory.newRelationship('org.hyperledger.composer.system',this.registryType+'Registry', this.id); transaction.resourceIds = resources.map((resource) =&gt; { if (resource instanceof Resource) { return resource.getIdentifier(); } else { return resource; } }); return this.bnc.submitTransaction(transaction); } /** * Remove an asset with a given type and id from the registry. * * @param {(Resource|string)} resource The resource, or the unique identifier of the resource. * @return {Promise} A promise that will be resolved when the resource is * removed from the registry. */ remove(resource) { Util.securityCheck(this.securityContext); if (!resource) { throw new Error('resource not specified'); } return this.removeAll([resource]); } /** * Get all of the resources in the registry. * * @return {Promise} A promise that will be resolved with an array of JSON * objects representing the resources. */ getAll() { Util.securityCheck(this.securityContext); return Util.queryChainCode(this.securityContext, 'getAllResourcesInRegistry', [this.registryType, this.id]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }) .then((resources) =&gt; { return resources.map((resource) =&gt; { return this.serializer.fromJSON(resource); }); }); } /** * Get a specific resource in the registry. * * @param {string} id The unique identifier of the resource. * @return {Promise} A promise that will be resolved with a JSON object * representing the resource. */ get(id) { Util.securityCheck(this.securityContext); if (!id) { throw new Error('id not specified'); } return Util.queryChainCode(this.securityContext, 'getResourceInRegistry', [this.registryType, this.id, id]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }) .then((resource) =&gt; { return this.serializer.fromJSON(resource); }); } /** * Determines whether a specific resource exists in the registry. * * @param {string} id The unique identifier of the resource. * @return {Promise} A promise that will be resolved with true/false depending on whether the resource exists. */ exists(id) { Util.securityCheck(this.securityContext); if (!id) { throw new Error('id not specified'); } return Util.queryChainCode(this.securityContext, 'existsResourceInRegistry', [this.registryType, this.id, id]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }); } /** * Get all of the resources in the registry, and resolve all of their relationships * to other assets, participants, and transactions. The result is a JavaScript * object, and should only be used for visualization purposes. You cannot use * the {@link add} or {@link update} functions with a resolved resource. * * @return {Promise} A promise that will be resolved with an array of JavaScript * objects representing the resources and all of their resolved relationships. */ resolveAll() { Util.securityCheck(this.securityContext); return Util.queryChainCode(this.securityContext, 'resolveAllResourcesInRegistry', [this.registryType, this.id]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }); } /** * Get a specific resource in the registry, and resolve all of its relationships * to other assets, participants, and transactions. The result is a JavaScript * object, and should only be used for visualization purposes. You cannot use * the {@link add} or {@link update} functions with a resolved resource. * * @param {string} id The unique identifier of the asset. * @return {Promise} A promise that will be resolved with a JavaScript object * representing the resource and all of its resolved relationships. */ resolve(id) { Util.securityCheck(this.securityContext); if (!id) { throw new Error('id not specified'); } return Util.queryChainCode(this.securityContext, 'resolveResourceInRegistry', [this.registryType, this.id, id]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }); } } module.exports = Registry; × Search results Close "},"composer-client_lib_transactionregistry.js.html":{"id":"composer-client_lib_transactionregistry.js.html","title":"Source: composer-client/lib/transactionregistry.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-client/lib/transactionregistry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Registry = require('./registry'); const Util = require('composer-common').Util; const REGISTRY_TYPE = 'Transaction'; /** * The TransactionRegistry is used to store a set of transactions on the blockchain. * &lt;p&gt;&lt;a href=&quot;./diagrams/transactionregistry.svg&quot;&gt;&lt;img src=&quot;./diagrams/transactionregistry.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends Registry * @see See [Registry]{@link module:composer-client.Registry} * @class * @memberof module:composer-client */ class TransactionRegistry extends Registry { /** * Get a list of all existing transaction registries. * * @param {SecurityContext} securityContext The user's security context. * @param {ModelManager} modelManager The ModelManager to use for this transaction registry. * @param {Factory} factory The factory to use for this transaction registry. * @param {Serializer} serializer The Serializer to use for this transaction registry. * @param {BusinessNetworkConnection} bnc BusinessNetworkConnection to use * @param {Boolean} systemRegistry True if system transaction registries should be included in the list. * @return {Promise} A promise that will be resolved with a list of {@link TransactionRegistry} * instances representing the transaction registries. */ static getAllTransactionRegistries(securityContext, modelManager, factory, serializer,bnc,systemRegistry) { Util.securityCheck(securityContext); if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getAllRegistries(securityContext, REGISTRY_TYPE,systemRegistry) .then((transactionRegistries) =&gt; { return transactionRegistries.map((transactionRegistry) =&gt; { return new TransactionRegistry(transactionRegistry.id, transactionRegistry.name, securityContext, modelManager, factory, serializer); }); }); } /** * Get an existing transaction registry. * * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the transaction registry. * @param {ModelManager} modelManager The ModelManager to use for this transaction registry. * @param {Factory} factory The factory to use for this transaction registry. * @param {Serializer} serializer The Serializer to use for this transaction registry. * @return {Promise} A promise that will be resolved with a {@link TransactionRegistry} * instance representing the transaction registry. */ static getTransactionRegistry(securityContext, id, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getRegistry(securityContext, REGISTRY_TYPE, id) .then((registry) =&gt; { return new TransactionRegistry(registry.id, registry.name, securityContext, modelManager, factory, serializer); }); } /** * Add a new transaction registry. * * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the transaction registry. * @param {string} name The name of the transaction registry. * @param {ModelManager} modelManager The ModelManager to use for this transaction registry. * @param {Factory} factory The factory to use for this transaction registry. * @param {Serializer} serializer The Serializer to use for this transaction registry. * @return {Promise} A promise that will be resolved with a {@link TransactionRegistry} * instance representing the new transaction registry. */ static addTransactionRegistry(securityContext, id, name, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.addRegistry(securityContext, REGISTRY_TYPE, id, name) .then(() =&gt; { return new TransactionRegistry(id, name, securityContext, modelManager, factory, serializer); }); } /** * Determine whether an registry exists. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the asset registry. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @return {Promise} A promise that will be resolved with a boolean indicating whether the asset registry exists */ static transactionRegistryExists(securityContext, id, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.existsRegistry(securityContext, REGISTRY_TYPE, id); } /** * Create an transaction registry. * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkConnection}&lt;/strong&gt; * &lt;/p&gt; * * @param {string} id The unique identifier of the transaction registry. * @param {string} name The display name for the transaction registry. * @param {SecurityContext} securityContext The security context to use for this asset registry. * @param {ModelManager} modelManager The ModelManager to use for this transaction registry. * @param {Factory} factory The factory to use for this transaction registry. * @param {Serializer} serializer The Serializer to use for this transaction registry. * @private */ constructor(id, name, securityContext, modelManager, factory, serializer) { super(REGISTRY_TYPE, id, name, securityContext, modelManager, factory, serializer); } /** * Unsupported operation; you cannot add a transaction to a transaction * registry. Call {@link BusinessNetworkConnection.submitTransaction} to submit a transaction. * * @param {Resource} resource The resource to be added to the registry. * @param {string} data The data for the resource. * @private */ add(resource) { throw new Error('cannot add transactions to a transaction registry'); } /** * Unsupported operation; you cannot add a transaction to a transaction * registry. Call {@link BusinessNetworkConnection.submitTransaction} to submit a transaction. * * @param {Resource[]} resources The resources to be added to the registry. * @private */ addAll(resources) { throw new Error('cannot add transactions to a transaction registry'); } /** * Unsupported operation; you cannot update a transaction in a transaction * registry. This method will always throw an exception when called. * * @param {Resource} resource The resource to be updated in the registry. * @private */ update(resource) { throw new Error('cannot update transactions in a transaction registry'); } /** * Unsupported operation; you cannot update a transaction in a transaction * registry. Call {@link BusinessNetworkConnection.submitTransaction} to submit a transaction. * * @param {Resource[]} resources The resources to be updated in the asset registry. * @private */ updateAll(resources) { throw new Error('cannot update transactions in a transaction registry'); } /** * Unsupported operation; you cannot remove a transaction from a transaction * registry. This method will always throw an exception when called. * * @param {(Resource|string)} resource The resource, or the unique identifier of the resource. * @private */ remove(resource) { throw new Error('cannot remove transactions from a transaction registry'); } /** * Unsupported operation; you cannot remove a transaction from a transaction * registry. This method will always throw an exception when called. * * @param {(Resource[]|string[])} resources The resources, or the unique identifiers of the resources. * @private */ removeAll(resources) { throw new Error('cannot remove transactions from a transaction registry'); } } module.exports = TransactionRegistry; × Search results Close "},"composer-common_index.js.html":{"id":"composer-common_index.js.html","title":"Source: composer-common/index.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/index.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Hyperledger-Composer module. Hyperledger-Composer is a framework for creating * blockchain backed digital networks and exchanging assets between participants * via processing transactions. * @module composer-common */ /** * Check whether we're running in a version of node which has the updated Buffer implementation * Used above to fall back to the old version if needed. * @return {boolean} whether the new version is supported */ function nodeHasNewBufferVersion() { try { Buffer.from('b2xkbm9kZQ==', 'base64'); return true; } catch (e) { /* istanbul ignore next */ return false; } } /* istanbul ignore next */ if (!nodeHasNewBufferVersion()) { const originalBufferFrom = Buffer.from; const newBufferFrom = function (str, encoding) { if (arguments.length === 2 &amp;&amp; typeof str === 'string' &amp;&amp; encoding === 'base64') { return new Buffer(str, encoding); } return originalBufferFrom.apply(null, arguments); }; Object.defineProperty(Buffer, 'from', { value: newBufferFrom }); } module.exports.AclRule = require('./lib/acl/aclrule'); module.exports.AclFile = require('./lib/acl/aclfile'); module.exports.AclManager = require('./lib/aclmanager'); module.exports.AssetDeclaration = require('./lib/introspect/assetdeclaration'); module.exports.BaseException = require('./lib/baseexception'); module.exports.BaseFileException = require('./lib/basefileexception'); module.exports.BusinessNetworkDefinition = require('./lib/businessnetworkdefinition'); module.exports.BusinessNetworkMetadata = require('./lib/businessnetworkmetadata'); module.exports.ClassDeclaration = require('./lib/introspect/classdeclaration'); module.exports.EnumDeclaration = require('./lib/introspect/enumdeclaration'); module.exports.EnumValueDeclaration = require('./lib/introspect/enumvaluedeclaration'); module.exports.Field = require('./lib/introspect/field'); module.exports.CodeGen = require('./lib/codegen/codegen.js'); module.exports.ComboConnectionProfileStore = require('./lib/comboconnectionprofilestore'); module.exports.Concept = require('./lib/model/concept'); module.exports.ConceptDeclaration = require('./lib/introspect/conceptdeclaration'); module.exports.Connection = require('./lib/connection'); module.exports.ConnectionManager = require('./lib/connectionmanager'); module.exports.ConnectionProfileManager = require('./lib/connectionprofilemanager'); module.exports.ConnectionProfileStore = require('./lib/connectionprofilestore'); module.exports.ConsoleLogger = require('./lib/log/consolelogger'); module.exports.EnvConnectionProfileStore = require('./lib/envconnectionprofilestore'); module.exports.EventDeclaration = require('./lib/introspect/eventdeclaration'); module.exports.Factory = require('./lib/factory'); module.exports.FileWallet = require('./lib/filewallet'); module.exports.FileWriter = require('./lib/codegen/filewriter'); module.exports.FSConnectionProfileStore = require('./lib/fsconnectionprofilestore'); module.exports.FunctionDeclaration = require('./lib/introspect/functiondeclaration'); module.exports.Globalize = require('./lib/globalize'); module.exports.IdCard = require('./lib/idcard'); module.exports.Introspector = require('./lib/introspect/introspector'); module.exports.Limit = require('./lib/query/limit'); module.exports.Logger = require('./lib/log/logger'); module.exports.LoopbackVisitor = require('./lib/codegen/fromcto/loopback/loopbackvisitor'); module.exports.ModelFile = require('./lib/introspect/modelfile'); module.exports.ModelManager = require('./lib/modelmanager'); module.exports.OrderBy = require('./lib/query/orderby'); module.exports.ParticipantDeclaration = require('./lib/introspect/participantdeclaration'); module.exports.Property = require('./lib/introspect/property'); module.exports.Query = require('./lib/query/query'); module.exports.QueryAnalyzer = require('./lib/query/queryanalyzer.js'); module.exports.QueryFile = require('./lib/query/queryfile'); module.exports.QueryManager = require('./lib/querymanager'); module.exports.Relationship = require('./lib/model/relationship'); module.exports.RelationshipDeclaration = require('./lib/introspect/relationshipdeclaration'); module.exports.Resource = require('./lib/model/resource'); module.exports.ScriptManager = require('./lib/scriptmanager'); module.exports.Script = require('./lib/introspect/script'); module.exports.ScriptManager = require('./lib/scriptmanager'); module.exports.SecurityContext = require('./lib/securitycontext'); module.exports.SecurityException = require('./lib/securityexception'); module.exports.Select = require('./lib/query/select'); module.exports.Serializer = require('./lib/serializer'); module.exports.Skip = require('./lib/query/skip'); module.exports.Sort = require('./lib/query/sort'); module.exports.TransactionDeclaration = require('./lib/introspect/transactiondeclaration'); module.exports.TypescriptVisitor = require('./lib/codegen/fromcto/typescript/typescriptvisitor'); module.exports.Util = require('./lib/util'); module.exports.ModelUtil = require('./lib/modelutil'); module.exports.Wallet = require('./lib/wallet'); module.exports.Where = require('./lib/query/where'); module.exports.Writer = require('./lib/codegen/writer.js'); module.exports.version = require('./package.json'); × Search results Close "},"composer-common_lib_acl_aclfile.js.html":{"id":"composer-common_lib_acl_aclfile.js.html","title":"Source: composer-common/lib/acl/aclfile.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/acl/aclfile.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const parser = require('./parser'); const AclRule = require('./aclrule'); const ParseException = require('../introspect/parseexception'); /** * Class representing an ACL File. * @private * @class * @memberof module:composer-common */ class AclFile { /** * Create an AclFile. This should only be called by framework code. * @param {string} id - The identifier of this ACL File (may be a filename for example) * @param {ModelManager} modelManager - the ModelManager that manages this * ModelFile and that will be used to validate the rules in the AclFile * @param {string} definitions - The ACL rules as a string. * @throws {IllegalModelException} */ constructor(id, modelManager, definitions) { this.modelManager = modelManager; this.rules = []; this.identifier = id; if(!definitions || typeof definitions !== 'string') { throw new Error('AclFile expects an AclFile as a string as input.'); } this.definitions = definitions; try { this.ast = parser.parse(definitions); } catch(err) { if(err.location &amp;&amp; err.location.start) { throw new ParseException(err.message, err.location); } else { throw err; } } for(let n=0; n &lt; this.ast.rules.length; n++ ) { let thing = this.ast.rules[n]; const aclRule = new AclRule(this, thing); // TODO (DCS) check that the id of the AclRule does not already exist this.rules.push(aclRule); } // console.log(JSON.stringify(this.ast)); } /** * Returns the name of this ACL File. * @return {string} the identifier of this ACL File */ getIdentifier() { return this.identifier; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the ModelManager associated with this AclFile * * @return {ModelManager} The ModelManager for this ModelFile */ getModelManager() { return this.modelManager; } /** * Validates the ModelFile. * * @throws {IllegalModelException} if the model is invalid * @private */ validate() { const aclRules = {}; this.rules.forEach((aclRule) =&gt; { aclRule.validate(); let name = aclRule.getName(); if (aclRules[name]){ throw new Error(`Found two or more ACL rules with the name '${name}'`); } aclRules[name] = aclRule; }); } /** * Get all declarations in this ACL file * @return {AclRule[]} the AclRules defined in the ACL file */ getAclRules() { return this.rules; } /** * Get the definitions for this ACL file. * @return {string} The definitions for this ACL file. */ getDefinitions() { return this.definitions; } } module.exports = AclFile; × Search results Close "},"composer-common_lib_aclmanager.js.html":{"id":"composer-common_lib_aclmanager.js.html","title":"Source: composer-common/lib/aclmanager.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/aclmanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AclFile = require('./acl/aclfile'); /** * &lt;p&gt; * Manages a set of ACL rules. * &lt;/p&gt; * @private * @class * @memberof module:composer-common */ class AclManager { /** * Create the AclManager. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkDefinition}&lt;/strong&gt; * &lt;/p&gt; * @param {ModelManager} modelManager - The ModelManager to use for this AclManager * @param {AclFile} aclFile - The AclFile that stores the rules */ constructor(modelManager) { this.modelManager = modelManager; this.aclFile = null; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Create an ACL file using the specified ID and contents. * @param {string} identifier The identifier of the ACL file. * @param {string} contents The contents of the ACL file. * @return {AclFile} The new ACL file. */ createAclFile(identifier, contents) { return new AclFile(identifier, this.modelManager, contents); } /** * Set the AclFile for this AclManager * @param {AclFile} aclFile - the AclFile to associate with this AclManager * @private */ setAclFile(aclFile) { aclFile.validate(); this.aclFile = aclFile; } /** * Get the AclFile associated with this AclManager * @return {AclFile} The AclFile for this AclManager or null if it has not been set */ getAclFile() { return this.aclFile; } /** * Get the AclRules associated with this AclManager * @return {AclRule[]} The AclRules for the AclManager or an empty array if not set */ getAclRules() { if(this.aclFile) { return this.aclFile.getAclRules(); } return []; } } module.exports = AclManager; × Search results Close "},"composer-common_lib_acl_aclrule.js.html":{"id":"composer-common_lib_acl_aclrule.js.html","title":"Source: composer-common/lib/acl/aclrule.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/acl/aclrule.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const IllegalModelException = require('../introspect/illegalmodelexception'); const ModelBinding = require('./modelbinding'); const ParticipantDeclaration = require('../introspect/participantdeclaration'); const Predicate = require('./predicate'); const TransactionDeclaration = require('../introspect/transactiondeclaration'); /** * AclRule captures the details of an Access Control Rule. It is defined in terms of * an ACTION performed on a NOUN by a PARTICIPANT with a PREDICATE used to filter the * NOUN/PARTICPANT interaction. * * @private * @class * @memberof module:composer-common */ class AclRule { /** * Create an AclRule from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {AclFile} aclFile - the AclFile for this rule * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(aclFile, ast) { if(!aclFile || !ast) { throw new IllegalModelException('Invalid AclFile or AST'); } this.ast = ast; this.aclFile = aclFile; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the AclFile that owns this AclRule. * * @return {AclFile} the owning AclFile */ getAclFile() { return this.aclFile; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { this.name = this.ast.id.name; this.noun = new ModelBinding(this, this.ast.noun, this.ast.nounVariable); this.verbs = this.ast.verbs; this.participant = null; if(this.ast.participant &amp;&amp; this.ast.participant !== 'ANY') { this.participant = new ModelBinding(this, this.ast.participant, this.ast.participantVariable); } this.transaction = null; if(this.ast.transaction) { this.transaction = new ModelBinding(this, this.ast.transaction.binding, this.ast.transaction.variableBinding); } this.predicate = null; if(this.ast.predicate) { this.predicate = new Predicate(this, this.ast.predicate); } else { this.predicate = new Predicate(this, 'true'); } this.action = this.ast.action; this.description = this.ast.description; } /** * Semantic validation of the structure of this AclRule. * * @throws {IllegalModelException} * @private */ validate() { this.noun.validate(); const foundVerbs = {}; this.verbs.forEach((verb) =&gt; { if (foundVerbs[verb]) { throw new IllegalModelException(`The verb '${verb}' has been specified more than once in the ACL rule '${this.name}'`); } foundVerbs[verb] = true; }); if(this.participant) { this.participant.validate(); let participantClassDeclaration = this.participant.getClassDeclaration(); if (participantClassDeclaration &amp;&amp; !(participantClassDeclaration instanceof ParticipantDeclaration)) { throw new IllegalModelException(`The participant '${participantClassDeclaration.getName()}' must be a participant`); } } if(this.transaction) { this.transaction.validate(); let transactionClassDeclaration = this.transaction.getClassDeclaration(); if (transactionClassDeclaration &amp;&amp; !(transactionClassDeclaration instanceof TransactionDeclaration)) { throw new IllegalModelException(`The transaction '${transactionClassDeclaration.getName()}' must be a transaction`); } } if(this.predicate) { this.predicate.validate(); } } /** * Returns the name of this AclRule. * * @return {string} the name of the AclRule */ getName() { return this.name; } /** * Returns the noun for this ACL rule. * * @return {ModelBinding} the noun ModelBinding */ getNoun() { return this.noun; } /** * Returns the verb associated with this ACL Rule. * * @return {string} the verb */ getVerbs() { return this.verbs; } /** * Returns the participant for this ACL rule. Returns null if this rule * does not filter based on participant. * * @return {ModelBinding} the participant ModelBinding or null */ getParticipant() { return this.participant; } /** * Returns the transaction for this ACL rule. Returns null if this rule * does not filter based on transaction. * * @return {ModelBinding} the transaction ModelBinding or null */ getTransaction() { return this.transaction; } /** * Returns the predicate associated with this ACL Rule * * @return {Predicate} the predicate */ getPredicate() { return this.predicate; } /** * Returns the action associated with this ACL Rule. * * @return {string} the action */ getAction() { return this.action; } /** * Returns the description associated with this ACL Rule. * * @return {string} the description */ getDescription() { return this.description; } } module.exports = AclRule; × Search results Close "},"composer-common_lib_codegen_fromjs_apisignaturegenerator.js.html":{"id":"composer-common_lib_codegen_fromjs_apisignaturegenerator.js.html","title":"Source: composer-common/lib/codegen/fromjs/apisignaturegenerator.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/codegen/fromjs/apisignaturegenerator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const fs = require('fs'); const Writer = require('../writer'); /** * Converts the includes, classes and methods in a Javascript * file into an API Signature File called api.txt, stored in the * output directory. * @private * @class * @memberof module:composer-common */ class APISignatureGenerator { /** * @param {Object} program - the program arguments * @param {Object} file - the file instance being processed * @param {Object[]} includes - the includes (require statements) within the file * @param {Object[]} classes - the classes within the file * @param {Object[]} functions - the functions within the file */ generate(program, file, includes, classes, functions) { // generate the output if(classes.length &gt; 0 || functions.length &gt; 0) { let writer = new Writer(); for(let n=0; n &lt; classes.length; n++) { const clazz = classes[n]; let superType = ''; if(clazz.superClass) { superType = ' extends ' + clazz.superClass; } writer.writeLine(0, 'class ' + clazz.name + superType + ' {' ); for(let i=0; i &lt; clazz.methods.length; i++) { const method = clazz.methods[i]; let throws = ''; if(method.throws) { throws = 'throws ' + method.throws; } writer.writeLine(1, method.visibility + ' ' + method.returnType + ' ' + method.name + paramsToString(method.methodArgs) + ' ' + throws ); } writer.writeLine(0, '}'); } for(let n=0; n &lt; functions.length; n++) { const func = functions[n]; let throws = ''; if(func.throws) { throws = 'throws ' + func.throws; } writer.writeLine(1, func.visibility + ' ' + func.returnType + ' ' + func.name + paramsToString(func.methodArgs) + ' ' + throws ); } fs.appendFileSync(program.outputDir + '/api.txt', writer.getBuffer()); } } } /** * Converts an array of parameter types to a string * @param {string[]} paramTypes array of parameter type names * @return {string} - string representation * @private */ function paramsToString(paramTypes) { let result = '('; for(let n=0; n &lt; paramTypes.length; n++) { result += paramTypes[n]; if(n &lt; paramTypes.length-1) { result += ','; } } result += ')'; return result; } module.exports = APISignatureGenerator; × Search results Close "},"composer-common_lib_introspect_assetdeclaration.js.html":{"id":"composer-common_lib_introspect_assetdeclaration.js.html","title":"Source: composer-common/lib/introspect/assetdeclaration.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/assetdeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); const IllegalModelException = require('./illegalmodelexception'); /** * AssetDeclaration defines the schema (aka model or class) for * an Asset. It extends ClassDeclaration which manages a set of * fields, a super-type and the specification of an * identifying field. * @private * @extends ClassDeclaration * @see See [ClassDeclaration]{@link module:composer-common.ClassDeclaration} * @class * @memberof module:composer-common */ class AssetDeclaration extends ClassDeclaration { /** * Create an AssetDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {IllegalModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } /** * Returns true if this class can be pointed to by a relationship * * @return {boolean} true if the class may be pointed to by a relationship */ isRelationshipTarget() { return true; } /** * Returns the base system type for Assets from the system namespace * * @return {string} the short name of the base system type */ getSystemType() { return 'Asset'; } /** * Semantic validation of the structure of this asset. Subclasses should * override this method to impose additional semantic constraints on the * contents/relations of fields. * * @throws {IllegalModelException} * @private */ validate() { super.validate(); if(!this.isSystemType() &amp;&amp; this.getName() === 'Asset') { throw new IllegalModelException('Asset is a reserved type name.', this.modelFile, this.ast.location); } } } module.exports = AssetDeclaration; × Search results Close "},"composer-common_lib_baseexception.js.html":{"id":"composer-common_lib_baseexception.js.html","title":"Source: composer-common/lib/baseexception.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/baseexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * A base class for all Composer exceptions * &lt;p&gt;&lt;a href=&quot;./diagrams/baseexception.svg&quot;&gt;&lt;img src=&quot;./diagrams/baseexception.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends Error * @class * @memberof module:composer-common */ class BaseException extends Error { /** * Create the BaseException. * @param {string} message - The exception message. */ constructor(message) { super(message); this.name = this.constructor.name; this.message = message; if (typeof Error.captureStackTrace === 'function') { Error.captureStackTrace(this, this.constructor); } } } module.exports = BaseException; × Search results Close "},"composer-common_lib_basefileexception.js.html":{"id":"composer-common_lib_basefileexception.js.html","title":"Source: composer-common/lib/basefileexception.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/basefileexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BaseException = require('./baseexception'); /** * Exception throws when a composer file is semantically invalid * @extends BaseException * @see See [BaseException]{@link module:composer-common.BaseException} * @class * @memberof module:composer-common */ class BaseFileException extends BaseException { /** * Create an IllegalModelException * @param {string} message - the message for the exception * @param {string} fileLocation - the optional file location associated with the exception * @param {string} fullMessage - the optional full message text */ constructor(message, fileLocation, fullMessage) { super(fullMessage ? fullMessage : message); this.fileLocation = fileLocation; this.shortMessage = message; } /** * Returns the file location associated with the exception or null * @return {string} the optional location associated with the exception */ getFileLocation() { return this.fileLocation; } /** * Returns the error message without the location of the error * @returns {string} the error message */ getShortMessage() { return this.shortMessage; } } module.exports = BaseFileException; × Search results Close "},"composer-common_lib_cardstore_businessnetworkcardstore.js.html":{"id":"composer-common_lib_cardstore_businessnetworkcardstore.js.html","title":"Source: composer-common/lib/cardstore/businessnetworkcardstore.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/cardstore/businessnetworkcardstore.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Manages persistence of business network cards. * * @private * @abstract * @class * @memberof module:composer-common */ class BusinessNetworkCardStore { /** * Gets a card from the store. * @abstract * @param {String} cardName The name of the card to get * @return {Promise} A promise that is resolved with a {@link IdCard}. */ get(cardName) { return Promise.reject(new Error('Abstract function called')); } /** * Puts a card in the store. * @abstract * @param {String} cardName The name of the card to save * @param {IdCard} card The card * @return {Promise} A promise that resolves once the data is written */ put(cardName, card) { return Promise.reject(new Error('Abstract function called')); } /** * Gets all cards from the store. * @abstract * @return {Promise} A promise that is resolved with a {@link Map} where * the keys are identity card names and the values are {@link IdCard} objects. */ getAll() { return Promise.reject(new Error('Abstract function called')); } /** * Delete a specific card from the store. * @abstract * @param {String} cardName The name of the card to delete * @return {Promise} A promise that resolves when the card is deleted. */ delete(cardName) { return Promise.reject(new Error('Abstract function called')); } } module.exports = BusinessNetworkCardStore; × Search results Close "},"composer-common_lib_businessnetworkdefinition.js.html":{"id":"composer-common_lib_businessnetworkdefinition.js.html","title":"Source: composer-common/lib/businessnetworkdefinition.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/businessnetworkdefinition.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AclFile = require('./acl/aclfile'); const AclManager = require('./aclmanager'); const QueryFile = require('./query/queryfile'); const QueryManager = require('./querymanager'); const BusinessNetworkMetadata = require('./businessnetworkmetadata'); const Factory = require('./factory'); const fs = require('fs'); const fsPath = require('path'); const Introspector = require('./introspect/introspector'); const JSZip = require('jszip'); const Logger = require('./log/logger'); const ModelManager = require('./modelmanager'); const minimatch = require('minimatch'); const ScriptManager = require('./scriptmanager'); const semver = require('semver'); const Serializer = require('./serializer'); const ENCODING = 'utf8'; const LOG = Logger.getLog('BusinessNetworkDefinition'); /** define a help function that will filter out files * that are inside a node_modules directory under the path * we are processing * @private * @param {File} file to load * @param {Path} basePath to search from * @return {boolean} returns true/false */ const _isFileInNodeModuleDir = function (file, basePath) { const method = 'isFileInNodeModuleDir'; let filePath = fsPath.parse(file); let subPath = filePath.dir.substring(basePath.length); let result = subPath.split(fsPath.sep).some((element) =&gt; { return element === 'node_modules'; }); LOG.debug(method, file, result); return result; }; /** * &lt;p&gt; * A BusinessNetworkDefinition defines a set of Participants that exchange Assets by * sending Transactions. This class manages the metadata and domain-specific types for * the network as well as a set of executable scripts. * &lt;/p&gt; * @class * @memberof module:composer-common */ class BusinessNetworkDefinition { /** * Create the BusinessNetworkDefinition. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkDefinition.fromArchive}&lt;/strong&gt; * &lt;/p&gt; * @param {String} identifier - the identifier of the business network. The * identifier is formed from a business network name + '@' + version. The * version is a semver valid version string. If package.json is passed this is ignored. * @param {String} description - the description of the business network. If package.json is passed then this is ignored. * @param {object} packageJson - the JS object for package.json (optional) * @param {String} readme - the readme in markdown for the business network (optional) */ constructor(identifier, description, packageJson, readme) { const method = 'constructor'; LOG.entry(method, identifier, description); // if package.json is not present we generate one based on the metadata passed if(!packageJson) { const atIndex = identifier.lastIndexOf('@'); let name = null; if (atIndex &gt;= 0) { name = identifier.substring(0, atIndex); } else { throw new Error('Malformed business network identifier. It must be &quot;name@major.minor.micro&quot;'); } const version = identifier.substring(atIndex + 1); if (!semver.valid(version)) { throw new Error('Version number is invalid. Should be valid according to semver but found: ' + version); } packageJson = {}; packageJson.name = name; packageJson.version = version; packageJson.description = description; LOG.debug(method, 'Created package.json' + JSON.stringify(packageJson)); } else { LOG.debug(method, 'Using package.json' + JSON.stringify(packageJson)); } this.modelManager = new ModelManager(); this.aclManager = new AclManager(this.modelManager); this.queryManager = new QueryManager(this.modelManager); this.scriptManager = new ScriptManager(this.modelManager); this.introspector = new Introspector(this.modelManager); this.factory = new Factory(this.modelManager); this.serializer = new Serializer(this.factory, this.modelManager); this.metadata = new BusinessNetworkMetadata(packageJson,readme); LOG.exit(method); } /** * Returns the identifier for this business network * @return {String} the identifier of this business network */ getIdentifier() { return this.getMetadata().getIdentifier(); } /** * Returns the metadata for this business network * @return {BusinessNetworkMetadata} the metadata for this business network */ getMetadata() { return this.metadata; } /** * Returns the name for this business network * @return {String} the name of this business network */ getName() { return this.getMetadata().getName(); } /** * Returns the version for this business network * @return {String} the version of this business network. Use semver module * to parse. */ getVersion() { return this.getMetadata().getVersion(); } /** * Returns the description for this business network * @return {String} the description of this business network */ getDescription() { return this.getMetadata().getDescription(); } /** * Create a BusinessNetworkDefinition from an archive. * @param {Buffer} Buffer - the Buffer to a zip archive * @return {Promise} a Promise to the instantiated business network */ static fromArchive(Buffer) { const method = 'fromArchive'; LOG.entry(method, Buffer.length); return JSZip.loadAsync(Buffer).then(function(zip) { let promise = Promise.resolve(); let ctoModelFiles = []; let ctoModelFileNames = []; let jsScriptFiles = []; let permissionsFiles = []; let queriesFiles = []; let businessNetworkDefinition; let readmeContents = null; let packageJsonContents = null; LOG.debug(method, 'Loading README.md'); let readme = zip.file('README.md'); if(readme) { promise = promise.then(() =&gt; { return readme.async('string'); }).then((contents) =&gt; { LOG.debug(method, 'Loaded README.md'); readmeContents = contents; }); } LOG.debug(method, 'Loading package.json'); let packageJson = zip.file('package.json'); if (packageJson === null) { throw Error('package.json must exist'); } promise = promise.then(() =&gt; { return packageJson.async('string'); }).then((contents) =&gt; { LOG.debug(method, 'Loaded package.json'); packageJsonContents = JSON.parse(contents); }); LOG.debug(method, 'Looking for model files'); let ctoFiles = zip.file(/models\\/.*\\.cto$/); //Matches any file which is in the 'models' folder and has a .cto extension ctoFiles.forEach(function(file) { LOG.debug(method, 'Found model file, loading it', file.name); ctoModelFileNames.push(file.name); promise = promise.then(() =&gt; { return file.async('string'); }).then((contents) =&gt; { LOG.debug(method, 'Loaded model file'); ctoModelFiles.push(contents); }); }); LOG.debug(method, 'Looking for JavaScript files'); let jsFiles = zip.file(/lib\\/.*\\.js$/); //Matches any file which is in the 'lib' folder and has a .js extension jsFiles.forEach(function(file) { LOG.debug(method, 'Found JavaScript file, loading it', file.name); promise = promise.then(() =&gt; { return file.async('string'); }).then((contents) =&gt; { LOG.debug(method, 'Loaded JavaScript file'); let tempObj = { 'name': file.name, 'contents': contents }; jsScriptFiles.push(tempObj); }); }); LOG.debug(method, 'Loading permissions.acl'); let aclFile = zip.file('permissions.acl'); if (aclFile !== null) { promise = promise.then(() =&gt; { return aclFile.async('string'); }).then(contents =&gt; { LOG.debug(method, 'Loaded permissions.acl'); permissionsFiles.push(contents); }); } LOG.debug(method, 'Loading query queries.qry'); let queryFile = zip.file('queries.qry'); if (queryFile !== null) { promise = promise.then(() =&gt; { return queryFile.async('string'); }).then(contents =&gt; { LOG.debug(method, 'Loaded queries.qry'); queriesFiles.push(contents); }); } return promise.then(() =&gt; { LOG.debug(method, 'Loaded package.json'); businessNetworkDefinition = new BusinessNetworkDefinition(null, null, packageJsonContents, readmeContents); LOG.debug(method, 'Loaded all model, JavaScript, ACL files and Query files'); LOG.debug(method, 'Adding model files to model manager'); businessNetworkDefinition.modelManager.addModelFiles(ctoModelFiles,ctoModelFileNames); // Adds all cto files to model manager LOG.debug(method, 'Added model files to model manager'); LOG.debug(method, 'Adding JavaScript files to script manager'); jsScriptFiles.forEach(function(obj) { let jsObject = businessNetworkDefinition.scriptManager.createScript(obj.name, 'js', obj.contents); businessNetworkDefinition.scriptManager.addScript(jsObject); // Adds all js files to script manager }); LOG.debug(method, 'Added JavaScript files to script manager'); LOG.debug(method, 'Adding ACL files to ACL manager'); permissionsFiles.forEach((permissionFile) =&gt; { businessNetworkDefinition.getAclManager().setAclFile( new AclFile('permissions.acl', businessNetworkDefinition.getModelManager(), permissionFile)); }); LOG.debug(method, 'Added ACL files to ACL manager'); LOG.debug(method, 'Adding Query files to query manager'); queriesFiles.forEach((queryFile) =&gt; { businessNetworkDefinition.getQueryManager().setQueryFile( new QueryFile('queries.qry', businessNetworkDefinition.getModelManager(), queryFile)); }); LOG.debug(method, 'Added Query files to query manager'); LOG.exit(method, businessNetworkDefinition.toString()); return businessNetworkDefinition; // Returns business network (with model manager and script manager) }); }); } /** * Store a BusinessNetworkDefinition as an archive. * @param {Object} [options] - JSZip options * @return {Buffer} buffer - the zlib buffer */ toArchive(options) { let zip = new JSZip(); let packageFileContents = JSON.stringify(this.getMetadata().getPackageJson()); zip.file('package.json', packageFileContents, options); // save the README.md if present if(this.getMetadata().getREADME()) { zip.file('README.md', this.getMetadata().getREADME(), options); } const aclFile = this.getAclManager().getAclFile(); if(aclFile) { zip.file(aclFile.getIdentifier(), aclFile.definitions, options); } const queryFile = this.getQueryManager().getQueryFile(); if(queryFile) { zip.file(queryFile.getIdentifier(), queryFile.definitions, options); } let modelManager = this.getModelManager(); let modelFiles = modelManager.getModelFiles(); zip.file('models/', null, Object.assign({}, options, { dir: true })); modelFiles.forEach(function(file) { let fileName; // ignore the system namespace when creating an archive if (file.isSystemModelFile()){ return; } if (file.fileName === 'UNKNOWN' || file.fileName === null || !file.fileName) { fileName = file.namespace + '.cto'; } else { let fileIdentifier = file.fileName; fileName = fsPath.basename(fileIdentifier); } zip.file('models/' + fileName, file.definitions, options); }); let scriptManager = this.getScriptManager(); let scriptFiles = scriptManager.getScripts(); zip.file('lib/', null, Object.assign({}, options, { dir: true })); scriptFiles.forEach(function(file) { let fileIdentifier = file.identifier; let fileName = fsPath.basename(fileIdentifier); zip.file('lib/' + fileName, file.contents, options); }); return zip.generateAsync({ type: 'nodebuffer' }).then(something =&gt; { return Promise.resolve(something).then(result =&gt; { return result; }); }); } /** Load and parse the package.json * @private * @param {Path} path to load from * @return {Object} parsed object */ static _getPackageJson(path){ const method='_getPackageJson'; // grab the package.json let packageJsonContents = fs.readFileSync( fsPath.resolve(path, 'package.json'), ENCODING); if(!packageJsonContents) { throw new Error('Failed to find package.json'); } LOG.debug(method, 'Loaded package.json', packageJsonContents); // parse the package.json return JSON.parse(packageJsonContents); } /** * This is looking through the dependancies that are listed in the package.json. * @private * @param {Object} jsonObject the package.json object * @param {Path} path the location that was specified * @param {Object} options that include the globs * @param {String[]} modelFiles find and add to this array modelFiles contents * @param {String[]} modelFileNames finad and add to this array the modelFileNames */ static _processDependencies(jsonObject,path,options,modelFiles,modelFileNames){ const method='_processDependencies'; LOG.debug(method, 'All dependencies', Object.keys(jsonObject.dependencies).toString()); const dependencies = Object.keys(jsonObject.dependencies).filter(minimatch.filter(options.dependencyGlob, { dot: true })); LOG.debug(method, 'Matched dependencies', dependencies); for( let dep of dependencies) { // find all the *.cto files under the npm install dependency path let dependencyPath = fsPath.resolve(path, 'node_modules', dep); LOG.debug(method, 'Checking dependency path', dependencyPath); if (!fs.existsSync(dependencyPath)) { // need to check to see if this is in a peer directory as well // LOG.debug(method,'trying different path '+path.replace(jsonObject.name,'')); dependencyPath = fsPath.resolve(path.replace(jsonObject.name,''),dep); if(!fs.existsSync(dependencyPath)){ throw new Error('npm dependency path ' + dependencyPath + ' does not exist. Did you run npm install?'); } } BusinessNetworkDefinition.processDirectory(dependencyPath, { accepts: function(file) { return _isFileInNodeModuleDir(file, dependencyPath) === false &amp;&amp; minimatch(file, options.modelFileGlob, { dot: true }); }, acceptsDir: function(dir) { return !_isFileInNodeModuleDir(dir, dependencyPath); }, process: function(path,contents) { modelFiles.push(contents); modelFileNames.push(path); LOG.debug(method, 'Found model file', path); } }); } } /** * Looks for the model files in the path, and sets on the business network. * @private * @param {Object} jsonObject the package.json object * @param {Path} path the location that was specified * @param {Object} options that include the globs * @param {BusinessNetworkDefinition} businessNetwork that is being created */ static _processModelFiles(jsonObject,path,options,businessNetwork){ const method='_processModelFiles'; const modelFiles = []; const modelFileNames = []; // process each module dependency // filtering using a glob on the module dependency name if(jsonObject.dependencies) { this._processDependencies(jsonObject,path,options,modelFiles,modelFileNames); } // find CTO files outside the npm install directory // BusinessNetworkDefinition.processDirectory(path, { accepts: function(file) { return _isFileInNodeModuleDir(file, path) === false &amp;&amp; minimatch(file, options.modelFileGlob, { dot: true }); }, acceptsDir: function(dir) {modelFileNames; return !_isFileInNodeModuleDir(dir, path); }, process: function(path,contents) { modelFiles.push(contents); modelFileNames.push(path); LOG.debug(method, 'Found model file', path); } }); if(modelFiles.length === 0) { throw new Error('Failed to find a model file.'); } businessNetwork.getModelManager().addModelFiles(modelFiles,modelFileNames); LOG.debug(method, 'Added model files', modelFiles.length); } /** * Looks for the script files in the path, and sets on the business network. * @private * @param {Object} jsonObject the package.json object * @param {Path} path the location that was specified * @param {Object} options that include the globs * @param {BusinessNetworkDefinition} businessNetwork that is being created */ static _processScriptFiles(jsonObject,path,options,businessNetwork){ const method='_processScriptFiles'; const scriptFiles = []; BusinessNetworkDefinition.processDirectory(path, { accepts: function(file) { return _isFileInNodeModuleDir(file, path) === false &amp;&amp; minimatch(file, options.scriptGlob, { dot: true }); }, acceptsDir: function(dir) { return !_isFileInNodeModuleDir(dir, path); }, process: function(path,contents) { let filePath = fsPath.parse(path); const jsScript = businessNetwork.getScriptManager().createScript(path, filePath.ext.toLowerCase(), contents); scriptFiles.push(jsScript); LOG.debug(method, 'Found script file ', path); } }); for( let script of scriptFiles) { businessNetwork.getScriptManager().addScript(script); } LOG.debug(method, 'Added script files', scriptFiles.length); } /** * Looks for the permissions.acl file in the path, and sets on the business network. * @private * @param {Object} jsonObject the package.json object * @param {Path} path the location that was specified * @param {Object} options that include the globs * @param {BusinessNetworkDefinition} businessNetwork that is being created */ static _processPermissionsAcl(jsonObject,path,options,businessNetwork){ const method = '_processPermissionsAcl'; const aclPath = fsPath.resolve(path, 'permissions.acl'); if(fs.existsSync(aclPath)) { let permissionsAclContents = fs.readFileSync( aclPath, ENCODING); if(permissionsAclContents) { LOG.debug(method, 'Loaded permissions.acl', permissionsAclContents); const aclFile = new AclFile('permissions.acl', businessNetwork.getModelManager(), permissionsAclContents); businessNetwork.getAclManager().setAclFile(aclFile); } } } /** * Looks for the queries file in the path, and sets on the business network. * @private * @param {Object} jsonObject the package.json object * @param {Path} path the location that was specified * @param {Object} options that include the globs * @param {BusinessNetworkDefinition} businessNetwork that is being created */ static _processQueryFile(jsonObject,path,options,businessNetwork){ const method = '_processQueryFile'; const queryPath = fsPath.resolve(path, 'queries.qry'); if(fs.existsSync(queryPath)) { let queryContents = fs.readFileSync( queryPath, ENCODING); if(queryContents) { LOG.debug(method, 'Loaded queries.qry', queryContents); const queryFile = new QueryFile('queries.qry', businessNetwork.getModelManager(), queryContents); businessNetwork.getQueryManager().setQueryFile(queryFile); } } } /** * @private * @param {String} path to search for the readme * @return {String} contents of the readme, if any. defaults to null */ static _processReadme(path){ const method = '_processReadme'; let readmeContents = null; const readmePath = fsPath.resolve(path, 'README.md'); if(fs.existsSync(readmePath)) { readmeContents = fs.readFileSync(readmePath, ENCODING); if(readmeContents) { LOG.debug(method, 'Loaded README.md', readmeContents); } } return readmeContents; } /** * Builds a BusinessNetworkDefintion from the contents of a directory. * The directory must include a package.json in the root (used to specify * the name, version and description of the business network). This method * is designed to work with business networks that refer to external models * using npm dependencies as well as business networks that statically * package their model files. * &lt;p&gt; * If package.json contains a dependencies property then this method will search for * model (CTO) files under the node_modules directory for each dependency that * passes the options.dependencyGlob pattern. * &lt;/p&gt; * &lt;p&gt; * If the network depends on an npm module its dependencies (transitive closure) * will also be scanned for model (CTO) files. * &lt;/p&gt; * &lt;p&gt; * The directory may optionally contain a README.md file which is accessible from the * BusinessNetworkMetadata.getREADME method. * &lt;/p&gt; * &lt;p&gt; * In addition all model files will be added that are not under node_modules * and that pass the options.modelFileGlob pattern. By default you should put * model files under a directory called 'models'. * &lt;/p&gt; * &lt;p&gt; * All script (js) files will be added that are not under node_modules and * that pass the options.scriptGlob pattern. By default you should put Javascript * files under the 'lib' directory. * &lt;/p&gt; * * @param {String} path to a local directory * @param {Object} [options] - an optional set of options to configure the instance. * @param {Object} [options.dependencyGlob] - specify the glob pattern used to match * the npm dependencies to process. Defaults to ** * @param {boolean} [options.modelFileGlob] - specify the glob pattern used to match * the model files to include. Defaults to **\\/models/**\\/*.cto * @param {boolean} [options.scriptGlob] - specify the glob pattern used to match * the script files to include. Defaults to **\\/lib/**\\/*.js * @return {Promise} a Promise to the instantiated business network */ static fromDirectory(path, options) { const method = 'fromDirectory'; LOG.entry(method, path); return Promise.resolve().then(()=&gt; { options = options || {}; if(!options.dependencyGlob) { options.dependencyGlob = '**'; } if(!options.modelFileGlob) { options.modelFileGlob = '**/models/**/*.cto'; } if(!options.scriptGlob) { options.scriptGlob = '**/lib/**/*.js'; } // resolve the path to remove relative paths so the globs make more sense // and minimatch path = fsPath.resolve(path); let jsonObject = this._getPackageJson(path); // create the business network definition const businessNetwork = new BusinessNetworkDefinition(null, null, jsonObject, this._processReadme(path)); // search and find the cto files this._processModelFiles(jsonObject,path,options,businessNetwork); // find script files outside the npm install directory this._processScriptFiles(jsonObject,path,options,businessNetwork); // grab the permissions.acl this._processPermissionsAcl(jsonObject,path,options,businessNetwork); // grab the queries.qry this._processQueryFile(jsonObject,path,options,businessNetwork); LOG.exit(method, path); return businessNetwork; }); } /** * @param {String} path - the path to process * @param {Object} fileProcessor - the file processor. It must have * accept and process methods. * @private */ static processDirectory(path, fileProcessor) { const items = BusinessNetworkDefinition.walkSync(path, [], fileProcessor); items.sort(); LOG.debug('processDirectory', 'Path ' + path, items); items.forEach((item) =&gt; { BusinessNetworkDefinition.processFile(item, fileProcessor); }); } /** * @param {String} file - the file to process * @param {Object} fileProcessor - the file processor. It must have * accepts and process methods. * @private */ static processFile(file, fileProcessor) { if (fileProcessor.accepts(file)) { LOG.debug('processFile', 'FileProcessor accepted', file ); let fileContents = fs.readFileSync(file, ENCODING); fileProcessor.process(file, fileContents); } else { LOG.debug('processFile', 'FileProcessor rejected', file ); } } /** * @param {String} dir - the dir to walk * @param {Object[]} filelist - input files * @param {Object} fileProcessor - the file processor. It must have * accepts and process methods. * @return {Object[]} filelist - output files * @private */ static walkSync(dir, filelist, fileProcessor) { let files = fs.readdirSync(dir); files.forEach(function (file) { let nestedPath = fsPath.join(dir, file); if (fs.lstatSync(nestedPath).isDirectory()) { if (fileProcessor.acceptsDir(nestedPath)) { filelist = BusinessNetworkDefinition.walkSync(nestedPath, filelist, fileProcessor); } } else { filelist.push(nestedPath); } }); return filelist; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor, parameters) { return visitor.visit(this, parameters); } /** * Provides access to the Introspector for this business network. The Introspector * is used to reflect on the types defined within this business network. * @return {Introspector} the Introspector for this business network */ getIntrospector() { return this.introspector; } /** * Provides access to the Factory for this business network. The Factory * is used to create the types defined in this business network. * @return {Factory} the Factory for this business network */ getFactory() { return this.factory; } /** * Provides access to the Serializer for this business network. The Serializer * is used to serialize instances of the types defined within this business network. * @return {Serializer} the Serializer for this business network */ getSerializer() { return this.serializer; } /** * Provides access to the ScriptManager for this business network. The ScriptManager * manage access to the scripts that have been defined within this business network. * @return {ScriptManager} the ScriptManager for this business network * @private */ getScriptManager() { return this.scriptManager; } /** * Provides access to the AclManager for this business network. The AclManager * manage access to the access conrol rules that have been defined for this business network. * @return {AclManager} the AclManager for this business network * @private */ getAclManager() { return this.aclManager; } /** * Provides access to the ModelManager for this business network. The ModelManager * manage access to the models that have been defined within this business network. * @return {ModelManager} the ModelManager for this business network * @private */ getModelManager() { return this.modelManager; } /** * Provides access to the QueryManager for this business network. The QueryManager * manage access to the models that have been defined within this business network. * @return {QueryManager} the QueryManager for this business network * @private */ getQueryManager() { return this.queryManager; } /** * Set the readme file within the BusinessNetworkMetadata * @param {String} readme the readme in markdown for the business network * @private */ setReadme(readme) { this.metadata = new BusinessNetworkMetadata(this.metadata.getPackageJson(), readme); } /** * Set the packageJson within the BusinessNetworkMetadata * @param {object} packageJson the JS object for package.json * @private */ setPackageJson(packageJson) { this.metadata = new BusinessNetworkMetadata(packageJson, this.metadata.getREADME()); } } module.exports = BusinessNetworkDefinition; × Search results Close "},"composer-common_lib_businessnetworkmetadata.js.html":{"id":"composer-common_lib_businessnetworkmetadata.js.html","title":"Source: composer-common/lib/businessnetworkmetadata.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/businessnetworkmetadata.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('./log/logger'); const LOG = Logger.getLog('BusinessNetworkMetadata'); /** * &lt;p&gt; * Defines the metadata for a BusinessNeworkDefinition. This includes: * &lt;ul&gt; * &lt;li&gt;package.json&lt;/li&gt; * &lt;li&gt;README.md (optional)&lt;/li&gt; * &lt;/ul&gt; * &lt;/p&gt; * @class * @memberof module:composer-common */ class BusinessNetworkMetadata { /** * Create the BusinessNetworkMetadata. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkDefinition}&lt;/strong&gt; * &lt;/p&gt; * @param {object} packageJson - the JS object for package.json (required) * @param {String} readme - the README.md for the business network (may be null) */ constructor(packageJson, readme) { const method = 'constructor'; LOG.entry(method, readme); if(!packageJson || typeof(packageJson) !== 'object') { throw new Error('package.json is required and must be an object'); } if (!packageJson.name || !this._validName(packageJson.name)) { throw new Error ('business network name can only contain lowercase alphanumerics, _ or -'); } this.packageJson = packageJson; if(readme &amp;&amp; typeof(readme) !== 'string') { throw new Error('README must be a string'); } this.readme = readme; LOG.exit(method); } /** * check to see if it is a valid name. for some reason regex is not working when this executes * inside the chaincode runtime, which is why regex hasn't been used. * * @param {string} name the business network name to check * @returns {boolean} true if valid, false otherwise * * @memberOf BusinessNetworkMetadata * @private */ _validName(name) { const validChars = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z', '0','1','2','3','4','5','6','7','8','9','-','_']; for (let i = 0; i&lt;name.length; i++){ const strChar = name.charAt(i); if ( validChars.indexOf(strChar) === -1 ) { return false; } } return true; } /** * Returns the README.md for this business network. This may be null if the business network does not have a README.md * @return {String} the README.md file for the business network or null */ getREADME() { return this.readme; } /** * Returns the package.json for this business network. * @return {object} the Javascript object for package.json */ getPackageJson() { return this.packageJson; } /** * Returns the name for this business network. * @return {string} the name of the business network */ getName() { return this.packageJson.name; } /** * Returns the description for this business network. * @return {string} the description of the business network */ getDescription() { return this.packageJson.description; } /** * Returns the version for this business network. * @return {string} the description of the business network */ getVersion() { return this.packageJson.version; } /** * Returns the identifier for this business network, formed from name@version. * @return {string} the identifier of the business network */ getIdentifier() { return this.packageJson.name + '@' + this.packageJson.version; } } module.exports = BusinessNetworkMetadata; × Search results Close "},"composer-common_lib_introspect_classdeclaration.js.html":{"id":"composer-common_lib_introspect_classdeclaration.js.html","title":"Source: composer-common/lib/introspect/classdeclaration.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/classdeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Decorated = require('./decorated'); const Field = require('./field'); const EnumValueDeclaration = require('./enumvaluedeclaration'); const RelationshipDeclaration = require('./relationshipdeclaration'); const IllegalModelException = require('./illegalmodelexception'); const Globalize = require('../globalize'); const Introspector = require('./introspector'); /** * ClassDeclaration defines the structure (model/schema) of composite data. * It is composed of a set of Properties, may have an identifying field, and may * have a super-type. * A ClassDeclaration is conceptually owned by a ModelFile which * defines all the classes that are part of a namespace. * * @private * @abstract * @class * @memberof module:composer-common */ class ClassDeclaration extends Decorated { /** * Create a ClassDeclaration from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {ModelFile} modelFile - the ModelFile for this class * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(modelFile, ast) { super(ast); if(!modelFile) { throw new IllegalModelException(Globalize.formatMessage('classdeclaration-constructor-modelastreq')); } this.modelFile = modelFile; this.process(); } /** * Returns the ModelFile that defines this class. * * @return {ModelFile} the owning ModelFile */ getModelFile() { return this.modelFile; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { super.process(); this.name = this.ast.id.name; this.properties = []; this.superType = null; this.idField = null; this.abstract = false; if(this.ast.abstract) { this.abstract = true; } if(this.ast.classExtension) { this.superType = this.ast.classExtension.class.name; } else { // if we are not a system type, then we should set the // super type to the system type for this class declaration if(!this.isSystemCoreType()) { this.superType = this.getSystemType(); } } if(this.ast.idField) { this.idField = this.ast.idField.name; } for(let n=0; n &lt; this.ast.body.declarations.length; n++ ) { let thing = this.ast.body.declarations[n]; if(thing.type === 'FieldDeclaration') { this.properties.push( new Field(this, thing) ); } else if(thing.type === 'RelationshipDeclaration') { this.properties.push( new RelationshipDeclaration(this, thing) ); } else if(thing.type === 'EnumPropertyDeclaration') { this.properties.push( new EnumValueDeclaration(this, thing) ); } else { let formatter = Globalize.messageFormatter('classdeclaration-process-unrecmodelelem'); throw new IllegalModelException(formatter({ 'type': thing.type }), this.modelFile, this.ast.location); } } } /** * Semantic validation of the structure of this class. Subclasses should * override this method to impose additional semantic constraints on the * contents/relations of fields. * * @throws {IllegalModelException} * @private */ validate() { super.validate(); const declarations = this.getModelFile().getAllDeclarations(); for(let n=0; n &lt; declarations.length; n++) { let declaration = declarations[n]; // check we don't have an asset with the same name for(let i=n+1; i &lt; declarations.length; i++) { let otherDeclaration = declarations[i]; if(declaration.getFullyQualifiedName() === otherDeclaration.getFullyQualifiedName()) { throw new IllegalModelException(`Duplicate class name ${declaration.getName()}`); } } } // TODO (LG) check that all imported classes exist, rather than just // used imports // if we have a super type make sure it exists if(this.superType!==null) { let classDecl = null; if(this.getModelFile().isImportedType(this.superType)) { let fqnSuper = this.getModelFile().resolveImport(this.superType); classDecl = this.modelFile.getModelManager().getType(fqnSuper); } else { classDecl = this.getModelFile().getType(this.superType); } if(classDecl===null) { throw new IllegalModelException('Could not find super type ' + this.superType, this.modelFile, this.ast.location); } // Prevent extending declaration with different type of declaration const supertypeDeclaration = this.getModelFile().getType(this.superType); if (supertypeDeclaration) { if (this.constructor.name !== supertypeDeclaration.constructor.name) { let typeName = this.getSystemType(); let superTypeName = supertypeDeclaration.getSystemType(); throw new IllegalModelException(`${typeName} (${this.getName()}) cannot extend ${superTypeName} (${supertypeDeclaration.getName()})`, this.modelFile, this.ast.location); } } } if(this.idField) { const field = this.getProperty(this.idField); if(!field) { let formatter = Globalize('en').messageFormatter('classdeclaration-validate-identifiernotproperty'); throw new IllegalModelException(formatter({ 'class': this.name, 'idField': this.idField }), this.modelFile, this.ast.location); } else { // check that identifiers are strings if(field.getType() !== 'String') { let formatter = Globalize('en').messageFormatter('classdeclaration-validate-identifiernotstring'); throw new IllegalModelException( formatter({ 'class': this.name, 'idField': this.idField }),this.modelFile, this.ast.location); } if(field.isOptional()) { throw new IllegalModelException('Identifying fields cannot be optional.',this.modelFile, this.ast.location); } } } else { if( this.isAbstract() === false &amp;&amp; this.isEnum() === false &amp;&amp; this.isConcept() === false) { if( this.getIdentifierFieldName() === null) { let formatter = Globalize('en').messageFormatter('classdeclaration-validate-missingidentifier'); throw new IllegalModelException( formatter({ 'class': this.name }),this.modelFile, this.ast.location); } } } // we also have to check fields defined in super classes const properties = this.getProperties(); for(let n=0; n &lt; properties.length; n++) { let field = properties[n]; // check we don't have a field with the same name for(let i=n+1; i &lt; properties.length; i++) { let otherField = properties[i]; if(field.getName() === otherField.getName()) { let formatter = Globalize('en').messageFormatter('classdeclaration-validate-duplicatefieldname'); throw new IllegalModelException( formatter({ 'class': this.name, 'fieldName': field.getName() }),this.modelFile, this.ast.location); } } // we now validate the field, however to ensure that // imports are resolved correctly we validate in the context // of the declared type of the field for non-primitives in a different namespace if(field.isPrimitive() || this.isEnum() || field.getNamespace() === this.getNamespace() ) { field.validate(this); } else { const typeFqn = field.getFullyQualifiedTypeName(); const classDecl = this.modelFile.getModelManager().getType(typeFqn); field.validate(classDecl); } } } /** * Returns the base system type for this type of class declaration. Override * this method in derived classes to specify a base system type. * * @return {string} the short name of the base system type or null */ getSystemType() { return null; } /** * Returns true if this class is declared as abstract in the model file * * @return {boolean} true if the class is abstract */ isAbstract() { return this.abstract; } /** * Returns true if this class is an enumeration. * * @return {boolean} true if the class is an enumerated type */ isEnum() { return false; } /** * Returns true if this class is the definition of a concept. * * @return {boolean} true if the class is a concept */ isConcept() { return false; } /** * Returns true if this class is the definition of an event. * * @return {boolean} true if the class is an event */ isEvent() { return false; } /** * Returns true if this class can be pointed to by a relationship * * @return {boolean} true if the class may be pointed to by a relationship */ isRelationshipTarget() { return false; } /** * Returns true if this class can be pointed to by a relationship in a * system model * * @return {boolean} true if the class may be pointed to by a relationship */ isSystemRelationshipTarget() { return this.isRelationshipTarget(); } /** * Returns true is this type is in the system namespace * * @return {boolean} true if the class may be pointed to by a relationship */ isSystemType() { return this.modelFile.isSystemModelFile(); } /** * Returns true if this class is a system core type - both in the system * namespace, and also one of the system core types (Asset, Participant, etc). * * @return {boolean} true if the class may be pointed to by a relationship */ isSystemCoreType() { return this.isSystemType() &amp;&amp; this.getSystemType() === this.getName(); } /** * Returns the short name of a class. This name does not include the * namespace from the owning ModelFile. * * @return {string} the short name of this class */ getName() { return this.name; } /** * Return the namespace of this class. * @return {String} namespace - a namespace. */ getNamespace() { return this.modelFile.getNamespace(); } /** * Returns the fully qualified name of this class. * The name will include the namespace if present. * * @return {string} the fully-qualified name of this class */ getFullyQualifiedName() { return this.getNamespace() + '.' + this.name; } /** * Returns the name of the identifying field for this class. Note * that the identifying field may come from a super type. * * @return {string} the name of the id field for this class */ getIdentifierFieldName() { if(this.idField) { return this.idField; } else { if(this.getSuperType()) { // we first check our own modelfile, as we may be called from validate // in which case our model file has not yet been added to the model modelManager let classDecl = this.getModelFile().getLocalType(this.getSuperType()); // not a local type, so we try the model manager if(!classDecl) { classDecl = this.modelFile.getModelManager().getType(this.getSuperType()); } return classDecl.getIdentifierFieldName(); } else { return null; } } } /** * Returns the field with a given name or null if it does not exist. * The field must be directly owned by this class -- the super-type is * not introspected. * * @param {string} name the name of the field * @return {Property} the field definition or null if it does not exist. */ getOwnProperty(name) { for(let n=0; n &lt; this.properties.length; n++) { const field = this.properties[n]; if(field.getName() === name) { return field; } } return null; } /** * Returns the fields directly defined by this class. * * @return {Property[]} the array of fields */ getOwnProperties() { return this.properties; } /** * Returns the FQN of the super type for this class or null if this * class does not have a super type. * * @return {string} the FQN name of the super type or null */ getSuperType() { const superTypeDeclaration = this.getSuperTypeDeclaration(); if (superTypeDeclaration) { return superTypeDeclaration.getFullyQualifiedName(); } else { return null; } } /** * Get the super type class declaration for this class. * @return {ClassDeclaration} the super type declaration, or null if there is no super type. */ getSuperTypeDeclaration() { if (!this.superType) { return null; } const supertypeDeclaration = this.getModelFile().getType(this.superType); if (!supertypeDeclaration) { throw new Error('Could not find super type: ' + this.superType); } return supertypeDeclaration; } /** * Get the class declarations for all subclasses of this class, including this class. * @return {ClassDeclaration[]} subclass declarations. */ getAssignableClassDeclarations() { const results = new Set(); const modelManager = this.getModelFile().getModelManager(); const introspector = new Introspector(modelManager); const allClassDeclarations = introspector.getClassDeclarations(); const subclassMap = new Map(); // Build map of all direct subclasses relationships allClassDeclarations.forEach((declaration) =&gt; { const superType = declaration.getSuperType(); if (superType) { const subclasses = subclassMap.get(superType) || new Set(); subclasses.add(declaration); subclassMap.set(superType, subclasses); } }); // Recursive function to collect all direct and indirect subclasses of a given (set) of base classes. const collectSubclasses = (superclasses) =&gt; { superclasses.forEach((declaration) =&gt; { results.add(declaration); const superType = declaration.getFullyQualifiedName(); const subclasses = subclassMap.get(superType); if (subclasses) { collectSubclasses(subclasses); } }); }; collectSubclasses([this]); return Array.from(results); } /** * Get all the super-type declarations for this type. * @return {ClassDeclaration[]} super-type declarations. */ getAllSuperTypeDeclarations() { const results = []; for (let type = this; (type = type.getSuperTypeDeclaration()); ) { results.push(type); } return results; } /** * Returns the property with a given name or null if it does not exist. * Fields defined in super-types are also introspected. * * @param {string} name the name of the field * @return {Property} the field, or null if it does not exist */ getProperty(name) { let result = this.getOwnProperty(name); let classDecl = null; if(result === null &amp;&amp; this.superType!==null) { if(this.getModelFile().isImportedType(this.superType)) { let fqnSuper = this.getModelFile().resolveImport(this.superType); classDecl = this.modelFile.getModelManager().getType(fqnSuper); } else { classDecl = this.getModelFile().getType(this.superType); } result = classDecl.getProperty(name); } return result; } /** * Returns the properties defined in this class and all super classes. * * @return {Property[]} the array of fields */ getProperties() { let result = this.getOwnProperties(); let classDecl = null; if(this.superType!==null) { if(this.getModelFile().isImportedType(this.superType)) { let fqnSuper = this.getModelFile().resolveImport(this.superType); classDecl = this.modelFile.getModelManager().getType(fqnSuper); } else { classDecl = this.getModelFile().getType(this.superType); } if(classDecl===null) { throw new IllegalModelException('Could not find super type ' + this.superType,this.modelFile, this.ast.location); } // go get the fields from the super type result = result.concat(classDecl.getProperties()); } else { // console.log('No super type for ' + this.getName() ); } return result; } /** * Get a nested property using a dotted property path * @param {string} propertyPath The property name or name with nested structure e.g a.b.c * @returns {Property} the property * @throws {IllegalModelException} if the property path is invalid or the property does not exist */ getNestedProperty(propertyPath) { const propertyNames = propertyPath.split('.'); let classDeclaration = this; let result = null; for (let n = 0; n &lt; propertyNames.length; n++) { // get the nth property result = classDeclaration.getProperty(propertyNames[n]); if (result === null) { throw new IllegalModelException('Property ' + propertyNames[n] + ' does not exist on ' + classDeclaration.getFullyQualifiedName(), this.modelFile, this.ast.location); } // not the last element, get the class of the element else if( n &lt; propertyNames.length-1) { if(result.isPrimitive() || result.isTypeEnum()) { throw new Error('Property ' + propertyNames[n] + ' is a primitive or enum. Invalid property path: ' + propertyPath ); } else { // get the nested type, this throws if the type is missing or if the type is an enum classDeclaration = classDeclaration.getModelFile().getModelManager().getType(result.getFullyQualifiedTypeName()); } } } return result; } /** * Returns the string representation of this class * @return {String} the string representation of the class */ toString() { let superType = ''; if(this.superType) { superType = ' super=' + this.superType; } return 'ClassDeclaration {id=' + this.getFullyQualifiedName() + superType + ' enum=' + this.isEnum() + ' abstract=' + this.isAbstract() + '}'; } } module.exports = ClassDeclaration; × Search results Close "},"composer-common_lib_comboconnectionprofilestore.js.html":{"id":"composer-common_lib_comboconnectionprofilestore.js.html","title":"Source: composer-common/lib/comboconnectionprofilestore.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/comboconnectionprofilestore.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ConnectionProfileStore = require('./connectionprofilestore'); const Logger = require('./log/logger'); const LOG = Logger.getLog('EnvConnectionProfileStore'); /** * Manages persistence of connection profiles across multiple * connection profile stores. * * @private * @abstract * @class * @memberof module:composer-common */ class ComboConnectionProfileStore extends ConnectionProfileStore { /** * Constructor. */ constructor() { super(); const method = 'constructor'; const args = Array.prototype.slice.call(arguments); LOG.entry(method, arguments); this.connectionProfileStores = args.map((arg) =&gt; { if (arg instanceof ConnectionProfileStore) { return arg; } throw new Error('Specified argument is not a connection profile store instance'); }); LOG.exit(method); } /** * Loads connectOptions for a given connection profile. * * @param {string} connectionProfile The name of the connection profile to load * @return {Promise} A promise that is resolved with a JS Object for the * data in the connection profile. */ load(connectionProfile) { const method = 'load'; LOG.entry(method, connectionProfile); return this.connectionProfileStores .reduce((result, connectionProfileStore) =&gt; { return result.then((connectionProfileData) =&gt; { LOG.debug(method, 'Looking at connection profile store', connectionProfileStore); if (connectionProfileData) { LOG.debug(method, 'Connection profile already loaded, skipping'); return connectionProfileData; } LOG.debug(method, 'Connection profile not loaded, loading'); return connectionProfileStore.load(connectionProfile) .catch((error) =&gt;{ LOG.debug(method, 'Caught error, ignoring', error); return null; }); }); }, Promise.resolve(null)) .then((connectionProfileData) =&gt; { if (!connectionProfileData) { throw new Error(`The connection profile ${connectionProfile} does not exist`); } LOG.exit(method, connectionProfileData); return connectionProfileData; }) .catch((e) =&gt; { LOG.error(method, e); throw e; }); } /** * Save connectOptions for a given connection profile. * * @param {string} connectionProfile The name of the connection profile to save * @param {Object} connectOptions The connection options object * @return {Promise} A promise that once the data is written */ save(connectionProfile, connectOptions) { const method = 'save'; LOG.entry(method, connectionProfile, connectOptions); return this.connectionProfileStores .reduce((result, connectionProfileStore) =&gt; { return result.then((saved) =&gt; { LOG.debug(method, 'Looking at connection profile store', connectionProfileStore); if (saved) { LOG.debug(method, 'Connection profile already saved, skipping'); return true; } LOG.debug(method, 'Connection profile not saved, saving'); return connectionProfileStore.save(connectionProfile, connectOptions) .then(() =&gt; { LOG.debug(method, 'Saved'); return true; }) .catch((error) =&gt;{ LOG.debug(method, 'Caught error, ignoring', error); return false; }); }); }, Promise.resolve(false)) .then((saved) =&gt; { if (!saved) { throw new Error(`The connection profile ${connectionProfile} could not be saved`); } LOG.exit(method); }) .catch((e) =&gt; { LOG.error(method, e); throw e; }); } /** * Loads all of the connection profiles. * * @return {Promise} A promise that is resolved with a JS Object where the * keys are the connection profiles, and the values are the connection options. */ loadAll() { const method = 'loadAll'; LOG.entry(method); return this.connectionProfileStores .reduce((result, connectionProfileStore) =&gt; { return result.then((connectionProfiles) =&gt; { LOG.debug(method, 'Looking at connection profile store', connectionProfileStore); return connectionProfileStore.loadAll() .then((thisConnectionProfiles) =&gt; { return Object.assign(thisConnectionProfiles, connectionProfiles); }); }); }, Promise.resolve({})) .then((connectionProfiles) =&gt; { LOG.exit(method, connectionProfiles); return connectionProfiles; }) .catch((e) =&gt; { LOG.error(method, e); throw e; }); } /** * Delete the given connection profile. * * @param {string} connectionProfile The name of the connection profile to delete * @return {Promise} A promise that is resolved when the connection profile * is deleted. */ delete(connectionProfile) { const method = 'delete'; LOG.entry(method, connectionProfile); return this.connectionProfileStores .reduce((result, connectionProfileStore) =&gt; { return result.then(() =&gt; { LOG.debug(method, 'Looking at connection profile store', connectionProfileStore); // We don't skip if already deleted as we likely want to delete it from everywhere. LOG.debug(method, 'Deleting connection profile'); return connectionProfileStore.delete(connectionProfile) .then(() =&gt; { LOG.debug(method, 'Deleted'); }) .catch((error) =&gt;{ LOG.debug(method, 'Caught error, ignoring', error); }); }); }, Promise.resolve()) .then(() =&gt; { LOG.exit(method); }); } } module.exports = ComboConnectionProfileStore; × Search results Close "},"composer-common_lib_model_concept.js.html":{"id":"composer-common_lib_model_concept.js.html","title":"Source: composer-common/lib/model/concept.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/model/concept.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Typed = require('./typed'); /** * &lt;p&gt; * Resource is an instance that has a type. The type of the resource * specifies a set of properites (which themselves have types). * &lt;/p&gt; * &lt;p&gt; * Type information in Composer is used to validate the structure of * Resource instances and for serialization. * &lt;/p&gt; * &lt;p&gt; * Resources are used in Composer to represent Assets, Participants, Transactions and * other domain classes that can be serialized for long-term persistent storage. * &lt;/p&gt; * @extends Identifiable * @see See [Resource]{@link module:composer-common.Resource} * @class * @memberof module:composer-common */ class Concept extends Typed { /** * This constructor should not be called directly. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @private */ constructor(modelManager, ns, type) { super(modelManager, ns, type); } /** * Determine if this typed is a concept. * @return {boolean} True if this typed is a concept, * false if not. */ isConcept() { return true; } } module.exports = Concept; × Search results Close "},"composer-common_lib_introspect_conceptdeclaration.js.html":{"id":"composer-common_lib_introspect_conceptdeclaration.js.html","title":"Source: composer-common/lib/introspect/conceptdeclaration.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/conceptdeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); /** * ConceptDeclaration defines the schema (aka model or class) for * an Concept. It extends ClassDeclaration which manages a set of * fields, a super-type and the specification of an * identifying field. * @private * @extends ClassDeclaration * @see See [ClassDeclaration]{@link module:composer-common.ClassDeclaration} * @class * @memberof module:composer-common */ class ConceptDeclaration extends ClassDeclaration { /** * Create an AssetDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {IllegalModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } /** * Returns true if this class is the definition of a concept. * * @return {boolean} true if the class is a concept */ isConcept() { return true; } } module.exports = ConceptDeclaration; × Search results Close "},"composer-common_lib_connection.js.html":{"id":"composer-common_lib_connection.js.html","title":"Source: composer-common/lib/connection.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/connection.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ConnectionManager = require('./connectionmanager'); const EventEmitter = require('events'); const Util = require('./util.js'); const BusinessNetworkDefinition = require('./businessnetworkdefinition.js'); const uuid = require('uuid'); /** * Base class representing a connection to a business network. * @private * @abstract * @class * @memberof module:composer-common */ class Connection extends EventEmitter { /** * Constructor. * @param {ConnectionManager} connectionManager The owning connection manager. * @param {string} connectionProfile The name of the connection profile associated with this connection * @param {string} businessNetworkIdentifier The identifier of the business network for this connection, or null if an admin connection */ constructor(connectionManager, connectionProfile, businessNetworkIdentifier) { super(); if (!(connectionManager instanceof ConnectionManager)) { throw new Error('connectionManager not specified'); } else if (!connectionProfile) { throw new Error('connectionProfile not specified'); } this.connectionManager = connectionManager; this.connectionProfile = connectionProfile; this.businessNetworkIdentifier = businessNetworkIdentifier; } /** * Get the connection manager that owns this connection. * @return {ConnectionManager} The owning connection manager. */ getConnectionManager() { return this.connectionManager; } /** * Returns a string that can be used to identify this connection. * @return {string} the identifier of this connection */ getIdentifier() { if(this.businessNetworkIdentifier) { return this.businessNetworkIdentifier + '@' + this.connectionProfile; } else { return this.connectionProfile; } } /** * Terminate the connection to the business network. * @abstract * @return {Promise} A promise that is resolved once the connection has been * terminated, or rejected with an error. */ disconnect() { return new Promise((resolve, reject) =&gt; { this._disconnect((error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback disconnectCallback * @protected * @param {Error} error The error if any. */ /** * Terminate the connection to the business network. * @abstract * @param {disconnectCallback} callback The callback function to call when complete. */ _disconnect(callback) { throw new Error('abstract function called'); } /** * Login as a participant on the business network. * @abstract * @param {string} enrollmentID The enrollment ID of the participant. * @param {string} enrollmentSecret The enrollment secret of the participant. * @return {Promise} A promise that is resolved with a {@link SecurityContext} * object representing the logged in participant, or rejected with a login error. */ login(enrollmentID, enrollmentSecret) { return new Promise((resolve, reject) =&gt; { this._login(enrollmentID, enrollmentSecret, (error, result) =&gt; { if (error) { return reject(error); } return resolve(result); }); }); } /** * @callback loginCallback * @protected * @param {Error} error The error if any. * @param {SecurityContext} result An object representing the logged in participant. */ /** * Login as a participant on the business network. * @abstract * @param {string} enrollmentID The enrollment ID of the participant. * @param {string} enrollmentSecret The enrollment secret of the participant. * @param {loginCallback} callback The callback function to call when complete. */ _login(enrollmentID, enrollmentSecret, callback) { throw new Error('abstract function called'); } /** * Install the Hyperledger Composer runtime. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {string} businessNetworkIdentifier The identifier of the Business network that will be started in this installed runtime * @param {Object} installOptions connector specific installation options * @return {Promise} A promise that is resolved once the business network * artefacts have been installed, or rejected with an error. */ install(securityContext, businessNetworkIdentifier, installOptions) { return new Promise((resolve, reject) =&gt; { this._install(securityContext, businessNetworkIdentifier, installOptions, (error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback installCallback * @protected * @param {Error} error The error if any. */ /** * Install the Hyperledger Composer runtime. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {string} businessNetworkIdentifier The identifier of the Business network that will be started in this installed runtime * @param {Object} installOptions connector specific installation options * @param {installCallback} callback The callback function to call when complete. */ _install(securityContext, businessNetworkIdentifier, installOptions, callback) { throw new Error('abstract function called'); } /** * Start a business network definition. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {string} businessNetworkIdentifier The identifier of the Business network that will be started in this installed runtime * @param {string} startTransaction The serialized start transaction. * @param {Object} startOptions connector specific installation options * @return {Promise} A promise that is resolved once the business network * artefacts have been installed, or rejected with an error. */ start(securityContext, businessNetworkIdentifier, startTransaction, startOptions) { return new Promise((resolve, reject) =&gt; { this._start(securityContext, businessNetworkIdentifier, startTransaction, startOptions, (error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback startCallback * @protected * @param {Error} error The error if any. */ /** * Start a business network definition. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {string} businessNetworkIdentifier The identifier of the Business network that will be started in this installed runtime * @param {string} startTransaction The serialized start transaction. * @param {Object} startOptions connector specific statement options * @param {startCallback} callback The callback function to call when complete. */ _start(securityContext, businessNetworkIdentifier, startTransaction, startOptions, callback) { throw new Error('abstract function called'); } /** * Deploy a business network definition. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {string} businessNetworkIdentifier The identifier of the Business network that will be started in this installed runtime * @param {string} deployTransaction The serialized deploy transaction. * @param {Object} deployOptions connector specific deployment options * @return {Promise} A promise that is resolved once the business network * artefacts have been deployed, or rejected with an error. */ deploy(securityContext, businessNetworkIdentifier, deployTransaction, deployOptions) { return new Promise((resolve, reject) =&gt; { this._deploy(securityContext, businessNetworkIdentifier, deployTransaction, deployOptions, (error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback deployCallback * @protected * @param {Error} error The error if any. */ /** * Deploy a business network definition. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {string} businessNetworkIdentifier The identifier of the Business network that will be started in this installed runtime * @param {string} deployTransaction The serialized deploy transaction. * @param {Object} deployOptions connector specific deployment options * @param {deployCallback} callback The callback function to call when complete. */ _deploy(securityContext, businessNetworkIdentifier, deployTransaction, deployOptions, callback) { throw new Error('abstract function called'); } /** * Updates an existing deployed business network definition. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {BusinessNetworkDefinition} businessNetworkDefinition The BusinessNetworkDefinition to deploy * @return {Promise} A promise that is resolved once the business network * artefacts have been updated, or rejected with an error. */ update(securityContext, businessNetworkDefinition) { // create the new transaction to update the network if (!businessNetworkDefinition) { throw new Error('business network definition not specified'); } let currentDeployedNetwork; return Util.queryChainCode(securityContext, 'getBusinessNetwork', []) .then((buffer) =&gt; { let businessNetworkJSON = JSON.parse(buffer.toString()); let businessNetworkArchive = Buffer.from(businessNetworkJSON.data, 'base64'); return BusinessNetworkDefinition.fromArchive(businessNetworkArchive); }) .then((businessNetwork) =&gt; { currentDeployedNetwork = businessNetwork; // Serialize the business network. return businessNetworkDefinition.toArchive(); }) .then((businessNetworkArchive) =&gt; { // Send an update request to the chaincode. // create the new system transaction to add the resources let transaction = currentDeployedNetwork.getFactory().newTransaction('org.hyperledger.composer.system','UpdateBusinessNetwork'); let id = transaction.getIdentifier(); if (id === null || id === undefined) { id = uuid.v4(); transaction.setIdentifier(id); } let timestamp = transaction.timestamp; if (timestamp === null || timestamp === undefined) { timestamp = transaction.timestamp = new Date(); } transaction.businessNetworkArchive = businessNetworkArchive.toString('base64'); let data = currentDeployedNetwork.getSerializer().toJSON(transaction); return Util.invokeChainCode(securityContext, 'submitTransaction', [JSON.stringify(data)]); }); } /** * Resets an existing deployed business network definition. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {String} businessNetworkIdentifier The identifier of the business network * @return {Promise} A promise that is resolved once the business network * artefacts have been reset, or rejected with an error. */ reset(securityContext, businessNetworkIdentifier) { let currentDeployedNetwork; return Promise.resolve() .then(()=&gt;{ // create the new transaction to update the network if (!businessNetworkIdentifier) { throw new Error('business network identifier not specified'); } return Util.queryChainCode(securityContext, 'getBusinessNetwork', []); }) .then((buffer) =&gt; { let businessNetworkJSON = JSON.parse(buffer.toString()); let businessNetworkArchive = Buffer.from(businessNetworkJSON.data, 'base64'); return BusinessNetworkDefinition.fromArchive(businessNetworkArchive); }) .then((businessNetwork) =&gt; { currentDeployedNetwork = businessNetwork; // Send an update request to the chaincode. // create the new system transaction to add the resources if (currentDeployedNetwork.getName() !== businessNetworkIdentifier){ throw new Error('Incorrect Business Network Identifier'); } let transaction = currentDeployedNetwork.getFactory().newTransaction('org.hyperledger.composer.system','ResetBusinessNetwork'); let id = transaction.getIdentifier(); if (id === null || id === undefined) { id = uuid.v4(); transaction.setIdentifier(id); } let timestamp = transaction.timestamp; if (timestamp === null || timestamp === undefined) { timestamp = transaction.timestamp = new Date(); } let data = currentDeployedNetwork.getSerializer().toJSON(transaction); return Util.invokeChainCode(securityContext, 'submitTransaction', [JSON.stringify(data)]); }); } /** * Resets an existing deployed business network definition. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {String} loglevel The new log level * @return {Promise} A promise that is resolved once the business network * logging level has been changed */ setLogLevel(securityContext, loglevel) { let currentDeployedNetwork; return Promise.resolve() .then(()=&gt;{ // create the new transaction to update the network if (!loglevel) { throw new Error('Log Level not specified'); } return Util.queryChainCode(securityContext, 'getBusinessNetwork', []); }) .then((buffer) =&gt; { let businessNetworkJSON = JSON.parse(buffer.toString()); let businessNetworkArchive = Buffer.from(businessNetworkJSON.data, 'base64'); return BusinessNetworkDefinition.fromArchive(businessNetworkArchive); }) .then((businessNetwork) =&gt; { currentDeployedNetwork = businessNetwork; let transaction = currentDeployedNetwork.getFactory().newTransaction('org.hyperledger.composer.system','SetLogLevel'); let id = transaction.getIdentifier(); if (id === null || id === undefined) { id = uuid.v4(); transaction.setIdentifier(id); } let timestamp = transaction.timestamp; if (timestamp === null || timestamp === undefined) { timestamp = transaction.timestamp = new Date(); } transaction.newLogLevel = loglevel; let data = currentDeployedNetwork.getSerializer().toJSON(transaction); return Util.invokeChainCode(securityContext, 'submitTransaction', [JSON.stringify(data)]); }); } /** * Upgrade the Hyperledger Composer runtime. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @return {Promise} A promise that is resolved once the business network * runtime has been upgraded, or rejected with an error. */ upgrade(securityContext) { return new Promise((resolve, reject) =&gt; { this._upgrade(securityContext, (error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback upgradeCallback * @protected * @param {Error} error The error if any. */ /** * Upgrade the Hyperledger Composer runtime. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {upgradeCallback} callback The callback function to call when complete. */ _upgrade(securityContext, callback) { throw new Error('abstract function called'); } /** * Undeploy a business network definition. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {string} businessNetworkIdentifier The identifier of the business network to remove * @return {Promise} A promise that is resolved once the business network * artefacts have been undeployed, or rejected with an error. */ undeploy(securityContext, businessNetworkIdentifier) { return new Promise((resolve, reject) =&gt; { this._undeploy(securityContext, businessNetworkIdentifier, (error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback undeployCallback * @protected * @param {Error} error The error if any. */ /** * Undeploy a business network definition. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {string} businessNetworkIdentifier The identifier of the business network to remove * @param {undeployCallback} callback The callback function to call when complete. */ _undeploy(securityContext, businessNetworkIdentifier, callback) { throw new Error('abstract function called'); } /** * Test (&quot;ping&quot;) the connection to the business network. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @return {Promise} A promise that is resolved once the connection to the * business network has been tested, or rejected with an error. */ ping(securityContext) { return new Promise((resolve, reject) =&gt; { this._ping(securityContext, (error, result) =&gt; { if (error) { return reject(error); } return resolve(result); }); }); } /** * @callback pingCallback * @protected * @param {Error} error The error if any. * @param {string} result The data returned by the chaincode function. */ /** * Test (&quot;ping&quot;) the connection to the business network. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {pingCallback} callback The callback function to call when complete. */ _ping(securityContext, callback) { throw new Error('abstract function called'); } /** * Invoke a &quot;query&quot; chaincode function with the specified name and arguments. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {string} functionName The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that is resolved with the data returned by the * chaincode function once it has been invoked, or rejected with an error. */ queryChainCode(securityContext, functionName, args) { return new Promise((resolve, reject) =&gt; { this._queryChainCode(securityContext, functionName, args, (error, result) =&gt; { if (error) { return reject(error); } return resolve(result); }); }); } /** * @callback queryChainCodeCallback * @protected * @param {Error} error The error if any. * @param {string} result The data returned by the chaincode function. */ /** * Invoke a &quot;query&quot; chaincode function with the specified name and arguments. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {string} functionName The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @param {queryChainCodeCallback} callback The callback function to call when complete. */ _queryChainCode(securityContext, functionName, args, callback) { throw new Error('abstract function called'); } /** * Invoke a &quot;invoke&quot; chaincode function with the specified name and arguments. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {string} functionName The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @param {Object} [options] Options for the invoking chaing code to use * @param {Object} [options.transactionId] Transaction Id to use. * @return {Promise} A promise that is resolved once the chaincode function * has been invoked, or rejected with an error. */ invokeChainCode(securityContext, functionName, args, options) { return new Promise((resolve, reject) =&gt; { this._invokeChainCode(securityContext, functionName, args, options, (error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback invokeChainCodeCallback * @protected * @param {Error} error The error if any. */ /** * Invoke a &quot;invoke&quot; chaincode function with the specified name and arguments. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {string} functionName The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @param {Object} [options] options for the invoking chain code * @param {Object} [options.transactionId] Transaction Id to use. * @param {invokeChainCodeCallback} callback The callback function to call when complete. */ _invokeChainCode(securityContext, functionName, args, options, callback) { throw new Error('abstract function called'); } /** * Create a new identity for the specified user ID. * @param {SecurityContext} securityContext The participant's security context. * @param {string} userID The user ID. * @param {object} [options] Options for the new identity. * @param {boolean} [options.issuer] Whether or not the new identity should have * permissions to create additional new identities. False by default. * @param {string} [options.affiliation] Specify the affiliation for the new * identity. Defaults to 'institution_a'. * @return {Promise} A promise that is resolved with a generated user * secret once the new identity has been created, or rejected with an error. */ createIdentity(securityContext, userID, options) { return new Promise((resolve, reject) =&gt; { this._createIdentity(securityContext, userID, options, (error, result) =&gt; { if (error) { return reject(error); } return resolve(result); }); }); } /** * @callback createIdentityCallback * @protected * @param {Error} error The error if any. * @param {string[]} result A generated user secret. */ /** * Create a new identity for the specified user ID. * @param {SecurityContext} securityContext The participant's security context. * @param {string} userID The user ID. * @param {object} [options] Options for the new identity. * @param {boolean} [options.issuer] Whether or not the new identity should have * permissions to create additional new identities. False by default. * @param {string} [options.affiliation] Specify the affiliation for the new * identity. Defaults to 'institution_a'. * @param {createIdentityCallback} callback The callback function to call when complete. */ _createIdentity(securityContext, userID, options, callback) { throw new Error('abstract function called'); } /** * List all of the deployed business networks. The connection must * be connected for this method to succeed. * @param {SecurityContext} securityContext The participant's security context. * @return {Promise} A promise that will be resolved with an array of * business network identifiers, or rejected with an error. */ list(securityContext) { return new Promise((resolve, reject) =&gt; { this._list(securityContext, (error, result) =&gt; { if (error) { return reject(error); } return resolve(result); }); }); } /** * @callback listCallback * @protected * @param {Error} error The error if any. * @param {string[]} result An array of business network identifiers. */ /** * List all of the deployed business networks. The connection must * be connected for this method to succeed. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {listCallback} callback The callback function to call when complete. */ _list(securityContext, callback) { throw new Error('abstract function called'); } /** * Create a Transaction Id * @param {SecurityContext} securityContext The participant's security context. * @return {Promise} A promise that will be resolved with a representation of the id */ createTransactionId(securityContext) { return new Promise((resolve, reject) =&gt; { this._createTransactionId(securityContext, (error, result) =&gt; { if (error) { return reject(error); } return resolve(result); }); }); } /** * @callback transactionIdCallback * @protected * @param {Error} error The error if any. * @param {string} result Transaction id. */ /** * Create a transaction id * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {listCallback} callback The callback function to call when complete. */ _createTransactionId(securityContext, callback) { throw new Error('abstract function called'); } } module.exports = Connection; × Search results Close "},"composer-common_lib_connectionmanager.js.html":{"id":"composer-common_lib_connectionmanager.js.html","title":"Source: composer-common/lib/connectionmanager.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/connectionmanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ConnectionProfileManager = require('./connectionprofilemanager'); /** * Base class representing a connection manager that establishes and manages * connections to one or more business networks. The ConnectionManager loads * connection profiles using the ConnectionProfileManager. * * @private * @abstract * @class * @memberof module:composer-common */ class ConnectionManager { /** * Create the ConnectionManager * @param {ConnectionProfileManager} connectionProfileManager - the ConnectionProfileManager * that controls this instance. */ constructor(connectionProfileManager) { if(!(connectionProfileManager instanceof ConnectionProfileManager)) { throw new Error('Must create ConnectionManager with a ConnectionProfileManager implementation.'); } this.connectionProfileManager = connectionProfileManager; } /** * Returns the ConnectionProfileManager associated with this ConnectionManager * @return {ConnectionProfileManager} the connection profile manager for this * connection manager. */ getConnectionProfileManager() { return this.connectionProfileManager; } /** * Establish a connection to the business network, using connection information * from the connection profile. * @abstract * @param {string} connectionProfile The name of the connection profile * @param {string} businessNetworkIdentifier The identifier of the business network, or null if this is an admin connection * @param {object} connectionOptions The connection options loaded from the profile * @return {Promise} A promise that is resolved with a {@link Connection} * object once the connection is established, or rejected with a connection error. */ connect(connectionProfile, businessNetworkIdentifier, connectionOptions) { return new Promise((resolve, reject) =&gt; { this._connect(connectionProfile, businessNetworkIdentifier, connectionOptions, (error, result) =&gt; { if (error) { return reject(error); } return resolve(result); }); }); } /** * @callback connectCallback * @protected * @param {Error} error The error if any. * @param {Connection} connection The connection. */ /** * Establish a connection to the business network, using connection information * from the connection profile. * @abstract * @param {string} connectionProfile The name of the connection profile * @param {string} businessNetworkIdentifier The identifier of the business network, or null if this is an admin connection * @param {object} connectionOptions The connection options loaded from the profile * @param {connectCallback} callback The callback function to call when complete. */ _connect(connectionProfile, businessNetworkIdentifier, connectionOptions, callback) { throw new Error('abstract function called'); } /** * Import an identity into a profile wallet or keystore * @abstract * @param {string} connectionProfile The name of the connection profile * @param {object} connectionOptions The connection options loaded from the profile * @param {string} id the id to associate with the identity * @param {string} certificate the certificate * @param {string} privateKey the private key * @returns {Promise} a promise which resolves when the identity is imported */ importIdentity(connectionProfile, connectionOptions, id, certificate, privateKey) { return new Promise((resolve, reject) =&gt; { this._importIdentity(connectionProfile, connectionOptions, id, certificate, privateKey, (error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback importIdentityCallback * @protected * @param {Error} error The error if any. */ /** * Import an identity into a profile wallet or keystore * @abstract * @param {string} connectionProfile The name of the connection profile * @param {object} connectionOptions The connection options loaded from the profile * @param {string} id the id to associate with the identity * @param {string} certificate the certificate * @param {string} privateKey the private key * @param {importIdentityCallback} callback The callback function to call when complete. */ _importIdentity(connectionProfile, connectionOptions, id, certificate, privateKey, callback) { throw new Error('abstract function called'); } /** * Request an identity's certificates. * @abstract * @param {string} connectionProfile The name of the connection profile * @param {object} connectionOptions The connection options loaded from the profile * @param {any} enrollmentID The enrollment id * @param {any} enrollmentSecret The enrollment secret * @returns {promise} resolves with the identity certificates, rejected if a problem occurs */ requestIdentity(connectionProfile, connectionOptions, enrollmentID, enrollmentSecret) { return new Promise((resolve, reject) =&gt; { this._requestIdentity(connectionProfile, connectionOptions, enrollmentID, enrollmentSecret, (error, result) =&gt; { if (error) { return reject(error); } return resolve(result); }); }); } /** * @callback requestIdentityCallback * @protected * @param {Error} error The error if any. * @param {Object} identity The identity. */ /** * Request an identity's certificates. * @abstract * @param {string} connectionProfile The name of the connection profile * @param {object} connectionOptions The connection options loaded from the profile * @param {any} enrollmentID The enrollment id * @param {any} enrollmentSecret The enrollment secret * @param {requestIdentityCallback} callback The callback function to call when complete. */ _requestIdentity(connectionProfile, connectionOptions, enrollmentID, enrollmentSecret, callback) { throw new Error('abstract function called'); } /** * Obtain the credentials associated with a given identity. * @param {String} connectionProfileName Name of the connection profile. * @param {Object} connectionOptions connection options loaded from the profile. * @param {String} id Name of the identity. * @return {Promise} Resolves to credentials in the form &lt;em&gt;{ certificate: String, privateKey: String }&lt;/em&gt;. * @abstract */ exportIdentity(connectionProfileName, connectionOptions, id) { return new Promise((resolve, reject) =&gt; { this._exportIdentity(connectionProfileName, connectionOptions, id, (error, result) =&gt; { if (error) { return reject(error); } return resolve(result); }); }); } /** * @callback exportIdentityCallback * @protected * @param {Error} error The error if any. * @param {Object} credentials Credentials in the form &lt;em&gt;{ certificate: String, privateKey: String }&lt;/em&gt;. */ /** * Obtain the credentials associated with a given identity. * @param {String} connectionProfileName - Name of the connection profile. * @param {Object} connectionOptions - connection options loaded from the profile. * @param {String} id - Name of the identity. * @param {exportIdentityCallback} callback The callback function to call when complete. * @abstract */ _exportIdentity(connectionProfileName, connectionOptions, id, callback) { throw new Error('abstract function called'); } } module.exports = ConnectionManager; × Search results Close "},"composer-common_lib_connectionprofilemanager.js.html":{"id":"composer-common_lib_connectionprofilemanager.js.html","title":"Source: composer-common/lib/connectionprofilemanager.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/connectionprofilemanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('./log/logger'); const LOG = Logger.getLog('ConnectionProfileManager'); const connectionManagerLoaders = []; const connectionManagerClasses = {}; const connectionManagers = {}; /** * A connection profile manager that manages a set of connection profiles. Each * connection profile defines an arbitrary set of configuration data and is associated * with a ConnectionManager. * @private * @class * @memberof module:composer-common */ class ConnectionProfileManager { /** * The composer-common module cannot load connector modules from parent modules * when the dependencies are linked together using npm link or lerna. To work * around this, the packages that require the connectors register themselves as * modules that can load connection managers. * @param {Object} module The module that can load connector modules. */ static registerConnectionManagerLoader(module) { connectionManagerLoaders.push(module); } /** * Register a new ConnectionManager class. * @param {string} type - the profile type identifier of the ConnectionManager * @param {function} ctor - the constructor of the ConnectionManager */ static registerConnectionManager(type, ctor) { connectionManagerClasses[type] = ctor; } /** * Create the ConnectionManager and attach a file system * @param {ConnectionProfileStore} connectionProfileStore - Node.js FS implementation, for example BrowserFS */ constructor(connectionProfileStore) { LOG.info('constructor','Created a new ConnectionProfileManager', connectionProfileStore); if(!connectionProfileStore) { throw new Error('Must create ConnectionProfileManager with a ConnectionProfileStore implementation.'); } this.connectionProfileStore = connectionProfileStore; } /** * Returns the ConnectionProfileStore associated with this * instance. * @return {ConnectionProfileStore} the associated store. */ getConnectionProfileStore() { return this.connectionProfileStore; } /** * Adds a ConnectionManager to the mappings of this ConnectionProfileManager * @param {string} type - the profile type identifier of the ConnectionManager * @param {ConnectionManager} connectionManager - the instance */ addConnectionManager(type, connectionManager) { LOG.info('addConnectionManager','Adding a new connection manager', type); connectionManagers[type] = connectionManager; } /** * Retrieves the ConnectionManager for the given connection profile. * * @param {string} connectionProfile The name of the connection profile * @return {Promise} A promise that is resolved with a {@link ConnectionManager} * object once the connection is established, or rejected with a connection error. */ getConnectionManager(connectionProfile) { const METHOD = 'getConnectionManager'; LOG.info(METHOD,'Looking up a connection manager for profile', connectionProfile); let errorList = []; return this.connectionProfileStore.load(connectionProfile) .then((data) =&gt; { LOG.debug(METHOD,data); let connectionManager = connectionManagers[data.type]; if(!connectionManager) { const mod = `composer-connector-${data.type}`; LOG.debug(METHOD,'Looking for module',mod); try { // Check for the connection manager class registered using // registerConnectionManager (used by the web connector). let connectionManagerClass = connectionManagerClasses[data.type]; if (connectionManagerClass) { connectionManager = new(connectionManagerClass)(this); } else { // Not registered using registerConnectionManager, we now // need to search for the connector module in our module // and all of the parent modules (the ones who required // us) as we do not depend on any connector modules. let curmod = module; while (curmod) { try { connectionManager = new(curmod.require(mod))(this); break; } catch (e) { errorList.push(e.message); LOG.info(METHOD,'No yet located the module ',e.message); // Continue to search the parent. } curmod = curmod.parent; } LOG.info(METHOD,'Using this connection manager ',connectionManager); if (!connectionManager) { connectionManagerLoaders.some((connectionManagerLoader) =&gt; { try { connectionManager = new(connectionManagerLoader.require(mod))(this); return true; } catch (e) { // Search the next one. errorList.push(e.message); LOG.info(METHOD,e); return false; } }); } if (!connectionManager) { LOG.verbose(METHOD,'not located the module - final try '); // We still didn't find it, so try plain old require // one last time. connectionManager = new(require(mod))(this); } } } catch (e) { // takes the error list, and filters out duplicate lines errorList.push(e.message); errorList.filter((element, index, self)=&gt;{ return index === self.indexOf(element); }); const newError = new Error(`Failed to load connector module &quot;${mod}&quot; for connection profile &quot;${connectionProfile}&quot;. ${errorList.join('-')}`); LOG.error(METHOD, newError); throw newError; } connectionManagers[data.type] = connectionManager; } return connectionManager; }); } /** * Establish a connection to the business network, using connection information * from the connection profile. * * @param {string} connectionProfile The name of the connection profile * @param {string} businessNetworkIdentifier The identifier of the business network, or null if this is an admin connection * @param {Object} [additionalConnectOptions] Additional configuration options supplied * at runtime that override options set in the connection profile. * @return {Promise} A promise that is resolved with a {@link Connection} * object once the connection is established, or rejected with a connection error. * @abstract */ connect(connectionProfile, businessNetworkIdentifier, additionalConnectOptions) { LOG.info('connect','Connecting using ' + connectionProfile, businessNetworkIdentifier); let connectOptions; return this.connectionProfileStore.load(connectionProfile) .then((connectOptions_) =&gt; { connectOptions = connectOptions_; if (additionalConnectOptions) { connectOptions = Object.assign(connectOptions, additionalConnectOptions); } return this.getConnectionManager(connectionProfile); }) .then((connectionManager) =&gt; { return connectionManager.connect(connectionProfile, businessNetworkIdentifier, connectOptions); }); } /** * Clear the static object containing all the connection managers */ static removeAllConnectionManagers() { connectionManagerLoaders.length = 0; Object.keys(connectionManagerClasses).forEach((key) =&gt; { connectionManagerClasses[key] = null; }); Object.keys(connectionManagers).forEach((key) =&gt; { connectionManagers[key] = null; }); } } module.exports = ConnectionProfileManager; × Search results Close "},"composer-common_lib_connectionprofilestore.js.html":{"id":"composer-common_lib_connectionprofilestore.js.html","title":"Source: composer-common/lib/connectionprofilestore.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/connectionprofilestore.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Manages persistence of connection profiles. * * @private * @abstract * @class * @memberof module:composer-common */ class ConnectionProfileStore { /** * Loads connectOptions for a given connection profile. * @abstract * @param {string} connectionProfile The name of the connection profile to load * @return {Promise} A promise that is resolved with a JS Object for the * data in the connection profile. */ load(connectionProfile) { return Promise.reject(new Error('abstract function called')); } /** * Save connectOptions for a given connection profile. * @abstract * @param {string} connectionProfile The name of the connection profile to save * @param {Object} connectOptions The connection options object * @return {Promise} A promise that once the data is written */ save(connectionProfile, connectOptions) { return Promise.reject(new Error('abstract function called')); } /** * Loads all of the connection profiles. * @abstract * @return {Promise} A promise that is resolved with a JS Object where the * keys are the connection profiles, and the values are the connection options. */ loadAll() { return Promise.reject(new Error('abstract function called')); } /** * Delete the given connection profile. * @abstract * @param {string} connectionProfile The name of the connection profile to delete * @return {Promise} A promise that is resolved when the connection profile * is deleted. */ delete(connectionProfile) { return Promise.reject(new Error('abstract function called')); } } module.exports = ConnectionProfileStore; × Search results Close "},"composer-common_lib_introspect_decorated.js.html":{"id":"composer-common_lib_introspect_decorated.js.html","title":"Source: composer-common/lib/introspect/decorated.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/decorated.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Decorator = require('./decorator'); const IllegalModelException = require('./illegalmodelexception'); const Globalize = require('../globalize'); /** * Decorated defines a model element that may have decorators attached. * * @private * @abstract * @class * @memberof module:composer-common */ class Decorated { /** * Create a Decorated from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(ast) { if(!ast) { throw new IllegalModelException(Globalize.formatMessage('classdeclaration-constructor-modelastreq')); } this.ast = ast; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { this.decorators = []; if(this.ast.decorators) { for(let n=0; n &lt; this.ast.decorators.length; n++ ) { let thing = this.ast.decorators[n]; this.decorators.push( new Decorator(this, thing) ); } } } /** * Semantic validation of the structure of this decorated. Subclasses should * override this method to impose additional semantic constraints on the * contents/relations of fields. * * @throws {IllegalModelException} * @private */ validate() { for(let n=0; n &lt; this.decorators.length; n++) { let decorator = this.decorators[n]; decorator.validate(); // check we don't have this decorator twice for(let i=n+1; i &lt; this.decorators.length; i++) { let otherDecorator = this.decorators[i]; if(decorator.getName() === otherDecorator.getName()) { throw new IllegalModelException(`Duplicate decorator ${decorator.getName()}`,this.modelFile, this.ast.location); } } } } /** * Returns the decorators for this class. * * @return {Decorator[]} the decorators for the class */ getDecorators() { return this.decorators; } /** * Returns the decorator for this class with a given name. * @param {string} name - the name of the decorator * @return {Decorator} the decorator attached to this class with the given name, or null if it does not exist. */ getDecorator(name) { for(let n=0; n &lt; this.decorators.length; n++) { let decorator = this.decorators[n]; if(decorator.getName() === name) { return decorator; } } return null; } } module.exports = Decorated; × Search results Close "},"composer-common_lib_introspect_decorator.js.html":{"id":"composer-common_lib_introspect_decorator.js.html","title":"Source: composer-common/lib/introspect/decorator.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/decorator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Decorator encapsulates a decorator (annotation) on a class or property. * @private * @class * @memberof module:composer-common */ class Decorator { /** * Create a Decorator. * @param {ClassDeclaration | Property} parent - the owner of this property * @param {Object} ast - The AST created by the parser * @throws {IllegalModelException} */ constructor(parent, ast) { this.ast = ast; this.parent = parent; this.arguments = null; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the owner of this property * @return {ClassDeclaration|Property} the parent class or property declaration */ getParent() { return this.parent; } /** * Process the AST and build the model * @throws {IllegalModelException} * @private */ process() { this.name = this.ast.name; this.arguments = []; if(this.ast.arguments) { for(let n=0; n &lt; this.ast.arguments.list.length; n++ ) { let thing = this.ast.arguments.list[n]; if(thing) { this.arguments.push( thing.value ); } } } } /** * Validate the property * @throws {IllegalModelException} * @private */ validate() { } /** * Returns the name of a decorator * @return {string} the name of this decorator */ getName() { return this.name; } /** * Returns the arguments for this decorator * @return {object[]} the arguments for this decorator or null if it does not have any arguments */ getArguments() { return this.arguments; } } module.exports = Decorator; × Search results Close "},"composer-common_lib_introspect_enumdeclaration.js.html":{"id":"composer-common_lib_introspect_enumdeclaration.js.html","title":"Source: composer-common/lib/introspect/enumdeclaration.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/enumdeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); /** * EnumDeclaration defines an enumeration of static values. * @private * @extends ClassDeclaration * @see See [ClassDeclaration]{@link module:composer-common.ClassDeclaration} * @class * @memberof module:composer-common */ class EnumDeclaration extends ClassDeclaration { /** * Create an AssetDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {IllegalModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } /** * Returns true if this class is an enumeration. * * @return {boolean} true if the class is an enumerated type */ isEnum() { return true; } /** * Returns the string representation of this class * @return {String} the string representation of the class */ toString() { return 'EnumDeclaration {id=' + this.getFullyQualifiedName() + '}'; } } module.exports = EnumDeclaration; × Search results Close "},"composer-common_lib_envconnectionprofilestore.js.html":{"id":"composer-common_lib_envconnectionprofilestore.js.html","title":"Source: composer-common/lib/envconnectionprofilestore.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/envconnectionprofilestore.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ConnectionProfileStore = require('./connectionprofilestore'); const Logger = require('./log/logger'); const LOG = Logger.getLog('EnvConnectionProfileStore'); /** * Manages persistence of connection profiles in the environment. * * @private * @abstract * @class * @memberof module:composer-common */ class EnvConnectionProfileStore extends ConnectionProfileStore { /** * Constructor. */ constructor() { super(); const method = 'constructor'; LOG.entry(method); if (process.env.COMPOSER_CONFIG) { try { this.env = JSON.parse(process.env.COMPOSER_CONFIG); } catch (e) { LOG.error(method, 'Failed to parse the value of the COMPOSER_CONFIG environment variable', e); throw new Error('Failed to parse the value of the COMPOSER_CONFIG environment variable'); } } else { this.env = {}; } this.env.connectionProfiles = this.env.connectionProfiles || {}; LOG.debug(method, 'Loaded environment', this.env); LOG.exit(method); } /** * Loads connectOptions for a given connection profile. * * @param {string} connectionProfile The name of the connection profile to load * @return {Promise} A promise that is resolved with a JS Object for the * data in the connection profile. */ load(connectionProfile) { const method = 'load'; LOG.entry(method, connectionProfile); return Promise.resolve() .then(() =&gt; { const connectionProfileData = this.env.connectionProfiles[connectionProfile]; if (!connectionProfileData) { throw new Error(`The connection profile ${connectionProfile} does not exist in the environment`); } LOG.exit(method, connectionProfileData); return connectionProfileData; }) .catch((e) =&gt; { LOG.error(method, e); throw e; }); } /** * Save connectOptions for a given connection profile. * * @param {string} connectionProfile The name of the connection profile to save * @param {Object} connectOptions The connection options object * @return {Promise} A promise that once the data is written */ save(connectionProfile, connectOptions) { const method = 'save'; LOG.entry(method, connectionProfile, connectOptions); const e = new Error(`Cannot save connection profile ${connectionProfile} into the environment`); LOG.error(method, e); return Promise.reject(e); } /** * Loads all of the connection profiles. * * @return {Promise} A promise that is resolved with a JS Object where the * keys are the connection profiles, and the values are the connection options. */ loadAll() { const method = 'loadAll'; LOG.entry(method); return Promise.resolve() .then(() =&gt; { const connectionProfiles = Object.keys(this.env.connectionProfiles).sort(); const result = {}; connectionProfiles.forEach((connectionProfile) =&gt; { const connectionProfileData = this.env.connectionProfiles[connectionProfile]; result[connectionProfile] = connectionProfileData; }); LOG.exit(method, result); return result; }); } /** * Delete the given connection profile. * * @param {string} connectionProfile The name of the connection profile to delete * @return {Promise} A promise that is resolved when the connection profile * is deleted. */ delete(connectionProfile) { const method = 'delete'; LOG.entry(method, connectionProfile); const e = new Error(`Cannot delete connection profile ${connectionProfile} from the environment`); LOG.error(method, e); return Promise.reject(e); } } module.exports = EnvConnectionProfileStore; × Search results Close "},"composer-common_lib_introspect_eventdeclaration.js.html":{"id":"composer-common_lib_introspect_eventdeclaration.js.html","title":"Source: composer-common/lib/introspect/eventdeclaration.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/eventdeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); const IllegalModelException = require('./illegalmodelexception'); const ModelUtil = require('../modelutil'); /** Class representing the definition of an Event. * @extends ClassDeclaration * @see See [ClassDeclaration]{@link module:composer-common.ClassDeclaration} * @private * @class * @memberof module:composer-common */ class EventDeclaration extends ClassDeclaration { /** * Create an EventDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } /** * Returns the base system type for Events from the system namespace * * @return {string} the short name of the base system type */ getSystemType() { return 'Event'; } /** * Semantic validation of the structure of this event. Subclasses should * override this method to impose additional semantic constraints on the * contents/relations of fields. * * @throws {IllegalModelException} * @private */ validate() { super.validate(); if(!this.isSystemType() &amp;&amp; this.getName() === 'Event') { throw new IllegalModelException('Event is a reserved type name.', this.modelFile, this.ast.location); } let systemTypeDeclared = true; // If using models without importing system models try { this.getModelFile().getType(ModelUtil.getSystemNamespace() + '.' + this.getSystemType()); } catch (e) { systemTypeDeclared = false; } if (!this.isSystemType() &amp;&amp; this.idField &amp;&amp; systemTypeDeclared) { throw new IllegalModelException('Event should not specify an identifying field.', this.modelFile, this.ast.location); } } /** * Returns true if this class is the definition of an event * * @return {boolean} true if the class is an event */ isEvent() { return true; } } module.exports = EventDeclaration; × Search results Close "},"composer-common_lib_factory.js.html":{"id":"composer-common_lib_factory.js.html","title":"Source: composer-common/lib/factory.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/factory.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const debug = require('debug')('hyperledger-composer'); const Globalize = require('./globalize'); const ModelUtil = require('./modelutil'); const InstanceGenerator = require('./serializer/instancegenerator'); const ValueGeneratorFactory = require('./serializer/valuegenerator'); const ResourceValidator = require('./serializer/resourcevalidator'); const TypedStack = require('./serializer/typedstack'); const Relationship = require('./model/relationship'); const Resource = require('./model/resource'); const ValidatedResource = require('./model/validatedresource'); const Concept = require('./model/concept'); const ValidatedConcept = require('./model/validatedconcept'); const TransactionDeclaration = require('./introspect/transactiondeclaration'); const EventDeclaration = require('./introspect/eventdeclaration'); const uuid = require('uuid'); /** * Use the Factory to create instances of Resource: transactions, participants * and assets. * &lt;p&gt;&lt;a href=&quot;./diagrams/factory.svg&quot;&gt;&lt;img src=&quot;./diagrams/factory.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @class * @memberof module:composer-common */ class Factory { /** * Create the factory. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Hyperledger-Composer}&lt;/strong&gt; * &lt;/p&gt; * @param {ModelManager} modelManager - The ModelManager to use for this registry */ constructor(modelManager) { this.modelManager = modelManager; } /** * Create a new Resource with a given namespace, type name and id * @param {string} ns - the namespace of the Resource * @param {string} type - the type of the Resource * @param {string} id - the identifier * @param {Object} [options] - an optional set of options * @param {boolean} [options.disableValidation] - pass true if you want the factory to * return a {@link Resource} instead of a {@link ValidatedResource}. Defaults to false. * @param {string} [options.generate] - Pass one of: &lt;dl&gt; * &lt;dt&gt;sample&lt;/dt&gt;&lt;dd&gt;return a resource instance with generated sample data.&lt;/dd&gt; * &lt;dt&gt;empty&lt;/dt&gt;&lt;dd&gt;return a resource instance with empty property values.&lt;/dd&gt;&lt;/dl&gt; * @param {boolean} [options.includeOptionalFields] - if &lt;code&gt;options.generate&lt;/code&gt; * is specified, whether optional fields should be generated. * @return {Resource} the new instance * @throws {TypeNotFoundException} if the type is not registered with the ModelManager */ newResource(ns, type, id, options) { if(!id || typeof(id) !== 'string') { let formatter = Globalize.messageFormatter('factory-newinstance-invalididentifier'); throw new Error(formatter({ namespace: ns, type: type })); } if(id.trim().length === 0) { let formatter = Globalize.messageFormatter('factory-newinstance-missingidentifier'); throw new Error(formatter({ namespace: ns, type: type })); } const qualifiedName = ModelUtil.getFullyQualifiedName(ns, type); const classDecl = this.modelManager.getType(qualifiedName); if(classDecl.isAbstract()) { let formatter = Globalize.messageFormatter('factory-newinstance-abstracttype'); throw new Error(formatter({ namespace: ns, type: type })); } if(classDecl.isConcept()) { throw new Error('Use newConcept to create concepts ' + classDecl.getFullyQualifiedName()); } let newObj = null; options = options || {}; if(options.disableValidation) { newObj = new Resource(this.modelManager, ns, type, id); } else { newObj = new ValidatedResource(this.modelManager, ns, type, id, new ResourceValidator()); } newObj.assignFieldDefaults(); this.initializeNewObject(newObj, classDecl, options); // if we have an identifier, we set it now let idField = classDecl.getIdentifierFieldName(); newObj[idField] = id; debug('Factory.newResource created %s', id ); return newObj; } /** * Create a new Concept with a given namespace and type name * @param {string} ns - the namespace of the Concept * @param {string} type - the type of the Concept * @param {Object} [options] - an optional set of options * @param {boolean} [options.disableValidation] - pass true if you want the factory to * return a {@link Concept} instead of a {@link ValidatedConcept}. Defaults to false. * @param {string} [options.generate] - Pass one of: &lt;dl&gt; * &lt;dt&gt;sample&lt;/dt&gt;&lt;dd&gt;return a resource instance with generated sample data.&lt;/dd&gt; * &lt;dt&gt;empty&lt;/dt&gt;&lt;dd&gt;return a resource instance with empty property values.&lt;/dd&gt;&lt;/dl&gt; * @param {boolean} [options.includeOptionalFields] - if &lt;code&gt;options.generate&lt;/code&gt; * is specified, whether optional fields should be generated. * @return {Resource} the new instance * @throws {TypeNotFoundException} if the type is not registered with the ModelManager */ newConcept(ns, type, options) { const qualifiedName = ModelUtil.getFullyQualifiedName(ns, type); const classDecl = this.modelManager.getType(qualifiedName); if(classDecl.isAbstract()) { let formatter = Globalize.messageFormatter('factory-newinstance-abstracttype'); throw new Error(formatter({ namespace: ns, type: type })); } if(!classDecl.isConcept()) { throw new Error('Class is not a concept ' + classDecl.getFullyQualifiedName()); } let newObj = null; options = options || {}; if(options.disableValidation) { newObj = new Concept(this.modelManager,ns,type); } else { newObj = new ValidatedConcept(this.modelManager,ns,type, new ResourceValidator()); } newObj.assignFieldDefaults(); this.initializeNewObject(newObj, classDecl, options); debug('Factory.newResource created concept %s', classDecl.getFullyQualifiedName() ); return newObj; } /** * Create a new Relationship with a given namespace, type and identifier. * A relationship is a typed pointer to an instance. I.e the relationship * with namespace = 'org.acme', type = 'Vehicle' and id = 'ABC' creates` * a pointer that points at an instance of org.acme.Vehicle with the id * ABC. * * @param {string} ns - the namespace of the Resource * @param {string} type - the type of the Resource * @param {string} id - the identifier * @return {Relationship} - the new relationship instance * @throws {TypeNotFoundException} if the type is not registered with the ModelManager */ newRelationship(ns, type, id) { // Load the type declaration to force an error if it doesn't exist const fqn = ModelUtil.getFullyQualifiedName(ns, type); this.modelManager.getType(fqn); return new Relationship(this.modelManager, ns, type, id); } /** * Create a new transaction object. The identifier of the transaction is * set to a UUID. * @param {string} ns - the namespace of the transaction. * @param {string} type - the type of the transaction. * @param {string} [id] - an optional identifier for the transaction; if you do not specify * one then an identifier will be automatically generated. * @param {Object} [options] - an optional set of options * @param {string} [options.generate] - Pass one of: &lt;dl&gt; * &lt;dt&gt;sample&lt;/dt&gt;&lt;dd&gt;return a resource instance with generated sample data.&lt;/dd&gt; * &lt;dt&gt;empty&lt;/dt&gt;&lt;dd&gt;return a resource instance with empty property values.&lt;/dd&gt;&lt;/dl&gt; * @param {boolean} [options.includeOptionalFields] - if &lt;code&gt;options.generate&lt;/code&gt; * is specified, whether optional fields should be generated. * @return {Resource} A resource for the new transaction. */ newTransaction(ns, type, id, options) { if (!ns) { throw new Error('ns not specified'); } else if (!type) { throw new Error('type not specified'); } id = id || uuid.v4(); let transaction = this.newResource(ns, type, id, options); const classDeclaration = transaction.getClassDeclaration(); if (!(classDeclaration instanceof TransactionDeclaration)) { throw new Error(transaction.getClassDeclaration().getFullyQualifiedName() + ' is not a transaction'); } // set the timestamp transaction.timestamp = new Date(); return transaction; } /** * Create a new event object. The identifier of the event is * set to a UUID. * @param {string} ns - the namespace of the event. * @param {string} type - the type of the event. * @param {string} [id] - an optional identifier for the event; if you do not specify * one then an identifier will be automatically generated. * @param {Object} [options] - an optional set of options * @param {string} [options.generate] - Pass one of: &lt;dl&gt; * &lt;dt&gt;sample&lt;/dt&gt;&lt;dd&gt;return a resource instance with generated sample data.&lt;/dd&gt; * &lt;dt&gt;empty&lt;/dt&gt;&lt;dd&gt;return a resource instance with empty property values.&lt;/dd&gt;&lt;/dl&gt; * @param {boolean} [options.includeOptionalFields] - if &lt;code&gt;options.generate&lt;/code&gt; * is specified, whether optional fields should be generated. * @return {Resource} A resource for the new event. */ newEvent(ns, type, id, options) { if (!ns) { throw new Error('ns not specified'); } else if (!type) { throw new Error('type not specified'); } id = id || 'valid'; let event = this.newResource(ns, type, id, options); const classDeclaration = event.getClassDeclaration(); if (!(classDeclaration instanceof EventDeclaration)) { throw new Error(event.getClassDeclaration().getFullyQualifiedName() + ' is not an event'); } // set the timestamp event.timestamp = new Date(); return event; } /** * PRIVATE IMPLEMENTATION. DO NOT CALL FROM OUTSIDE THIS CLASS. * * Initialize the state of a newly created resource * @private * @param {Typed} newObject - resource to initialize. * @param {ClassDeclaration} classDeclaration - class declaration for the resource. * @param {Object} clientOptions - field generation options supplied by the caller. */ initializeNewObject(newObject, classDeclaration, clientOptions) { const generateParams = this.parseGenerateOptions(clientOptions); if (generateParams) { generateParams.stack = new TypedStack(newObject); const visitor = new InstanceGenerator(); classDeclaration.accept(visitor, generateParams); } } /** * PRIVATE IMPLEMENTATION. DO NOT CALL FROM OUTSIDE THIS CLASS. * * Parse the client-supplied field generation options and return a corresponding set of InstanceGenerator * options that can be used to initialize a resource. * @private * @param {Object} clientOptions - field generation options supplied by the caller. * @return {Object} InstanceGenerator options. */ parseGenerateOptions(clientOptions) { if (!clientOptions.generate) { return null; } const generateParams = { }; generateParams.modelManager = this.modelManager; generateParams.factory = this; if ((/^empty$/i).test(clientOptions.generate)) { generateParams.valueGenerator = ValueGeneratorFactory.empty(); } else { // Allow any other value for backwards compatibility with previous (truthy) behavior generateParams.valueGenerator = ValueGeneratorFactory.sample(); } generateParams.includeOptionalFields = clientOptions.includeOptionalFields ? true : false; return generateParams; } } module.exports = Factory; × Search results Close "},"composer-common_lib_introspect_field.js.html":{"id":"composer-common_lib_introspect_field.js.html","title":"Source: composer-common/lib/introspect/field.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/field.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Property = require('./property'); const NumberValidator = require('./numbervalidator'); const StringValidator = require('./stringvalidator'); /** * Class representing the definition of a Field. A Field is owned * by a ClassDeclaration and has a name, type and additional metadata * (see below). * @private * @extends Property * @see See [Property]{@link module:composer-common.Property} * @class * @memberof module:composer-common */ class Field extends Property { /** * Create an Field. * @param {ClassDeclaration} parent - The owner of this property * @param {Object} ast - The AST created by the parser * @throws {IllegalModelException} */ constructor(parent, ast) { super(parent, ast); } /** * Process the AST and build the model * @throws {IllegalModelException} * @private */ process() { super.process(); this.validator = null; switch(this.getType()) { case 'Integer': case 'Double': case 'Long': if(this.ast.range) { this.validator = new NumberValidator(this, this.ast.range); } break; case 'String': if(this.ast.regex) { this.validator = new StringValidator(this, this.ast.regex); } break; } if(this.ast.default) { this.defaultValue = this.ast.default; } else { this.defaultValue = null; } } /** * Returns the validator string for this field * @return {string} the validator for the field or null */ getValidator() { return this.validator; } /** * Returns the default value for the field or null * @return {string} the default value for the field or null */ getDefaultValue() { if(this.defaultValue) { return this.defaultValue; } else { return null; } } /** * Returns a string representation of this property§ * @return {String} the string version of the property. */ toString() { return 'Field {name=' + this.name + ', type=' + this.getFullyQualifiedTypeName() + ', array=' + this.array + ', optional=' + this.optional +'}'; } } module.exports = Field; × Search results Close "},"composer-common_lib_cardstore_filesystemcardstore.js.html":{"id":"composer-common_lib_cardstore_filesystemcardstore.js.html","title":"Source: composer-common/lib/cardstore/filesystemcardstore.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/cardstore/filesystemcardstore.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const nodeFs = require('fs'); const os = require('os'); const path = require('path'); const rimraf = require('rimraf'); const thenifyAll = require('thenify-all'); const IdCard = require('../idcard'); const BusinessNetworkCardStore = require('./businessnetworkcardstore'); const thenifyRimraf = thenifyAll(rimraf); const Logger = require('../log/logger'); const LOG = Logger.getLog('FileSystemCardStore'); /** * Manages persistence of business network cards to a Node file system implementation. * * @private * @class * @memberof module:composer-common */ class FileSystemCardStore extends BusinessNetworkCardStore { /** * Constructor. * @param {Object} options Additional configuration options for the card store. * @param {*} [options.fs] Node file system implementation. Defaults to Node implementation. * @param {String} [options.storePath] Location of the card store. Default: $HOME/.composer/cards */ constructor(options) { super(); if (!options) { options = {}; } this.fs = options.fs || nodeFs; this.thenifyFs = thenifyAll(this.fs); this.rimrafOptions = Object.assign({}, this.fs); this.rimrafOptions.disableGlob = true; this.storePath = options.storePath || path.join(os.homedir(), '.composer', 'cards'); } /** * Get the file system path for a given card. * @private * @param {String} cardName name of the card. * @return {String} directory in which the card is stored. */ _cardPath(cardName) { return path.join(this.storePath, cardName); } /** * Gets a card from the store. * @param {String} cardName The name of the card to get * @return {Promise} A promise that is resolved with a {@link IdCard}. */ get(cardName) { const method = 'get'; return IdCard.fromDirectory(this._cardPath(cardName), this.fs).catch(cause =&gt; { LOG.error(method, cause); const error = new Error('Card not found: ' + cardName); error.cause = cause; throw error; }); } /** * Puts a card in the store. * @param {String} cardName The name of the card to save * @param {IdCard} card The card * @return {Promise} A promise that resolves once the data is written */ put(cardName, card) { const method = 'put'; if (!cardName) { return Promise.reject(new Error('Invalid card name')); } return card.toDirectory(this._cardPath(cardName), this.fs).catch(cause =&gt; { LOG.error(method, cause); const error = new Error('Failed to save card: ' + cardName); error.cause = cause; throw error; }); } /** * Gets all cards from the store. * @return {Promise} A promise that is resolved with a {@link Map} where * the keys are identity card names and the values are {@link IdCard} objects. */ getAll() { const method = 'getAll'; const results = new Map(); return this.thenifyFs.readdir(this.storePath).catch(cause =&gt; { // Store directory does not exist, so there are no cards LOG.debug(method, cause); return results; }).then(fileNames =&gt; { const getPromises = []; fileNames.forEach(cardName =&gt; { const promise = this.get(cardName).then(card =&gt; { results.set(cardName, card); }); getPromises.push(promise); }); return Promise.all(getPromises); }).then(() =&gt; { return results; }); } /** * Delete a specific card from the store. * @param {String} cardName The name of the card to delete * @return {Promise} A promise that resolves when the card is deleted. */ delete(cardName) { const method = 'delete'; const cardPath = this._cardPath(cardName); return this.thenifyFs.access(cardPath).then(() =&gt; { return thenifyRimraf(cardPath, this.rimrafOptions); }).catch(cause =&gt; { LOG.debug(method, cause); throw new Error('Card not found: ' + cardName); }); } } module.exports = FileSystemCardStore; × Search results Close "},"composer-common_lib_codegen_filewriter.js.html":{"id":"composer-common_lib_codegen_filewriter.js.html","title":"Source: composer-common/lib/codegen/filewriter.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/codegen/filewriter.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const fs = require('fs'); const mkdirp = require('mkdirp'); const path = require('path'); const Writer = require('./writer'); /** * FileWriter creates text files under a directory tree. It can be used * by code generators to create source files for example. * Basic usage is: openFile(fileName), writeLine(...), closeFile(). * * @private * @extends Writer * @see See [Writer]{@link module:composer-common.Writer} * @class * @memberof module:composer-common */ class FileWriter extends Writer { /** * Create a FileWriter. * * @param {string} outputDirectory - the path to an output directory * that will be used to store generated files. */ constructor(outputDirectory) { super(); this.outputDirectory = outputDirectory; this.relativeDir = null; this.fileName = null; mkdirp.sync(outputDirectory); } /** * Opens a file for writing. The file will be created in the * root directory of this FileWriter. * * @param {string} fileName - the name of the file to open */ openFile(fileName) { this.fileName = fileName; this.relativeDir = null; } /** * Opens a file for writing, with a location relative to the * root directory of this FileWriter. * * @param {string} relativeDir - the relative directory to use * @param {string} fileName - the name of the file to open */ openRelativeFile(relativeDir, fileName) { this.relativeDir = relativeDir; this.fileName = fileName; } /** * Writes text to the current open file * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeLine(tabs,text) { if (this.fileName) { super.writeLine(tabs,text); } else { throw Error('File has not been opened!'); } } /** * Writes text to the start of the current open file * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeBeforeLine(tabs,text) { if (this.fileName) { super.writeBeforeLine(tabs,text); } else { throw Error('File has not been opened!'); } } /** * Closes the current open file */ closeFile() { if (!this.fileName) { throw new Error('No file open'); } let filePath = this.outputDirectory; if (this.relativeDir) { filePath = path.resolve(filePath, this.relativeDir); } filePath = path.resolve(filePath, this.fileName); //console.log('Writing to ' + filePath ); mkdirp.sync(path.dirname(filePath)); fs.writeFileSync(filePath, this.getBuffer()); this.fileName = null; this.relativeDir = null; this.clearBuffer(); } } module.exports = FileWriter; × Search results Close "},"composer-common_lib_fsconnectionprofilestore.js.html":{"id":"composer-common_lib_fsconnectionprofilestore.js.html","title":"Source: composer-common/lib/fsconnectionprofilestore.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/fsconnectionprofilestore.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ConnectionProfileStore = require('./connectionprofilestore'); const homedir = require('homedir'); const mkdirp = require('mkdirp'); const path = require('path'); const rimraf = require('rimraf'); const thenify = require('thenify'); const thenifyAll = require('thenify-all'); const PROFILE_ROOT = (() =&gt; { const h = homedir(); if (h) { return path.resolve(h, '.composer-connection-profiles'); } else { return path.resolve('/', '.composer-connection-profiles'); } })(); const CONNECTION_FILE = 'connection.json'; const ENCODING = 'utf8'; const LOG = require('./log/logger').getLog('FSConnectionProfileStore'); /** * Stores connection profiles on an attached fs fs. * The connection profiles are loaded from the ''&lt;HOME_DIR&gt;/composer-connection-profiles/' * directory. * * @private * @extends ConnectionProfileStore * @see See [ConnectionProfileStore]{@link module:composer-common.ConnectionProfileStore} * @class * @memberof module:composer-common */ class FSConnectionProfileStore extends ConnectionProfileStore { /** * Create the ConnectionManager and attach a file system * @param {fs} fs - Node.js FS implementation, for example BrowserFS */ constructor(fs) { super(); if (!fs) { throw new Error('Must create FSConnectionProfileStore with an fs implementation.'); } this.fs = thenifyAll(fs, {}); this.mkdirp = thenify((dir, cb) =&gt; { return mkdirp(dir, { fs: fs }, cb); }); this.rimraf = thenify((dir, cb) =&gt; { return rimraf(dir, fs, cb); }); } /** * Loads connectOptions for a given connection profile. * * @param {string} connectionProfile The name of the connection profile to load * @return {Promise} A promise that is resolved with a JS Object for the * data in the connection profile. */ load(connectionProfile) { const options = { flag : 'r', encoding : ENCODING }; return this.fs.readFile(path.resolve(PROFILE_ROOT, connectionProfile, CONNECTION_FILE), options) .then((contents) =&gt; { LOG.info('load','Loaded connection profile ' + connectionProfile, contents); return JSON.parse(contents); }) .catch((err) =&gt; { LOG.error('load','Failed to loaded connection profile ' + connectionProfile, err); throw new Error('Failed to load connection profile ' + connectionProfile + '. Error was ' + err); }); } /** * Save connectOptions for a given connection profile. * * @param {string} connectionProfile The name of the connection profile to save * @param {Object} connectOptions The connection options object * @return {Promise} A promise that once the data is written */ save(connectionProfile, connectOptions) { const DIR = path.resolve(PROFILE_ROOT, connectionProfile); return this.mkdirp(DIR) .then(() =&gt; { const options = { flag : 'w', encoding : ENCODING }; return this.fs.writeFile(path.resolve(DIR, CONNECTION_FILE), JSON.stringify(connectOptions, null, 4), options); }) .then(() =&gt; { LOG.info('save','Saved connection profile ' + connectionProfile); }) .catch((err) =&gt; { LOG.error('save','Failed to save connection profile ' + connectionProfile, err); throw new Error('Failed to save connection profile ' + connectionProfile); }); } /** * Loads all of the connection profiles. * * @return {Promise} A promise that is resolved with a JS Object where the * keys are the connection profiles, and the values are the connection options. */ loadAll() { const result = {}; return this.fs.readdir(PROFILE_ROOT) .then((files) =&gt; { return files.reduce((promise, file) =&gt; { return promise.then(() =&gt; { return this.load(file); }) .then((profile) =&gt; { result[file] = profile; }) .catch((error) =&gt; { // Ignore any errors. }); }, Promise.resolve()); }) .catch((error) =&gt; { // Ignore any errors. }) .then(() =&gt; { return result; }); } /** * Delete the given connection profile. * * @param {string} connectionProfile The name of the connection profile to delete * @return {Promise} A promise that is resolved when the connection profile * is deleted. */ delete(connectionProfile) { const DIR = path.resolve(PROFILE_ROOT, connectionProfile); return this.rimraf(DIR); } } module.exports = FSConnectionProfileStore; × Search results Close "},"composer-common_lib_introspect_functiondeclaration.js.html":{"id":"composer-common_lib_introspect_functiondeclaration.js.html","title":"Source: composer-common/lib/introspect/functiondeclaration.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/functiondeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const TransactionDeclaration = require('./transactiondeclaration'); const IllegalModelException = require('./illegalmodelexception'); const ModelUtil = require('../modelutil'); //const Globalize = require('../globalize'); /** * FunctionDeclaration defines a function that has been defined * in a model file. If the name of the function starts with 'on' * then the name of the function denotes the name of a transaction * declaration that the function processes. * @private * @class * @memberof module:composer-common */ class FunctionDeclaration { /** * Create a FunctionDeclaration * * @param {ModelManager} modelManager - the ModelManager used to validate this function * @param {string} language - the language that the function is written in. E.g. JS. * @param {string} name - the name of the function * @param {string} visibility - the visibility of the function * @param {string} returnType - the return type of the function * @param {string} throws - the type that is thrown by the function * @param {string[]} parameterNames - the names of parameters of the function * @param {string[]} parameterTypes - the type names of parameters of the function * @param {string[]} decorators - the function decorators * @param {string} functionText - the function as text * @throws {IllegalModelException} */ constructor(modelManager, language, name, visibility, returnType, throws, parameterNames, parameterTypes, decorators, functionText) { if(modelManager === null) { throw new Error('ModelManager is required.'); } this.modelManager = modelManager; this.name = name; this.language = language; this.visibility = visibility; this.returnType = returnType; this.throws = throws; this.decorators = decorators; this.parameterNames = parameterNames; this.parameterTypes = parameterTypes; this.functionText = functionText; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the text of this function. * * @return {string} the text that defines the function */ getFunctionText() { return this.functionText; } /** * Returns the type thrown by this function * * @return {string} the type thrown by the function */ getThrows() { return this.throws; } /** * Returns the programming language that the function is written in * * @return {string} the language of the function */ getLanguage() { return this.language; } /** * Returns the decorators that the function was tagged with * * @return {string[]} the @ prefixed decorators for the function */ getDecorators() { return this.decorators; } /** * Returns the visibility of this function * * @return {string} the visibility of the function (+ is public), * (- is private) */ getVisibility() { return this.visibility; } /** * Returns the return type for this function * * @return {string} the return type for the function */ getReturnType() { return this.returnType; } /** * Semantic validation of the structure of this function. * * @throws {IllegalModelException} * @private */ validate() { if(this.decorators.indexOf('transaction') &gt; -1) { if(this.decorators.indexOf('query') &gt; -1) { throw new Error('A function cannot be decorated with both @transaction and @query.'); } if(this.parameterTypes.length !== 1) { throw new IllegalModelException('Transaction processing function ' + this.name + ' must have 1 function argument of type transaction.' ); } const transactionClassName = this.parameterTypes[0]; if (ModelUtil.isPrimitiveType(transactionClassName) || !(this.modelManager.getType(transactionClassName) instanceof TransactionDeclaration)) { throw new IllegalModelException('Function ' + this.getName() + ' processes ' + transactionClassName + ' which is not a transaction.'); } } } /** * Returns the name of the function * * @return {string} the name of the function. */ getName() { return this.name; } /** * Returns the short name of the transaction declaration * that is being processed. This is calculated by removing * the 'on' prefix from the function name. * If the function name does not start with 'on' then null * * @return {string} the name of the transaction declaration. */ getTransactionDeclarationName() { if(this.name.startsWith('on')) { return this.name.substring(2); } else { return null; } } /** * Returns the names of the parameters processed by the function. * * @return {string[]} the names of the parameters. */ getParameterNames() { return this.parameterNames; } /** * Returns the types of the parameters processed by the function. * * @return {string[]} the types of the parameters. */ getParameterTypes() { return this.parameterTypes; } } module.exports = FunctionDeclaration; × Search results Close "},"composer-common_lib_idcard.js.html":{"id":"composer-common_lib_idcard.js.html","title":"Source: composer-common/lib/idcard.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/idcard.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const mkdirp = require('mkdirp'); const nodeFs = require('fs'); const path = require('path'); const process = require('process'); const thenifyAll = require('thenify-all'); const JSZip = require('jszip'); const thenifyMkdirp = thenifyAll(mkdirp); const Logger = require('./log/logger'); const LOG = Logger.getLog('IdCard'); const CONNECTION_FILENAME = 'connection.json'; const METADATA_FILENAME = 'metadata.json'; const CREDENTIALS_DIRNAME = 'credentials'; const CURRENT_VERSION = 1; const newErrorWithCause = (message, cause) =&gt; { const error = new Error(message); error.cause = cause; return error; }; /** * An ID card. Encapsulates credentials and other information required to connect to a specific business network * as a specific user. * &lt;p&gt; * Instances of this class should be created using {@link IdCard.fromArchive}. * @private * @class * @memberof module:composer-common */ class IdCard { /** * Create the IdCard. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link IdCard.fromArchive}&lt;/strong&gt; * @private * @param {Object} metadata - metadata associated with the card. * @param {Object} connectionProfile - connection profile associated with the card. */ constructor(metadata, connectionProfile) { const method = 'constructor'; LOG.entry(method); if (!metadata) { throw new Error('Missing metadata'); } if (metadata.version || metadata.version === 0) { // Migrate earlier versions using fall-through logic to migrate in single version steps switch (metadata.version) { case 0: metadata.userName = metadata.enrollmentId; delete metadata.enrollmentId; delete metadata.name; metadata.version = 1; } if (metadata.version !== CURRENT_VERSION) { throw new Error(`Incompatible card version ${metadata.version}. Current version is ${CURRENT_VERSION}`); } } else { metadata.version = CURRENT_VERSION; } if (!metadata.userName) { throw new Error('Required metadata field not found: userName'); } if (!(connectionProfile &amp;&amp; connectionProfile.name)) { throw new Error('Required connection field not found: name'); } this.metadata = metadata; this.connectionProfile = connectionProfile; this.credentials = { }; LOG.exit(method); } /** * Name of the user identity associated with the card. This should be unique within the scope of a given * business network and connection profile. * &lt;p&gt; * This is a mandatory field. * @return {String} Name of the user identity. */ getUserName() { return this.metadata.userName; } /** * Free text description of the card. * @return {String} card description. */ getDescription() { return this.metadata.description || ''; } /** * Name of the business network to which the ID card applies. Generally this will be present but may be * omitted for system cards. * @return {String} business network name. */ getBusinessNetworkName() { return this.metadata.businessNetwork || ''; } /** * Connection profile for this card. * &lt;p&gt; * This is a mandatory field. * @return {Object} connection profile. */ getConnectionProfile() { return this.connectionProfile; } /** * Credentials associated with this card, and which are used to connect to the associated business network. * &lt;p&gt; * For PKI-based authentication, the credentials are expected to be of the form: * &lt;em&gt;{ certificate: String, privateKey: String }&lt;/em&gt;. * @return {Object} credentials. */ getCredentials() { return this.credentials; } /** * Credentials to associate with this card. * &lt;p&gt; * For PKI-based authentication, the credentials are expected to be of the form: * &lt;em&gt;{ certificate: String, privateKey: String }&lt;/em&gt;. * @param {Object} credentials credentials. */ setCredentials(credentials) { const method = 'setCredentials'; LOG.entry(method, credentials); this.credentials = credentials || { }; LOG.exit(method); } /** * Enrollment credentials. If there are no credentials associated with this card, these credentials are used to * enroll with a business network and obtain certificates. * &lt;p&gt; * For an ID/secret enrollment scheme, the credentials are expected to be of the form: * &lt;em&gt;{ secret: String }&lt;/em&gt;. * @return {Object} enrollment credentials, or {@link null} if none exist. */ getEnrollmentCredentials() { const secret = this.metadata.enrollmentSecret; return secret ? { secret: secret } : null; } /** * Special roles for which this ID can be used, which can include: * &lt;ul&gt; * &lt;li&gt;PeerAdmin&lt;/li&gt; * &lt;li&gt;ChannelAdmin&lt;/li&gt; * &lt;li&gt;Issuer&lt;/li&gt; * &lt;/ul&gt; * @return {String[]} roles. */ getRoles() { return this.metadata.roles || [ ]; } /** * Create an IdCard from a card archive. * &lt;p&gt; * Valid types for &lt;em&gt;zipData&lt;/em&gt; are any of the types supported by JSZip. * @param {String|ArrayBuffer|Uint8Array|Buffer|Blob|Promise} zipData - card archive data. * @return {Promise} Promise to the instantiated IdCard. */ static fromArchive(zipData) { const method = 'fromArchive'; LOG.entry(method, zipData.length); return JSZip.loadAsync(zipData).then((zip) =&gt; { let promise = Promise.resolve(); let metadata; let connection; let credentials = { }; LOG.debug(method, 'Loading ' + CONNECTION_FILENAME); const connectionFile = zip.file(CONNECTION_FILENAME); if (!connectionFile) { throw Error('Required file not found: ' + CONNECTION_FILENAME); } promise = promise.then(() =&gt; { return connectionFile.async('string'); }).then((connectionContent) =&gt; { connection = JSON.parse(connectionContent); }); LOG.debug(method, 'Loading ' + METADATA_FILENAME); const metadataFile = zip.file(METADATA_FILENAME); if (!metadataFile) { throw Error('Required file not found: ' + METADATA_FILENAME); } promise = promise.then(() =&gt; { return metadataFile.async('string'); }).then((metadataContent) =&gt; { metadata = JSON.parse(metadataContent); // First cut of ID cards did not have a version so call them version zero if (!metadata.version) { metadata.version = 0; } }); const loadDirectoryToObject = function(directoryName, obj) { // Incude '/' following directory name const fileIndex = directoryName.length + 1; // Find all files that are direct children of specified directory const files = zip.file(new RegExp(`^${directoryName}/[^/]+$`)); files &amp;&amp; files.forEach((file) =&gt; { promise = promise.then(() =&gt; { return file.async('string'); }).then((content) =&gt; { const filename = file.name.slice(fileIndex); obj[filename] = content; }); }); }; LOG.debug(method, 'Loading ' + CREDENTIALS_DIRNAME); loadDirectoryToObject(CREDENTIALS_DIRNAME, credentials); return promise.then(() =&gt; { const idCard = new IdCard(metadata, connection); idCard.setCredentials(credentials); LOG.exit(method, idCard.toString()); return idCard; }); }); } /** * Generate a card archive representing this ID card. * &lt;p&gt; * The default value for the &lt;em&gt;options.type&lt;/em&gt; parameter is &lt;em&gt;arraybuffer&lt;/em&gt;. See JSZip documentation * for other valid values. * @param {Object} [options] - JSZip generation options. * @param {String} [options.type] - type of the resulting ZIP file data. * @return {Promise} Promise of the generated ZIP file; by default an {@link ArrayBuffer}. */ toArchive(options) { const method = 'fromArchive'; LOG.entry(method, options); const zipOptions = Object.assign({ type: 'arraybuffer' }, options); const zip = new JSZip(); const connectionContents = JSON.stringify(this.connectionProfile); zip.file(CONNECTION_FILENAME, connectionContents); const metadataContents = JSON.stringify(this.metadata); zip.file(METADATA_FILENAME, metadataContents); Object.keys(this.credentials).forEach(credentialName =&gt; { const filename = CREDENTIALS_DIRNAME + '/' + credentialName; const credentialData = this.credentials[credentialName]; zip.file(filename, credentialData); }); const result = zip.generateAsync(zipOptions); LOG.exit(method, result); return result; } /** * Create an IdCard from a directory consisting of the content of an ID card. * @param {String} cardDirectory directory containing card data. * @param {*} [fs] Node file system API implementation to use for reading card data. * Defaults to the Node implementation. * @return {Promise} Promise that resolves to an {@link IdCard}. */ static fromDirectory(cardDirectory, fs) { const method = 'fromDirectory'; LOG.entry(method, cardDirectory, fs); if (!fs) { fs = nodeFs; } let metadata; let connection; const credentials = { }; fs = thenifyAll(fs); const readOptions = { encoding: 'utf8', flag: 'r' }; const metadataPath = path.resolve(cardDirectory, METADATA_FILENAME); const connectionPath = path.resolve(cardDirectory, CONNECTION_FILENAME); const credentialsPath = path.resolve(cardDirectory, CREDENTIALS_DIRNAME); return fs.access(cardDirectory).catch(cause =&gt; { throw newErrorWithCause('Unable to read card directory: ' + cardDirectory, cause); }).then(() =&gt; { return fs.readFile(metadataPath, readOptions).catch(cause =&gt; { throw newErrorWithCause('Unable to read required file: ' + METADATA_FILENAME, cause); }); }).then(metadataContent =&gt; { metadata = JSON.parse(metadataContent); // First cut of ID cards did not have a version so call them version zero if (!metadata.version) { metadata.version = 0; } }).then(() =&gt; { return fs.readFile(connectionPath, readOptions).catch(cause =&gt; { throw newErrorWithCause('Unable to read required file: ' + CONNECTION_FILENAME, cause); }); }).then(connectionContent =&gt; { connection = JSON.parse(connectionContent); }).then(() =&gt; { return fs.readdir(credentialsPath).then(credentialFilenames =&gt; { const credentialPromises = []; credentialFilenames.forEach(filename =&gt; { const filePath = path.resolve(credentialsPath, filename); credentialPromises.push( fs.readFile(filePath, readOptions).then(credentialData =&gt; { credentials[filename] = credentialData; }) ); }); return Promise.all(credentialPromises); }).catch(cause =&gt; { // Ignore missing credentials as they are optional LOG.debug(method, 'Ignored error reading credentials', cause); }); }).then(() =&gt; { const idCard = new IdCard(metadata, connection); idCard.setCredentials(credentials); LOG.exit(method, idCard); return idCard; }); } /** * Save the content of an IdCard a directory. * @param {String} cardDirectory directory to save card data. * @param {*} [fs] Node file system API implementation to use for writing card data. * Defaults to the Node implementation. * @return {Promise} Promise that resolves then the save is complete. */ toDirectory(cardDirectory, fs) { const method = 'toDirectory'; if (!fs) { fs = nodeFs; } const metadataPath = path.join(cardDirectory, METADATA_FILENAME); const connectionPath = path.join(cardDirectory, CONNECTION_FILENAME); const credentialsDir = path.join(cardDirectory, CREDENTIALS_DIRNAME); const umask = process.umask(); const createDirMode = 0o0750 &amp; ~umask; // At most: user=all, group=read/execute, others=none const createFileMode = 0o0640 &amp; ~umask; // At most: user=read/write, group=read, others=none const mkdirpOptions = { fs: fs, mode: createDirMode }; const writeFileOptions = { encoding: 'utf8', mode: createFileMode }; fs = thenifyAll(fs); return thenifyMkdirp(cardDirectory, mkdirpOptions).then(() =&gt; { const metadataContent = JSON.stringify(this.metadata); return fs.writeFile(metadataPath, metadataContent, writeFileOptions); }).then(() =&gt; { const connectionContent = JSON.stringify(this.connectionProfile); return fs.writeFile(connectionPath, connectionContent, writeFileOptions); }).then(() =&gt; { return thenifyMkdirp(credentialsDir, mkdirpOptions); }).then(() =&gt; { const credentialPromises = []; Object.keys(this.credentials).forEach(credentialName =&gt; { const credentialPath = path.join(credentialsDir, credentialName); const credentialContent = this.credentials[credentialName]; const promise = fs.writeFile(credentialPath, credentialContent, writeFileOptions); credentialPromises.push(promise); }); return Promise.all(credentialPromises); }).catch(cause =&gt; { LOG.error(method, cause); throw newErrorWithCause('Failed to save card to directory: ' + cardDirectory, cause); }); } } module.exports = IdCard; × Search results Close "},"composer-common_lib_model_identifiable.js.html":{"id":"composer-common_lib_model_identifiable.js.html","title":"Source: composer-common/lib/model/identifiable.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/model/identifiable.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ResourceId = require('./resourceid'); const Typed = require('./typed'); /** * Identifiable is an entity with a namespace, type and an identifier. * * This class is abstract. * @abstract * @class * @memberof module:composer-common */ class Identifiable extends Typed { /** * Create an instance. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {string} id - The identifier of this instance. * @private */ constructor(modelManager, ns, type, id) { super(modelManager, ns, type); this.$identifier = id; } /** * Get the identifier of this instance * @return {string} The identifier for this object */ getIdentifier() { return this.$identifier; } /** * Set the identifier of this instance * @param {string} id - the new identifier for this object */ setIdentifier(id) { this.$identifier = id; const modelFile = this.$modelManager.getModelFile(this.getNamespace()); const typeDeclaration = modelFile.getType(this.getFullyQualifiedType()); const idField = typeDeclaration.getIdentifierFieldName(); this[idField] = id; } /** * Get the fully qualified identifier of this instance. * (namespace '.' type '#' identifier). * @return {string} the fully qualified identifier of this instance */ getFullyQualifiedIdentifier() { return this.getFullyQualifiedType() + '#' + this.$identifier; } /** * Returns the string representation of this class * @return {String} the string representation of the class */ toString() { return 'Identifiable {id=' + this.getFullyQualifiedIdentifier() +'}'; } /** * Determine if this identifiable is a relationship. * @return {boolean} True if this identifiable is a relationship, * false if not. */ isRelationship() { return false; } /** * Determine if this identifiable is a resource. * @return {boolean} True if this identifiable is a resource, * false if not. */ isResource() { return false; } /** * Returns a URI representation of a reference to this identifiable * @return {String} the URI for the identifiable */ toURI() { const resourceId = new ResourceId(this.getNamespace(), this.getType(), this.getIdentifier()); const result = resourceId.toURI(); //console.log( '***** URI for ' + this.toString() + ' is ' + result ); return result; } } module.exports = Identifiable; × Search results Close "},"composer-common_lib_introspect_illegalmodelexception.js.html":{"id":"composer-common_lib_introspect_illegalmodelexception.js.html","title":"Source: composer-common/lib/introspect/illegalmodelexception.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/illegalmodelexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BaseFileException = require('../basefileexception'); /** * Exception throws when a composer file is semantically invalid * @extends BaseFileException * @see See [BaseFileException]{@link module:composer-common.BaseFileException} * @class * @memberof module:composer-common */ class IllegalModelException extends BaseFileException { /** * Create an IllegalModelException. * @param {String} message - the message for the exception * @param {ModelFile} [modelFile] - the optional modelfile associated with the exception * @param {Object} [fileLocation] - location details of the error within the model file. * @param {String} fileLocation.start.line - start line of the error location. * @param {String} fileLocation.start.column - start column of the error location. * @param {String} fileLocation.end.line - end line of the error location. * @param {String} fileLocation.end.column - end column of the error location. */ constructor(message, modelFile, fileLocation) { let messageSuffix = ''; if(modelFile &amp;&amp; modelFile.getName()) { messageSuffix = 'File \\'' + modelFile.getName() + '\\': ' ; } if(fileLocation) { messageSuffix = messageSuffix + 'line ' + fileLocation.start.line + ' column ' + fileLocation.start.column + ', to line ' + fileLocation.end.line + ' column ' + fileLocation.end.column + '. '; } // First character to be uppercase messageSuffix = messageSuffix.charAt(0).toUpperCase() + messageSuffix.slice(1); super(message, fileLocation, message + ' ' + messageSuffix); this.modelFile = modelFile; } /** * Returns the modelfile associated with the exception or null * @return {string} the optional filename associated with the model */ getModelFile() { return this.modelFile; } } module.exports = IllegalModelException; × Search results Close "},"composer-common_lib_serializer_instancegenerator.js.html":{"id":"composer-common_lib_serializer_instancegenerator.js.html","title":"Source: composer-common/lib/serializer/instancegenerator.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/serializer/instancegenerator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('../introspect/classdeclaration'); const EnumDeclaration = require('../introspect/enumdeclaration'); const Field = require('../introspect/field'); const leftPad = require('left-pad'); const ModelUtil = require('../modelutil'); const RelationshipDeclaration = require('../introspect/relationshipdeclaration'); const Util = require('../util'); const Globalize = require('../globalize'); /** * Generate sample instance data for the specified class declaration * and resource instance. The specified resource instance will be * updated with either default values or generated sample data. * @private * @class * @memberof module:composer-common */ class InstanceGenerator { /** * Visitor design pattern * @param {Object} thing - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visit(thing, parameters) { if (thing instanceof ClassDeclaration) { return this.visitClassDeclaration(thing, parameters); } else if (thing instanceof RelationshipDeclaration) { return this.visitRelationshipDeclaration(thing, parameters); } else if (thing instanceof Field) { return this.visitField(thing, parameters); } else { throw new Error('Unrecognised ' + JSON.stringify(thing) ); } } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitClassDeclaration(classDeclaration, parameters) { const obj = parameters.stack.pop(); const properties = classDeclaration.getProperties(); for (const property of properties) { if (!parameters.includeOptionalFields &amp;&amp; property.isOptional()) { continue; } const value = obj[property.getName()]; if(Util.isNull(value)) { obj[property.getName()] = property.accept(this,parameters); } } return obj; } /** * Visitor design pattern * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitField(field, parameters) { if (field.isArray()) { const valueSupplier = () =&gt; this.getFieldValue(field, parameters); return parameters.valueGenerator.getArray(valueSupplier); } else { return this.getFieldValue(field, parameters); } } /** * Get a value for the specified field. * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @return {*} A value for the specified field. */ getFieldValue(field, parameters) { let type = field.getFullyQualifiedTypeName(); if (ModelUtil.isPrimitiveType(type)) { switch(type) { case 'DateTime': return parameters.valueGenerator.getDateTime(); case 'Integer': return parameters.valueGenerator.getInteger(); case 'Long': return parameters.valueGenerator.getLong(); case 'Double': return parameters.valueGenerator.getDouble(); case 'Boolean': return parameters.valueGenerator.getBoolean(); default: return parameters.valueGenerator.getString(); } } let classDeclaration = parameters.modelManager.getType(type); if (classDeclaration instanceof EnumDeclaration) { let enumValues = classDeclaration.getOwnProperties(); return parameters.valueGenerator.getEnum(enumValues).getName(); } classDeclaration = this.findConcreteSubclass(classDeclaration); if (classDeclaration.isConcept()) { let concept = parameters.factory.newConcept(classDeclaration.getNamespace(), classDeclaration.getName()); parameters.stack.push(concept); return classDeclaration.accept(this, parameters); } else { const id = this.generateRandomId(classDeclaration); let resource = parameters.factory.newResource(classDeclaration.getNamespace(), classDeclaration.getName(), id); parameters.stack.push(resource); return classDeclaration.accept(this, parameters); } } /** * Find a concrete type that extends the provided type. If the supplied type argument is * not abstract then it will be returned. * TODO: work out whether this has to be a leaf node or whether the closest type can be used * It depends really since the closest type will satisfy the model but whether it satisfies * any transaction code which attempts to use the generated resource is another matter. * @param {ClassDeclaration} declaration the class declaration. * @return {ClassDeclaration} the closest extending concrete class definition. * @throws {Error} if no concrete subclasses exist. */ findConcreteSubclass(declaration) { if (!declaration.isAbstract()) { return declaration; } const concreteSubclasses = declaration.getAssignableClassDeclarations() .filter(subclass =&gt; !subclass.isAbstract()) .filter(subclass =&gt; !subclass.isSystemType()); if (concreteSubclasses.length === 0) { const formatter = Globalize.messageFormatter('instancegenerator-newinstance-noconcreteclass'); throw new Error(formatter({ type: declaration.getFullyQualifiedName() })); } return concreteSubclasses[0]; } /** * Visitor design pattern * @param {RelationshipDeclaration} relationshipDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Relationship} the result of visiting * @private */ visitRelationshipDeclaration(relationshipDeclaration, parameters) { let classDeclaration = parameters.modelManager.getType(relationshipDeclaration.getFullyQualifiedTypeName()); classDeclaration = this.findConcreteSubclass(classDeclaration); const factory = parameters.factory; const valueSupplier = () =&gt; { const id = this.generateRandomId(classDeclaration); return factory.newRelationship(classDeclaration.getNamespace(), classDeclaration.getName(), id); }; if (relationshipDeclaration.isArray()) { return parameters.valueGenerator.getArray(valueSupplier); } else { return valueSupplier(); } } /** * Generate a random ID for a given type. * @private * @param {ClassDeclaration} classDeclaration - class declaration for a type. * @return {String} an ID. */ generateRandomId(classDeclaration) { const prefix = classDeclaration.getIdentifierFieldName(); let index = Math.round(Math.random() * 9999).toString(); index = leftPad(index, 4, '0'); return `${prefix}:${index}`; } } module.exports = InstanceGenerator; × Search results Close "},"composer-common_lib_introspect_introspector.js.html":{"id":"composer-common_lib_introspect_introspector.js.html","title":"Source: composer-common/lib/introspect/introspector.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/introspector.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * &lt;p&gt; * Provides access to the structure of transactions, assets and participants. * &lt;/p&gt; * @class * @memberof module:composer-common */ class Introspector { /** * Create the Introspector. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkDefinition}&lt;/strong&gt; * &lt;/p&gt; * @param {ModelManager} modelManager - the ModelManager that backs this Introspector */ constructor(modelManager) { this.modelManager = modelManager; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns all the class declarations for the business network. * @return {ClassDeclaration[]} the array of class declarations */ getClassDeclarations() { let result = []; const modelFiles = this.modelManager.getModelFiles(); for(let n=0; n &lt; modelFiles.length; n++) { const modelFile = modelFiles[n]; result = result.concat(modelFile.getAllDeclarations()); } return result; } /** * Returns the class declaration with the given fully qualified name. * Throws an error if the class declaration does not exist. * @param {String} fullyQualifiedTypeName - the fully qualified name of the type * @return {ClassDeclaration} the class declaration * @throws {Error} if the class declaration does not exist */ getClassDeclaration(fullyQualifiedTypeName) { return this.modelManager.getType(fullyQualifiedTypeName); } /** * Returns the backing ModelManager * @return {ModelManager} the backing ModelManager * @private */ getModelManager() { return this.modelManager; } } module.exports = Introspector; × Search results Close "},"composer-common_lib_query_invalidqueryexception.js.html":{"id":"composer-common_lib_query_invalidqueryexception.js.html","title":"Source: composer-common/lib/query/invalidqueryexception.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/query/invalidqueryexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BaseFileException = require('../basefileexception'); /** * Exception thrown for invalid queries * @extends BaseFileException * @see See [BaseFileException]{@link module:composer-common.BaseFileException} * @class * @memberof module:composer-common */ class InvalidQueryException extends BaseFileException { /** * Create an InvalidQueryException. * @param {String} message - the message for the exception * @param {QueryFile} [queryFile] - the optional queryFile associated with the exception * @param {Object} [fileLocation] - location details of the error within the model file. * @param {String} fileLocation.start.line - start line of the error location. * @param {String} fileLocation.start.column - start column of the error location. * @param {String} fileLocation.end.line - end line of the error location. * @param {String} fileLocation.end.column - end column of the error location. */ constructor(message, queryFile, fileLocation) { let messageSuffix = ''; if(queryFile &amp;&amp; queryFile.getIdentifier()) { messageSuffix = 'File \\'' + queryFile.getIdentifier() + '\\': ' ; } if(fileLocation) { messageSuffix = messageSuffix + 'line ' + fileLocation.start.line + ' column ' + fileLocation.start.column + ', to line ' + fileLocation.end.line + ' column ' + fileLocation.end.column + '. '; } // First character to be uppercase messageSuffix = messageSuffix.charAt(0).toUpperCase() + messageSuffix.slice(1); super(message, fileLocation, message + ' ' + messageSuffix); this.queryFile = queryFile; } /** * Returns the query file associated with the exception or null * @return {QueryFile} the optional query file associated with the exception */ getQueryFile() { return this.queryFile; } } module.exports = InvalidQueryException; × Search results Close "},"composer-common_lib_codegen_javascriptparser.js.html":{"id":"composer-common_lib_codegen_javascriptparser.js.html","title":"Source: composer-common/lib/codegen/javascriptparser.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/codegen/javascriptparser.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const doctrine = require('doctrine'); const esprima = require('esprima'); const acorn = require('acorn'); const Util = require('util'); /** * Processes a single Javascript file (.js extension) * * @param {string} file - the file to process * @param {Object} fileProcessor - the processor instance to use to generate code * @private * @class * @memberof module:composer-common */ class JavaScriptParser { /** * Create a JavaScriptParser. * * @param {string} fileContents - the text of the JS file to parse * @param {boolean} [includePrivates] - if true methods tagged as private are also returned * @param {number} [ecmaVersion] - the ECMAScript version to use */ constructor(fileContents, includePrivates, ecmaVersion) { let comments = []; this.tokens = []; let options = { // collect ranges for each node ranges: true, // collect comments in Esprima's format onComment: comments, // collect token ranges onToken: this.tokens, // collect token locations locations: true, // locations: true, plugins: {'composereof':true} }; if (ecmaVersion) { options.ecmaVersion = ecmaVersion; } // let parser = new Parser(options, fileContents); // let ast = parser.parse(); acorn.plugins.composereof=function(parser){ parser.extend('parseTopLevel', function(nextMethod){ return function(node){ let this$1 = this; let exports = {}; if (!node.body) { node.body = []; } while (this.type.label!=='eof') { let stmt = this$1.parseStatement(true, true, exports); node.body.push(stmt); } this.next(); if (this.options.ecmaVersion &gt;= 6) { node.sourceType = this.options.sourceType; } return this.finishNode(node, 'Program'); }; }); }; let ast = acorn.parse(fileContents, options); this.includes = []; this.classes = []; this.functions = []; // let nodesToProcess = ast.body; let nodesToProcess = []; const walk = require('acorn/dist/walk'); walk.simple(ast, { FunctionExpression(node) { if (node.id &amp;&amp; node.id.name){ nodesToProcess.push(node); } }, ClassDeclaration(node) { nodesToProcess.push(node); } }); // console.log(Util.inspect(nodesToProcess)); for (let n = 0; n &lt; nodesToProcess.length; n++) { let statement = nodesToProcess[n]; // record the end of the previous node. let previousEnd = -1; if (n !== 0) { previousEnd = nodesToProcess[n-1].end; } if (statement.type === 'VariableDeclaration') { let variableDeclarations = statement.declarations; for (let n = 0; n &lt; variableDeclarations.length; n++) { let variableDeclaration = variableDeclarations[n]; if (variableDeclaration.init &amp;&amp; variableDeclaration.init.type === 'CallExpression' &amp;&amp; variableDeclaration.init.callee.name === 'require') { let requireName = variableDeclaration.init.arguments[0].value; // we only care about the code we require with a relative path if (requireName.startsWith('.')) { this.includes.push(variableDeclaration.init.arguments[0].value); } } } } else if (statement.type === 'FunctionDeclaration' || statement.type === 'FunctionExpression') { let closestComment = JavaScriptParser.findCommentBefore(statement.start, statement.end, previousEnd, comments,statement.loc); let returnType = ''; let visibility = '+'; let parameterTypes = []; let parameterNames = []; let decorators = []; let throws = ''; let example = ''; let commentData; if(closestComment &gt;= 0) { let comment = comments[closestComment].value; commentData = doctrine.parse(comment, {unwrap: true, sloppy: true}); returnType = JavaScriptParser.getReturnType(comment); visibility = JavaScriptParser.getVisibility(comment); parameterTypes = JavaScriptParser.getMethodArguments(comment); throws = JavaScriptParser.getThrows(comment); decorators = JavaScriptParser.getDecorators(comment); example = JavaScriptParser.getExample(comment); } if(visibility === '+' || includePrivates) { for(let n=0; n &lt; statement.params.length; n++) { parameterNames.push(statement.params[n].name); } const func = { visibility: visibility, returnType: returnType, name: statement.id.name, parameterTypes: parameterTypes, parameterNames: parameterNames, throws: throws, decorators: decorators, functionText : JavaScriptParser.getText(statement.start, statement.end, fileContents), example: example, commentData : commentData }; this.functions.push(func); } } else if (statement.type === 'ClassDeclaration') { let closestComment = JavaScriptParser.findCommentBefore(statement.start, statement.end, previousEnd, comments,statement.loc); let privateClass = false; let d; if(closestComment &gt;= 0) { let comment = comments[closestComment].value; d = doctrine.parse(comment, {unwrap: true, sloppy: true}); privateClass = JavaScriptParser.getVisibility(comment) === '-'; } if(privateClass === false || includePrivates) { d = d || []; const clazz = { name: statement.id.name , commentData : d }; clazz.methods = []; for(let n=0; n &lt; statement.body.body.length; n++) { let thing = statement.body.body[n]; // previousEnd is the end of the node before the ClassDeclaration let previousThingEnd = previousEnd; if (n !== 0) { // record the end of the previous thing inside the ClassDeclaration let previousThing = statement.body.body[n-1]; previousThingEnd = previousThing.end; } if (thing.type === 'MethodDefinition') { let closestComment = JavaScriptParser.findCommentBefore(thing.key.start, thing.key.end, previousThingEnd, comments,thing.loc); let returnType = ''; let visibility = '+'; let methodArgs = []; let throws = ''; let decorators = []; let example = ''; let commentData; if(closestComment &gt;= 0) { let comment = comments[closestComment].value; commentData = doctrine.parse(comment, {unwrap: true, sloppy: true}); returnType = JavaScriptParser.getReturnType(comment); visibility = JavaScriptParser.getVisibility(comment); methodArgs = JavaScriptParser.getMethodArguments(comment); decorators = JavaScriptParser.getDecorators(comment); throws = JavaScriptParser.getThrows(comment); example = JavaScriptParser.getExample(comment); } commentData = commentData || []; if(visibility === '+' || includePrivates) { const method = { visibility: visibility, returnType: returnType, name: thing.key.name, methodArgs: methodArgs, decorators: decorators, throws: throws, example: example, commentData : commentData }; clazz.methods.push(method); } } } if (statement.superClass) { clazz.superClass = statement.superClass.name; } this.classes.push(clazz); } } } } /** * Return the includes that were extracted from the JS file. * * @return {Object[]} information about each include */ getIncludes() { return this.includes; } /** * Return the classes that were extracted from the JS file. * * @return {Object[]} information about each class */ getClasses() { return this.classes; } /** * Return the methods that were extracted from the JS file. * * @return {Object[]} information about each method */ getFunctions() { return this.functions; } /** * Return the tokens that were extracted from the JS file. * * @return {Object[]} information about each tokens */ getTokens() { return this.tokens; } /** * Grab the text between a range * * @param {integer} rangeStart - the start of the range * @param {integer} rangeEnd - the end of the range * @param {string} source - the source text * @return {string} the text between start and end * @private */ static getText(rangeStart, rangeEnd, source) { return source.substring(rangeStart, rangeEnd); } /** * Find the comments that are above and closest to the start of the range. * * @param {integer} rangeStart - the start of the range * @param {integer} rangeEnd - the end of the range * @param {integer} stopPoint - the point to stop searching for previous comments * @param {string[]} comments - the end of the range * @return {integer} the comment index or -1 if there are no comments * @private */ static findCommentBefore(rangeStart, rangeEnd, stopPoint, comments,loc) { let foundIndex = -1; // let distance = -1; let lineNumber=parseInt(loc.start.line); for(let n=0; n &lt; comments.length; n++) { let comment = comments[n]; let endComment = parseInt(comment.loc.end.line); if ( (lineNumber-endComment) === 1 ){ // i.e. on the line before foundIndex = n; break; } // if(rangeStart &gt; endComment &amp;&amp; comment.start &gt; stopPoint) { // if(distance === -1 || rangeStart - endComment &lt; distance) { // distance = rangeStart - endComment; // foundIndex = n; // } // } } return foundIndex; } /** * Grabs all the @ prefixed decorators from a comment block. * @param {string} comment - the comment block * @return {string[]} the @ prefixed decorators within the comment block * @private */ static getDecorators(comment) { const re = /(?:^|\\W)@(\\w+)/g; let match; const matches = []; match = re.exec(comment); while (match) { matches.push(match[1]); match = re.exec(comment); } return matches; } /** * Extracts the visibilty from a comment block * @param {string} comment - the comment block * @return {string} the return visibility (either + for public, or - for private) * @private */ static getVisibility(comment) { const PRIVATE = 'private'; let parsedComment = doctrine.parse(comment, {unwrap: true, sloppy: true, tags: [PRIVATE]}); const tags = parsedComment.tags; if (tags.length &gt; 0) { return '-'; } return '+'; } /** * Extracts the return type from a comment block. * @param {string} comment - the comment block * @return {string} the return type of the comment * @private */ static getReturnType(comment) { const RETURN = 'return'; const RETURNS = 'returns'; let result = 'void'; let parsedComment = doctrine.parse(comment, {unwrap: true, sloppy: true, tags: [RETURN, RETURNS]}); const tags = parsedComment.tags; if (tags.length &gt; 1) { throw new Error('Malformed JSDoc comment. More than one returns: ' + comment ); } tags.forEach((tag) =&gt; { if (tag.type) { if (!tag.type.name &amp;&amp; !tag.type) { throw new Error('Malformed JSDoc comment. ' + comment ); } if (tag.type.name) { result = tag.type.name; } else if (tag.type.applications){ result = tag.type.applications[0].name + '[]'; } else if (tag.type.expression) { result = tag.type.expression.name; } } else { throw new Error('Malformed JSDoc comment. ' + comment ); } }); return result; } /** * Extracts the return type from a comment block. * @param {string} comment - the comment block * @return {string} the return type of the comment * @private */ static getThrows(comment) { const THROWS = 'throws'; const EXCEPTION = 'exception'; let result = ''; let parsedComment = doctrine.parse(comment, {unwrap: true, sloppy: true, tags: [THROWS, EXCEPTION]}); const tags = parsedComment.tags; if (tags.length &gt; 1) { throw new Error('Malformed JSDoc comment. More than one throws/exception: ' + comment ); } tags.forEach((tag) =&gt; { if (tag.type) { if (!tag.type.type || !tag.type.name) { throw new Error('Malformed JSDoc comment. ' + comment ); } result = tag.type.name; } else { throw new Error('Malformed JSDoc comment. ' + comment); } }); return result; } /** * Extracts the method arguments from a comment block. * @param {string} comment - the comment block * @return {string} the the argument types * @private */ static getMethodArguments(comment) { const TAG = 'param'; let paramTypes = []; let parsedComment = doctrine.parse(comment, {unwrap: true, sloppy: true, tags: [TAG]}); const tags = parsedComment.tags; // param is mentined but not picked up by parser if (comment.indexOf('@'+TAG) !== -1 &amp;&amp; tags.length === 0) { throw new Error('Malformed JSDoc comment: ' + comment ); } tags.forEach((tag) =&gt; { if (tag.description) { //If description starts with } if (tag.description.trim().indexOf('}') === 0 || !tag.type || !tag.name ) { throw new Error('Malformed JSDoc comment: ' + comment ); } } if(tag.type.name) { if (tag.type.name.indexOf(' ') !== -1) { throw new Error('Malformed JSDoc comment: ' + comment ); } } if (tag.type.name) { paramTypes.push(tag.type.name); } else if (tag.type.applications){ paramTypes.push(tag.type.applications[0].name + '[]'); } else if (tag.type.expression) { paramTypes.push(tag.type.expression.name); } }); return paramTypes; } /** * Extracts the example tag from a comment block. * @param {string} comment - the comment block * @return {string} the the argument types * @private */ static getExample(comment) { const EXAMPLE = 'example'; let result = ''; let parsedComment = doctrine.parse(comment, {unwrap: true, sloppy: true, tags: [EXAMPLE]}); const tags = parsedComment.tags; if (tags.length &gt; 0) { result = tags[0].description; } try { // Pass as a function so that return statements are valid let program = 'function testSyntax() {' + result + '}'; esprima.parse(program); } catch (e) { throw Error('Malformed JSDoc Comment. Invalid @example tag: ' + comment); } return result; } } module.exports = JavaScriptParser; × Search results Close "},"composer-common_lib_codegen_fromjs_jsongenerator.js.html":{"id":"composer-common_lib_codegen_fromjs_jsongenerator.js.html","title":"Source: composer-common/lib/codegen/fromjs/jsongenerator.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/codegen/fromjs/jsongenerator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const fs = require('fs'); const path = require('path'); /** * @private * @class * @memberof module:composer-common */ class JSONGenerator { /** * @param {Object} program - the program arguments * @param {Object} file - the file instance being processed * @param {Object[]} includes - the includes (require statements) within the file * @param {Object[]} classes - the classes within the file * @param {Object[]} functions - the functions within the file */ generate(program, file, includes, classes, functions) { let classData = classes[0]; if (classData){ // merge the methods and the functions classData.methods = classData.methods || []; classData.methods = classData.methods.concat(functions); let json = this._process(classData); let f = path.resolve(program.outputDir, json.module+'-'+path.parse(file).name+'.json'); fs.writeFileSync(f,JSON.stringify(json)); } } /** * This takes a set of data that represents a class, or something that is effectively a class * and produces a formed up set of JSON data reperesenting this. * This can then be processed for documentation of other puposes. * @return {Object} JSON data * @param {Object} data to process */ _process(data) { if (data){ data.commentData.description = data.commentData.description || ''; data.commentData.tags = data.commentData.tags || []; data.description = data.commentData.description.replace(/\\n\\s*\\n/g, '~~~~').replace(/\\n/g, ' ').split('~~~~'); data.seeAlso=[]; data.visibility='public'; data.commentData.tags.forEach((e)=&gt;{ if (e.title==='extends'){ data.extends=e.name; } else if (e.title === 'see'){ // &quot;See [Registry]{@link module:composer-client.Registry}&quot; let s1 = e.description.substring(0,e.description.indexOf('{')); let a = e.description.indexOf('}'); let b = e.description.lastIndexOf('.')+1; data.seeAlso.push(s1+'('+e.description.substring(a,b).toLowerCase()+')'); } else if (e.title === 'memberof'){ data.module=e.description.substr(e.description.indexOf('-')+1); } else if (e.title === 'private'){ data.visibility ='private'; } else if (e.title === 'protected'){ data.visibility='protected'; } }); delete data.tags; // process the methods (or functions) of the classes, including all parameters and types thereof let listMethods = data.methods; listMethods .forEach((e)=&gt;{ e.description = e.commentData.description.replace(/\\n\\s*\\n/g, '~~~~').replace(/\\n/g, ' ').split('~~~~'); e.parameters = []; e.commentData.tags.forEach( (p)=&gt;{ if (p.title==='param'){ let oneParam = {}; oneParam.description=p.description; if (p.type.type==='OptionalType'){ oneParam.type=p.type.expression.name; oneParam.name=p.name; oneParam.optional=true; } else { oneParam.type=p.type.name; oneParam.name=p.name; oneParam.optional=true; } e.parameters.push(oneParam); } else if (p.title.startsWith('return')) { e.return={description:p.description.split('\\n'), type : p.type.name}; } }); }); } return data; } } module.exports = JSONGenerator; × Search results Close "},"composer-common_lib_serializer_jsongenerator.js.html":{"id":"composer-common_lib_serializer_jsongenerator.js.html","title":"Source: composer-common/lib/serializer/jsongenerator.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/serializer/jsongenerator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('../introspect/classdeclaration'); const Field = require('../introspect/field'); const RelationshipDeclaration = require('../introspect/relationshipdeclaration'); const Resource = require('../model/resource'); const Identifiable = require('../model/identifiable'); const Typed = require('../model/typed'); const Concept = require('../model/concept'); const ModelUtil = require('../modelutil'); const Util = require('../util'); /** * Converts the contents of a Resource to JSON. The parameters * object should contain the keys * 'writer' - the JSONWriter instance to use to accumulate the JSON text. * 'stack' - the TypedStack of objects being processed. It should * start with a Resource. * 'modelManager' - the ModelManager to use. * @private * @class * @memberof module:composer-common */ class JSONGenerator { /** * Constructor. * @param {boolean} [convertResourcesToRelationships] Convert resources that * are specified for relationship fields into relationships, false by default. * @param {boolean} [permitResourcesForRelationships] Permit resources in the * place of relationships (serializing them as resources), false by default. * @param {boolean} [deduplicateResources] If resources appear several times * in the object graph only the first instance is serialized, with only the $id * written for subsequent instances, false by default. */ constructor(convertResourcesToRelationships, permitResourcesForRelationships, deduplicateResources) { this.convertResourcesToRelationships = convertResourcesToRelationships; this.permitResourcesForRelationships = permitResourcesForRelationships; this.deduplicateResources = deduplicateResources; } /** * Visitor design pattern * @param {Object} thing - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visit(thing, parameters) { if (thing instanceof ClassDeclaration) { return this.visitClassDeclaration(thing, parameters); } else if (thing instanceof RelationshipDeclaration) { return this.visitRelationshipDeclaration(thing, parameters); } else if (thing instanceof Field) { return this.visitField(thing, parameters); } else { throw new Error('Unrecognised ' + JSON.stringify(thing)); } } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitClassDeclaration(classDeclaration, parameters) { const obj = parameters.stack.pop(); if (!((obj instanceof Resource) || (obj instanceof Concept))) { throw new Error('Expected a Resource or a Concept, but found ' + obj); } let writeFields = true; let id = null; if (obj instanceof Identifiable &amp;&amp; this.deduplicateResources) { id = obj.toURI(); if( parameters.dedupeResources.has(id)) { writeFields = false; parameters.writer.writeStringValue( id ); } else { parameters.dedupeResources.add(id); } } if (writeFields) { parameters.writer.openObject(); parameters.writer.writeKeyStringValue('$class', classDeclaration.getFullyQualifiedName()); if(this.deduplicateResources &amp;&amp; id) { parameters.writer.writeKeyStringValue('$id', id ); } const properties = classDeclaration.getProperties(); for (let n = 0; n &lt; properties.length; n++) { const property = properties[n]; const value = obj[property.getName()]; if (!Util.isNull(value)) { parameters.stack.push(value); property.accept(this, parameters); } } parameters.writer.closeObject(); } return null; } /** * Visitor design pattern * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitField(field, parameters) { const obj = parameters.stack.pop(); parameters.writer.writeKey(field.getName()); if (field.isArray()) { parameters.writer.openArray(); for (let n = 0; n &lt; obj.length; n++) { const item = obj[n]; if (!field.isPrimitive() &amp;&amp; !ModelUtil.isEnum(field)) { parameters.writer.writeComma(); parameters.stack.push(item, Typed); const classDecl = parameters.modelManager.getType(item.getFullyQualifiedType()); classDecl.accept(this, parameters); } else { parameters.writer.writeArrayValue(this.convertToJSON(field, item)); } } parameters.writer.closeArray(); } else if (field.isPrimitive() || ModelUtil.isEnum(field)) { parameters.writer.writeValue(this.convertToJSON(field, obj)); } else { parameters.stack.push(obj); const classDeclaration = parameters.modelManager.getType(obj.getFullyQualifiedType()); classDeclaration.accept(this, parameters); } return null; } /** * Converts a primtive object to JSON text. * * @param {Field} field - the field declaration of the object * @param {Object} obj - the object to convert to text * @return {string} the text representation */ convertToJSON(field, obj) { switch (field.getType()) { case 'DateTime': { return `&quot;${obj.toISOString()}&quot;`; } case 'Integer': case 'Long': case 'Double': case 'Boolean': { return `${obj.toString()}`; } default: { return JSON.stringify(obj.toString()); } } } /** * Visitor design pattern * @param {RelationshipDeclaration} relationshipDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitRelationshipDeclaration(relationshipDeclaration, parameters) { const obj = parameters.stack.pop(); parameters.writer.writeKey(relationshipDeclaration.getName()); if (relationshipDeclaration.isArray()) { parameters.writer.openArray(); for (let n = 0; n &lt; obj.length; n++) { const item = obj[n]; if (this.permitResourcesForRelationships &amp;&amp; item instanceof Resource) { let fqi = item.getFullyQualifiedIdentifier(); if (parameters.seenResources.has(fqi)) { let relationshipText = this.getRelationshipText(relationshipDeclaration, item); parameters.writer.writeStringValue(relationshipText); } else { parameters.seenResources.add(fqi); parameters.writer.writeComma(); parameters.stack.push(item, Resource); const classDecl = parameters.modelManager.getType(relationshipDeclaration.getFullyQualifiedTypeName()); classDecl.accept(this, parameters); parameters.seenResources.delete(fqi); } } else { let relationshipText = this.getRelationshipText(relationshipDeclaration, item); parameters.writer.writeArrayStringValue(relationshipText); } } parameters.writer.closeArray(); } else if (this.permitResourcesForRelationships &amp;&amp; obj instanceof Resource) { let fqi = obj.getFullyQualifiedIdentifier(); if (parameters.seenResources.has(fqi)) { let relationshipText = this.getRelationshipText(relationshipDeclaration, obj); parameters.writer.writeStringValue(relationshipText); } else { parameters.seenResources.add(fqi); parameters.stack.push(obj, Resource); const classDecl = parameters.modelManager.getType(relationshipDeclaration.getFullyQualifiedTypeName()); classDecl.accept(this, parameters); parameters.seenResources.delete(fqi); } } else { let relationshipText = this.getRelationshipText(relationshipDeclaration, obj); parameters.writer.writeStringValue(relationshipText); } return null; } /** * Returns the persistent format for a relationship. * @param {RelationshipDeclaration} relationshipDeclaration - the relationship being persisted * @param {Identifiable} relationshipOrResource - the relationship or the resource * @returns {string} the text to use to persist the relationship */ getRelationshipText(relationshipDeclaration, relationshipOrResource) { if (relationshipOrResource instanceof Resource) { const allowRelationships = this.convertResourcesToRelationships || this.permitResourcesForRelationships; if (!allowRelationships) { throw new Error('Did not find a relationship for ' + relationshipDeclaration.getFullyQualifiedTypeName() + ' found ' + relationshipOrResource); } } return relationshipOrResource.toURI(); } } module.exports = JSONGenerator; × Search results Close "},"composer-common_lib_serializer_jsonpopulator.js.html":{"id":"composer-common_lib_serializer_jsonpopulator.js.html","title":"Source: composer-common/lib/serializer/jsonpopulator.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/serializer/jsonpopulator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('../introspect/classdeclaration'); const Field = require('../introspect/field'); const RelationshipDeclaration = require('../introspect/relationshipdeclaration'); const Relationship = require('../model/relationship'); const Util = require('../util'); const ModelUtil = require('../modelutil'); /** * Populates a Resource with data from a JSON object graph. The JSON objects * should be the result of calling Serializer.toJSON and then JSON.parse. * The parameters object should contain the keys * 'stack' - the TypedStack of objects being processed. It should * start with the root object from JSON.parse. * 'factory' - the Factory instance to use for creating objects. * 'modelManager' - the ModelManager instance to use to resolve classes * @private * @class * @memberof module:composer-common */ class JSONPopulator { /** * Constructor. * @param {boolean} [acceptResourcesForRelationships] Permit resources in the * place of relationships, false by default. */ constructor(acceptResourcesForRelationships) { this.acceptResourcesForRelationships = acceptResourcesForRelationships; } /** * Visitor design pattern * @param {Object} thing - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visit(thing, parameters) { if (thing instanceof ClassDeclaration) { return this.visitClassDeclaration(thing, parameters); } else if (thing instanceof RelationshipDeclaration) { return this.visitRelationshipDeclaration(thing, parameters); } else if (thing instanceof Field) { return this.visitField(thing, parameters); } else { throw new Error('Unrecognised ' + JSON.stringify(thing) ); } } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitClassDeclaration(classDeclaration, parameters) { const jsonObj = parameters.jsonStack.pop(); const resourceObj = parameters.resourceStack.pop(); const properties = classDeclaration.getProperties(); for(let n=0; n &lt; properties.length; n++) { const property = properties[n]; const value = jsonObj[property.getName()]; if(!Util.isNull(value)) { parameters.jsonStack.push(value); resourceObj[property.getName()] = property.accept(this,parameters); } } return resourceObj; } /** * Visitor design pattern * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitField(field, parameters) { const jsonObj = parameters.jsonStack.pop(); let result = null; if(field.isArray()) { result = []; for(let n=0; n &lt; jsonObj.length; n++) { const jsonItem = jsonObj[n]; result.push(this.convertItem(field,jsonItem, parameters)); } } else { result = this.convertItem(field,jsonObj, parameters); } return result; } /** * * @param {Field} field - the field of the item being converted * @param {Object} jsonItem - the JSON object of the item being converted * @param {Object} parameters - the parameters * @return {Object} - the populated object. */ convertItem(field, jsonItem, parameters) { let result = null; if(!field.isPrimitive() &amp;&amp; !field.isTypeEnum()) { let typeName = jsonItem.$class; if(!typeName) { // If the type name is not specified in the data, then use the // type name from the model. This will only happen in the case of // a sub resource inside another resource. typeName = field.getFullyQualifiedTypeName(); } // This throws if the type does not exist. const classDeclaration = parameters.modelManager.getType(typeName); // create a new instance, using the identifier field name as the ID. let subResource = null; // if this is identifiable, then we create a resource if(!classDeclaration.isConcept()) { subResource = parameters.factory.newResource(classDeclaration.getNamespace(), classDeclaration.getName(), jsonItem[classDeclaration.getIdentifierFieldName()] ); } else { // otherwise we create a concept subResource = parameters.factory.newConcept(classDeclaration.getNamespace(), classDeclaration.getName() ); } result = subResource; parameters.resourceStack.push(subResource); parameters.jsonStack.push(jsonItem); classDeclaration.accept(this, parameters); } else { result = this.convertToObject(field,jsonItem); } return result; } /** * Converts a primtive object to JSON text. * * @param {Field} field - the field declaration of the object * @param {Object} json - the JSON object to convert to a Composer Object * @return {string} the text representation */ convertToObject(field, json) { let result = null; switch(field.getType()) { case 'DateTime': result = new Date(json); break; case 'Integer': case 'Long': result = parseInt(json); break; case 'Double': result = parseFloat(json); break; case 'Boolean': result = (json === true || json === 'true'); break; case 'String': result = json.toString(); break; default: // everything else should be an enumerated value... result = json; } return result; } /** * Visitor design pattern * @param {RelationshipDeclaration} relationshipDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitRelationshipDeclaration(relationshipDeclaration, parameters) { const jsonObj = parameters.jsonStack.pop(); let result = null; let typeFQN = relationshipDeclaration.getFullyQualifiedTypeName(); let defaultNamespace = ModelUtil.getNamespace(typeFQN); if(!defaultNamespace) { defaultNamespace = relationshipDeclaration.getNamespace(); } let defaultType = ModelUtil.getShortName(typeFQN); if(relationshipDeclaration.isArray()) { result = []; for(let n=0; n &lt; jsonObj.length; n++) { let jsonItem = jsonObj[n]; if (typeof jsonItem === 'string') { result.push(Relationship.fromURI(parameters.modelManager, jsonItem, defaultNamespace, defaultType )); } else { if (!this.acceptResourcesForRelationships) { throw new Error('Invalid JSON data. Found a value that is not a string: ' + jsonObj + ' for relationship ' + relationshipDeclaration); } // this isn't a relationship, but it might be an object! if(!jsonItem.$class) { throw new Error('Invalid JSON data. Does not contain a $class type identifier: ' + jsonItem + ' for relationship ' + relationshipDeclaration ); } const classDeclaration = parameters.modelManager.getType(jsonItem.$class); // create a new instance, using the identifier field name as the ID. let subResource = parameters.factory.newResource(classDeclaration.getNamespace(), classDeclaration.getName(), jsonItem[classDeclaration.getIdentifierFieldName()] ); parameters.jsonStack.push(jsonItem); parameters.resourceStack.push(subResource); classDeclaration.accept(this, parameters); result.push(subResource); } } } else { if (typeof jsonObj === 'string') { result = Relationship.fromURI(parameters.modelManager, jsonObj, defaultNamespace, defaultType ); } else { if (!this.acceptResourcesForRelationships) { throw new Error('Invalid JSON data. Found a value that is not a string: ' + jsonObj + ' for relationship ' + relationshipDeclaration); } // this isn't a relationship, but it might be an object! if(!jsonObj.$class) { throw new Error('Invalid JSON data. Does not contain a $class type identifier: ' + jsonObj + ' for relationship ' + relationshipDeclaration ); } const classDeclaration = parameters.modelManager.getType(jsonObj.$class); // create a new instance, using the identifier field name as the ID. let subResource = parameters.factory.newResource(classDeclaration.getNamespace(), classDeclaration.getName(), jsonObj[classDeclaration.getIdentifierFieldName()] ); parameters.jsonStack.push(jsonObj); parameters.resourceStack.push(subResource); classDeclaration.accept(this, parameters); result = subResource; } } return result; } } module.exports = JSONPopulator; × Search results Close "},"composer-common_lib_codegen_jsonwriter.js.html":{"id":"composer-common_lib_codegen_jsonwriter.js.html","title":"Source: composer-common/lib/codegen/jsonwriter.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/codegen/jsonwriter.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Writer = require('./writer'); /** * JSONWriter manages a text buffer for writing JSON data structures. * It tracks when a comma is needed to separate items. Commas are inserted * automatically based on context. * @private * @extends Writer * @see See [Writer]{@link module:composer-common.Writer} * @class * @memberof module:composer-common */ class JSONWriter extends Writer { /** * Create a JSONWriter. * */ constructor() { super(); this.indent = 0; this.firstItem = true; } /** * Opens an object declaration * @param {string} key - the key */ openObject() { this.write('{'); this.indent++; this.firstItem = true; } /** * Close the current object declaration. */ closeObject() { this.write('}'); this.indent--; this.firstItem = false; } /** * Writes a key, in the format * '&quot;key&quot; : ' * @param {string} key - the key */ writeKey(key) { this.writeComma(); this.write(JSON.stringify(key) + ':'); } /** * Writes a comma when this.firstItem === false */ writeComma() { if(this.firstItem === false) { this.write(','); } } /** * Writes a value, in the format: * '&quot;value&quot;' * @param {string} value - the value */ writeStringValue(value) { this.write(JSON.stringify(value)); this.firstItem = false; } /** * Writes a value, in the format: * 'value' * @param {string} value - the value */ writeValue(value) { this.write(`${value}`); this.firstItem = false; } /** * Writes a key/value, in the format: * '&quot;key&quot; : &quot;value&quot;' * @param {string} key - the key * @param {string} value - the value */ writeKeyStringValue(key,value) { this.writeKey(key); this.writeStringValue(value); this.firstItem = false; } /** * Writes a key/value, in the format: * '&quot;key&quot; : value' * @param {string} key - the key * @param {string} value - the value */ writeKeyValue(key,value) { this.writeComma(); this.writeKey(key); this.writeValue(value); this.firstItem = false; } /** * Writes an array value, in the format * '&quot;value&quot;' * @param {string} value - the value */ writeArrayStringValue(value) { this.writeComma(); this.writeStringValue(value); this.firstItem = false; } /** * Writes an array value, in the format * 'value' * @param {string} value - the value */ writeArrayValue(value) { this.writeComma(); this.write(`${value}`); this.firstItem = false; } /** * Opens a new array */ openArray() { this.write('['); this.indent++; this.firstItem = true; } /** * Closes the current array */ closeArray() { this.write(']'); this.indent--; this.firstItem = false; } /** * @return {String} a string represention of this class */ toString() { return 'indent ' + this.indent + ' firstItem ' + this.firstItem; } /** * Empties the underyling buffer and resets the line count. */ clearBuffer() { super.clearBuffer(); this.indent = 0; this.firstItem = true; } } module.exports = JSONWriter; × Search results Close "},"composer-common_lib_query_limit.js.html":{"id":"composer-common_lib_query_limit.js.html","title":"Source: composer-common/lib/query/limit.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/query/limit.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const IllegalModelException = require('../introspect/illegalmodelexception'); /** * Limit defines the LIMIT portion of a SELECT statement * * @private * @class * @memberof module:composer-common */ class Limit { /** * Create a Limit from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {Select} select - the Select for this Limit * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(select, ast) { if(!select || !ast) { throw new IllegalModelException('Invalid Select or AST'); } this.ast = ast; this.select = select; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the Select that owns this Limit. * * @return {Select} the owning Select */ getSelect() { return this.select; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { } /** * Semantic validation of the structure of this limit. * * @throws {IllegalModelException} * @private */ validate() { } /** * Return the AST for this limit statement. * @return {Object} The AST for this limit statement. */ getAST() { return this.ast; } } module.exports = Limit; × Search results Close "},"composer-common_lib_log_logger.js.html":{"id":"composer-common_lib_log_logger.js.html","title":"Source: composer-common/lib/log/logger.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/log/logger.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Tree = require('./tree.js'); // Root node of the selection tree let _tree = null; // Core logger that is in use (user configurable) let _logger = null; // Set of instances of this logger class that acts as a proxy to the core logger let _clInstances = {}; /** * @description Class that provides the API to enable parts of the *Composer* * library to diagnostic messages. * * The aim is to provide a system whereby * - The *Composer* library has a common API to call and formats the essential data * its way * - It's own control of what level of data points are currently being collected * and for what module/class level * - Provide a default console and/or file basic log if user's application doesn't have * any preference * - Provide hook in which application can provide an injected dependency to route * tracing to its own Logger * * # Log Levels * Standard log levels are in use. In order these are * - silly, debug, verbose, info, warn, error * In addition, there are functions that record method entry and method exit. these * map down to the debug level. [Silly level isn't being used] * * Examples of using each function are included for each API below. * * At the top of the class (or file if not object style) issue. * * ``` * const log = require('./log/logger.js').getLog(&lt;CLASSNAME&gt;); * log.info(.....) * ``` * The classname is in a fully qualified format eg common/BusinessNetworkDefinition or * cli/archiveCreate. * * @private * @class * @memberof module:composer-common */ class Logger { /** * Constructor *THIS SHOULD ONLY BE CALLED INTERNALLY* * @param {String} name Classname or other filename for this logger * @private * */ constructor(name) { this.className = name; this.str25 = Array(25).join(' '); } /** * Pad a string * @param {String} pad padding * @param {String} str string * @return {String} padded string */ padRight(pad, str) { return (str + pad).slice(0, pad.length); } /** * * @description Do the formatting of the data that *Composer* wishes to have for all * logging systems. This method does basic formatting before passing to the * log method of the selected logger implementation. * * Internal method * * @private * @param {String} logLevel log loglevel * @param {String} method method name * @param {String} msg to log * @param {others} arguments parameters are treated as data points to be logged */ intlog(logLevel,method,msg){ // first we need to make sure that we have logger setup this._intLogFirst.apply(this,arguments); } /** * @description Main internal logging method * Required fn here is to form up the arguments into a suitable string, and * process any errors to capture the stack trace. The core logger is then CALLED * * The assumption is that this logger has a method called `log`. with this prototype * `log(String loglevel, String codeunit, String message, Array[optional] data)` * * @param {String} loglevel log loglevel * @param {String} method method name * @param {String} msg to log */ _intLogMain(loglevel,method,msg){ if (typeof arguments[3] ==='undefined'){ // this is the case where there are no additional arguments; data for example _logger.log(loglevel,this.padRight(this.str25,this.className)+':'+this.padRight(this.str25,method+'()'),msg); } else { // loop over the arguments - if any are Errors make sure that the stack trace is captured let args = []; for(let i = 3; i &lt; arguments.length; i++) { if (arguments[i] instanceof Error){ let str = '{'+arguments[i].name + '}'+ arguments[i].message+' '+ arguments[i].stack; args.push( {'stack' : str.match(/[^\\r\\n]+/g)}); }else { args.push(arguments[i]); } } _logger.log(loglevel,this.padRight(this.str25,this.className)+':'+this.padRight(this.str25,method+'()'),msg, args); } } /** * @description initial internal log function that sets up the logger to use. * Then it calls the normal internal log method (and modifies the original * function definition) * * @param {String} logLevel log loglevel * @param {String} method method name * @param {String} msg to log */ _intLogFirst(logLevel,method,msg){ // call the setup logger to make sure that things are setup // this is done now to be as late as possible Logger._setupLog(this); //reroute the ingLog method to the main implementation // and call this.intLog = this._intLogMain; // this._intLogMain.apply(this,arguments); this._intLogMain.apply(this,arguments); } /** * @description Log a message at the _debug_level * * @param {String} method calling method * @param {String} msg Text Message * @param {stuff} data Data to log * * @private */ debug(method, msg, data) { const args = Array.prototype.slice.call(arguments); args.unshift('debug'); this.intlog.apply(this, args); } /** * @description Log a message at the _warn_ level * * @param {String} method calling method * @param {String} msg Text Message * @param {stuff} data Data to log at warn level * * @private */ warn(method, msg, data) { const args = Array.prototype.slice.call(arguments); args.unshift('warn'); this.intlog.apply(this, args); } /** * @description Log a message at the _info_ level * * @param {String} method calling method * @param {String} msg Text Message * @param {stuff} data Data to log at an info level * * @private */ info(method, msg, data) { const args = Array.prototype.slice.call(arguments); args.unshift('info'); this.intlog.apply(this, args); } /** * @description Log a message at the _verbose_ level * * @param {String} method calling method * @param {String} msg Text Message * @param {stuff} data Data to log at a verbose level * * @private */ verbose(method,msg, data) { const args = Array.prototype.slice.call(arguments); args.unshift('verbose'); this.intlog.apply(this, args); } /** * @description Log a message at the _error_ level * * @param {String} method calling method * @param {String} msg Text Message * @param {stuff} data Data to log at an error level * * @private */ error(method, msg,data) { const args = Array.prototype.slice.call(arguments); args.unshift('error'); this.intlog.apply(this, args); } /** * @description Logs the entry to a method at the _debug_ level * * @param {String} method Text Message. * @param {stuff} data Data to log at an info level * * @private */ entry(method, data) { const args = Array.prototype.slice.call(arguments); args.shift(); args.unshift('debug', method, '&gt;'); this.intlog.apply(this, args); } /** * @description Logs the entry to a method at the _debug_ level * @param {String} method Method name * @param {objects} data Data to log * * @private */ exit(method, data) { const args = Array.prototype.slice.call(arguments); args.shift(); args.unshift('debug', method, '&lt;'); this.intlog.apply(this, args); } /** * Get the selection tree. * @return {Tree} The selection tree. */ static getSelectionTree() { return _tree; } /** * Set the selection tree. * @param {Tree} tree The selection tree. */ static setSelectionTree(tree) { _tree = tree; } /** * Get the functional logger. * @return {Object} The functional logger. */ static getFunctionalLogger() { return _logger; } /** * @description Method to call passing an instance of an object that has the * method definition * * log(level,msg,data...) * * @param {Object} newlogger sets a new log processor to the one of your choice * * @private */ static setFunctionalLogger(newlogger){ _logger = newlogger; } /** * @description what is the debug environment variable set to * Note that the _envDebug property of this object is for debugging the debugging log * and emergency use ONLY * * @return {String} String of the DEBUG env variable * */ static getDebugEnv(){ return process.env.DEBUG || Logger._envDebug || ''; } /** * @description Get the configuration for the logging. * This uses the config module to look for a configuration block under the * composer.debug property. * * The 'logger' property is required to specify the core logger to use. By * default this is the 'winstonInjector' that creates and returns a Winston backed * console and file logger. * * The 'config' property is required - but the contents of this property are passed * as is to the class defined in the logger property. * * @return {Object} with the config information * */ static getLoggerConfig(){ try { // This weird code is needed to trick browserify. process.env.SUPPRESS_NO_CONFIG_WARNING = 'y'; const mod = 'config'; const req = require; const config = req(mod); if (config.has('composer.debug')){ return config.get('composer.debug'); } } catch (e) { // We don't care if we can't find the config module, it won't be // there when the code is running inside a browser/chaincode. } return { 'logger': './winstonInjector.js', 'config': { 'console': { 'enabledLevel': 'info', 'alwaysLevel': 'none' }, 'file': { 'filename': 'trace_TIMESTAMP.log', 'enabledLevel': 'debug', 'alwaysLevel': 'error' } }}; } /** * @description Get the logger instance to be used for this class or file. * * @param {String} classname The classname (or filename if not a class) to get the logger for * @return {ComposerLog} instance of a composerLog to use * * @private */ static getLog(classname) { if(typeof _clInstances[classname] === 'undefined') { _clInstances[classname] = new Logger(classname); _clInstances[classname].log = Logger._intLogFirst; } return _clInstances[classname]; } /** * @description gets the configuration that has been passed in to this node.js runtime * to control the tracing. This will update the composerLogger instance that * is passed in to match the settings * * @param {Logger} composerLogger the instance of the Logger class to update * @private */ static _setupLog(composerLogger){ let configElements = []; // Parse the logger configuration if it hasn't been done already. if (_tree === null){ _tree = Logger._parseLoggerConfig(configElements); } // Load the logger if it hasn't been done already. if(_logger === null) { _logger = Logger._loadLogger(configElements); } // now we need to check if the name that has come in and should be traced composerLogger.include = _tree.getInclusion(composerLogger.className); return ; } /** * Parse the logger configuration. * @param {string[]} configElements The configuration elements for the logger. * @return {Tree} The configuration tree. * @private */ static _parseLoggerConfig(configElements) { // need to do the filtering to see if this should be enabled or not let string = Logger.getDebugEnv(); let details = string.split(/[\\s,]+/); let tree = new Tree(); const regex = /(-?)composer:(.*)?/; // now we have an array of the elements that we might need to be enabled // for (let i=0; i&lt; details.length;i++){ let e = details[i]; if (e === '*' || e ==='composer:*'){ tree.setRootInclusion(); } // determine if the element is for composer or not let machResult = e.match(regex); if (machResult!==null){ // got a result that we need to trace therefore setup the child node correctly tree.addNode(machResult[2] ,(machResult[1]==='') ); // make a note of the debug settings that permit the config elements configElements.push(machResult[2]); } } return tree; } /** * Load the logger module specified in the logger configuration, and get a logger. * @param {string[]} configElements The configuration elements for the logger. * @return {Logger} The logger. * @private */ static _loadLogger(configElements) { let localConfig = Logger.getLoggerConfig(); // use the config package to get configuration to see what we should be doing. // and pass the rest of the data to the logger indicated along with the // array of the data that might have been passed on the DEBUG variable. let loggerToUse = localConfig.logger; let myLogger; try { myLogger = require(loggerToUse); } catch (e) { // Print the error to the console and just use the null logger instead. console.error(`Failed to load logger module ${loggerToUse}: ${e.message}`); myLogger = { getLogger: () =&gt; { return { log: () =&gt; { } }; } }; } // primary used to determine what has been enabled to allow the logger to // go into a default mode.. NOT MEANT TO BE USED FOR FILTERING. return myLogger.getLogger(localConfig.config,{ 'debug' : configElements } ); } /** * @description clean up the logger; required if anything is dynamically changed */ static reset(){ _tree=null; _logger=null; _clInstances={}; } } module.exports = Logger; × Search results Close "},"composer-common_lib_acl_modelbinding.js.html":{"id":"composer-common_lib_acl_modelbinding.js.html","title":"Source: composer-common/lib/acl/modelbinding.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/acl/modelbinding.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const IllegalModelException = require('../introspect/illegalmodelexception'); const ModelUtil = require('../modelutil'); /** * ModelBinding captures a binding to a model element. A ModelBinding can * be to a namespace, a class, or an instance of a class, and may optionally * be bound to a named variable. * * @private * @class * @memberof module:composer-common */ class ModelBinding { /** * Create an ModelBinding from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {AclRule} aclRule - the AclRule for this ModelBinding * @param {Object} ast - the AST created by the parser * @param {Object} variableAst - the variable binding AST created by the parser * @throws {IllegalModelException} */ constructor(aclRule, ast, variableAst) { if(!aclRule || !ast) { throw new IllegalModelException('Invalid AclRule or AST'); } this.ast = ast; this.aclRule = aclRule; if(variableAst) { this.variableAst = variableAst; } else { this.variableAst = null; } this.classDeclaration = null; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the AclRule that owns this ModelBinding. * * @return {AclRule} the owning AclRule */ getAclRule() { return this.aclRule; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { this.qualifiedName = this.ast.qualifiedName; this.instanceId = null; if(this.ast.instanceId) { this.instanceId = this.ast.instanceId; } this.variableName = null; if(this.variableAst) { this.variableName = this.variableAst.name; } } /** * Returns strind representation of this object * * @return {string} the string version of the object */ toString() { let result = 'ModelBinding ' + this.qualifiedName; if(this.instanceId) { result += '#' + this.instanceId; } if(this.variableName) { result += ':' + this.variableName; } return result; } /** * Returns the fully qualified name of the model element for this ModelBinding. * * @return {string} the fully qualified model name */ getFullyQualifiedName() { return this.qualifiedName; } /** * Returns the identifier of the instance of the model element for this ModelBinding. * * @return {string} the identifier of the instance, or null */ getInstanceIdentifier() { return this.instanceId; } /** * Returns the name of the variable of the model element for this ModelBinding. * * @return {string} the name of the variable, or null */ getVariableName() { return this.variableName; } /** * Semantic validation of the structure of this ModelBinding. * * @throws {IllegalModelException} * @private */ validate() { const mm = this.getAclRule().getAclFile().getModelManager(); const ns = ModelUtil.getNamespace(this.qualifiedName); if (ModelUtil.isRecursiveWildcardName(this.qualifiedName)) { const namespaces = mm.getNamespaces(); // Check for recursive glob only if (!ns) { return; } if (namespaces.findIndex(function (element, index, array) { return (ns === element || element.startsWith(ns + '.')); })=== -1) { throw new IllegalModelException('Failed to find namespace ' + this.qualifiedName); } } else if (ModelUtil.isWildcardName(this.qualifiedName)) { const modelFile = mm.getModelFile(ns); if(!modelFile) { throw new IllegalModelException('Failed to find namespace ' + this.qualifiedName); } } else { const modelFile = mm.getModelFile(ns); if(!modelFile) { throw new IllegalModelException('Failed to find namespace ' + ns); } const className = ModelUtil.getShortName(this.qualifiedName); const classDeclaration = modelFile.getLocalType(className); if(!classDeclaration) { throw new IllegalModelException('Failed to find class ' + this.qualifiedName); } this.classDeclaration = classDeclaration; } } /** * Get the class declaration for the class that this instance is bound to. * @return {ClassDeclaration} The class declaration for the class that * this instance is bound to, or null if this instance is bound to a namespace. */ getClassDeclaration() { return this.classDeclaration; } } module.exports = ModelBinding; × Search results Close "},"composer-common_lib_introspect_modelfile.js.html":{"id":"composer-common_lib_introspect_modelfile.js.html","title":"Source: composer-common/lib/introspect/modelfile.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/modelfile.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const parser = require('./parser'); const AssetDeclaration = require('./assetdeclaration'); const EnumDeclaration = require('./enumdeclaration'); const ConceptDeclaration = require('./conceptdeclaration'); const ParticipantDeclaration = require('./participantdeclaration'); const TransactionDeclaration = require('./transactiondeclaration'); const EventDeclaration = require('./eventdeclaration'); const IllegalModelException = require('./illegalmodelexception'); const ParseException = require('./parseexception'); const ModelUtil = require('../modelutil'); const Globalize = require('../globalize'); /** * Class representing a Model File. A Model File contains a single namespace * and a set of model elements: assets, transactions etc. * @private * @class * @memberof module:composer-common */ class ModelFile { /** * Create a ModelFile. This should only be called by framework code. * Use the ModelManager to manage ModelFiles. * * @param {ModelManager} modelManager - the ModelManager that manages this * ModelFile * @param {string} definitions - The DSL model as a string. * @param {string} [fileName] - The optional filename for this modelfile * @throws {IllegalModelException} */ constructor(modelManager, definitions, fileName) { this.modelManager = modelManager; this.declarations = []; this.imports = []; this.fileName = 'UNKNOWN'; if(!definitions || typeof definitions !== 'string') { throw new Error('ModelFile expects a Composer model as a string as input.'); } this.definitions = definitions; if(fileName &amp;&amp; typeof fileName !== 'string') { throw new Error('ModelFile expects an (optional) filename as a string.'); } this.fileName = fileName; try { this.ast = parser.parse(definitions); } catch(err) { if(err.location &amp;&amp; err.location.start) { throw new ParseException(err.message, err.location); } else { throw err; } } this.namespace = this.ast.namespace; this.systemModelFile = (this.namespace === ModelUtil.getSystemNamespace()); if(this.ast.imports) { this.imports = this.ast.imports; } // if we are not in the system namespace we add imports to all the system types if(!this.isSystemModelFile()) { const systemTypes = this.modelManager.getSystemTypes(); for(let n=0; n &lt; systemTypes.length; n++) { this.imports.unshift(systemTypes[n].getFullyQualifiedName()); } } for(let n=0; n &lt; this.ast.body.length; n++ ) { let thing = this.ast.body[n]; if(thing.type === 'AssetDeclaration') { this.declarations.push( new AssetDeclaration(this, thing) ); } else if(thing.type === 'TransactionDeclaration') { this.declarations.push( new TransactionDeclaration(this, thing) ); } else if(thing.type === 'EventDeclaration') { this.declarations.push( new EventDeclaration(this, thing) ); } else if(thing.type === 'ParticipantDeclaration') { this.declarations.push( new ParticipantDeclaration(this, thing) ); } else if(thing.type === 'EnumDeclaration') { this.declarations.push( new EnumDeclaration(this, thing) ); } else if(thing.type === 'ConceptDeclaration') { this.declarations.push( new ConceptDeclaration(this, thing) ); } else { let formatter = Globalize('en').messageFormatter('modelfile-constructor-unrecmodelelem'); throw new IllegalModelException(formatter({ 'type': thing.type, }),this.modelFile); } } } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the ModelManager associated with this ModelFile * * @return {ModelManager} The ModelManager for this ModelFile */ getModelManager() { return this.modelManager; } /** * Returns the types that have been imported into this ModelFile. * * @return {string[]} The array of imports for this ModelFile */ getImports() { return this.imports; } /** * Validates the ModelFile. * * @throws {IllegalModelException} if the model is invalid * @private */ validate() { // Validate all of the imports to check that they reference // namespaces or types that actually exist. this.imports.forEach((importName) =&gt; { const importNamespace = ModelUtil.getNamespace(importName); const modelFile = this.getModelManager().getModelFile(importNamespace); if (!modelFile) { let formatter = Globalize.messageFormatter('modelmanager-gettype-noregisteredns'); throw new IllegalModelException(formatter({ type: importName }), this); } if (ModelUtil.isWildcardName(importName)) { // This is a wildcard import, org.acme.* // Doesn't matter if 0 or 100 types in the namespace. return; } const importShortName = ModelUtil.getShortName(importName); if (!modelFile.isLocalType(importShortName)) { let formatter = Globalize.messageFormatter('modelmanager-gettype-notypeinns'); throw new IllegalModelException(formatter({ type: importShortName, namespace: importNamespace }), this); } }); // Validate all of the types in this model file. for(let n=0; n &lt; this.declarations.length; n++) { let classDeclaration = this.declarations[n]; classDeclaration.validate(); } } /** * Check that the type is valid. * @param {string} context - error reporting context * @param {string} type - a short type name * @throws {IllegalModelException} - if the type is not defined * @private */ resolveType(context,type) { // is the type a primitive? if(!ModelUtil.isPrimitiveType(type)) { // is it an imported type? if(!this.isImportedType(type)) { // is the type declared locally? if(!this.isLocalType(type)) { let formatter = Globalize('en').messageFormatter('modelfile-resolvetype-undecltype'); throw new IllegalModelException(formatter({ 'type': type, 'context': context }),this.modelFile); } } else { // check whether type is defined in another file this.getModelManager().resolveType(context,this.resolveImport(type)); } } } /** * Returns true if the type is defined in this namespace. * @param {string} type - the short name of the type * @return {boolean} - true if the type is defined in this ModelFile * @private */ isLocalType(type) { let result = (type !== null &amp;&amp; this.getLocalType(type) !== null); //console.log('isLocalType ' + this.getNamespace() + ' ' + type + '=' + result ); return result; } /** * Returns true if the type is imported from another namespace * @param {string} type - the short name of the type * @return {boolean} - true if the type is imported from another namespace * @private */ isImportedType(type) { //console.log('isImportedType ' + this.getNamespace() + ' ' + type ); for(let n=0; n &lt; this.imports.length; n++) { let importName = this.imports[n]; if( ModelUtil.getShortName(importName) === type ) { return true; } else if (ModelUtil.isWildcardName(importName)) { const wildcardNamespace = ModelUtil.getNamespace(importName); const modelFile = this.getModelManager().getModelFile(wildcardNamespace); if (modelFile &amp;&amp; modelFile.isLocalType(type)) { return true; } } } return false; } /** * Returns the FQN for a type that is imported from another namespace * @param {string} type - the short name of the type * @return {string} - the FQN of the resolved import * @throws {Error} - if the type is not imported * @private */ resolveImport(type) { for(let n=0; n &lt; this.imports.length; n++) { let importName = this.imports[n]; if( ModelUtil.getShortName(importName) === type ) { return importName; } else if (ModelUtil.isWildcardName(importName)) { const wildcardNamespace = ModelUtil.getNamespace(importName); const modelFile = this.getModelManager().getModelFile(wildcardNamespace); if (modelFile &amp;&amp; modelFile.isLocalType(type)) { return wildcardNamespace + '.' + type; } } } let formatter = Globalize('en').messageFormatter('modelfile-resolveimport-failfindimp'); throw new IllegalModelException(formatter({ 'type': type, 'imports': this.imports, 'namespace': this.getNamespace() }),this.modelFile); } /** * Returns true if the type is defined in the model file * @param {string} type the name of the type * @return {boolean} true if the type (asset or transaction) is defined */ isDefined(type) { return ModelUtil.isPrimitiveType(type) || this.getLocalType(type) !== null; } /** * Returns the FQN of the type or null if the type could not be resolved. * For primitive types the type name is returned. * @param {string} type - a FQN or short type name * @return {string | ClassDeclaration} the class declaration for the type or null. * @private */ getType(type) { // is the type a primitive? if(!ModelUtil.isPrimitiveType(type)) { // is it an imported type? if(!this.isImportedType(type)) { // is the type declared locally? if(!this.isLocalType(type)) { return null; } else { return this.getLocalType(type); } } else { // check whether type is defined in another file const fqn = this.resolveImport(type); const modelFile = this.getModelManager().getModelFile(ModelUtil.getNamespace(fqn)); if (!modelFile) { return null; } else { return modelFile.getLocalType(fqn); } } } else { // for primitive types we just return the name return type; } } /** * Returns the FQN of the type or null if the type could not be resolved. * For primitive types the short type name is returned. * @param {string} type - a FQN or short type name * @return {string} the FQN type name or null * @private */ getFullyQualifiedTypeName(type) { // is the type a primitive? if(!ModelUtil.isPrimitiveType(type)) { // is it an imported type? if(!this.isImportedType(type)) { // is the type declared locally? if(!this.isLocalType(type)) { return null; } else { return this.getLocalType(type).getFullyQualifiedName(); } } else { // check whether type is defined in another file const fqn = this.resolveImport(type); const modelFile = this.getModelManager().getModelFile(ModelUtil.getNamespace(fqn)); return modelFile.getLocalType(fqn).getFullyQualifiedName(); } } else { // for primitive types we just return the name return type; } } /** * Returns the type with the specified name or null * @param {string} type the short OR FQN name of the type * @return {ClassDeclaration} the ClassDeclaration, or null if the type does not exist */ getLocalType(type) { if(!type.startsWith(this.getNamespace())) { type = this.getNamespace() + '.' + type; } for(let n=0; n &lt; this.declarations.length; n++) { let classDeclaration = this.declarations[n]; if(type === this.getNamespace() + '.' + classDeclaration.getName() ) { return classDeclaration; } } return null; } /** * Get the AssetDeclarations defined in this ModelFile or null * @param {string} name the name of the type * @return {AssetDeclaration} the AssetDeclaration with the given short name */ getAssetDeclaration(name) { let classDeclaration = this.getLocalType(name); if(classDeclaration instanceof AssetDeclaration) { return classDeclaration; } return null; } /** * Get the TransactionDeclaration defined in this ModelFile or null * @param {string} name the name of the type * @return {TransactionDeclaration} the TransactionDeclaration with the given short name */ getTransactionDeclaration(name) { let classDeclaration = this.getLocalType(name); if(classDeclaration instanceof TransactionDeclaration) { return classDeclaration; } return null; } /** * Get the EventDeclaration defined in this ModelFile or null * @param {string} name the name of the type * @return {EventDeclaration} the EventDeclaration with the given short name */ getEventDeclaration(name) { let classDeclaration = this.getLocalType(name); if(classDeclaration instanceof EventDeclaration) { return classDeclaration; } return null; } /** * Get the ParticipantDeclaration defined in this ModelFile or null * @param {string} name the name of the type * @return {ParticipantDeclaration} the ParticipantDeclaration with the given short name */ getParticipantDeclaration(name) { let classDeclaration = this.getLocalType(name); if(classDeclaration instanceof ParticipantDeclaration) { return classDeclaration; } return null; } /** * Get the Namespace for this model file. * @return {string} The Namespace for this model file */ getNamespace() { return this.namespace; } /** * Get the filename for this model file. Note that this may be null. * @return {string} The filename for this model file */ getName() { return this.fileName; } /** * Get the AssetDeclarations defined in this ModelFile * @param {Boolean} includeSystemType - Include the decalarations of system type in returned data * @return {AssetDeclaration[]} the AssetDeclarations defined in the model file */ getAssetDeclarations(includeSystemType = true) { return this.getDeclarations(AssetDeclaration, includeSystemType); } /** * Get the TransactionDeclarations defined in this ModelFile * @param {Boolean} includeSystemType - Include the decalarations of system type in returned data * @return {TransactionDeclaration[]} the TransactionDeclarations defined in the model file */ getTransactionDeclarations(includeSystemType = true) { return this.getDeclarations(TransactionDeclaration, includeSystemType); } /** * Get the EventDeclarations defined in this ModelFile * @param {Boolean} includeSystemType - Include the decalarations of system type in returned data * @return {EventDeclaration[]} the EventDeclarations defined in the model file */ getEventDeclarations(includeSystemType = true) { return this.getDeclarations(EventDeclaration, includeSystemType); } /** * Get the ParticipantDeclarations defined in this ModelFile * @param {Boolean} includeSystemType - Include the decalarations of system type in returned data * @return {ParticipantDeclaration[]} the ParticipantDeclaration defined in the model file */ getParticipantDeclarations(includeSystemType = true) { return this.getDeclarations(ParticipantDeclaration, includeSystemType); } /** * Get the ConceptDeclarations defined in this ModelFile * @param {Boolean} includeSystemType - Include the decalarations of system type in returned data * @return {ConceptDeclaration[]} the ParticipantDeclaration defined in the model file */ getConceptDeclarations(includeSystemType = true) { return this.getDeclarations(ConceptDeclaration, includeSystemType); } /** * Get the EnumDeclarations defined in this ModelFile * @param {Boolean} includeSystemType - Include the decalarations of system type in returned data * @return {EnumDeclaration[]} the EnumDeclaration defined in the model file */ getEnumDeclarations(includeSystemType = true) { return this.getDeclarations(EnumDeclaration, includeSystemType); } /** * Get the instances of a given type in this ModelFile * @param {Function} type - the type of the declaration * @param {Boolean} includeSystemType - Include the decalarations of system type in returned data * @return {ClassDeclaration[]} the ClassDeclaration defined in the model file */ getDeclarations(type, includeSystemType = true) { let result = []; for(let n=0; n &lt; this.declarations.length; n++) { let classDeclaration = this.declarations[n]; if(classDeclaration instanceof type &amp;&amp; (includeSystemType || !classDeclaration.isSystemType())) { result.push(classDeclaration); } } return result; } /** * Get all declarations in this ModelFile * @return {ClassDeclaration[]} the ClassDeclarations defined in the model file */ getAllDeclarations() { return this.declarations; } /** * Get the definitions for this model. * @return {string} The definitions for this model. */ getDefinitions() { return this.definitions; } /** * Returns true if this ModelFile is a system model * @return {boolean} true of this ModelFile is a system model */ isSystemModelFile() { return this.systemModelFile; } } module.exports = ModelFile; × Search results Close "},"composer-common_lib_modelmanager.js.html":{"id":"composer-common_lib_modelmanager.js.html","title":"Source: composer-common/lib/modelmanager.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/modelmanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Globalize = require('./globalize'); const IllegalModelException = require('./introspect/illegalmodelexception'); const ModelUtil = require('./modelutil'); const ModelFile = require('./introspect/modelfile'); const TypeNotFoundException = require('./typenotfoundexception'); const LOG = require('./log/logger').getLog('ModelManager'); const SYSTEM_MODELS = require('./systemmodel'); /** * &lt;p&gt; * The structure of {@link Resource}s (Assets, Transactions, Participants) is modelled * in a set of Composer files. The contents of these files are managed * by the {@link ModelManager}. Each Composer file has a single namespace and contains * a set of asset, transaction and participant type definitions. * &lt;/p&gt; * &lt;p&gt; * Composer applications load their Composer files and then call the {@link ModelManager#addModelFile addModelFile} * method to register the Composer file(s) with the ModelManager. The ModelManager * parses the text of the Composer file and will make all defined types available * to other Composer services, such as the {@link Serializer} (to convert instances to/from JSON) * and {@link Factory} (to create instances). * &lt;/p&gt; * &lt;p&gt;&lt;a href=&quot;./diagrams-private/modelmanager.svg&quot;&gt;&lt;img src=&quot;./diagrams-private/modelmanager.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @private * @class * @memberof module:composer-common */ class ModelManager { /** * Create the ModelManager. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Composer}&lt;/strong&gt; * &lt;/p&gt; */ constructor() { LOG.entry('constructor'); this.modelFiles = {}; this.addSystemModels(); LOG.exit('constructor'); } /** * Add the system models to the model manager * @private */ addSystemModels() { const method = 'addSystemModels'; LOG.entry(method); // add the system model SYSTEM_MODELS.forEach((SYSTEM_MODEL) =&gt; { LOG.info(method, SYSTEM_MODEL); let m = new ModelFile(this, SYSTEM_MODEL.contents, SYSTEM_MODEL.fileName); this.modelFiles[m.getNamespace()] = m; }); // now validate all the models Object.keys(this.modelFiles).forEach((ns) =&gt; { this.modelFiles[ns].validate(); }); LOG.exit(method); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor, parameters) { return visitor.visit(this, parameters); } /** * Validates a Composer file (as a string) to the ModelManager. * Composer files have a single namespace. * * Note that if there are dependencies between multiple files the files * must be added in dependency order, or the addModelFiles method can be * used to add a set of files irrespective of dependencies. * @param {string} modelFile - The Composer file as a string * @param {string} fileName - an optional file name to associate with the model file * @throws {IllegalModelException} */ validateModelFile(modelFile, fileName) { if (typeof modelFile === 'string') { let m = new ModelFile(this, modelFile, fileName); m.validate(); } else { modelFile.validate(); } } /** * Adds a Composer file (as a string) to the ModelManager. * Composer files have a single namespace. If a Composer file with the * same namespace has already been added to the ModelManager then it * will be replaced. * Note that if there are dependencies between multiple files the files * must be added in dependency order, or the addModelFiles method can be * used to add a set of files irrespective of dependencies. * @param {string} modelFile - The Composer file as a string * @param {string} fileName - an optional file name to associate with the model file * @throws {IllegalModelException} * @return {Object} The newly added model file (internal). */ addModelFile(modelFile, fileName) { const NAME = 'addModelFile'; LOG.info(NAME, 'addModelFile', modelFile, fileName); let m = null; if (typeof modelFile === 'string') { m = new ModelFile(this, modelFile, fileName); } else { m = modelFile; } if (m.isSystemModelFile()) { throw new Error('Cannot add a model file with the reserved system namespace: ' + m.getNamespace()); } if (!this.modelFiles[m.getNamespace()]) { m.validate(); this.modelFiles[m.getNamespace()] = m; } else { throw new Error('namespace already exists'); } return m; } /** * Updates a Composer file (as a string) on the ModelManager. * Composer files have a single namespace. If a Composer file with the * same namespace has already been added to the ModelManager then it * will be replaced. * @param {string} modelFile - The Composer file as a string * @param {string} fileName - an optional file name to associate with the model file * @throws {IllegalModelException} * @returns {Object} The newly added model file (internal). */ updateModelFile(modelFile, fileName) { const NAME = 'updateModelFile'; LOG.info(NAME, 'updateModelFile', modelFile, fileName); if (typeof modelFile === 'string') { let m = new ModelFile(this, modelFile, fileName); let existing = this.modelFiles[m.getNamespace()]; if (!existing) { throw new Error('model file does not exist'); } else if (existing.isSystemModelFile()) { throw new Error('System namespace can not be updated'); } m.validate(); this.modelFiles[m.getNamespace()] = m; return m; } else { let existing = this.modelFiles[modelFile.getNamespace()]; if (!existing) { throw new Error('model file does not exist'); } else if (existing.isSystemModelFile()) { throw new Error('System namespace can not be updated'); } modelFile.validate(); this.modelFiles[modelFile.getNamespace()] = modelFile; return modelFile; } } /** * Remove the Composer file for a given namespace * @param {string} namespace - The namespace of the model file to * delete. */ deleteModelFile(namespace) { if (!this.modelFiles[namespace]) { throw new Error('model file does not exist'); } else if (namespace === ModelUtil.getSystemNamespace()) { throw new Error('Cannot delete system namespace'); } else { delete this.modelFiles[namespace]; } } /** * Add a set of Composer files to the model manager. * @param {string[]} modelFiles - An array of Composer files as * strings. * @param {string[]} fileNames - An optional array of file names to * associate with the model files * @returns {Object[]} The newly added model files (internal). */ addModelFiles(modelFiles, fileNames) { const NAME = 'addModelFiles'; LOG.entry(NAME, 'addModelFiles', modelFiles, fileNames); const originalModelFiles = {}; Object.assign(originalModelFiles, this.modelFiles); let newModelFiles = []; try { // create the model files for (let n = 0; n &lt; modelFiles.length; n++) { const modelFile = modelFiles[n]; let fileName = null; if (fileNames) { fileName = fileNames[n]; } if (typeof modelFile === 'string') { let m = new ModelFile(this, modelFile, fileName); if (m.isSystemModelFile()) { throw new Error('System namespace can not be updated'); } if (!this.modelFiles[m.getNamespace()]) { this.modelFiles[m.getNamespace()] = m; newModelFiles.push(m); } else { throw new Error('namespace already exists'); } } else { if (modelFile.isSystemModelFile()) { throw new Error('System namespace can not be updated'); } if (!this.modelFiles[modelFile.getNamespace()]) { this.modelFiles[modelFile.getNamespace()] = modelFile; newModelFiles.push(modelFile); } else { throw new Error('namespace already exists'); } } } // re-validate all the model files for (let ns in this.modelFiles) { this.modelFiles[ns].validate(); } // return the model files. return newModelFiles; } catch (err) { this.modelFiles = {}; Object.assign(this.modelFiles, originalModelFiles); throw err; } finally { LOG.exit(NAME, newModelFiles); } } /** * Get the array of model file instances * Note - this is an internal method and therefore will return the system model * as well as any network defined models. * * It is the callers responsibility to remove this before the data leaves an external API * * @return {ModelFile[]} The ModelFiles registered * @private */ getModelFiles() { let keys = Object.keys(this.modelFiles); let result = []; for (let n = 0; n &lt; keys.length; n++) { result.push(this.modelFiles[keys[n]]); } return result; } /** * Check that the type is valid and returns the FQN of the type. * @param {string} context - error reporting context * @param {string} type - fully qualified type name * @return {string} - the resolved type name (fully qualified) * @throws {IllegalModelException} - if the type is not defined * @private */ resolveType(context, type) { // is the type a primitive? if (ModelUtil.isPrimitiveType(type)) { return type; } let ns = ModelUtil.getNamespace(type); let modelFile = this.getModelFile(ns); if (!modelFile) { let formatter = Globalize.messageFormatter('modelmanager-resolvetype-nonsfortype'); throw new IllegalModelException(formatter({ type: type, context: context })); } if (modelFile.isLocalType(type)) { return type; } let formatter = Globalize.messageFormatter('modelmanager-resolvetype-notypeinnsforcontext'); throw new IllegalModelException(formatter({ context: context, type: type, namespace: modelFile.getNamespace() })); } /** * Remove all registered Composer files */ clearModelFiles() { this.modelFiles = {}; this.addSystemModels(); } /** * Get the ModelFile associated with a namespace * Note - this is an internal method and therefore will return the system model * as well as any network defined models. * * It is the callers responsibility to remove this before the data leaves an external API * @param {string} namespace - the namespace containing the ModelFile * @return {ModelFile} registered ModelFile for the namespace or null * @private */ getModelFile(namespace) { return this.modelFiles[namespace]; } /** * Get the namespaces registered with the ModelManager. * @return {string[]} namespaces - the namespaces that have been registered. */ getNamespaces() { return Object.keys(this.modelFiles); } /** * Look up a type in all registered namespaces. * * @param {string} qualifiedName - fully qualified type name. * @return {ClassDeclaration} - the class declaration for the specified type. * @throws {TypeNotFoundException} - if the type cannot be found or is a primitive type. * @private */ getType(qualifiedName) { const namespace = ModelUtil.getNamespace(qualifiedName); const modelFile = this.getModelFile(namespace); if (!modelFile) { const formatter = Globalize.messageFormatter('modelmanager-gettype-noregisteredns'); throw new TypeNotFoundException(qualifiedName, formatter({ type: qualifiedName })); } const classDecl = modelFile.getType(qualifiedName); if (!classDecl) { const formatter = Globalize.messageFormatter('modelmanager-gettype-notypeinns'); throw new TypeNotFoundException(qualifiedName, formatter({ type: ModelUtil.getShortName(qualifiedName), namespace: namespace })); } return classDecl; } /** * Get all class declarations from system namespaces * @return {ClassDeclaration[]} the ClassDeclarations from system namespaces */ getSystemTypes() { return this.getModelFiles() .filter((modelFile) =&gt; { return modelFile.isSystemModelFile(); }) .reduce((classDeclarations, modelFile) =&gt; { return classDeclarations.concat(modelFile.getAllDeclarations()); }, []) .filter((classDeclaration) =&gt; { return classDeclaration.isSystemCoreType(); }); } /** * Get the AssetDeclarations defined in this model manager * @param {Boolean} includeSystemType - Include the decalarations of system type in returned data * @return {AssetDeclaration[]} the AssetDeclarations defined in the model manager */ getAssetDeclarations(includeSystemType = true) { return this.getModelFiles().reduce((prev, cur) =&gt; { return prev.concat(cur.getAssetDeclarations(includeSystemType)); }, []); } /** * Get the TransactionDeclarations defined in this model manager * @param {Boolean} includeSystemType - Include the decalarations of system type in returned data * @return {TransactionDeclaration[]} the TransactionDeclarations defined in the model manager */ getTransactionDeclarations(includeSystemType = true) { return this.getModelFiles().reduce((prev, cur) =&gt; { return prev.concat(cur.getTransactionDeclarations(includeSystemType)); }, []); } /** * Get the EventDeclarations defined in this model manager * @param {Boolean} includeSystemType - Include the decalarations of system type in returned data * @return {EventDeclaration[]} the EventDeclaration defined in the model manager */ getEventDeclarations(includeSystemType = true) { return this.getModelFiles().reduce((prev, cur) =&gt; { return prev.concat(cur.getEventDeclarations(includeSystemType)); }, []); } /** * Get the ParticipantDeclarations defined in this model manager * @param {Boolean} includeSystemType - Include the decalarations of system type in returned data * @return {ParticipantDeclaration[]} the ParticipantDeclaration defined in the model manager */ getParticipantDeclarations(includeSystemType = true) { return this.getModelFiles().reduce((prev, cur) =&gt; { return prev.concat(cur.getParticipantDeclarations(includeSystemType)); }, []); } /** * Get the EnumDeclarations defined in this model manager * @param {Boolean} includeSystemType - Include the decalarations of system type in returned data * @return {EnumDeclaration[]} the EnumDeclaration defined in the model manager */ getEnumDeclarations(includeSystemType = true) { return this.getModelFiles().reduce((prev, cur) =&gt; { return prev.concat(cur.getEnumDeclarations(includeSystemType)); }, []); } /** * Get the Concepts defined in this model manager * @param {Boolean} includeSystemType - Include the decalarations of system type in returned data * @return {ConceptDeclaration[]} the ConceptDeclaration defined in the model manager */ getConceptDeclarations(includeSystemType = true) { return this.getModelFiles().reduce((prev, cur) =&gt; { return prev.concat(cur.getConceptDeclarations(includeSystemType)); }, []); } } module.exports = ModelManager; × Search results Close "},"composer-common_lib_modelutil.js.html":{"id":"composer-common_lib_modelutil.js.html","title":"Source: composer-common/lib/modelutil.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/modelutil.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Globalize = require('./globalize'); const COMPOSER_SYSTEM_NAMESPACE = 'org.hyperledger.composer.system'; /** * Internal Model Utility Class * &lt;p&gt;&lt;a href=&quot;./diagrams-private/modelutil.svg&quot;&gt;&lt;img src=&quot;./diagrams-private/modelutil.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @private * @class * @memberof module:composer-common */ class ModelUtil { /** * Returns everything after the last dot, if present, of the source string * @param {string} fqn - the source string * @return {string} - the string after the last dot * @private */ static getShortName(fqn) { //console.log('toShortName ' + name ); let result = fqn; let dotIndex = fqn.lastIndexOf('.'); if (dotIndex &gt; -1) { result = fqn.substr(dotIndex + 1); } //console.log('result ' + result ); return result; } /** * Returns true if the specified name is a wildcard * @param {string} fqn - the source string * @return {boolean} true if the specified name is a wildcard * @private */ static isWildcardName(fqn) { return ModelUtil.getShortName(fqn) === '*'; } /** * Returns true if the specified name is a recusive wildcard * @param {string} fqn - the source string * @return {boolean} true if the specified name is a recusive wildcard * @private */ static isRecursiveWildcardName(fqn) { return ModelUtil.getShortName(fqn) === '**'; } /** * Returns true if a type matches the required fully qualified name. The required * name may be a wildcard or recursive wildcard * @param {Typed} type - the type to test * @param {string} fqn - required fully qualified name * @return {boolean} true if the specified type and namespace match * @private */ static isMatchingType(type, fqn) { let ns = ModelUtil.getNamespace(fqn); let typeNS = type.getNamespace(); if (type.instanceOf(fqn)) { // matching type or subtype } else if (ModelUtil.isWildcardName(fqn) &amp;&amp; typeNS === ns) { // matching namespace } else if (ModelUtil.isRecursiveWildcardName(fqn) &amp;&amp; (typeNS + '.').startsWith(ns + '.')) { // matching recursive namespace } else if (ModelUtil.isRecursiveWildcardName(fqn) &amp;&amp; !ns) { // matching root recursive namespace } else { // does not match return false; } return true; } /** * Returns the namespace for a the fully qualified name of a type * @param {string} fqn - the fully qualified identifier of a type * @return {string} - namespace of the type (everything before the last dot) * or the empty string if there is no dot * @private */ static getNamespace(fqn) { if (!fqn) { throw new Error(Globalize.formatMessage('modelutil-getnamespace-nofnq')); } let result = ''; let dotIndex = fqn.lastIndexOf('.'); if (dotIndex &gt; -1) { result = fqn.substr(0, dotIndex); } return result; } /** * Returns the system namespace * @return {string} - namespace of system types * @private */ static getSystemNamespace() { return COMPOSER_SYSTEM_NAMESPACE; } /** * Returns true if the type is a primitive type * @param {string} typeName - the name of the type * @return {boolean} - true if the type is a primitive * @private */ static isPrimitiveType(typeName) { const primitiveTypes = ['Boolean', 'String', 'DateTime', 'Double', 'Integer', 'Long']; return (primitiveTypes.indexOf(typeName) &gt;= 0); } /** * Returns true if the type is assignable to the propertyType. * * @param {ModelFile} modelFile - the ModelFile that owns the Property * @param {string} typeName - the FQN of the type we are trying to assign * @param {Property} property - the property that we'd like to store the * type in. * @return {boolean} - true if the type can be assigned to the property * @private */ static isAssignableTo(modelFile, typeName, property) { const propertyTypeName = property.getFullyQualifiedTypeName(); const isDirectMatch = (typeName === propertyTypeName); if (isDirectMatch || ModelUtil.isPrimitiveType(typeName) || ModelUtil.isPrimitiveType(propertyTypeName)) { return isDirectMatch; } const typeDeclaration = modelFile.getType(typeName); if (!typeDeclaration) { throw new Error('Cannot find type ' + typeName); } return typeDeclaration.getAllSuperTypeDeclarations(). some(type =&gt; type.getFullyQualifiedName() === propertyTypeName); } /** * Returns the passed string with the first character capitalized * @param {string} string - the string * @return {string} the string with the first letter capitalized * @private */ static capitalizeFirstLetter(string) { return string.charAt(0).toUpperCase() + string.slice(1); } /** * Returns the true if the given field is an enumerated type * @param {Field} field - the string * @return {boolean} true if the field is declared as an enumeration * @private */ static isEnum(field) { const modelFile = field.getParent().getModelFile(); const typeDeclaration = modelFile.getType(field.getType()); return (typeDeclaration !== null &amp;&amp; typeDeclaration.isEnum()); } /** * Get the fully qualified name of a type. * @param {string} namespace - namespace of the type. * @param {string} type - short name of the type. * @returns {string} the fully qualified type name. */ static getFullyQualifiedName(namespace, type) { if (namespace) { return `${namespace}.${type}`; } else { return type; } } } module.exports = ModelUtil; × Search results Close "},"composer-common_lib_log_node.js.html":{"id":"composer-common_lib_log_node.js.html","title":"Source: composer-common/lib/log/node.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/log/node.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** @description Internal class for handling a simple directed tree to support filtering * @private * @class * @memberof module:composer-common */ class Node { /** @description creates a new node * @TODO replace the include with a filter level * * @param {String} name name of the node i.e. package &amp; class * @param {boolean} include should this included in the trace * * @private */ constructor(name,include){ this.name=name; this.include =include; this.children=[]; } /** * @description adds a new node as a child of this at the start of the listTitles * @param {Node} node Child node to add * * @private */ addChildNodeAtStart(node){ this.children.push(node); } /** * @description what is the name of this node? * @return {String} name as set on constructor * * @private */ getName(){ return this.name; } /** * @description is this node included in the set trace settings * @return {boolean} included true or false * * @private */ isIncluded(){ return this.include; } /** * @description Set the node to be an inclusion */ setIncluded(){ this.include = true; } /** Find the node in the children that matches the array * * @param {String} nameToFind which node to try and locate in the children * @return {node} Node that matches - * * @private */ findChild(nameToFind){ // do an array search of the children and match the nameToFind return this.children.find(function(element){ return element.getName()===this; },nameToFind); } } module.exports = Node; × Search results Close "},"composer-common_lib_query_orderby.js.html":{"id":"composer-common_lib_query_orderby.js.html","title":"Source: composer-common/lib/query/orderby.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/query/orderby.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const IllegalModelException = require('../introspect/illegalmodelexception'); const Sort = require('./sort'); /** * Defines the ORDER BY specification for a SELECT statement * * @private * @class * @memberof module:composer-common */ class OrderBy { /** * Create an OrderBy from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {Select} select - the Select for this order by * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(select, ast) { if(!select || !ast) { throw new IllegalModelException('Invalid Select or AST'); } this.ast = ast; this.select = select; this.sortCriteria = []; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the Select that owns this OrderBy. * * @return {Select} the owning Select */ getSelect() { return this.select; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { if(this.ast.sort) { for(let n=0; n &lt; this.ast.sort.length; n++) { this.sortCriteria.push( new Sort(this, this.ast.sort[n])); } } else { throw new IllegalModelException('Invalid AST'); } } /** * Semantic validation of the structure of this select. * * @throws {IllegalModelException} * @private */ validate() { for(let n=0; n &lt; this.sortCriteria.length; n++) { this.sortCriteria[n].validate(); } } /** * Return the sort criteria of this order by. * @return {Sort[]} The sort criteria of this order by. */ getSortCriteria() { return this.sortCriteria; } } module.exports = OrderBy; × Search results Close "},"composer-common_lib_introspect_parseexception.js.html":{"id":"composer-common_lib_introspect_parseexception.js.html","title":"Source: composer-common/lib/introspect/parseexception.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/parseexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BaseFileException = require('../basefileexception'); /** * Exception throws when a Composer file is syntactically invalid * @extends BaseFileException * @see See [BaseFileException]{@link module:composer-common.BaseFileException} * @class * @memberof module:composer-common */ class ParseException extends BaseFileException { /** * Create an ParseException * @param {string} message - the message for the exception * @param {string} fileLocation - the optional file location associated with the exception */ constructor(message, fileLocation) { let fullMessage = message; // The parser does not give us back the end location of an invalid token. // Making the end column equal to the end column makes use of // vscodes default behaviour of selecting an entire word if (fileLocation) { if (fileLocation.end &amp;&amp; fileLocation.start) { if (fileLocation.end.offset &amp;&amp; fileLocation.start.offset) { if (fileLocation.end.offset - fileLocation.start.offset === 1) { fileLocation.end.column = fileLocation.start.column; fileLocation.end.offset = fileLocation.start.offset; } } } fullMessage+= ' Line ' + fileLocation.start.line + ' column ' + fileLocation.start.column; } super(message, fileLocation, fullMessage); } } module.exports = ParseException; × Search results Close "},"composer-common_lib_introspect_participantdeclaration.js.html":{"id":"composer-common_lib_introspect_participantdeclaration.js.html","title":"Source: composer-common/lib/introspect/participantdeclaration.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/participantdeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); const IllegalModelException = require('./illegalmodelexception'); /** Class representing the definition of a Participant. * @extends ClassDeclaration * @see See [ClassDeclaration]{@link module:composer-common.ClassDeclaration} * @private * @class * @memberof module:composer-common */ class ParticipantDeclaration extends ClassDeclaration { /** * Create an ParticipantDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {IllegalModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } /** * Returns true if this class can be pointed to by a relationship * * @return {boolean} true if the class may be pointed to by a relationship */ isRelationshipTarget() { return true; } /** * Returns the base system type for Participants from the system namespace * * @return {string} the short name of the base system type */ getSystemType() { return 'Participant'; } /** * Semantic validation of the structure of this participant. Subclasses should * override this method to impose additional semantic constraints on the * contents/relations of fields. * * @throws {IllegalModelException} * @private */ validate() { super.validate(); if(!this.isSystemType() &amp;&amp; this.getName() === 'Participant') { throw new IllegalModelException('Participant is a reserved type name.', this.modelFile, this.ast.location); } } } module.exports = ParticipantDeclaration; × Search results Close "},"composer-common_lib_codegen_fromjs_plantumlgenerator.js.html":{"id":"composer-common_lib_codegen_fromjs_plantumlgenerator.js.html","title":"Source: composer-common/lib/codegen/fromjs/plantumlgenerator.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/codegen/fromjs/plantumlgenerator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const fs = require('fs'); const path = require('path'); const FileWriter = require('../filewriter'); /** * Converts the includes, classes and methods in a Javascript * file into a PlantUML format file. * @private * @class * @memberof module:composer-common */ class PlantUMLGenerator { /** * @param {Object} program - the program arguments * @param {Object} file - the file instance being processed * @param {Object[]} includes - the includes (require statements) within the file * @param {Object[]} classes - the classes within the file * @param {Object[]} functions - the functions within the file */ generate(program, file, includes, classes, functions) { // generate the output if (classes.length &gt; 0 ) { let fileWriter = new FileWriter(program.outputDir); const umlFilename = this.toUMLFilename(program.inputDir, program.outputDir, file); console.log('open file: ' + umlFilename); fileWriter.openFile(umlFilename); fileWriter.writeLine(0, '@startuml'); console.log('+'); fileWriter.writeLine(0, '!include ' + program.outputDir + '/../../jsdoc-template/umlstyle.uml'); for (let n = 0; n &lt; includes.length; n++) { // only include files that exist // the file may not exist if it was empty const includeFile = program.outputDir + '/' + includes[n] + '.uml'; if (fs.existsSync(includeFile)) { fileWriter.writeLine(0, '!include ' + includeFile); } } for (let n = 0; n &lt; classes.length; n++) { const clazz = classes[n]; fileWriter.writeLine(0, 'class ' + clazz.name + '{'); for (let i = 0; i &lt; clazz.methods.length; i++) { const method = clazz.methods[i]; fileWriter.writeLine(1, method.visibility + ' ' + method.returnType + ' ' + method.name + this.paramsToString(method.methodArgs)); } fileWriter.writeLine(0, '}'); if (clazz.superClass) { const filePath = path.parse(file); fileWriter.writeBeforeLine(0, '!include ' + filePath.dir + '/' + clazz.superClass.toLowerCase() + '.uml'); fileWriter.writeLine(0, clazz.name + ' --|&gt; ' + clazz.superClass); } } fileWriter.writeLine(0, '@enduml'); fileWriter.closeFile(); } } /** * Converts an array of parameter types to a string * @param {string[]} paramTypes array of parameter type names * @return {string} - string representation * @private */ paramsToString(paramTypes) { let result = '('; for (let n = 0; n &lt; paramTypes.length; n++) { result += paramTypes[n]; if (n &lt; paramTypes.length - 1) { result += ','; } } result += ')'; return result; } /** * @param {string} inputDir - the fully qualified input directory * @param {string} outputDir - the fully qualified output directory * @param {string} filename - the fully qualified input file name (.js) * @return {string} the UML file name to use * @private */ toUMLFilename(inputDir, outputDir, filename) { console.log('inputDir' + inputDir); console.log('outputDir' + outputDir); console.log('filename' + filename); let index = filename.indexOf(inputDir); console.log('index ' + index); let rest = filename.substr(index + 1 + inputDir.length); // let out = outputDir + '/' + rest; let i = rest.lastIndexOf('.'); // console.log('result' + out.substr(0, i) + '.uml' ); return (i &lt; 0) ? '' : rest.substr(0, i) + '.uml'; } } module.exports = PlantUMLGenerator; × Search results Close "},"composer-common_lib_acl_predicate.js.html":{"id":"composer-common_lib_acl_predicate.js.html","title":"Source: composer-common/lib/acl/predicate.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/acl/predicate.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const IllegalModelException = require('../introspect/illegalmodelexception'); /** * Predicate captures a conditional Javascript expression: * anything that can legally appear within a if statement. * * @private * @class * @memberof module:composer-common */ class Predicate { /** * Create an Predicate from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {AclRule} aclRule - the AclRule for this Predicate * @param {Object} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(aclRule, ast) { if(!aclRule || !ast) { throw new IllegalModelException('Invalid AclRule or AST'); } this.expression = ast; this.aclRule = aclRule; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the AclRule that owns this ModelBinding. * * @return {AclRule} the owning AclRule */ getAclRule() { return this.aclRule; } /** * Returns the expression as a text string. * * @return {string} the operator for the predicate */ getExpression() { return this.expression; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { } /** * Semantic validation of the structure of this ModelBinding. * * @throws {IllegalModelException} * @private */ validate() { } } module.exports = Predicate; × Search results Close "},"composer-common_lib_introspect_property.js.html":{"id":"composer-common_lib_introspect_property.js.html","title":"Source: composer-common/lib/introspect/property.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/property.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Decorated = require('./decorated'); const ModelUtil = require('../modelutil'); /** * Property representing an attribute of a class declaration, * either a Field or a Relationship. * @private * @class * @memberof module:composer-common */ class Property extends Decorated { /** * Create a Property. * @param {ClassDeclaration} parent - the owner of this property * @param {Object} ast - The AST created by the parser * @throws {IllegalModelException} */ constructor(parent, ast) { super(ast); this.parent = parent; this.process(); } /** * Returns the owner of this property * @return {ClassDeclaration} the parent class declaration */ getParent() { return this.parent; } /** * Process the AST and build the model * @throws {IllegalModelException} * @private */ process() { super.process(); this.name = this.ast.id.name; this.decorator = null; if(!this.name) { throw new Error('No name for type ' + this.ast ); } if(this.ast.propertyType) { this.type = this.ast.propertyType.name; } else { this.type = null; } this.array = false; if(this.ast.array) { this.array = true; } if(this.ast.optional) { this.optional = true; } else { this.optional = false; } } /** * Validate the property * @param {ClassDeclaration} classDecl the class declaration of the property * @throws {IllegalModelException} * @private */ validate(classDecl) { super.validate(); if(this.type) { classDecl.getModelFile().resolveType( 'property ' + this.getFullyQualifiedName(), this.type); } } /** * Returns the name of a property * @return {string} the name of this field */ getName() { return this.name; } /** * Returns the type of a property * @return {string} the type of this field */ getType() { return this.type; } /** * Returns true if the field is optional * @return {boolean} true if the field is optional */ isOptional() { return this.optional; } /** * Returns the fully qualified type name of a property * @return {string} the fully qualified type of this property */ getFullyQualifiedTypeName() { if(this.isPrimitive()) { return this.type; } const parent = this.getParent(); if(!parent) { throw new Error('Property ' + this.name + ' does not have a parent.'); } const modelFile = parent.getModelFile(); if(!modelFile) { throw new Error('Parent of property ' + this.name + ' does not have a ModelFile!'); } const result = modelFile.getFullyQualifiedTypeName(this.type); if(!result) { throw new Error('Failed to find fully qualified type name for property ' + this.name + ' with type ' + this.type ); } return result; } /** * Returns the fully name of a property (ns + class name + property name) * @return {string} the fully qualified name of this property */ getFullyQualifiedName() { return this.getParent().getFullyQualifiedName() + '.' + this.getName(); } /** * Returns the namespace of the parent of this property * @return {string} the namespace of the parent of this property */ getNamespace() { return this.getParent().getNamespace(); } /** * Returns true if the field is declared as an array type * @return {boolean} true if the property is an array type */ isArray() { return this.array; } /** * Returns true if the field is declared as an enumerated value * @return {boolean} true if the property is an enumerated value */ isTypeEnum() { if(this.isPrimitive()) { return false; } else { const type = this.getParent().getModelFile().getType(this.getType()); return type.isEnum(); } } /** * Returns true if this property is a primitive type. *@return {boolean} true if the property is a primitive type. */ isPrimitive() { return ModelUtil.isPrimitiveType(this.getType()); } } module.exports = Property; × Search results Close "},"composer-common_lib_query_query.js.html":{"id":"composer-common_lib_query_query.js.html","title":"Source: composer-common/lib/query/query.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/query/query.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const IllegalModelException = require('../introspect/illegalmodelexception'); const ParseException = require('../introspect/parseexception'); const parser = require('./parser'); const Select = require('./select'); /** * Query defines a SELECT query over a resource (asset, transaction or participant) * * @private * @class * @memberof module:composer-common */ class Query { /** * Create a query programmatically without supplying an AST. * @param {QueryFile} queryFile The owning query file. * @param {string} name The name of the query. * @param {string} description A description of the query. * @param {string} select The select statement. * @return {Query} The created query. */ static buildQuery(queryFile, name, description, select) { let selectAst; try { // We must tell the PEG.js parser to use an alternate start rule, // so that we can parse just the statement rather than the full query. selectAst = parser.parse(select, { startRule: 'SelectStatement' }); } catch (err) { if(err.location &amp;&amp; err.location.start) { throw new ParseException( err.message + ' Line ' + err.location.start.line + ' column ' + err.location.start.column, err.location ); } else { throw err; } } const ast = { identifier: { name: name }, description: description, select: selectAst }; return new Query(queryFile, ast); } /** * Create an Query from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {QueryFile} queryFile - the QueryFile for this query * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(queryFile, ast) { if(!queryFile || !ast) { throw new IllegalModelException('Invalid QueryFile or AST'); } this.ast = ast; this.queryFile = queryFile; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the QueryFile that owns this Query. * * @return {AclFile} the owning QueryFile */ getQueryFile() { return this.queryFile; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { this.name = this.ast.identifier.name; this.description = this.ast.description; this.select = new Select(this, this.ast.select); } /** * Semantic validation of the structure of this Query. * * @throws {IllegalModelException} * @private */ validate() { this.select.validate(); } /** * Returns the name of this Query. * * @return {string} the name of the Query */ getName() { return this.name; } /** * Returns the description associated with this Query. * * @return {string} the description */ getDescription() { return this.description; } /** * Returns the select statement associated with this Query. * @return {Select} The select statement. */ getSelect() { return this.select; } } module.exports = Query; × Search results Close "},"composer-common_lib_query_queryfile.js.html":{"id":"composer-common_lib_query_queryfile.js.html","title":"Source: composer-common/lib/query/queryfile.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/query/queryfile.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const parser = require('./parser'); const Query = require('./query'); const ParseException = require('../introspect/parseexception'); /** * Class representing a Query File * @private * @class * @memberof module:composer-common */ class QueryFile { /** * Create an QueryFile. This should only be called by framework code. * @param {string} id - The identifier of this Query File (may be a filename for example) * @param {ModelManager} modelManager - the ModelManager that manages this * ModelFile and that will be used to validate the queries in the QueryFile * @param {string} definitions - The queries as a string. * @throws {IllegalModelException} */ constructor(id, modelManager, definitions) { this.modelManager = modelManager; this.queries = []; this.identifier = id; if(typeof definitions !== 'string') { throw new Error('QueryFile expects an QueryFile as a string as input.'); } this.definitions = definitions; try { this.ast = parser.parse(definitions); } catch(err) { if(err.location &amp;&amp; err.location.start) { throw new ParseException( err.message + ' Line ' + err.location.start.line + ' column ' + err.location.start.column, err.location ); } else { throw err; } } for(let n=0; n &lt; this.ast.queries.length; n++ ) { let thing = this.ast.queries[n]; this.queries.push(new Query(this, thing)); } } /** * Returns the name of this Query File. * @return {string} the name of this Query File */ getIdentifier() { return this.identifier; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the ModelManager associated with this QueryFile * * @return {ModelManager} The ModelManager for this QueryFile */ getModelManager() { return this.modelManager; } /** * Validates the QueryFile. * * @throws {IllegalModelException} if the query file is invalid * @private */ validate() { const queries = {}; this.queries.forEach((query) =&gt; { query.validate(); let name = query.getName(); if (queries[name]){ throw new Error(`Found two or more queries with the name '${name}'`); } queries[name] = query; }); } /** * Get all declarations in this Query file * @return {Query[]} the Queries defined in the Query file */ getQueries() { return this.queries; } /** * Get the definitions for this Query file. * @return {string} The definitions for this Query file. */ getDefinitions() { return this.definitions; } /** * Create a query programmatically without supplying an AST, * and add it into this query file. * @param {string} name The name of the query. * @param {string} description A description of the query. * @param {string} select The select statement. * @return {Query} The created query. */ buildQuery(name, description, select) { const query = Query.buildQuery(this, name, description, select); this.queries.push(query); return query; } } module.exports = QueryFile; × Search results Close "},"composer-common_lib_querymanager.js.html":{"id":"composer-common_lib_querymanager.js.html","title":"Source: composer-common/lib/querymanager.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/querymanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const QueryFile = require('./query/queryfile'); /** * &lt;p&gt; * Manages a set of queries. * &lt;/p&gt; * @private * @class * @memberof module:composer-common */ class QueryManager { /** * Create the QueryManager. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkDefinition}&lt;/strong&gt; * &lt;/p&gt; * @param {ModelManager} modelManager - The ModelManager to use for this QueryManager * @param {QueryFile} queryFile - The QueryFile that stores the queries */ constructor(modelManager) { this.modelManager = modelManager; this.queryFile = null; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Create an Query file using the specified ID and contents. * @param {string} identifier The identifier of the query file. * @param {string} contents The contents of the query file. * @return {QueryFile} The new Query file. */ createQueryFile(identifier, contents) { return new QueryFile(identifier, this.modelManager, contents); } /** * Set the QueryFile for this QueryManager * @param {QueryFile} queryFile - the QueryFile to associate with this QueryManager * @private */ setQueryFile(queryFile) { queryFile.validate(); this.queryFile = queryFile; } /** * Get the QueryFile associated with this QueryManager * @return {QueryFile} The QueryFile for this QueryManager or null if it has not been set */ getQueryFile() { return this.queryFile; } /** * Get the Queries associated with this QueryManager * @return {Query[]} The Queries for the QueryManager or an empty array if not set */ getQueries() { if(this.queryFile) { return this.queryFile.getQueries(); } return []; } /** * Remove the Query */ deleteQueryFile() { delete this.queryFile; } /** * Get the named Query associated with this QueryManager * @param {string} name - the name of the query * @return {Query} The Query or null if it does not exist */ getQuery(name) { if(this.queryFile) { const queries = this.queryFile.getQueries(); for(let n=0; n &lt; queries.length; n++) { const query = queries[n]; if(query.getName() === name) { return query; } } } return null; } } module.exports = QueryManager; × Search results Close "},"composer-common_lib_model_relationship.js.html":{"id":"composer-common_lib_model_relationship.js.html","title":"Source: composer-common/lib/model/relationship.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/model/relationship.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Identifiable = require('./identifiable'); const ResourceId = require('./resourceid'); const Globalize = require('../globalize'); /** * A Relationship is a typed pointer to an instance. I.e the relationship * with namespace = 'org.acme', type = 'Vehicle' and id = 'ABC' creates * a pointer that points at an instance of org.acme.Vehicle with the id * ABC. * @extends Identifiable * @see See [Identifiable]{@link module:composer-common.Identifiable} * @class * @memberof module:composer-common */ class Relationship extends Identifiable { /** * Create an asset. Use the Factory to create instances. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {string} id - The identifier of this instance. * @private */ constructor(modelManager, ns, type, id) { super(modelManager, ns, type, id); // we use this metatag to identify the instance as a relationship this.$class = 'Relationship'; } /** * Returns the string representation of this class * @return {String} the string representation of the class */ toString() { return 'Relationship {id=' + this.getFullyQualifiedIdentifier() + '}'; } /** * Determine if this identifiable is a relationship. * @return {boolean} True if this identifiable is a relationship, * false if not. */ isRelationship() { return true; } /** * Contructs a Relationship instance from a URI representation (created using toURI). * @param {ModelManager} modelManager - the model manager to bind the relationship to * @param {String} uriAsString - the URI as a string, generated using Identifiable.toURI() * @param {String} [defaultNamespace] - default namespace to use for backwards compatability (optional) * @param {String} [defaultType] - default type to use for backwards compatability (optional) * @return {Relationship} the relationship */ static fromURI(modelManager, uriAsString, defaultNamespace, defaultType) { const resourceId = ResourceId.fromURI(uriAsString, defaultNamespace, defaultType); let modelFile = modelManager.getModelFile(resourceId.namespace); if (!modelFile) { let formatter = Globalize.messageFormatter('factory-newrelationship-notregisteredwithmm'); throw new Error(formatter({ namespace: resourceId.namespace })); } if (!modelFile.isDefined(resourceId.type)) { let formatter = Globalize.messageFormatter('factory-newinstance-typenotdeclaredinns'); throw new Error(formatter({ namespace: resourceId.namespace, type: resourceId.type })); } let relationship = new Relationship(modelManager, resourceId.namespace, resourceId.type, resourceId.id); return relationship; } } module.exports = Relationship; × Search results Close "},"composer-common_lib_introspect_relationshipdeclaration.js.html":{"id":"composer-common_lib_introspect_relationshipdeclaration.js.html","title":"Source: composer-common/lib/introspect/relationshipdeclaration.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/relationshipdeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Property = require('./property'); const IllegalModelException = require('./illegalmodelexception'); const ModelUtil = require('../modelutil'); /** * Class representing a relationship between model elements * @extends Property * @see See [Property]{@link module:composer-common.Property} * @private * @class * @memberof module:composer-common */ class RelationshipDeclaration extends Property { /** * Create a Relationship. * @param {ClassDeclaration} parent - The owner of this property * @param {Object} ast - The AST created by the parser * @throws {IllegalModelException} */ constructor(parent, ast) { super(parent, ast); } /** * Validate the property * @param {ClassDeclaration} classDecl the class declaration of the property * @throws {IllegalModelException} * @private */ validate(classDecl) { super.validate(classDecl); // relationship cannot point to primitive types if(!this.getType()) { throw new IllegalModelException('Relationship must have a type', classDecl.getModelFile(), this.ast.location); } let classDeclaration = null; // you can't have a relationship with a primitive... if(ModelUtil.isPrimitiveType(this.getType())) { throw new IllegalModelException('Relationship ' + this.getName() + ' cannot be to the primitive type ' + this.getType(), classDecl.getModelFile(), this.ast.location ); } else { let namespace = this.getParent().getNamespace(); // we first try to get the type from our own model file // because during validate we have not yet been added to the model manager if(namespace === ModelUtil.getNamespace(this.getFullyQualifiedTypeName())) { classDeclaration = this.getParent().getModelFile().getType(this.getType()); } else { // otherwise we have to use the modelmanager to try to load try { classDeclaration = this.getParent().getModelFile().getModelManager().getType(this.getFullyQualifiedTypeName()); } catch (err) { // Let classDeclaration remain null and get handled below } } if(classDeclaration === null) { throw new IllegalModelException('Relationship ' + this.getName() + ' points to a missing type ' + this.getFullyQualifiedTypeName(), classDecl.getModelFile(), this.ast.location); } if ( namespace === ModelUtil.getSystemNamespace() ) { // Transaction relationship in event, continue } else if(classDeclaration.isRelationshipTarget() === false) { throw new IllegalModelException('Relationship ' + this.getName() + ' must be to an asset or participant, but is to ' + this.getFullyQualifiedTypeName(), classDecl.getModelFile(), this.ast.location); } } } /** * Returns a string representation of this property * @return {String} the string version of the property. */ toString() { return 'RelationshipDeclaration {name=' + this.name + ', type=' + this.getFullyQualifiedTypeName() + ', array=' + this.array + ', optional=' + this.optional +'}'; }} module.exports = RelationshipDeclaration; × Search results Close "},"composer-common_lib_model_resource.js.html":{"id":"composer-common_lib_model_resource.js.html","title":"Source: composer-common/lib/model/resource.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/model/resource.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Identifiable = require('./identifiable'); /** * &lt;p&gt; * Resource is an instance that has a type. The type of the resource * specifies a set of properites (which themselves have types). * &lt;/p&gt; * &lt;p&gt; * Type information in Composer is used to validate the structure of * Resource instances and for serialization. * &lt;/p&gt; * &lt;p&gt; * Resources are used in Composer to represent Assets, Participants, Transactions and * other domain classes that can be serialized for long-term persistent storage. * &lt;/p&gt; * @extends Identifiable * @see See [Resource]{@link module:composer-common.Resource} * @class * @memberof module:composer-common */ class Resource extends Identifiable { /** * This constructor should not be called directly. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {string} id - The identifier of this instance. * @private */ constructor(modelManager, ns, type, id) { super(modelManager, ns, type, id); } /** * Returns the string representation of this class * @return {String} the string representation of the class */ toString() { return 'Resource {id=' + this.getFullyQualifiedIdentifier() +'}'; } /** * Determine if this identifiable is a resource. * @return {boolean} True if this identifiable is a resource, * false if not. */ isResource() { return true; } } module.exports = Resource; × Search results Close "},"composer-common_lib_model_resourceid.js.html":{"id":"composer-common_lib_model_resourceid.js.html","title":"Source: composer-common/lib/model/resourceid.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/model/resourceid.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const URI = require('uri-js'); const ModelUtils = require('../modelutil'); const RESOURCE_SCHEME = 'resource'; /** * All the identifying properties of a resource. * @private * @class * @memberof module:composer-common * @property {String} namespace * @property {String} type * @property {String} id */ class ResourceId { /** * &lt;strong&gt;Note: only for use by internal framework code.&lt;/strong&gt; * @param {String} namespace - Namespace containing the type. * @param {String} type - Short type name. * @param {String} id - Instance identifier. * @private */ constructor(namespace, type, id) { if (!namespace) { throw new Error('Missing namespace'); } if (!type) { throw new Error('Missing type'); } if (!id) { throw new Error('Missing id'); } this.namespace = namespace; this.type = type; this.id = id; } /** * Parse a URI into an identifier. * &lt;p&gt; * Three formats are allowable: * &lt;ol&gt; * &lt;li&gt;Valid resource URI argument: &lt;em&gt;resource:qualifiedTypeName#ID&lt;/em&gt;&lt;/li&gt; * &lt;li&gt;Valid resource URI argument with missing URI scheme: &lt;em&gt;qualifiedTypeName#ID&lt;/em&gt;&lt;/li&gt; * &lt;li&gt;URI argument containing only an ID, with legacy namespace and type arguments supplied.&lt;/li&gt; * &lt;/ol&gt; * @param {String} uri - Resource URI. * @param {String} [legacyNamespace] - Namespace to use for legacy resource identifiers. * @param {String} [legacyType] - Type to use for legacy resource identifiers. * @return {Identifier} - An identifier. * @throws {Error} - On an invalid resource URI. */ static fromURI(uri, legacyNamespace, legacyType) { const uriComponents = URI.parse(uri, { unicodeSupport: true }); const scheme = uriComponents.scheme; // Accept legacy identifiers with missing URI scheme as valid if (scheme &amp;&amp; scheme !== RESOURCE_SCHEME) { throw new Error('Invalid URI scheme: ' + uri); } if (uriComponents.userinfo || uriComponents.host || uriComponents.port || uriComponents.query) { throw new Error('Invalid resource URI format: ' + uri); } let namespace, type; let id = uriComponents.fragment; if (!id) { // Legacy format where the whole path is the ID namespace = legacyNamespace; type = legacyType; id = uriComponents.path; } else { const qualifiedType = uriComponents.path; namespace = ModelUtils.getNamespace(qualifiedType); type = ModelUtils.getShortName(qualifiedType); } return new ResourceId(namespace, type, decodeURIComponent(id)); } /** * URI representation of this identifier. * @return {String} A URI. */ toURI() { const qualifiedType = ModelUtils.getFullyQualifiedName(this.namespace, this.type); return URI.serialize({ scheme: RESOURCE_SCHEME, path: qualifiedType, fragment: this.id }); } } module.exports = ResourceId; × Search results Close "},"composer-common_lib_introspect_script.js.html":{"id":"composer-common_lib_introspect_script.js.html","title":"Source: composer-common/lib/introspect/script.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/script.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const FunctionDeclaration = require('../introspect/functiondeclaration'); const JavaScriptParser = require('../codegen/javascriptparser'); const Logger = require('../log/logger'); const LOG = Logger.getLog('Script'); /** * &lt;p&gt; * An executable script. * &lt;/p&gt; * @private * @class * @memberof module:composer-common */ class Script { /** * Create the Script. * &lt;p&gt; * @param {ModelManager} modelManager - The ModelManager associated with this Script * @param {string} identifier - The identifier of the script * @param {string} language - The language type of the script * @param {string} contents - The contents of the script */ constructor(modelManager, identifier, language, contents) { this.modelManager = modelManager; this.identifier = identifier; this.language = language; this.contents = contents; this.functions = []; if(!contents) { throw new Error('Empty script contents'); } let data = {errorStatement:''}; let parser; try { parser = new JavaScriptParser(this.contents, false, 5,{}); } catch (cause) { // consider adding a toHex method in the exception to put out the pure hex values of the file. const error = new SyntaxError('Failed to parse ' + this.identifier + ': ' + cause.message+'\\n'+data.errorStatement); error.cause = cause; LOG.error('constructor', error.message, contents); throw error; } const functions = parser.getFunctions(); for(let n=0; n &lt; functions.length; n++) { const func = functions[n]; const functionDeclaration = new FunctionDeclaration(this.modelManager, this.language, func.name, func.visibility, func.returnType, func.throws, func.parameterNames, func.parameterTypes, func.decorators, func.functionText ); functionDeclaration.validate(); this.functions.push( functionDeclaration ); } this.tokens = parser.getTokens(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the identifier of the script * @return {string} the identifier of the script */ getIdentifier() { return this.identifier; } /** * Returns the identifier of the script * @return {string} the identifier of the script */ getName() { return this.identifier; } /** * Returns the language of the script * @return {string} the identifier of the script */ getLanguage() { return this.language; } /** * Returns the contents of the script * @return {string} the identifier of the script */ getContents() { return this.contents; } /** * Returns the FunctionDeclaration for all functions that have been defined in this * Script. * * @return {FunctionDeclaration[]} The array of FunctionDeclarations */ getFunctionDeclarations() { return this.functions; } /** * Returns the tokens of the script * @return {Object[]} the tokens of the script */ getTokens() { return this.tokens; } } module.exports = Script; × Search results Close "},"composer-common_lib_scriptmanager.js.html":{"id":"composer-common_lib_scriptmanager.js.html","title":"Source: composer-common/lib/scriptmanager.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/scriptmanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Script = require('./introspect/script'); /** * &lt;p&gt; * Manages a set of scripts. * &lt;/p&gt; * @private * @class * @memberof module:composer-common */ class ScriptManager { /** * Create the ScriptManager. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkDefinition}&lt;/strong&gt; * &lt;/p&gt; * @param {ModelManager} modelManager - The ModelManager to use for this ScriptManager */ constructor(modelManager) { this.modelManager = modelManager; this.scripts = {}; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Creates a new Script from a string. * * @param {string} identifier - the identifier of the script * @param {string} language - the language identifier of the script * @param {string} contents - the contents of the script * @returns {Script} - the instantiated script */ createScript(identifier, language, contents) { return new Script(this.modelManager, identifier, language, contents ); } /** * Adds a Script to the ScriptManager * @param {Script} script - The script to add to the ScriptManager */ addScript(script) { this.scripts[script.getIdentifier()] = script; } /** * Update an existing Script in the ScriptManager * @param {Script} script - The script to add to the ScriptManager */ updateScript(script) { if (!this.scripts[script.getIdentifier()]) { throw new Error('Script file does not exist'); } this.addScript(script); } /** * Remove the Script * @param {string} identifier - The identifier of the script to remove * delete. */ deleteScript(identifier) { if (!this.scripts[identifier]) { throw new Error('Script file does not exist'); } delete this.scripts[identifier]; } /** * Get the array of Script instances * @return {Script[]} The Scripts registered * @private */ getScripts() { let keys = Object.keys(this.scripts); let result = []; for(let n=0; n &lt; keys.length;n++) { result.push(this.scripts[keys[n]]); } return result; } /** * Remove all registered Composer files */ clearScripts() { this.scripts = {}; } /** * Get the Script associated with an identifier * @param {string} identifier - the identifier of the Script * @return {Script} the Script * @private */ getScript(identifier) { return this.scripts[identifier]; } /** * Get the identifiers of all registered scripts * @return {string[]} The identifiers of all registered scripts */ getScriptIdentifiers() { return Object.keys(this.scripts); } } module.exports = ScriptManager; × Search results Close "},"composer-common_lib_securitycontext.js.html":{"id":"composer-common_lib_securitycontext.js.html","title":"Source: composer-common/lib/securitycontext.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/securitycontext.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * SecurityContext is used to authenticate and manage * user credentials to the underlying blockchain fabric. * &lt;p&gt;&lt;a href=&quot;./diagrams/securitycontext.svg&quot;&gt;&lt;img src=&quot;./diagrams/securitycontext.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @abstract * @class * @memberof module:composer-common */ class SecurityContext { /** * Create the SecurityContext. * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances by calling {@link Composer#login login}&lt;/strong&gt; * &lt;/p&gt; * @param {Connection} connection The owning connection. * @param {string} user The user identifier. */ constructor(connection) { this.connection = connection; } /** * Get the owning connection. * @return {Connection} The owning connection. */ getConnection() { return this.connection; } /** * Get the current username. * @abstract * @return {string} The username */ getUser() { throw new Error('abstract function called'); } } module.exports = SecurityContext; × Search results Close "},"composer-common_lib_securityexception.js.html":{"id":"composer-common_lib_securityexception.js.html","title":"Source: composer-common/lib/securityexception.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/securityexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BaseException = require('./baseexception'); /** * Class representing a security exception * &lt;p&gt;&lt;a href=&quot;./diagrams/securityexception.svg&quot;&gt;&lt;img src=&quot;./diagrams/securityexception.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends BaseException * @see See [BaseException]{@link module:composer-common.BaseException} * @class * @memberof module:composer-common */ class SecurityException extends BaseException { /** * Create the SecurityException. * @param {string} message - The exception message. */ constructor(message) { super(message); } } module.exports = SecurityException; × Search results Close "},"composer-common_lib_query_select.js.html":{"id":"composer-common_lib_query_select.js.html","title":"Source: composer-common/lib/query/select.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/query/select.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const InvalidQueryException = require('./invalidqueryexception'); const Limit = require('./limit'); const OrderBy = require('./orderby'); const Skip = require('./skip'); const Where = require('./where'); /** * Select defines a SELECT query over a resource (asset, transaction or participant) * * @private * @class * @memberof module:composer-common */ class Select { /** * Create an Select from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {Query} query - the Query for this select * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(query, ast) { if(!query || !ast) { throw new InvalidQueryException('Invalid Query or AST'); } this.ast = ast; this.query = query; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the QueryFile that owns this Query. * * @return {Query} the owning QueryFile */ getQuery() { return this.query; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { // The grammar ensures that the resource property is set. this.resource = this.ast.resource; this.registry = null; if(this.ast.registry) { this.registry = this.ast.registry; } this.where = null; if(this.ast.where) { this.where = new Where(this, this.ast.where); } this.limit = null; if(this.ast.limit) { this.limit = new Limit(this, this.ast.limit); } this.skip = null; if(this.ast.skip) { this.skip = new Skip(this, this.ast.skip); } this.orderBy = null; if(this.ast.orderBy) { this.orderBy = new OrderBy(this, this.ast.orderBy); } this.text = null; if(this.ast.text) { this.text = this.ast.text; } } /** * Semantic validation of the structure of this select. * * @throws {IllegalModelException} * @private */ validate() { // The grammar ensures that the resource property is set. const resourceClassDeclaration = this.getResourceClassDeclaration(); if(!resourceClassDeclaration) { throw new InvalidQueryException('Type does not exist ' + this.resource, this.getQuery().getQueryFile(), this.ast.location); } // check that it is not an enum or concept if(resourceClassDeclaration.isConcept() || resourceClassDeclaration.isEnum()) { throw new InvalidQueryException('Can only select assets, participants and transactions.', this.getQuery().getQueryFile(), this.ast.location); } if(this.where) { this.where.validate(); } if(this.orderBy) { this.orderBy.validate(); } if(this.limit) { this.limit.validate(); } if(this.skip) { this.skip.validate(); } } /** * Returns the FQN of the resource of this select or null if it does not have a resource. * * @return {string} the fully qualified name of the select */ getResource() { return this.resource; } /** * Returns the FQN of the resource of this select or null if it does not have a resource. * * @return {string} the fully qualified name of the select */ getResourceClassDeclaration() { // The grammar ensures that the resource property is set. const mm = this.getQuery().getQueryFile().getModelManager(); // checks the resource type exists return mm.getType(this.resource); } /** * Returns the name of the registry of this select or null if it does not have a registry. * * @return {string} the name of the registry of the select */ getRegistry() { return this.registry; } /** * Returns the Where clause for this query or null if it does not have a WHERE clause. * * @return {Where} the Where or null */ getWhere() { return this.where; } /** * Returns the OrderBy clause for this query or null if it does not have an ORDER BY clause. * * @return {OrderBy} the OrderBy or null */ getOrderBy() { return this.orderBy; } /** * Returns the LIMIT count for this query or null if it does not have a LIMIT * * @return {Limit} the LIMIT or null */ getLimit() { return this.limit; } /** * Returns the SKIP count for this query or null if it does not have a SKIP * * @return {Skip} the SKIP or null */ getSkip() { return this.skip; } /** * Returns the text of this select statement. * @return {string} the text of this select statement. */ getText() { return this.text; } /** * Return the AST for this select statement. * @return {Object} The AST for this select statement. */ getAST() { return this.ast; } } module.exports = Select; × Search results Close "},"composer-common_lib_serializer.js.html":{"id":"composer-common_lib_serializer.js.html","title":"Source: composer-common/lib/serializer.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/serializer.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const EventDeclaration = require('./introspect/eventdeclaration'); const Globalize = require('./globalize'); const JSONGenerator = require('./serializer/jsongenerator'); const JSONPopulator = require('./serializer/jsonpopulator'); const Resource = require('./model/resource'); const ResourceValidator = require('./serializer/resourcevalidator'); const TransactionDeclaration = require('./introspect/transactiondeclaration'); const TypedStack = require('./serializer/typedstack'); const JSONWriter = require('./codegen/jsonwriter'); /** * Serialize Resources instances to/from various formats for long-term storage * (e.g. on the blockchain). * &lt;p&gt;&lt;a href=&quot;./diagrams/serializer.svg&quot;&gt;&lt;img src=&quot;./diagrams/serializer.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @class * @memberof module:composer-common */ class Serializer { /** * Create a Serializer. * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Composer}&lt;/strong&gt; * &lt;/p&gt; * @param {Factory} factory - The Factory to use to create instances * @param {ModelManager} modelManager - The ModelManager to use for validation etc. */ constructor(factory,modelManager) { if(!factory) { throw new Error(Globalize.formatMessage('serializer-constructor-factorynull')); } else if(!modelManager) { throw new Error(Globalize.formatMessage('serializer-constructor-modelmanagernull')); } this.factory = factory; this.modelManager = modelManager; } /** * &lt;p&gt; * Convert a {@link Resource} to a JavaScript object suitable for long-term * peristent storage. * &lt;/p&gt; * @param {Resource} resource - The instance to convert to JSON * @param {Object} options - the optional serialization options. * @param {boolean} options.validate - validate the structure of the Resource * with its model prior to serialization (default to true) * @param {boolean} options.convertResourcesToRelationships - Convert resources that * are specified for relationship fields into relationships, false by default. * @param {boolean} options.permitResourcesForRelationships - Permit resources in the * place of relationships (serializing them as resources), false by default. * @param {boolean} options.deduplicateResources - Generate $id for resources and * if a resources appears multiple times in the object graph only the first instance is * serialized in full, subsequent instances are replaced with a reference to the $id * @return {Object} - The Javascript Object that represents the resource * @throws {Error} - throws an exception if resource is not an instance of * Resource or fails validation. */ toJSON(resource, options) { // correct instance type if(!(resource instanceof Resource)) { throw new Error(Globalize.formatMessage('serializer-tojson-notcobject')); } const parameters = {}; parameters.stack = new TypedStack(resource); parameters.modelManager = this.modelManager; parameters.seenResources = new Set(); parameters.dedupeResources = new Set(); const classDeclaration = this.modelManager.getType( resource.getFullyQualifiedType() ); // validate the resource against the model options = options || {}; if(options.validate === undefined) { options.validate = true; } if(options.validate) { const validator = new ResourceValidator(options); classDeclaration.accept(validator, parameters); } const generator = new JSONGenerator( options.convertResourcesToRelationships === true, options.permitResourcesForRelationships === true, options.deduplicateResources === true ); const writer = new JSONWriter(); parameters.writer = writer; parameters.stack.clear(); parameters.stack.push(resource); // this writes the JSON into the parameters.writer classDeclaration.accept(generator, parameters); const jsonText = parameters.writer.getBuffer(); try { return JSON.parse(jsonText); } catch(err) { throw new Error( 'Generated invalid JSON: ' + jsonText ); } } /** * Create a {@link Resource} from a JavaScript Object representation. * The JavaScript Object should have been created by calling the * {@link Serializer#toJSON toJSON} API. * * The Resource is populated based on the JavaScript object. * * @param {Object} jsonObject The JavaScript Object for a Resource * @param {Object} options - the optional serialization options * @param {boolean} options.acceptResourcesForRelationships - handle JSON objects * in the place of strings for relationships, defaults to false. * @param {boolean} options.validate - validate the structure of the Resource * with its model prior to serialization (default to true) * @return {Resource} The new populated resource */ fromJSON(jsonObject, options) { if(!jsonObject.$class) { throw new Error('Invalid JSON data. Does not contain a $class type identifier.'); } const classDeclaration = this.modelManager.getType(jsonObject.$class); // default the options. options = options || {}; if(options.validate === undefined) { options.validate = true; } // create a new instance, using the identifier field name as the ID. let resource; if (classDeclaration instanceof TransactionDeclaration) { resource = this.factory.newTransaction( classDeclaration.getNamespace(), classDeclaration.getName(), jsonObject[classDeclaration.getIdentifierFieldName()] ); } else if (classDeclaration instanceof EventDeclaration) { resource = this.factory.newEvent( classDeclaration.getNamespace(), classDeclaration.getName(), jsonObject[classDeclaration.getIdentifierFieldName()] ); } else { resource = this.factory.newResource( classDeclaration.getNamespace(), classDeclaration.getName(), jsonObject[classDeclaration.getIdentifierFieldName()] ); } // populate the resource based on the jsonObject // by walking the classDeclaration const parameters = {}; parameters.jsonStack = new TypedStack(jsonObject); parameters.resourceStack = new TypedStack(resource); parameters.modelManager = this.modelManager; parameters.factory = this.factory; const populator = new JSONPopulator(options.acceptResourcesForRelationships === true); classDeclaration.accept(populator, parameters); // validate the resource against the model if(options.validate) { resource.validate(); } return resource; } } module.exports = Serializer; × Search results Close "},"composer-common_lib_query_skip.js.html":{"id":"composer-common_lib_query_skip.js.html","title":"Source: composer-common/lib/query/skip.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/query/skip.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const IllegalModelException = require('../introspect/illegalmodelexception'); /** * Skip defines the SKIP portion of a SELECT statement * * @private * @class * @memberof module:composer-common */ class Skip { /** * Create a Skip from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {Select} select - the Select for this Skip * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(select, ast) { if(!select || !ast) { throw new IllegalModelException('Invalid Select or AST'); } this.ast = ast; this.select = select; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the Select that owns this Skip. * * @return {Select} the owning Select */ getSelect() { return this.select; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { } /** * Semantic validation of the structure of this skip. * * @throws {IllegalModelException} * @private */ validate() { } /** * Return the AST for this skip statement. * @return {Object} The AST for this skip statement. */ getAST() { return this.ast; } } module.exports = Skip; × Search results Close "},"composer-common_lib_query_sort.js.html":{"id":"composer-common_lib_query_sort.js.html","title":"Source: composer-common/lib/query/sort.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/query/sort.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const IllegalModelException = require('../introspect/illegalmodelexception'); /** * Defines a sort on a field for an ORDER BY clause * * @private * @class * @memberof module:composer-common */ class Sort { /** * Create a Sort from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {OrderBy} orderBy - the OrderBy for this sort by * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(orderBy, ast) { if(!orderBy || !ast) { throw new IllegalModelException('Invalid OrderBy or AST'); } this.ast = ast; this.orderBy = orderBy; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the OrderBy that owns this Sort. * * @return {OrderBy} the owning OrderBy */ getOrderBy() { return this.orderBy; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { if(!this.ast.fieldName) { throw new IllegalModelException('Invalid AST'); }else{ this.propertyPath = this.ast.fieldName.name; } if(this.ast.direction) { this.direction = this.ast.direction; } else { this.direction = 'ASC'; } } /** * Semantic validation of the structure of this select. * * @throws {IllegalModelException} * @private */ validate() { // check that the property exists this.getOrderBy().getSelect().getResourceClassDeclaration().getNestedProperty(this.propertyPath); } /** * Returns the name of the property of the owning resource. This may be an dotted expression * to navigate to sub-properties of the owning resource. E.g. x.y.z. * * @return {string} the navigation property */ getPropertyPath() { return this.propertyPath; } /** * Returns the name of the property of the owning resource. This may be an dotted expression * to navigate to sub-properties of the owning resource. E.g. x.y.z. * * @return {string} the navigation property */ getDirection() { return this.direction; } } module.exports = Sort; × Search results Close "},"composer-common_lib_introspect_transactiondeclaration.js.html":{"id":"composer-common_lib_introspect_transactiondeclaration.js.html","title":"Source: composer-common/lib/introspect/transactiondeclaration.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/transactiondeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); const IllegalModelException = require('./illegalmodelexception'); const ModelUtil = require('../modelutil'); /** Class representing the definition of an Transaction. * @extends ClassDeclaration * @see See [ClassDeclaration]{@link module:composer-common.ClassDeclaration} * @private * @class * @memberof module:composer-common */ class TransactionDeclaration extends ClassDeclaration { /** * Create an TransactionDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {IllegalModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } /** * Returns the base system type for Transactions from the system namespace * * @return {string} the short name of the base system type */ getSystemType() { return 'Transaction'; } /** * Semantic validation of the structure of this asset. Subclasses should * override this method to impose additional semantic constraints on the * contents/relations of fields. * * @throws {IllegalModelException} * @private */ validate() { super.validate(); if(!this.isSystemType() &amp;&amp; this.getName() === 'Transaction') { throw new IllegalModelException('Transaction is a reserved type name.', this.modelFile, this.ast.location); } let systemTypeDeclared = true; // If using models without importing system models try { this.getModelFile().getType(ModelUtil.getSystemNamespace() + '.' + this.getSystemType()); } catch (e) { systemTypeDeclared = false; } if (!this.isSystemType() &amp;&amp; this.idField &amp;&amp; systemTypeDeclared) { throw new IllegalModelException('Transaction should not specify an identifying field.', this.modelFile, this.ast.location); } } } module.exports = TransactionDeclaration; × Search results Close "},"composer-common_lib_model_typed.js.html":{"id":"composer-common_lib_model_typed.js.html","title":"Source: composer-common/lib/model/typed.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/model/typed.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Field = require('../introspect/field'); const ModelUtil = require('../modelutil'); /** * Object is an instance with a namespace and a type. * * This class is abstract. * @abstract * @class * @memberof module:composer-common */ class Typed { /** * Create an instance. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @private */ constructor(modelManager, ns, type) { this.$modelManager = modelManager; this.$namespace = ns; this.$type = type; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Get the ModelManager for this instance * @return {ModelManager} The ModelManager for this object * @private */ getModelManager() { return this.$modelManager; } /** * Get the type of the instance (a short name, not including namespace). * @return {string} The type of this object */ getType() { return this.$type; } /** * Get the fully-qualified type name of the instance (including namespace). * @return {string} The fully-qualified type name of this object */ getFullyQualifiedType() { return ModelUtil.getFullyQualifiedName(this.$namespace, this.$type); } /** * Get the namespace of the instance. * @return {string} The namespace of this object */ getNamespace() { return this.$namespace; } /** * Returns the class declaration for this instance object. * * @return {ClassDeclaration} - the class declaration for this instance * @throws {Error} - if the class or namespace for the instance is not declared * @private */ getClassDeclaration() { // do we have a model file? let modelFile = this.getModelManager().getModelFile(this.getNamespace()); if (!modelFile) { throw new Error('No model for namespace ' + this.getNamespace() + ' is registered with the ModelManager'); } // do we have a class? let classDeclaration = modelFile.getType(this.getType()); if (!classDeclaration) { throw new Error('The namespace ' + this.getNamespace() + ' does not contain the type ' + this.getType()); } return classDeclaration; } /** * Sets a property on this Resource * @param {string} propName - the name of the field * @param {string} value - the value of the property */ setPropertyValue(propName, value) { this[propName] = value; } /** * Adds a value to an array property on this Resource * @param {string} propName - the name of the field * @param {string} value - the value of the property */ addArrayValue(propName, value) { if(this[propName]) { this[propName].push(value); } else { this[propName] = [value]; } } /** * Sets the fields to their default values, based on the model * @private */ assignFieldDefaults() { let classDeclaration = this.getClassDeclaration(); let fields = classDeclaration.getProperties(); for (let n = 0; n &lt; fields.length; n++) { let field = fields[n]; if (field instanceof Field) { let defaultValue = field.getDefaultValue(); if (defaultValue) { if (field.getType() === 'String') { this.setPropertyValue(field.getName(), defaultValue); } else if (field.getType() === 'Integer') { this.setPropertyValue(field.getName(), parseInt(defaultValue)); } else if (field.getType() === 'Long') { this.setPropertyValue(field.getName(), parseInt(defaultValue)); } else if (field.getType() === 'Double') { this.setPropertyValue(field.getName(), parseFloat(defaultValue)); } else if (field.getType() === 'Boolean') { this.setPropertyValue(field.getName(), (defaultValue === 'true')); } else if (field.getType() === 'DateTime') { const dateTime = new Date(); dateTime.setTime(Date.parse(defaultValue)); this.setPropertyValue(field.getName(), dateTime); } } } } } /** * Check to see if this instance is an instance of the specified fully qualified * type name. * @param {String} fqt The fully qualified type name. * @returns {boolean} True if this instance is an instance of the specified fully * qualified type name, false otherwise. */ instanceOf(fqt) { const classDeclaration = this.getClassDeclaration(); return classDeclaration.getFullyQualifiedName() === fqt || classDeclaration.getAllSuperTypeDeclarations().some(declaration =&gt; declaration.getFullyQualifiedName() === fqt); } /** * Overriden to prevent people accidentally converting a resource to JSON * without using the Serializer. * @private */ toJSON() { throw new Error('Use Serializer.toJSON to convert resource instances to JSON objects.'); } } module.exports = Typed; × Search results Close "},"composer-common_lib_serializer_typedstack.js.html":{"id":"composer-common_lib_serializer_typedstack.js.html","title":"Source: composer-common/lib/serializer/typedstack.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/serializer/typedstack.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Util = require('../util'); /** * Tracks a stack of typed instances. The type information is used to detect * overflow / underflow bugs by the caller. It also performs basic sanity * checking on push/pop to make detecting bugs easier. * @private * @class * @memberof module:composer-common */ class TypedStack { /** * Create the Stack with the resource at the head. * @param {Object} resource - the resource to be put at the head of the stack */ constructor(resource) { this.stack = []; this.push(resource); } /** * Push a new object. * @param {Object} obj - the object being visited * @param {Object} expectedType - the expected type of the object being pushed */ push(obj, expectedType) { if(expectedType &amp;&amp; !(obj instanceof expectedType)) { throw new Error('Did not find expected type ' + expectedType.constructor.name + ' as argument to push. Found: ' + obj.toString()); } if(Util.isNull(obj)) { throw new Error('Pushing null data!'); } this.stack.push(obj); //console.log('Push depth is: ' + this.stack.length + ', contents: ' + this.stack.toString() ); } /** * Push a new object. * @param {Object} expectedType - the type that should be the result of pop * @return {Object} the result of pop */ pop(expectedType) { this.peek(expectedType); return this.stack.pop(); } /** * Peek the top of the stack * @param {Object} expectedType - the type that should be the result of pop * @return {Object} the result of peek */ peek(expectedType) { //console.log( 'pop ' ); if(this.stack.length &lt; 1) { throw new Error('Stack is empty!'); } const result = this.stack[this.stack.length-1]; if(expectedType &amp;&amp; !(result instanceof expectedType)) { throw new Error('Did not find expected type ' + expectedType + ' on head of stack. Found: ' + result); } if(Util.isNull(result)) { throw new Error('Pop returned invalid data'); } return result; } /** * Clears the stack */ clear() { this.stack = []; } } module.exports = TypedStack; × Search results Close "},"composer-common_lib_typenotfoundexception.js.html":{"id":"composer-common_lib_typenotfoundexception.js.html","title":"Source: composer-common/lib/typenotfoundexception.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/typenotfoundexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BaseException = require('./baseexception'); const Globalize = require('./globalize'); /** * Error thrown when a Composer type does not exist. * @extends BaseException * @see See [BaseException]{@link module:composer-common.BaseException} * @class * @memberof module:composer-common */ class TypeNotFoundException extends BaseException { /** * Constructor. If the optional 'message' argument is not supplied, it will be set to a default value that * includes the type name. * @param {String} typeName - fully qualified type name. * @param {String} [message] - error message. */ constructor(typeName, message) { if (!message) { const formatter = Globalize.messageFormatter('typenotfounderror-defaultmessage'); message = formatter({ typeName: typeName }); } super(message); this.typeName = typeName; } /** * Get the name of the type that was not found. * @returns {string} fully qualified type name. */ getTypeName() { return this.typeName; } } module.exports = TypeNotFoundException; × Search results Close "},"composer-common_lib_util.js.html":{"id":"composer-common_lib_util.js.html","title":"Source: composer-common/lib/util.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/util.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Globalize = require('./globalize'); const SecurityContext = require('./securitycontext'); const SecurityException = require('./securityexception'); const uuid = require('uuid'); /** * Internal Utility Class * &lt;p&gt;&lt;a href=&quot;./diagrams-private/util.svg&quot;&gt;&lt;img src=&quot;./diagrams-private/util.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @private * @class * @memberof module:composer-common */ class Util { /** * Internal method to check the security context * @param {SecurityContext} securityContext - The user's security context * @throws {SecurityException} if the user context is invalid */ static securityCheck(securityContext) { if (Util.isNull(securityContext)) { throw new SecurityException(Globalize.formatMessage('composer-connect-notconnected')); } else if (!(securityContext instanceof SecurityContext)) { throw new SecurityException(Globalize.formatMessage('util-securitycheck-novalidcontext')); } } /** * Submit a query request to the chain-code * @param {SecurityContext} securityContext - The user's security context * @param {string} functionName - The name of the function to call. * @param {string[]} args - The arguments to pass to the function being called. * @return {Promise} - A promise that will be resolved with the value returned * by the chain-code function. */ static queryChainCode(securityContext, functionName, args) { Util.securityCheck(securityContext); if (!functionName) { throw new Error('functionName not specified'); } else if (!args) { throw new Error('args not specified'); } args.forEach((arg,index) =&gt; { if (typeof arg === 'boolean') { args[index] = arg.toString(); } else if (typeof arg !== 'string') { throw new Error('invalid arg specified: ' + arg); } }); return securityContext.getConnection().queryChainCode(securityContext, functionName, args); } /** * Submit an invoke request to the chain-code * @param {SecurityContext} securityContext - The user's security context * @param {string} functionName - The name of the function to call. * @param {string[]} args - The arguments to pass to the function being called. * @param {Object} options - options to pass to the invoking chain code * @param {Object} options.transactionId Transaction Id to use. * @return {Promise} - A promise that will be resolved with the value returned * by the chain-code function. */ static invokeChainCode(securityContext, functionName, args, options) { Util.securityCheck(securityContext); if (!functionName) { throw new Error('functionName not specified'); } else if (!args) { throw new Error('args not specified'); } options = options || {}; args.forEach((arg) =&gt; { if (typeof arg !== 'string') { throw new Error('invalid arg specified: ' + arg); } }); return securityContext.getConnection().invokeChainCode(securityContext, functionName, args, options); } /** * Returns true if the typeof the object === 'undefined' or * the object === null. * @param {Object} obj - the object to be tested * @returns {boolean} true if the object is null or undefined */ static isNull(obj) { return(typeof(obj) === 'undefined' || obj === null); } /** Obtain a UUID for use as a TransactionId * @param {SecurityContext} securityContext - The user's security context * @return {Promise} resolved with an object representing the transaction Id to be used later when invoking chain code * Strutcure of this object is { id: &lt;id object&gt;, idStr:&lt;string representation&gt;} */ static createTransactionId(securityContext){ Util.securityCheck(securityContext); return securityContext.getConnection().createTransactionId(securityContext) .then((id)=&gt;{ if (this.isNull(id)){ let tempId = uuid.v4(); return {id:tempId, idStr:tempId}; } return id; }); } } module.exports = Util; × Search results Close "},"composer-common_lib_model_validatedconcept.js.html":{"id":"composer-common_lib_model_validatedconcept.js.html","title":"Source: composer-common/lib/model/validatedconcept.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/model/validatedconcept.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Concept = require('./concept'); const TypedStack = require('../serializer/typedstack'); /** * &lt;p&gt; * Resource is an instance that has a type. The type of the resource * specifies a set of properites (which themselves have types). * &lt;/p&gt; * &lt;p&gt; * Type information in Composer is used to validate the structure of * Resource instances and for serialization. * &lt;/p&gt; * &lt;p&gt; * Resources are used in Composer to represent Assets, Participants, Transactions and * other domain classes that can be serialized for long-term persistent storage. * &lt;/p&gt; * @extends Identifiable * @see See [Resource]{@link module:composer-common.Resource} * @class * @memberof module:composer-common */ class ValidatedConcept extends Concept { /** * This constructor should not be called directly. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {ResourceValidator} resourceValidator - The validator to use for this instance * @private */ constructor(modelManager, ns, type, resourceValidator) { super(modelManager, ns, type); this.$validator = resourceValidator; } /** * Sets a property, validating that it does not violate the model * @param {string} propName - the name of the field * @param {string} value - the value of the property * @throws {Error} if the value is not compatible with the model definition for the field */ setPropertyValue(propName, value) { let classDeclaration = this.getClassDeclaration(); let field = classDeclaration.getProperty(propName); if (!field) { throw new Error('Trying to set field ' + propName + ' which is not declared in the model.'); } // else { // this.log( 'Validating field ' + field + ' with data ' + value ); // } const parameters = {}; parameters.stack = new TypedStack(value); parameters.modelManager = this.getModelManager(); parameters.rootResourceIdentifier = 'undefined'; field.accept(this.$validator, parameters); super.setPropertyValue(propName,value); } /** * Adds an array property value, validating that it does not violate the model * @param {string} propName - the name of the field * @param {string} value - the value of the property * @throws {Error} if the value is not compatible with the model definition for the field */ addArrayValue(propName, value) { let classDeclaration = this.getClassDeclaration(); let field = classDeclaration.getProperty(propName); if (!field) { throw new Error('Trying to set field ' + propName + ' which is not declared in the model.'); } if (!field.isArray()) { throw new Error('Trying to add array item ' + propName + ' which is not declared as an array in the model.'); } const parameters = {}; let newArray = []; if(this[propName]) { newArray = this[propName].slice(0); } newArray.push(value); parameters.stack = new TypedStack(newArray); parameters.modelManager = this.getModelManager(); parameters.rootResourceIdentifier = 'undefined'; field.accept(this.$validator, parameters); super.addArrayValue(propName, value); } /** * Validates the instance against its model. * * @throws {Error} - if the instance if invalid with respect to the model */ validate() { const classDeclaration = this.getClassDeclaration(); const parameters = {}; parameters.stack = new TypedStack(this); parameters.modelManager = this.getModelManager(); parameters.rootResourceIdentifier = 'undefined'; classDeclaration.accept(this.$validator, parameters); } } module.exports = ValidatedConcept; × Search results Close "},"composer-common_lib_model_validatedresource.js.html":{"id":"composer-common_lib_model_validatedresource.js.html","title":"Source: composer-common/lib/model/validatedresource.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/model/validatedresource.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const TypedStack = require('../serializer/typedstack'); const Resource = require('./resource'); /** * ValidatedResource is a Resource that can validate that property * changes (or the whole instance) do not violate the structure of * the type information associated with the instance. * @extends Resource * @see See [Resource]{@link module:composer-common.Resource} * @class * @memberof module:composer-common */ class ValidatedResource extends Resource { /** * This constructor should not be called directly. * Use the Factory class to create instances. * * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {string} id - The identifier of this instance. * @param {ResourceValidator} resourceValidator - The validator to use for this instance * @private */ constructor(modelManager, ns, type, id,resourceValidator) { super(modelManager, ns, type, id); this.$validator = resourceValidator; } /** * Sets a property, validating that it does not violate the model * @param {string} propName - the name of the field * @param {string} value - the value of the property * @throws {Error} if the value is not compatible with the model definition for the field */ setPropertyValue(propName, value) { let classDeclaration = this.getClassDeclaration(); let field = classDeclaration.getProperty(propName); if (!field) { throw new Error('The instance with id ' + this.getIdentifier() + ' trying to set field ' + propName + ' which is not declared in the model.'); } // else { // this.log( 'Validating field ' + field + ' with data ' + value ); // } const parameters = {}; parameters.stack = new TypedStack(value); parameters.modelManager = this.getModelManager(); parameters.rootResourceIdentifier = this.getFullyQualifiedIdentifier(); field.accept(this.$validator, parameters); super.setPropertyValue(propName,value); } /** * Adds an array property value, validating that it does not violate the model * @param {string} propName - the name of the field * @param {string} value - the value of the property * @throws {Error} if the value is not compatible with the model definition for the field */ addArrayValue(propName, value) { let classDeclaration = this.getClassDeclaration(); let field = classDeclaration.getProperty(propName); if (!field) { throw new Error('The instance with id ' + this.getIdentifier() + ' trying to set field ' + propName + ' which is not declared in the model.'); } if (!field.isArray()) { throw new Error('The instance with id ' + this.getIdentifier() + ' trying to add array item ' + propName + ' which is not declared as an array in the model.'); } const parameters = {}; let newArray = []; if(this[propName]) { newArray = this[propName].slice(0); } newArray.push(value); parameters.stack = new TypedStack(newArray); parameters.modelManager = this.getModelManager(); parameters.rootResourceIdentifier = this.getFullyQualifiedIdentifier(); field.accept(this.$validator, parameters); super.addArrayValue(propName, value); } /** * Validates the instance against its model. * * @throws {Error} - if the instance if invalid with respect to the model */ validate() { const classDeclaration = this.getClassDeclaration(); const parameters = {}; parameters.stack = new TypedStack(this); parameters.modelManager = this.getModelManager(); parameters.rootResourceIdentifier = this.getFullyQualifiedIdentifier(); classDeclaration.accept(this.$validator, parameters); } } module.exports = ValidatedResource; × Search results Close "},"composer-common_lib_serializer_validationexception.js.html":{"id":"composer-common_lib_serializer_validationexception.js.html","title":"Source: composer-common/lib/serializer/validationexception.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/serializer/validationexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BaseException = require('../baseexception'); /** * Exception thrown when a resource fails to model against the model * @extends BaseException * @see See [BaseException]{@link module:composer-common.BaseException} * @class * @memberof module:composer-common */ class ValidationException extends BaseException { /** * Create an ParseException * @param {string} message - the message for the exception */ constructor(message) { super(message); } } module.exports = ValidationException; × Search results Close "},"composer-common_lib_introspect_validator.js.html":{"id":"composer-common_lib_introspect_validator.js.html","title":"Source: composer-common/lib/introspect/validator.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/validator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * An Abstract field validator. Extend this class and override the * validate method. * @private * @class * @abstract * @memberof module:composer-common */ class Validator { /** * Create a Property. * @param {Field} field - the field this validator is attached to * @param {Object} validator - The validation string * @throws {IllegalModelException} */ constructor(field, validator) { this.validator = validator; this.field = field; } /** * @param {string} id the identifier of the instance * @param {string} msg the exception message * @throws {Error} throws an error to report the message */ reportError(id, msg) { throw new Error( 'Invalid validator for field ' + id + ' ' + this.getField().getFullyQualifiedName() + ': ' + msg ); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the field that this validator applies to * @return {Field} the field */ getField() { return this.field; } /** * Validate the property against a value * @param {string} identifier the identifier of the instance being validated * @param {Object} value the value to validate * @throws {IllegalModelException} * @private */ validate(identifier, value) { } } module.exports = Validator; × Search results Close "},"composer-common_lib_tools_versionchecker.js.html":{"id":"composer-common_lib_tools_versionchecker.js.html","title":"Source: composer-common/lib/tools/versionchecker.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/tools/versionchecker.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const crypto = require('crypto'); const semver = require('semver'); /** * Checks that a change log file takes into account * the signature of a public API (tracks API breakage) * and that the version number in package.json is in sync * with the contents of the changelog. * @private * @class * @memberof module:composer-common */ class VersionChecker { /** * @param {string} changelog - the text of a changelog file * @param {string} publicApi - the text of a public API description * @param {string} packageJson - the text of a package.json file * @returns {boolean} true if the version check passes * @throws {Error} if there is an issue with the version check */ static check(changelog, publicApi, packageJson) { const changelogLines = changelog.split('\\n'); const digest = VersionChecker.getDigest(publicApi); let result = false; for (let n = 0; n &lt; changelogLines.length; n++) { const line = changelogLines[n]; if (!line.startsWith('#')) { // find the first instance of 'Version' const versionIndex = line.indexOf('Version'); if (versionIndex &gt;= 0) { // find the version number const openBraceIndex = line.indexOf('{', versionIndex); if (openBraceIndex &lt; 0) { throw new Error('Invalid changelog, failed to find { in line ' + line); } const version = line.substring(versionIndex + 'Version'.length, openBraceIndex).trim(); // check the version in package.json is up to date const packageObj = JSON.parse(packageJson); if (!semver.lte(version, packageObj.version)) { throw new Error(`The version in the changelog file &quot;${version}&quot; is not less than or equal to the version in package.json &quot;${packageObj.version}&quot;.`); } // get MD5 const closeBraceIndex = line.indexOf('}', openBraceIndex); if (closeBraceIndex &lt; 0) { throw new Error('Invalid changelog, failed to find } in line ' + line); } const md5 = line.substring(openBraceIndex + 1, closeBraceIndex).trim(); if (digest !== md5) { throw new Error('Computed public API digest did not match the digest in the changelog for the most recent version. ' + 'Increment the version number and add a new entry to the changelog (explaining your public API change) using the digest ' + digest + '. Run \\'git diff api.txt\\' to understand the pubic API changes.'); } // we're done here... result = true; break; } } } if (!result) { throw new Error('Did not find any version in changelog'); } else { console.log('SUCCESS: validated public API against package.json and changelog.txt.'); } return true; } /** * Gets the digest (hash) for an input string * @param {string} data - the data to hash * @returns {string} the hash in hex format */ static getDigest(data) { return crypto.createHash('md5').update(data).digest('hex'); } } module.exports = VersionChecker; × Search results Close "},"composer-common_lib_query_where.js.html":{"id":"composer-common_lib_query_where.js.html","title":"Source: composer-common/lib/query/where.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/query/where.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const InvalidQueryException = require('./invalidqueryexception'); const WhereAstValidator = require('./whereastvalidator'); /** * Where defines the WHERE portion of a SELECT statement * * @private * @class * @memberof module:composer-common */ class Where { /** * Create a Where from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {Select} select - the Select for this Where * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(select, ast) { if(!select || !ast) { throw new InvalidQueryException('Invalid Select or AST'); } this.ast = ast; this.select = select; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the Select that owns this Where. * * @return {Select} the owning Select */ getSelect() { return this.select; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { } /** * Semantic validation of the structure of this where. * * @throws {IllegalModelException} * @private */ validate() { try { const wv = new WhereAstValidator(this.getSelect().getResourceClassDeclaration()); wv.visit(this.getAST(), {}); } catch(err) { if(err instanceof InvalidQueryException === false) { // console.log(err.stack); let msg = err.message; if(err.getShortMessage) { msg = err.getShortMessage(); } throw new InvalidQueryException( 'Invalid WHERE clause in query ' + this.getSelect().getQuery().getName() + ': ' + msg, this.getSelect().getQuery().getQueryFile(), this.getSelect().getAST().location ); } throw err; } } /** * Return the AST for this where statement. * @return {Object} The AST for this where statement. */ getAST() { return this.ast; } } module.exports = Where; × Search results Close "},"composer-common_lib_codegen_writer.js.html":{"id":"composer-common_lib_codegen_writer.js.html","title":"Source: composer-common/lib/codegen/writer.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/codegen/writer.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Writer buffers text to be written in memory. It handles simple * indentation and tracks the number of lines written. * @private * @class * @memberof module:composer-common */ class Writer { /** * Create a Writer. * */ constructor() { this.beforeBuffer = ''; this.buffer = ''; this.linesWritten = 0; } /** * Writes text to the start of the buffer * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeBeforeLine(tabs,text) { for(let n=0; n &lt; tabs; n++) { this.beforeBuffer += ' '; } this.beforeBuffer += text; this.beforeBuffer += '\\n'; this.linesWritten++; } /** * Append text to the buffer * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeLine(tabs,text) { for(let n=0; n &lt; tabs; n++) { this.write(' '); } this.write(text); this.write('\\n'); this.linesWritten++; } /** * Returns the number of lines that have been written to the buffer. * @return {int} the number of lines written to the buffer. */ getLineCount() { return this.linesWritten; } /** * Append text to the buffer, prepending tabs * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeIndented(tabs,text) { for(let n=0; n &lt; tabs; n++) { this.write(' '); } this.write(text); } /** * Append text to the buffer (no automatic newline). The * text may contain newline, and these will increment the linesWritten * counter. * @param {string} msg - the text to write */ write(msg) { if(typeof msg !== 'string' ) { throw new Error('Can only append strings. Argument ' + msg + ' has type ' + typeof msg); } this.buffer += msg; this.linesWritten += msg.split(/\\r\\n|\\r|\\n/).length; } /** * Returns the text that has been buffered in this Writer. * @return {string} the buffered text. */ getBuffer() { return this.beforeBuffer + this.buffer; } /** * Empties the underyling buffer and resets the line count. */ clearBuffer() { this.beforeBuffer = ''; this.buffer = ''; this.linesWritten = 0; } } module.exports = Writer; × Search results Close "},"composer-runtime_index.js.html":{"id":"composer-runtime_index.js.html","title":"Source: composer-runtime/index.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/index.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * The runtime module provides the API that is made available to transaction * processing functions. * @module composer-runtime */ module.exports.Container = require('./lib/container'); module.exports.Context = require('./lib/context'); module.exports.DataCollection = require('./lib/datacollection'); module.exports.DataService = require('./lib/dataservice'); module.exports.Engine = require('./lib/engine'); module.exports.HTTPService = require('./lib/httpservice'); module.exports.EventService = require('./lib/eventservice'); module.exports.IdentityService = require('./lib/identityservice'); module.exports.LoggingService = require('./lib/loggingservice'); module.exports.ScriptCompiler = require('./lib/scriptcompiler'); × Search results Close "},"composer-runtime_lib_accesscontroller.js.html":{"id":"composer-runtime_lib_accesscontroller.js.html","title":"Source: composer-runtime/lib/accesscontroller.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/accesscontroller.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AccessException = require('./accessexception'); const Logger = require('composer-common').Logger; const ModelUtil = require('composer-common').ModelUtil; const LOG = Logger.getLog('AccessController'); /** * A class that manages access to registries and resources by processing * the access control list(s) in a business network definition. * @private * @class * @memberof module:composer-runtime */ class AccessController { /** * Constructor. * @param {Context} context The transaction context. */ constructor(context) { const method = 'constructor'; LOG.entry(method, context); this.context = context; this.participant = null; this.transaction = null; LOG.exit(method); } /** * Get the current participant. * @return {Resource} The current participant. */ getParticipant() { return this.participant; } /** * Set the current participant. * @param {Resource} participant The current participant. */ setParticipant(participant) { this.participant = participant; } /** * Get the current transaction. * @return {Resource} The current transaction. */ getTransaction() { return this.transaction; } /** * Set the current transaction. * @param {Resource} transaction The current transaction. */ setTransaction(transaction) { this.transaction = transaction; } /** * Check that the specified participant has the specified * level of access to the specified resource. * @param {Resource} resource The resource. * @param {string} access The level of access. * @param {Resource} participant The participant. * @return {Promise} A promise that is resolved if the specified * participant has the specified level of access to the specified * resource, or rejected otherwise. */ check(resource, access) { const method = 'check'; LOG.entry(method, resource.getFullyQualifiedIdentifier(), access); // Check to see if a participant has been set. If not, then ACL // enforcement is not enabled. let participant = this.participant; if (!participant) { LOG.debug(method, 'No participant'); LOG.exit(method); return Promise.resolve(); } // Grab the transaction. Does not matter if this is null. let transaction = this.transaction; // Check to see if an ACL file was supplied. If not, then ACL // enforcement is not enabled. let aclManager = this.context.getAclManager(); if (!aclManager.getAclFile()) { LOG.debug(method, 'No ACL file'); LOG.exit(method); return Promise.resolve(); } // Iterate over the ACL rules in order, but stop at the first rule // that permits the action. let aclRules = aclManager.getAclRules(); return aclRules.reduce((promise, aclRule) =&gt; { return promise.then((result) =&gt; { if (result) { return result; } LOG.debug(method, 'Processing rule', aclRule); let value = this.checkRule(resource, access, participant, transaction, aclRule); LOG.debug(method, 'Processed rule', value); return value; }); }, Promise.resolve(false)) .then((result) =&gt; { // If a ACL rule permitted the action, return. if (result) { LOG.exit(method); return; } // Otherwise no ACL rule permitted the action. throw new AccessException(resource, access, participant, transaction); }) .catch((error) =&gt; { LOG.error(method, error); throw error; }); } /** * Check the specified ACL rule permits the specified level * of access to the specified resource. * @param {Resource} resource The resource. * @param {string} access The level of access. * @param {Resource} participant The participant. * @param {Resource} transaction The transaction. * @param {AclRule} aclRule The ACL rule. * @returns {boolean} True if the specified ACL rule permits * the specified level of access to the specified resource. */ checkRule(resource, access, participant, transaction, aclRule) { const method = 'checkRule'; LOG.entry(method, resource, access, participant, transaction, aclRule); // Is the ACL rule relevant to the specified noun? if (!this.matchNoun(resource, aclRule)) { LOG.debug(method, 'Noun does not match'); LOG.exit(method, false); return Promise.resolve(false); } // Is the ACL rule relevant to the specified verb? if (!this.matchVerb(access, aclRule)) { LOG.debug(method, 'Verb does not match'); LOG.exit(method, false); return Promise.resolve(false); } // Is the ACL rule relevant to the specified participant? if (!this.matchParticipant(participant, aclRule)) { LOG.debug(method, 'Participant does not match'); LOG.exit(method, false); return Promise.resolve(false); } // Is the ACL rule relevant to the specified transaction? if (!this.matchTransaction(transaction, aclRule)) { LOG.debug(method, 'Transaction does not match'); LOG.exit(method, false); return Promise.resolve(false); } // Is the predicate met? return this.matchPredicate(resource, participant, transaction, aclRule) .then((result) =&gt; { // No, predicate not met. if (!result) { LOG.debug(method, 'Predicate does not match'); LOG.exit(method, false); return false; } // Yes, predicate met, is this an allow or deny rule? if (aclRule.getAction() === 'ALLOW') { LOG.exit(method, true); return true; } // This must be an explicit deny rule, so throw. let e = new AccessException(resource, access, participant, transaction); LOG.error(method, e); throw e; }); } /** * Check that the specified participant has the specified * level of access to the specified resource. * @param {Resource} resource The resource. * @param {AclRule} aclRule The ACL rule. * @returns {boolean} True if the specified ACL rule permits * the specified level of access to the specified resource. */ matchNoun(resource, aclRule) { const method = 'matchNoun'; LOG.entry(method, resource.getFullyQualifiedIdentifier(), aclRule); // Determine the input ID. let id = resource.getIdentifier(); // Check to see if the resource is an instance of the // required resource type, or is in the required // namespace. let noun = aclRule.getNoun(); let reqFQN = noun.getFullyQualifiedName(); if (!ModelUtil.isMatchingType(resource, reqFQN)) { LOG.exit(method, false); return false; } // Check to see if the identifier matches (if specified). let reqID = noun.getInstanceIdentifier(); if (reqID) { if (id === reqID) { // Noun is matching identifier. } else { // Noun does not match. LOG.exit(method, false); return false; } } else { // Noun does not specify identifier. } LOG.exit(method, true); return true; } /** * Check that the specified participant has the specified * level of access to the specified resource. * @param {string} access The level of access. * @param {AclRule} aclRule The ACL rule. * @returns {boolean} True if the specified ACL rule permits * the specified level of access to the specified resource. */ matchVerb(access, aclRule) { const method = 'matchVerb'; LOG.entry(method, access, aclRule); // Check to see if the access matches the verb of the ACL rule. // Verb can be one of: // 'CREATE' / 'READ' / 'UPDATE' / 'ALL' / 'DELETE' let verbs = aclRule.getVerbs(); let result = verbs.some((verb) =&gt; { return verb === 'ALL' || access === verb; }); LOG.exit(method, result); return result; } /** * Check that the specified participant has the specified * level of access to the specified resource. * @param {Resource} participant The participant. * @param {AclRule} aclRule The ACL rule. * @returns {boolean} True if the specified ACL rule permits * the specified level of access to the specified resource. */ matchParticipant(participant, aclRule) { const method = 'matchParticipant'; LOG.entry(method, participant.getFullyQualifiedIdentifier(), aclRule); // Is a participant specified in the ACL rule? let reqParticipant = aclRule.getParticipant(); if (!reqParticipant) { LOG.exit(method, true); return true; } // Check to see if the participant is an instance of the // required participant type, or is in the required // namespace. let reqFQN = reqParticipant.getFullyQualifiedName(); if (!ModelUtil.isMatchingType(participant, reqFQN)) { LOG.exit(method, false); return false; } // Check to see if the identifier matches (if specified). let id = participant.getIdentifier(); let reqID = reqParticipant.getInstanceIdentifier(); if (reqID) { if (id === reqID) { // Participant is matching identifier. } else { // Participant does not match. LOG.exit(method, false); return false; } } else { // Participant does not specify identifier. } LOG.exit(method, true); return true; } /** * Check that the specified transaction has the specified * level of access to the specified resource. * @param {Resource} transaction The transaction. * @param {AclRule} aclRule The ACL rule. * @returns {boolean} True if the specified ACL rule permits * the specified level of access to the specified resource. */ matchTransaction(transaction, aclRule) { const method = 'matchTransaction'; LOG.entry(method, transaction ? transaction.getFullyQualifiedIdentifier() : transaction, aclRule); // Is a transaction specified in the ACL rule? let reqTransaction = aclRule.getTransaction(); if (!reqTransaction) { LOG.exit(method, true); return true; } // OK, a transaction is specified in the ACL rule, but // are we executing in the scope of a transaction? if (!transaction) { LOG.exit(method, false); return false; } // Check to see if the participant is an instance of the // required participant type, or is in the required // namespace. let reqFQN = reqTransaction.getFullyQualifiedName(); if (!ModelUtil.isMatchingType(transaction, reqFQN)) { LOG.exit(method, false); return false; } LOG.exit(method, true); return true; } /** * Check that the specified participant has the specified * level of access to the specified resource. * @param {Resource} resource The resource. * @param {Resource} participant The participant. * @param {Resource} transaction The transaction. * @param {AclRule} aclRule The ACL rule. * @returns {Promise} A promise that will be resolved with true if the specified ACL rule permits * the specified level of access to the specified resource, or false otherwise. */ matchPredicate(resource, participant, transaction, aclRule) { const method = 'matchPredicate'; LOG.entry(method, resource, participant, transaction, aclRule); // We want to permit access to related assets and participants, so prepare the resources. const compiledAclBundle = this.context.getCompiledAclBundle(); const resolver = this.context.getResolver(); let resolverPromise = Promise.resolve(), resolverCallbackCalled = false; const resolverCallback = (resolverPromise_) =&gt; { LOG.debug(method, 'Got resolver callback'); resolverCallbackCalled = true; resolverPromise = resolverPromise.then(() =&gt; { return resolverPromise_; }); }; let preparedResource, preparedParticipant, preparedTransaction; return Promise.resolve() .then(() =&gt; { // We should always have a resource to prepare. return resolver.prepare(resource, resolverCallback); }) .then((preparedResource_) =&gt; { // Save the prepared resource. preparedResource = preparedResource_; // We should always have a participant to prepare. return resolver.prepare(participant, resolverCallback); }) .then((preparedParticipant_) =&gt; { // Save the prepared participant. preparedParticipant = preparedParticipant_; // We may not have a transaction to prepare. if (transaction) { return resolver.prepare(transaction, resolverCallback); } }) .then((preparedTransaction_) =&gt; { // Save the prepared transaction. preparedTransaction = preparedTransaction_; // Now all the resources are prepared, loop until we are no longer resolving anything. const iteration = () =&gt; { LOG.debug(method, 'Executing compiled ACL predicate'); resolverCallbackCalled = false; const result = compiledAclBundle.execute(aclRule, preparedResource, preparedParticipant, preparedTransaction); if (resolverCallbackCalled) { return resolverPromise.then(() =&gt; { return iteration(); }); } else { return result; } }; return iteration(); }) .then((result) =&gt; { // Return the result, which should be a boolean. LOG.exit(method, result); return result; }); } } module.exports = AccessController; × Search results Close "},"composer-runtime_lib_accessexception.js.html":{"id":"composer-runtime_lib_accessexception.js.html","title":"Source: composer-runtime/lib/accessexception.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/accessexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BaseException = require('composer-common').BaseException; /** * Class representing an access exception * &lt;p&gt;&lt;a href=&quot;./diagrams/accessexception.svg&quot;&gt;&lt;img src=&quot;./diagrams/accessexception.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @protected * @extends BaseException * @see See [BaseException]{@link module:composer-common.BaseException} * @class * @memberof module:composer-runtime */ class AccessException extends BaseException { /** * Generate the exception message. * @param {Resource} resource The resource. * @param {string} access The level of access. * @param {Resource} participant The participant. * @param {Resource} transaction The transaction. * @return {string} The exception message. */ static generateMessage(resource, access, participant, transaction) { let resourceId = resource.getFullyQualifiedIdentifier(); let participantId = participant.getFullyQualifiedIdentifier(); return `Participant '${participantId}' does not have '${access}' access to resource '${resourceId}'`; } /** * Constructor. * @param {Resource} resource The resource. * @param {string} access The level of access. * @param {Resource} participant The participant. * @param {Resource} transaction The transaction. */ constructor(resource, access, participant, transaction) { super(AccessException.generateMessage(resource, access, participant, transaction)); } } module.exports = AccessException; × Search results Close "},"composer-runtime_lib_api_assetregistry.js.html":{"id":"composer-runtime_lib_api_assetregistry.js.html","title":"Source: composer-runtime/lib/api/assetregistry.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/api/assetregistry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const LOG = Logger.getLog('AssetRegistry'); /** * Do not attempt to create an instance of this class.&lt;br&gt; * You must use the {@link module:composer-runtime#getAssetRegistry getAssetRegistry} * method instead. * * @class AssetRegistry * @classdesc An asset registry manages a set of assets. * @memberof module:composer-runtime * @public */ class AssetRegistry { /** * Constructor. * @param {Registry} registry The registry to use. * @private */ constructor(registry) { const method = 'constructor'; LOG.entry(method, registry); /** * Get a list of all of the existing assets in this asset registry. * @example * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get all of the vehicles in the vehicle asset registry. * return assetRegistry.getAll(); * }) * .then(function (vehicles) { * // Process the array of vehicle objects. * vehicles.forEach(function (vehicle) { * console.log(vehicle.vehicleId); * }); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#getAll * @return {Promise} A promise. The promise is resolved with an array of * {@link Resource} instances representing all of the assets stored in this * asset registry. If the asset registry does not exist, or the current * user does not have access to the asset registry, then the promise will * be rejected with an error that describes the problem. */ this.getAll = function getAll() { return registry.getAll(); }; /** * Get the specified asset in this asset registry using the unique identifier * of the asset. * @example * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get the specific vehicle from the vehicle asset registry. * return assetRegistry.get('VEHICLE_1'); * }) * .then(function (vehicle) { * // Process the the vehicle object. * console.log(vehicle.vehicleId); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#get * @param {string} id The ID of the asset. * @return {Promise} A promise. The promise is resolved with a {@link Resource} * instance representing the specified asset in this asset registry. If the * specified asset does not exist, or the current user does not have access * to the specified asset, then the promise will be rejected with an error * that describes the problem. */ this.get = function get(id) { return registry.get(id); }; /** * Determines whether a specific asset exists in this asset registry. * @example * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Determine if the specific vehicle exists in the vehicle asset registry. * return assetRegistry.exists('VEHICLE_1'); * }) * .then(function (exists) { * // Process the the boolean result. * console.log('Vehicle exists', exists); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#exists * @param {string} id The ID of the asset. * @return {Promise} A promise. The promise is resolved with a boolean which * is true if the specified asset exists in this asset registry, and false * if the specified participant does not exist. */ this.exists = function exists(id) { return registry.exists(id); }; /** * Add all of the specified assets to this asset registry. * @example * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get the factory for creating new asset instances. * var factory = getFactory(); * // Create the first vehicle. * var vehicle1 = factory.newResource('org.acme', 'Vehicle', 'VEHICLE_1'); * vehicle1.colour = 'BLUE'; * // Create the second vehicle. * var vehicle2 = factory.newResource('org.acme', 'Vehicle', 'VEHICLE_2'); * vehicle2.colour = 'GREEN'; * // Add the vehicles to the vehicle asset registry. * return vehicleAssetRegistry.addAll([vehicle1, vehicle2]); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#addAll * @param {Resource[]} assets The assets to add to this asset registry. * @return {Promise} A promise. The promise is resolved when all of the * assets have been added to this asset registry. If the assets cannot be * added to this asset registry, or if the assets already exist in the * asset registry, then the promise will be rejected with an error * that describes the problem. */ this.addAll = function addAll(assets) { return registry.addAll(assets, { convertResourcesToRelationships: true }); }; /** * Add the specified asset to this asset registry. * @example * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get the factory for creating new asset instances. * var factory = getFactory(); * // Create the vehicle. * var vehicle = factory.newResource('org.acme', 'Vehicle', 'VEHICLE_1'); * vehicle.colour = 'BLUE'; * // Add the vehicle to the vehicle asset registry. * return vehicleAssetRegistry.add(vehicle); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#add * @param {Resource} asset The assets to add to this asset registry. * @return {Promise} A promise. The promise is resolved when the asset has * been added to this asset registry. If the asset cannot be added to this * asset registry, or if the asset already exists in the asset registry, * then the promise will be rejected with an error that describes the problem. */ this.add = function add(asset) { return registry.add(asset, { convertResourcesToRelationships: true }); }; /** * Update all of the specified assets in this asset registry. * @example * // The existing vehicles that have come from elsewhere. * var vehicle1; * var vehicle2; * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get the factory for creating new asset instances. * var factory = getFactory(); * // Modify the properties of the first vehicle. * vehicle1.colour = 'PURPLE'; * // Modify the properties of the second vehicle. * vehicle2.colour = 'ORANGE'; * // Update the vehicles in the vehicle asset registry. * return vehicleAssetRegistry.updateAll([vehicle1, vehicle2]); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#updateAll * @param {Resource[]} assets The assets to update in this asset registry. * @return {Promise} A promise. The promise is resolved when all of the * assets have been updated in this asset registry. If the assets cannot be * updated in this asset registry, or if the assets do not exist in the * asset registry, then the promise will be rejected with an error that * describes the problem. */ this.updateAll = function updateAll(assets) { return registry.updateAll(assets, { convertResourcesToRelationships: true }); }; /** * Update the specified asset in this asset registry. * @example * // The existing vehicle that has come from elsewhere. * var vehicle; * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get the factory for creating new asset instances. * var factory = getFactory(); * // Modify the properties of the vehicle. * vehicle.colour = 'PURPLE'; * // Update the vehicle in the vehicle asset registry. * return vehicleAssetRegistry.update(vehicle); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#update * @param {Resource} asset The asset to update in this asset registry. * @return {Promise} A promise. The promise is resolved when the asset * have been updated in this asset registry. If the asset cannot be * updated in this asset registry, or if the asset does not exist in the * asset registry, then the promise will be rejected with an error that * describes the problem. */ this.update = function update(asset) { return registry.update(asset, { convertResourcesToRelationships: true }); }; /** * Remove all of the specified assets from this asset registry. * @example * // The existing vehicles that have come from elsewhere. * var vehicle1; * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get the factory for creating new asset instances. * var factory = getFactory(); * // Remove the vehicles from the vehicle asset registry. Note that * // one vehicle is specified as a vehicle instance, and the other * // vehicle is specified by the ID of the vehicle. * return vehicleAssetRegistry.removeAll([vehicle1, 'VEHICLE_2']); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#removeAll * @param {string[]|Resource[]} assets The assets, or the IDs of the assets, * to remove from this asset registry. * @return {Promise} A promise. The promise is resolved when all of the * assets have been removed from this asset registry. If the assets cannot be * removed from this asset registry, or if the assets do not exist in the * asset registry, then the promise will be rejected with an error that * describes the problem. */ this.removeAll = function removeAll(assets) { return registry.removeAll(assets); }; /** * Remove the specified asset from this asset registry. * @example * // The existing vehicle that has come from elsewhere. * var vehicle; * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get the factory for creating new asset instances. * var factory = getFactory(); * // Remove the vehicle from the vehicle asset registry. * return vehicleAssetRegistry.remove(vehicle); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#remove * @param {string|Resource} asset The asset, or ID of the asset, to remove * from this asset registry. * @return {Promise} A promise. The promise is resolved when the asset * has been removed from this asset registry. If the asset cannot be * removed from this asset registry, or if the asset does not exist in the * asset registry, then the promise will be rejected with an error that * describes the problem. */ this.remove = function remove(asset) { return registry.remove(asset); }; Object.freeze(this); LOG.exit(method); } } module.exports = AssetRegistry; × Search results Close "},"composer-runtime_lib_container.js.html":{"id":"composer-runtime_lib_container.js.html","title":"Source: composer-runtime/lib/container.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/container.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * A class representing the chaincode container hosting the JavaScript engine. * @protected * @abstract * @memberof module:composer-runtime */ class Container { /** * Get the version of the chaincode container. * @abstract * @return {string} The version of the chaincode container. */ getVersion() { throw new Error('abstract function called'); } /** * Get the logging service provided by the chaincode container. * @abstract * @return {LoggingService} The logging service provided by the chaincode container. */ getLoggingService() { throw new Error('abstract function called'); } } module.exports = Container; × Search results Close "},"composer-runtime_lib_context.js.html":{"id":"composer-runtime_lib_context.js.html","title":"Source: composer-runtime/lib/context.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/context.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AclCompiler = require('./aclcompiler'); const AccessController = require('./accesscontroller'); const Api = require('./api'); const BusinessNetworkDefinition = require('composer-common').BusinessNetworkDefinition; const IdentityManager = require('./identitymanager'); const Logger = require('composer-common').Logger; const LRU = require('lru-cache'); const QueryCompiler = require('./querycompiler'); const RegistryManager = require('./registrymanager'); const ResourceManager = require('./resourcemanager'); const Resolver = require('./resolver'); const ScriptCompiler = require('./scriptcompiler'); const TransactionLogger = require('./transactionlogger'); const LOG = Logger.getLog('Context'); const businessNetworkCache = LRU(8); const compiledScriptBundleCache = LRU(8); const compiledQueryBundleCache = LRU(8); const compiledAclBundleCache = LRU(8); /** * A class representing the current request being handled by the JavaScript engine. * @protected * @abstract * @memberof module:composer-runtime */ class Context { /** * Store a business network in the cache. * @param {string} businessNetworkHash The hash of the business network definition. * @param {BusinessNetworkDefinition} businessNetworkDefinition The business network definition. */ static cacheBusinessNetwork(businessNetworkHash, businessNetworkDefinition) { const method = 'cacheBusinessNetwork'; LOG.entry(method, businessNetworkHash, businessNetworkDefinition); businessNetworkCache.set(businessNetworkHash, businessNetworkDefinition); LOG.exit(method); } /** * Get a compiled script bundle from the cache. * @param {string} businessNetworkHash The hash of the business network definition. * @return {CompiledScriptBundle} The cached compiled script bundle, or null if * there is no entry in the cache for the specified business network definition. */ static getCachedCompiledScriptBundle(businessNetworkHash) { const method = 'getCachedCompiledScriptBundle'; LOG.entry(method, businessNetworkHash); const result = compiledScriptBundleCache.get(businessNetworkHash); LOG.exit(method, result); return result; } /** * Store a compiled script bundle in the cache. * @param {string} businessNetworkHash The hash of the business network definition. * @param {CompiledScriptBundle} compiledScriptBundle The compiled script bundle. */ static cacheCompiledScriptBundle(businessNetworkHash, compiledScriptBundle) { const method = 'cacheCompiledScriptBundle'; LOG.entry(method, businessNetworkHash, compiledScriptBundle); compiledScriptBundleCache.set(businessNetworkHash, compiledScriptBundle); LOG.exit(method); } /** * Get a compiled query bundle from the cache. * @param {string} businessNetworkHash The hash of the business network definition. * @return {CompiledQueryBundle} The cached compiled query bundle, or null if * there is no entry in the cache for the specified business network definition. */ static getCachedCompiledQueryBundle(businessNetworkHash) { const method = 'getCachedCompiledQueryBundle'; LOG.entry(method, businessNetworkHash); const result = compiledQueryBundleCache.get(businessNetworkHash); LOG.exit(method, result); return result; } /** * Store a compiled query bundle in the cache. * @param {string} businessNetworkHash The hash of the business network definition. * @param {CompiledQueryBundle} compiledQueryBundle The compiled query bundle. */ static cacheCompiledQueryBundle(businessNetworkHash, compiledQueryBundle) { const method = 'cacheCompiledQueryBundle'; LOG.entry(method, businessNetworkHash, compiledQueryBundle); compiledQueryBundleCache.set(businessNetworkHash, compiledQueryBundle); LOG.exit(method); } /** * Get a compiled ACL bundle from the cache. * @param {string} businessNetworkHash The hash of the business network definition. * @return {CompiledAclBundle} The cached compiled ACL bundle, or null if * there is no entry in the cache for the specified business network definition. */ static getCachedCompiledAclBundle(businessNetworkHash) { const method = 'getCachedCompiledAclBundle'; LOG.entry(method, businessNetworkHash); const result = compiledAclBundleCache.get(businessNetworkHash); LOG.exit(method, result); return result; } /** * Store a compiled ACL bundle in the cache. * @param {string} businessNetworkHash The hash of the business network definition. * @param {CompiledAclBundle} compiledAclBundle The compiled ACL bundle. */ static cacheCompiledAclBundle(businessNetworkHash, compiledAclBundle) { const method = 'cacheCompiledAclBundle'; LOG.entry(method, businessNetworkHash, compiledAclBundle); compiledAclBundleCache.set(businessNetworkHash, compiledAclBundle); LOG.exit(method); } /** * Constructor. * @param {Engine} engine The chaincode engine that owns this context. */ constructor(engine) { this.engine = engine; this.function = null; this.arguments = null; this.businessNetworkDefinition = null; this.registryManager = null; this.resolver = null; this.api = null; this.identityManager = null; this.participant = null; this.transaction = null; this.accessController = null; this.sysregistries = null; this.eventNumber = 0; this.scriptCompiler = null; this.compiledScriptBundle = null; this.queryCompiler = null; this.compiledQueryBundle = null; this.aclCompiler = null; this.compiledAclBundle = null; this.loggingService = null; } /** * Get the name of the currently executing runtime method. * @return {string} The name of the currently executing runtime method. */ getFunction() { return this.function; } /** * Get the arguments for the currently executing runtime method. * @return {string} The arguments for the currently executing runtime method. */ getArguments() { return this.arguments; } /** * Load the business network record from the world state. * @return {Promise} A promise that will be resolved with the business network record * when complete, or rejected with an error. */ loadBusinessNetworkRecord() { const method = 'loadBusinessNetworkRecord'; LOG.entry(method); return this.getDataService().getCollection('$sysdata') .then((collection) =&gt; { LOG.debug(method, 'Getting business network archive from the $sysdata collection'); return collection.get('businessnetwork'); }) .then((object) =&gt; { // check if the network has been undeployed first. if is has throw exception. if (object.undeployed){ throw new Error('The business network has been undeployed'); } LOG.exit(method, object); return object; }); } /** * Load the business network definition. * @param {Object} businessNetworkRecord The business network record. * @return {Promise} A promise that will be resolved with a {@link BusinessNetworkDefinition} * when complete, or rejected with an error. */ loadBusinessNetworkDefinition(businessNetworkRecord) { const method = 'loadBusinessNetworkDefinition'; LOG.entry(method); LOG.debug(method, 'Looking in cache for business network', businessNetworkRecord.hash); let businessNetworkDefinition = businessNetworkCache.get(businessNetworkRecord.hash); if (businessNetworkDefinition) { LOG.debug(method, 'Business network is in cache'); return Promise.resolve(businessNetworkDefinition); } LOG.debug(method, 'Business network is not in cache, loading'); let businessNetworkArchive = Buffer.from(businessNetworkRecord.data, 'base64'); return BusinessNetworkDefinition.fromArchive(businessNetworkArchive) .then((businessNetworkDefinition) =&gt; { Context.cacheBusinessNetwork(businessNetworkRecord.hash, businessNetworkDefinition); LOG.exit(method, businessNetworkDefinition); return businessNetworkDefinition; }) .catch((error) =&gt; { LOG.error(method, error); throw error; }); } /** * Load or compile the compiled script bundle. * @param {Object} businessNetworkRecord The business network record. * @param {BusinessNetworkDefinition} businessNetworkDefinition The business network definition. * @return {Promise} A promise that will be resolved with a {@link BusinessNetworkDefinition} * when complete, or rejected with an error. */ loadCompiledScriptBundle(businessNetworkRecord, businessNetworkDefinition) { const method = 'loadCompiledScriptBundle'; LOG.entry(method); LOG.debug(method, 'Looking in cache for compiled script bundle', businessNetworkRecord.hash); let compiledScriptBundle = Context.getCachedCompiledScriptBundle(businessNetworkRecord.hash); if (compiledScriptBundle) { LOG.debug(method, 'Compiled script bundle is in cache'); return Promise.resolve(compiledScriptBundle); } LOG.debug(method, 'Compiled script bundle is not in cache, loading'); return Promise.resolve() .then(() =&gt; { let compiledScriptBundle = this.getScriptCompiler().compile(businessNetworkDefinition.getScriptManager()); Context.cacheCompiledScriptBundle(businessNetworkRecord.hash, compiledScriptBundle); LOG.exit(method, compiledScriptBundle); return compiledScriptBundle; }) .catch((error) =&gt; { LOG.error(method, error); throw error; }); } /** * Load or compile the compiled query bundle. * @param {Object} businessNetworkRecord The business network record. * @param {BusinessNetworkDefinition} businessNetworkDefinition The business network definition. * @return {Promise} A promise that will be resolved with a {@link BusinessNetworkDefinition} * when complete, or rejected with an error. */ loadCompiledQueryBundle(businessNetworkRecord, businessNetworkDefinition) { const method = 'loadCompiledQueryBundle'; LOG.entry(method); LOG.debug(method, 'Looking in cache for compiled query bundle', businessNetworkRecord.hash); let compiledQueryBundle = Context.getCachedCompiledQueryBundle(businessNetworkRecord.hash); if (compiledQueryBundle) { LOG.debug(method, 'Compiled query bundle is in cache'); return Promise.resolve(compiledQueryBundle); } LOG.debug(method, 'Compiled query bundle is not in cache, loading'); return Promise.resolve() .then(() =&gt; { let compiledQueryBundle = this.getQueryCompiler().compile(businessNetworkDefinition.getQueryManager()); Context.cacheCompiledQueryBundle(businessNetworkRecord.hash, compiledQueryBundle); LOG.exit(method, compiledQueryBundle); return compiledQueryBundle; }) .catch((error) =&gt; { LOG.error(method, error); throw error; }); } /** * Load or compile the compiled ACL bundle. * @param {Object} businessNetworkRecord The business network record. * @param {BusinessNetworkDefinition} businessNetworkDefinition The business network definition. * @return {Promise} A promise that will be resolved with a {@link BusinessNetworkDefinition} * when complete, or rejected with an error. */ loadCompiledAclBundle(businessNetworkRecord, businessNetworkDefinition) { const method = 'loadCompiledAclBundle'; LOG.entry(method); LOG.debug(method, 'Looking in cache for compiled ACL bundle', businessNetworkRecord.hash); let compiledAclBundle = Context.getCachedCompiledAclBundle(businessNetworkRecord.hash); if (compiledAclBundle) { LOG.debug(method, 'Compiled ACL bundle is in cache'); return Promise.resolve(compiledAclBundle); } LOG.debug(method, 'Compiled ACL bundle is not in cache, loading'); return Promise.resolve() .then(() =&gt; { let compiledAclBundle = this.getAclCompiler().compile(businessNetworkDefinition.getAclManager(), businessNetworkDefinition.getScriptManager()); Context.cacheCompiledAclBundle(businessNetworkRecord.hash, compiledAclBundle); LOG.exit(method, compiledAclBundle); return compiledAclBundle; }) .catch((error) =&gt; { LOG.error(method, error); throw error; }); } /** * Load the current participant. * @return {Promise} A promise that will be resolved with a {@link Resource} * when complete, or rejected with an error. */ loadCurrentParticipant() { const method = 'loadCurrentParticipant'; LOG.entry(method); // Load the current identity. return this.getIdentityManager().getIdentity() .then((identity) =&gt; { // Validate the identity. try { this.setIdentity(identity); this.getIdentityManager().validateIdentity(identity); } catch (e) { // Is this an activation transaction? let isActivation = false; try { if (this.getFunction() === 'submitTransaction') { const json = JSON.parse(this.getArguments()[0]); isActivation = json.$class === 'org.hyperledger.composer.system.ActivateCurrentIdentity'; } } catch (e) { // Ignore. } // Check for the case of activation required, and the user is trying to activate. if (e.activationRequired &amp;&amp; isActivation) { // Don't throw the error as we are activating the identity, but return null // so that the participant is not set because there is no current participant // until the identity is activated and not revoked. return null; } else { throw e; } } // Load the current participant. return this.getIdentityManager().getParticipant(identity); }) .then((participant) =&gt; { LOG.exit(method, participant); return participant; }); } /** * Get the business network definition to use. * @param {Object} [options] The options to use. * @param {BusinessNetworkDefinition} [options.businessNetworkDefinition] The business network definition to use. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ findBusinessNetworkDefinition(options) { const method = 'findBusinessNetworkDefinition'; LOG.entry(method, options); options = options || {}; return Promise.resolve() .then(() =&gt; { if (options.businessNetworkDefinition) { LOG.debug(method, 'Business network definition already specified'); return options.businessNetworkDefinition; } else { LOG.debug(method, 'Business network definition not specified, loading from world state'); return this.loadBusinessNetworkRecord() .then((businessNetworkRecord) =&gt; { return this.loadBusinessNetworkDefinition(businessNetworkRecord); }); } }) .then((businessNetworkDefinition) =&gt; { LOG.exit(method, businessNetworkDefinition); return businessNetworkDefinition; }); } /** * Get the compiled script bundle to use. * @param {BusinessNetworkDefinition} businessNetworkDefinition The business network definition to use. * @param {Object} [options] The options to use. * @param {CompiledScriptBundle} [options.compiledScriptBundle] The business network definition to use. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ findCompiledScriptBundle(businessNetworkDefinition, options) { const method = 'findCompiledScriptBundle'; LOG.entry(method, options); options = options || {}; return Promise.resolve() .then(() =&gt; { if (options.compiledScriptBundle) { LOG.debug(method, 'Compiled script bundle already specified'); return options.compiledScriptBundle; } else { LOG.debug(method, 'Compiled script bundle not specified, loading from world state'); return this.loadBusinessNetworkRecord() .then((businessNetworkRecord) =&gt; { return this.loadCompiledScriptBundle(businessNetworkRecord, businessNetworkDefinition); }); } }) .then((compiledScriptBundle) =&gt; { LOG.exit(method, compiledScriptBundle); return compiledScriptBundle; }); } /** * Get the compiled query bundle to use. * @param {BusinessNetworkDefinition} businessNetworkDefinition The business network definition to use. * @param {Object} [options] The options to use. * @param {CompiledQueryBundle} [options.compiledQueryBundle] The business network definition to use. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ findCompiledQueryBundle(businessNetworkDefinition, options) { const method = 'findCompiledQueryBundle'; LOG.entry(method, options); options = options || {}; return Promise.resolve() .then(() =&gt; { if (options.compiledQueryBundle) { LOG.debug(method, 'Compiled query bundle already specified'); return options.compiledQueryBundle; } else { LOG.debug(method, 'Compiled query bundle not specified, loading from world state'); return this.loadBusinessNetworkRecord() .then((businessNetworkRecord) =&gt; { return this.loadCompiledQueryBundle(businessNetworkRecord, businessNetworkDefinition); }); } }) .then((compiledQueryBundle) =&gt; { LOG.exit(method, compiledQueryBundle); return compiledQueryBundle; }); } /** * Get the compiled ACL bundle to use. * @param {BusinessNetworkDefinition} businessNetworkDefinition The business network definition to use. * @param {Object} [options] The options to use. * @param {CompiledAclBundle} [options.compiledAclBundle] The business network definition to use. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ findCompiledAclBundle(businessNetworkDefinition, options) { const method = 'findCompiledAclBundle'; LOG.entry(method, options); options = options || {}; return Promise.resolve() .then(() =&gt; { if (options.compiledAclBundle) { LOG.debug(method, 'Compiled ACL bundle already specified'); return options.compiledAclBundle; } else { LOG.debug(method, 'Compiled ACL bundle not specified, loading from world state'); return this.loadBusinessNetworkRecord() .then((businessNetworkRecord) =&gt; { return this.loadCompiledAclBundle(businessNetworkRecord, businessNetworkDefinition); }); } }) .then((compiledAclBundle) =&gt; { LOG.exit(method, compiledAclBundle); return compiledAclBundle; }); } /** * Initialize the context for use. * @param {Object} [options] The options to use. * @param {string} [options.function] The name of the currently executing runtime method. * @param {string} [options.arguments] The arguments for the currently executing runtime method. * @param {BusinessNetworkDefinition} [options.businessNetworkDefinition] The business network definition to use. * @param {CompiledScriptBundle} [options.compiledScriptBundle] The compiled script bundle to use. * @param {DataCollection} [options.sysregistries] The system registries collection to use. * @param {boolean} [options.reinitialize] Set to true if being reinitialized as a result of an upgrade to the * business network, falsey value if not. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ initialize(options) { const method = 'initialize'; LOG.entry(method, options); options = options || {}; this.function = options.function || this.function; this.arguments = options.arguments || this.arguments; this.container = options.container; return Promise.resolve() .then(() =&gt; { return this.findBusinessNetworkDefinition(options); }) .then((businessNetworkDefinition) =&gt; { LOG.debug(method, 'Got business network archive'); this.businessNetworkDefinition = businessNetworkDefinition; return this.findCompiledScriptBundle(this.businessNetworkDefinition, options); }) .then((compiledScriptBundle) =&gt; { LOG.debug(method, 'Got compiled script bundle'); this.compiledScriptBundle = compiledScriptBundle; return this.findCompiledQueryBundle(this.businessNetworkDefinition, options); }) .then((compiledQueryBundle) =&gt; { LOG.debug(method, 'Got compiled query bundle'); this.compiledQueryBundle = compiledQueryBundle; return this.findCompiledAclBundle(this.businessNetworkDefinition, options); }) .then((compiledAclBundle) =&gt; { LOG.debug(method, 'Got compiled ACL bundle'); this.compiledAclBundle = compiledAclBundle; LOG.debug(method, 'Loading sysregistries collection', options.sysregistries); if (options.sysregistries) { this.sysregistries = options.sysregistries; } else { return this.getDataService().getCollection('$sysregistries') .then((sysregistries) =&gt; { this.sysregistries = sysregistries; }); } }) .then(() =&gt; { if (options.function === 'init') { // No point loading the participant as no participants exist! LOG.debug(method, 'Not loading current participant as processing deployment'); return null; } else if (options.reinitialize) { // We don't want to change the participant in the middle of a update. LOG.debug(method, 'Reinitializing, not loading current participant'); return null; } else { LOG.debug(method, 'Loading current participant'); return this.loadCurrentParticipant(); } }) .then((participant) =&gt; { if (participant) { LOG.debug(method, 'Setting current participant', participant); this.setParticipant(participant); } else { // We don't want to change the participant in the middle of a update. LOG.debug(method, 'Deploying or reinitializing, not setting current participant'); } if (options.reinitialize) { // If we are reinitializing, things that are dependant on data in the // business network definition do need to be reset // TODO: Concerned about data migration when the model is changed. this.registryManager = null; this.resolver = null; this.resourceManager = null; this.identityManager = null; } return this.initializeInner(); }) .then(()=&gt;{ if (this.container){ this.loggingService = this.container.getLoggingService(); } }) .then(() =&gt; { LOG.exit(method); }); } /** * Perform additional initialization for the context. * @return {Promise} A promise that will be resolved when complete, or rejected with an error. */ initializeInner() { return new Promise((resolve, reject) =&gt; { this._initializeInner((error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback initializeInnerCallback * @protected * @param {Error} error The error if any. */ /** * Perform additional initialization for the context. * @abstract * @param {initializeInnerCallback} callback The callback function to call when complete. */ _initializeInner(callback) { callback(null); } /** * Get all of the services provided by the chaincode container. * @return {Service[]} All of the services provided by the chaincode container. */ getServices() { return [ this.getDataService(), this.getEventService(), this.getIdentityService(), this.getHTTPService() ]; } /** * Get the container. * @return {Container} The container. */ getContainer() { return this.container; } /** * Get the data service provided by the chaincode container. * @abstract * @return {DataService} The data service provided by the chaincode container. */ getDataService() { throw new Error('abstract function called'); } /** * Get the identity service provided by the chaincode container. * @abstract * @return {IdentityService} The identity service provided by the chaincode container. */ getIdentityService() { throw new Error('abstract function called'); } /** * Get the http service provided by the chaincode container. * @abstract * @return {HTTPService} The http service provided by the chaincode container. */ getHTTPService() { throw new Error('abstract function called'); } /** * Get the serializer. * @return {Serializer} The serializer. */ getSerializer() { if (!this.businessNetworkDefinition) { throw new Error('must call initialize before calling this function'); } return this.businessNetworkDefinition.getSerializer(); } /** * Get the event service provided by the chaincode container. * @abstract * @return {EventService} The event service provided by the chaincode container. */ getEventService() { throw new Error('abstract function called'); } /** * Get the model manager. * @return {ModelManager} The model manager. */ getModelManager() { if (!this.businessNetworkDefinition) { throw new Error('must call initialize before calling this function'); } return this.businessNetworkDefinition.getModelManager(); } /** * Get the script manager. * @return {ScriptManager} The script manager. */ getScriptManager() { if (!this.businessNetworkDefinition) { throw new Error('must call initialize before calling this function'); } return this.businessNetworkDefinition.getScriptManager(); } /** * Get the ACL manager. * @return {AclManager} The ACL manager. */ getAclManager() { if (!this.businessNetworkDefinition) { throw new Error('must call initialize before calling this function'); } return this.businessNetworkDefinition.getAclManager(); } /** * Get the factory. * @return {Factory} The factory. */ getFactory() { if (!this.businessNetworkDefinition) { throw new Error('must call initialize before calling this function'); } return this.businessNetworkDefinition.getFactory(); } /** * Get the introspector. * @return {Introspector} The serializer. */ getIntrospector() { if (!this.businessNetworkDefinition) { throw new Error('must call initialize before calling this function'); } return this.businessNetworkDefinition.getIntrospector(); } /** * Get the registry manager. * @return {RegistryManager} The registry manager. */ getRegistryManager() { if ( !this.registryManager) { // TODO: This method call is getting too long. this.registryManager = new RegistryManager(this.getDataService(), this.getIntrospector(), this.getSerializer(), this.getAccessController(), this.getSystemRegistries(),this.getFactory()); } return this.registryManager; } /** * Get the resolver. * @return {Resolver} The resolver. */ getResolver() { if (!this.resolver) { this.resolver = new Resolver(this.getFactory(), this.getIntrospector(), this.getRegistryManager()); } return this.resolver; } /** * Get the API. * @return {Api} The API. */ getApi() { if (!this.api) { this.api = new Api(this); } return this.api; } /** * Get the identity manager. * @return {IdentityManager} The identity manager. */ getIdentityManager() { if (!this.identityManager) { this.identityManager = new IdentityManager(this); } return this.identityManager; } /** * Get the resource manager. * @return {ResourceManager} The resource manager. */ getResourceManager() { if (!this.resourceManager) { this.resourceManager = new ResourceManager(this); } return this.resourceManager; } /** * Get the network manager. * @return {NetworkManager} The network manager. */ getNetworkManager() { if (!this.networkManager) { const NetworkManager = require('./networkmanager'); this.networkManager = new NetworkManager(this); } return this.networkManager; } /** * Get the current participant. * @return {Resource} the current participant. */ getParticipant() { return this.participant; } /** * Set the current participant. * @param {Resource} participant the current participant. */ setParticipant(participant) { if (this.participant) { throw new Error('A current participant has already been specified'); } this.participant = participant; this.getAccessController().setParticipant(participant); } /** * Get the current identity. * @return {Resource} the current identity. */ getIdentity() { return this.currentIdentity; } /** * Set the current identity. * @param {Resource} currentIdentity the current identity. */ setIdentity(currentIdentity) { if (this.currentIdentity) { throw new Error('A current identity has already been specified'); } this.currentIdentity = currentIdentity; } /** * Get the current transaction. * @return {Resource} the current transaction. */ getTransaction() { return this.transaction; } /** * Set the current transaction. * @param {Resource} transaction the current transaction. */ setTransaction(transaction) { if (this.transaction) { throw new Error('A current transaction has already been specified'); } this.transaction = transaction; this.transactionLogger = new TransactionLogger(this.transaction, this.getRegistryManager(), this.getSerializer()); this.getAccessController().setTransaction(transaction); } /** * Clear the current transaction. */ clearTransaction() { this.transaction = null; this.transactionLogger = null; this.getAccessController().setTransaction(null); } /** * Get the access controller. * @return {AccessController} The access controller. */ getAccessController() { if (!this.accessController) { this.accessController = new AccessController(this); } return this.accessController; } /** * Get the system registries collection. * @return {DataCollection} The system registries collection. */ getSystemRegistries() { if (!this.sysregistries) { throw new Error('must call initialize before calling this function'); } return this.sysregistries; } /** * Get the next event number * @return {integer} the event number. */ getEventNumber() { return this.eventNumber; } /** * Incrememnt the event number by 1 * @return {integer} the event number. */ incrementEventNumber() { return this.eventNumber++; } /** * Get the script compiler. * @return {ScriptCompiler} scriptCompiler The script compiler. */ getScriptCompiler() { if (!this.scriptCompiler) { this.scriptCompiler = new ScriptCompiler(); } return this.scriptCompiler; } /** * Get the compiled script bundle. * @return {CompiledScriptBundle} compiledScriptBundle The compiled script bundle. */ getCompiledScriptBundle() { return this.compiledScriptBundle; } /** * Get the query compiler. * @return {QueryCompiler} queryCompiler The query compiler. */ getQueryCompiler() { if (!this.queryCompiler) { this.queryCompiler = new QueryCompiler(); } return this.queryCompiler; } /** * Get the compiled query bundle. * @return {CompiledQueryBundle} compiledQueryBundle The compiled query bundle. */ getCompiledQueryBundle() { return this.compiledQueryBundle; } /** * Get the ACL compiler. * @return {AclCompiler} aclCompiler The ACL compiler. */ getAclCompiler() { if (!this.aclCompiler) { this.aclCompiler = new AclCompiler(); } return this.aclCompiler; } /** * Get the compiled ACL bundle. * @return {CompiledAclBundle} compiledAclBundle The compiled ACL bundle. */ getCompiledAclBundle() { return this.compiledAclBundle; } /** Obtains the logging service *@return {LoggingService} the logging service */ getLoggingService(){ return this.loggingService; } /** * Get the list of transaction handlers. * @return {TransactionHandler[]} The list of transaction handlers. */ getTransactionHandlers() { return [ this.getIdentityManager(),this.getResourceManager(),this.getNetworkManager() ]; } /** * Called at the start of a transaction. * @param {boolean} readOnly Is the transaction read-only? * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionStart(readOnly) { const services = this.getServices(); return services.reduce((promise, service) =&gt; { return promise.then(() =&gt; { return service.transactionStart(readOnly); }); }, Promise.resolve()); } /** * Called when a transaction is preparing to commit. * @abstract * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionPrepare() { const services = this.getServices(); return services.reduce((promise, service) =&gt; { return promise.then(() =&gt; { return service.transactionPrepare(); }); }, Promise.resolve()); } /** * Called when a transaction is rolling back. * @abstract * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionRollback() { const services = this.getServices(); return services.reduce((promise, service) =&gt; { return promise.then(() =&gt; { return service.transactionRollback(); }); }, Promise.resolve()); } /** * Called when a transaction is committing. * @abstract * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionCommit() { const services = this.getServices(); return services.reduce((promise, service) =&gt; { return promise.then(() =&gt; { return service.transactionCommit(); }); }, Promise.resolve()); } /** * Called at the end of a transaction. * @abstract * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionEnd() { const services = this.getServices(); return services.reduce((promise, service) =&gt; { return promise.then(() =&gt; { return service.transactionEnd(); }); }, Promise.resolve()); } } module.exports = Context; × Search results Close "},"composer-runtime_lib_datacollection.js.html":{"id":"composer-runtime_lib_datacollection.js.html","title":"Source: composer-runtime/lib/datacollection.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/datacollection.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Base class representing a data collection provided by a {@link DataService}. * @protected * @abstract * @memberof module:composer-runtime */ class DataCollection { /** * Constructor. * @param {DataService} dataService The owning data service. */ constructor(dataService) { this.dataService = dataService; } /** * Get all of the objects in this collection. * @abstract * @return {Promise} A promise that will be resolved with an array of objects, * or rejected with an error. */ getAll() { return new Promise((resolve, reject) =&gt; { this._getAll((error, result) =&gt; { if (error) { return reject(error); } return resolve(result); }); }); } /** * @callback getAllCallback * @protected * @param {Error} error The error if any. * @param {Object[]} objects The objects in the collection. */ /** * Get all of the objects in this collection. * @abstract * @private * @param {getAllCallback} callback The callback function to call when complete. */ _getAll(callback) { throw new Error('abstract function called'); } /** * Get the specified object in this collection. * @abstract * @param {string} id The ID of the object. * @return {Promise} A promise that will be resolved with an object, or rejected * with an error. */ get(id) { return new Promise((resolve, reject) =&gt; { this._get(id, (error, result) =&gt; { if (error) { return reject(error); } return resolve(result); }); }); } /** * @callback getCallback * @protected * @param {Error} error The error if any. * @param {Object} object The object in the collection. */ /** * Get the specified object in this collection. * @abstract * @private * @param {string} id The ID of the object. * @param {getCallback} callback The callback function to call when complete. */ _get(id, callback) { throw new Error('abstract function called'); } /** * Check to see if the specified object exists in this collection. * @abstract * @param {string} id The ID of the object. * @return {Promise} A promise that will be resolved with an boolean which will * be true if the specified object exists in this collection, or rejected with * an error. */ exists(id) { return new Promise((resolve, reject) =&gt; { this._exists(id, (error, result) =&gt; { if (error) { return reject(error); } return resolve(result); }); }); } /** * @callback existsCallback * @protected * @param {Error} error The error if any. * @param {boolean} exists Whether or not the object exists in the collection. */ /** * Check to see if the specified object exists in this collection. * @abstract * @private * @param {string} id The ID of the object. * @param {existsCallback} callback The callback function to call when complete. */ _exists(id, callback) { throw new Error('abstract function called'); } /** * Add an object to the collection. * @abstract * @param {string} id The ID of the object. * @param {Object} object The object. * @param {boolean} force Whether to force creation without checking it already exists. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ add(id, object, force) { force = !!force; return new Promise((resolve, reject) =&gt; { this._add(id, object, force, (error, result) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback addCallback * @protected * @param {Error} error The error if any. */ /** * Add an object to the collection. * @abstract * @private * @param {string} id The ID of the object. * @param {Object} object The object. * @param {boolean} force don't check for existence, force it * @param {addCallback} callback The callback function to call when complete. */ _add(id, object, force, callback) { throw new Error('abstract function called'); } /** * Add an object to the collection. * @abstract * @param {string} id The ID of the object. * @param {Object} object The object. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ update(id, object) { return new Promise((resolve, reject) =&gt; { this._update(id, object, (error, result) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback updateCallback * @protected * @param {Error} error The error if any. */ /** * Update an object in the collection. * @abstract * @private * @param {string} id The ID of the object. * @param {Object} object The object. * @param {updateCallback} callback The callback function to call when complete. */ _update(id, object, callback) { throw new Error('abstract function called'); } /** * Remove an object from the collection. * @abstract * @param {string} id The ID of the object. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ remove(id) { return new Promise((resolve, reject) =&gt; { this._remove(id, (error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback removeCallback * @protected * @param {Error} error The error if any. */ /** * Remove an object from the collection. * @abstract * @private * @param {string} id The ID of the object. * @param {removeCallback} callback The callback function to call when complete. */ _remove(id, callback) { throw new Error('abstract function called'); } } module.exports = DataCollection; × Search results Close "},"composer-runtime_lib_dataservice.js.html":{"id":"composer-runtime_lib_dataservice.js.html","title":"Source: composer-runtime/lib/dataservice.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/dataservice.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const Service = require('./service'); const LOG = Logger.getLog('DataService'); /** * Base class representing the data service provided by a {@link Container}. * @protected * @abstract * @memberof module:composer-runtime */ class DataService extends Service { /** * Create a collection with the specified ID. * @abstract * @param {string} id The ID of the collection. * @param {boolean} force Whether to force creation without checking it already exists. * @return {Promise} A promise that will be resolved with a {@link DataCollection} * when complete, or rejected with an error. */ createCollection(id, force) { force = !!force; return new Promise((resolve, reject) =&gt; { this._createCollection(id, force, (error, dataCollection) =&gt; { if (error) { return reject(error); } return resolve(dataCollection); }); }); } /** * @callback createCollectionCallback * @protected * @param {Error} error The error if any. * @param {DataCollection} dataCollection The data collection. */ /** * Create a collection with the specified ID. * @abstract * @private * @param {string} id The ID of the collection. * @param {force} force force creation, don't check for existence 1st * @param {createCollectionCallback} callback The callback function to call when complete. */ _createCollection(id, force, callback) { throw new Error('abstract function called'); } /** * Delete a collection with the specified ID. * @abstract * @param {string} id The ID of the collection. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ deleteCollection(id) { return new Promise((resolve, reject) =&gt; { this._deleteCollection(id, (error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback deleteCollectionCallback * @protected * @param {Error} error The error if any. */ /** * Delete a collection with the specified ID. * @abstract * @private * @param {string} id The ID of the collection. * @param {deleteCollectionCallback} callback The callback function to call when complete. */ _deleteCollection(id, callback) { throw new Error('abstract function called'); } /** * Get the collection with the specified ID. * @abstract * @param {string} id The ID of the collection. * @return {Promise} A promise that will be resolved with a {@link DataCollection} * when complete, or rejected with an error. */ getCollection(id) { return new Promise((resolve, reject) =&gt; { this._getCollection(id, (error, dataCollection) =&gt; { if (error) { return reject(error); } return resolve(dataCollection); }); }); } /** * @callback getCollectionCallback * @protected * @param {Error} error The error if any. * @param {DataCollection} dataCollection The data collection. */ /** * Get the collection with the specified ID. * @abstract * @private * @param {string} id The ID of the collection. * @param {getCollectionCallback} callback The callback function to call when complete. */ _getCollection(id, callback) { throw new Error('abstract function called'); } /** * Determine whether the collection with the specified ID exists. * @abstract * @param {string} id The ID of the collection. * @return {Promise} A promise that will be resolved with a boolean * indicating whether the collection exists. */ existsCollection(id) { return new Promise((resolve, reject) =&gt; { this._existsCollection(id, (error, exists) =&gt; { if (error) { return reject(error); } return resolve(exists); }); }); } /** * @callback existsCollectionCallback * @protected * @param {Error} error The error if any. * @param {DataCollection} dataCollection The data collection. */ /** * Determine whether the collection with the specified ID exists. * @abstract * @private * @param {string} id The ID of the collection. * @param {existsCollectionCallback} callback The callback function to call when complete. */ _existsCollection(id, callback) { throw new Error('abstract function called'); } /** * Execute a query across all objects stored in all collections, using a query * string that is dependent on the current Blockchain platform. * @abstract * @param {string} queryString The query string for the current Blockchain platform. * @return {Promise} A promise that will be resolved with an array of objects * when complete, or rejected with an error. */ executeQuery(queryString) { return new Promise((resolve, reject) =&gt; { this._executeQuery(queryString, (error, result) =&gt; { if (error) { return reject(error); } return resolve(result); }); }); } /** * @callback executeQueryCallback * @protected * @param {Error} error The error if any. * @param {Object[]} objects The objects. */ /** * Execute a query across all objects stored in all collections, using a query * string that is dependent on the current Blockchain platform. * @abstract * @param {string} queryString The query string for the current Blockchain platform. * @param {executeQueryCallback} callback The callback function to call when complete. */ _executeQuery(queryString, callback) { throw new Error('abstract function called'); } /** * Check to see if the collection with the specified ID exists, and if not create it. * @param {string} id The ID of the collection. * @return {Promise} A promise that will be resolved with a {@link DataCollection} * when complete, or rejected with an error. */ ensureCollection(id) { const method = 'ensureCollection'; LOG.entry(method, id); return this.getCollection(id) .catch((error) =&gt; { LOG.debug(method, 'The collection does not exist, creating'); return this.createCollection(id); }) .then((collection) =&gt; { LOG.exit(method, collection); return collection; }); } } module.exports = DataService; × Search results Close "},"composer-runtime_lib_engine.js.html":{"id":"composer-runtime_lib_engine.js.html","title":"Source: composer-runtime/lib/engine.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/engine.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BusinessNetworkDefinition = require('composer-common').BusinessNetworkDefinition; const Context = require('./context'); const createHash = require('sha.js'); const Logger = require('composer-common').Logger; const util = require('util'); const LOG = Logger.getLog('Engine'); /** * The JavaScript engine responsible for processing chaincode commands. * @protected * @memberof module:composer-runtime */ class Engine { /** * Constructor. * @param {Container} container The chaincode container hosting this engine. */ constructor(container) { this.container = container; this.installLogger(); const method = 'constructor'; LOG.entry(method); LOG.exit(method); } /** * Get the chaincode container hosting this engine. * @return {Container} The chaincode container hosting this engine. */ getContainer() { return this.container; } /** * Install the runtime logger into the common module. */ installLogger() { let loggingService = this.container.getLoggingService(); let loggingProxy = { log: (level, method, msg, args) =&gt; { args = args || []; let formattedArguments = args.map((arg) =&gt; { return String(arg); }).join(', '); switch (level) { case 'debug': return loggingService.logDebug(util.format('@JS : %s %s %s', method, msg, formattedArguments)); case 'warn': return loggingService.logWarning(util.format('@JS : %s %s %s', method, msg, formattedArguments)); case 'info': return loggingService.logInfo(util.format('@JS : %s %s %s', method, msg, formattedArguments)); case 'verbose': return loggingService.logDebug(util.format('@JS : %s %s %s', method, msg, formattedArguments)); case 'error': return loggingService.logError(util.format('@JS : %s %s %s', method, msg, formattedArguments)); } } }; Logger.setFunctionalLogger(loggingProxy); Logger._envDebug = 'composer:*'; } /** * Handle an initialisation (deploy) request. * @param {Context} context The request context. * @param {string} fcn The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ init(context, fcn, args) { const method = 'init'; LOG.entry(method, context, fcn, args); // chaincode was upgraded, no change to business network and obviously // nothing the runtime can do to stop it. if (fcn === 'upgrade') { LOG.info(method, 'runtime has been upgraded'); //TODO: Here we would need to invoke migrations if we are to support //upgrading from anything more than just micro version changes of the //runtime. Currently not supported and the connector will not allow //the upgrade. We could add a check here as well and reject the upgrade //but it's overkill at the moment. return Promise.resolve(); } if (fcn !== 'init') { throw new Error(util.format('Unsupported function &quot;%s&quot; with arguments &quot;%j&quot;', fcn, args)); } else if (args.length !== 1) { throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'init', ['serializedResource'])); } // Parse the transaction from the JSON string.. LOG.debug(method, 'Parsing transaction from JSON'); let transactionData = JSON.parse(args[0]); // We can't parse the transaction data using the serializer. // This is because it may contain classes that we haven't loaded yet. // So we need to do it the &quot;old fashioned way&quot;. if (transactionData.$class !== 'org.hyperledger.composer.system.StartBusinessNetwork') { throw new Error('The transaction data specified is not valid'); } // Extract and validate the required business network archive property. const businessNetworkBase64 = transactionData.businessNetworkArchive; if (!businessNetworkBase64) { throw new Error('The business network archive specified is not valid'); } // Extract and validate the optional log level property. const logLevel = transactionData.logLevel; if (logLevel) { this.getContainer().getLoggingService().setLogLevel(logLevel); } let dataService = context.getDataService(); let businessNetworkHash, businessNetworkRecord, businessNetworkDefinition; let compiledScriptBundle, compiledQueryBundle, compiledAclBundle; let sysregistries, sysdata; return Promise.resolve() .then(() =&gt; { // Start the transaction. return context.transactionStart(false); }) .then(() =&gt; { // Load, validate, and hash the business network definition. LOG.debug(method, 'Loading business network definition'); let businessNetworkArchive = Buffer.from(businessNetworkBase64, 'base64'); let sha256 = createHash('sha256'); businessNetworkHash = sha256.update(businessNetworkBase64, 'utf8').digest('hex'); LOG.debug(method, 'Calculated business network definition hash', businessNetworkHash); // Create the business network record. businessNetworkRecord = { data: businessNetworkBase64, hash: businessNetworkHash }; // Load the business network. return BusinessNetworkDefinition.fromArchive(businessNetworkArchive); }) .then((businessNetworkDefinition_) =&gt; { // Cache the business network. businessNetworkDefinition = businessNetworkDefinition_; LOG.debug(method, 'Loaded business network definition, storing in cache'); Context.cacheBusinessNetwork(businessNetworkHash, businessNetworkDefinition); // Cache the compiled script bundle. compiledScriptBundle = Context.getCachedCompiledScriptBundle(businessNetworkHash); if (!compiledScriptBundle) { compiledScriptBundle = context.getScriptCompiler().compile(businessNetworkDefinition.getScriptManager()); LOG.debug(method, 'Loaded compiled script bundle, storing in cache'); Context.cacheCompiledScriptBundle(businessNetworkHash, compiledScriptBundle); } // Cache the compiled query bundle. compiledQueryBundle = Context.getCachedCompiledQueryBundle(businessNetworkHash); if (!compiledQueryBundle) { compiledQueryBundle = context.getQueryCompiler().compile(businessNetworkDefinition.getQueryManager()); LOG.debug(method, 'Loaded compiled query bundle, storing in cache'); Context.cacheCompiledQueryBundle(businessNetworkHash, compiledQueryBundle); } // Cache the compiled ACL bundle. compiledAclBundle = Context.getCachedCompiledAclBundle(businessNetworkHash); if (!compiledAclBundle) { compiledAclBundle = context.getAclCompiler().compile(businessNetworkDefinition.getAclManager(), businessNetworkDefinition.getScriptManager()); LOG.debug(method, 'Loaded compiled ACL bundle, storing in cache'); Context.cacheCompiledAclBundle(businessNetworkHash, compiledAclBundle); } // Get the sysdata collection where the business network definition is stored. LOG.debug(method, 'Loaded business network definition, storing in $sysdata collection'); return dataService.ensureCollection('$sysdata'); }) .then((sysdata_) =&gt; { // Add the business network definition to the sysdata collection. sysdata = sysdata_; return sysdata.add('businessnetwork', businessNetworkRecord); }) .then(() =&gt; { return sysdata.add('metanetwork', { '$class': 'org.hyperledger.composer.system.Network', 'networkId': businessNetworkDefinition.getIdentifier() }); }) .then(() =&gt; { // Ensure that the system registries collection exists. LOG.debug(method, 'Ensuring that sysregistries collection exists'); return dataService.ensureCollection('$sysregistries') .then((sysregistries_) =&gt; { sysregistries = sysregistries_; }); }) .then(() =&gt; { // Initialize the context. LOG.debug(method, 'Initializing context 2',this.getContainer().getVersion()); return context.initialize({ function: fcn, arguments: args, businessNetworkDefinition: businessNetworkDefinition, compiledScriptBundle: compiledScriptBundle, compiledQueryBundle: compiledQueryBundle, compiledAclBundle: compiledAclBundle, sysregistries: sysregistries, container: this.getContainer() }); }) .then(() =&gt; { // Create all the default registries for each asset, participant, and transaction type. LOG.debug(method, 'Creating default registries'); let registryManager = context.getRegistryManager(); return registryManager.createDefaults(); }) .then(() =&gt; { // We want the historian entries to be ordered, so lets bump the milliseconds for every // bootstrap transaction we execute. const timestamp = new Date(transactionData.timestamp); // First we need to prepare any bootstrap transactions by forcing the transaction ID // and timestamp to be derived from the start business network transaction. const bootstrapTransactions = transactionData.bootstrapTransactions || []; bootstrapTransactions.forEach((bootstrapTransaction, index) =&gt; { bootstrapTransaction.transactionId = transactionData.transactionId + '#' + index; timestamp.setMilliseconds(timestamp.getMilliseconds() + 1); bootstrapTransaction.timestamp = timestamp.toISOString(); }); // Now update the original timestamp so the start business network transaction is correct. timestamp.setMilliseconds(timestamp.getMilliseconds() + 1); transactionData.timestamp = timestamp.toISOString(); // Now that we have initialized and loaded the business network defintion, we can now // safely execute all of the bootstrap transactions. return bootstrapTransactions.reduce((promise, bootstrapTransaction) =&gt; { return promise.then(() =&gt; { LOG.debug(method, 'Executing bootstrap transaction', bootstrapTransaction.transactionId); return this.submitTransaction(context, [JSON.stringify(bootstrapTransaction)]); }); }, Promise.resolve()); }) .then(() =&gt; { // This step executes the start business network transaction. This is a no-op, but records // the event into the transaction registry and historian. LOG.debug(method, 'Executing start business network transaction'); return this.submitTransaction(context, [JSON.stringify(transactionData)]); }) .then(() =&gt; { return context.transactionPrepare() .then(() =&gt; { return context.transactionCommit(); }) .then(() =&gt; { return context.transactionEnd(); }); }) .catch((error) =&gt; { LOG.error(method, 'Caught error, rethrowing', error); return context.transactionRollback() .then(() =&gt; { return context.transactionEnd(); }) .then(() =&gt; { throw error; }); }) .then(() =&gt; { LOG.exit(method); }); } /** * Handle an initialisation (deploy) request. * @private * @param {Context} context The request context. * @param {string} fcn The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @param {function} callback The callback function to call when complete. */ _init(context, fcn, args, callback) { this.init(context, fcn, args) .then((result) =&gt; { callback(null, result); }) .catch((error) =&gt; { callback(error, null); }); } /** * Handle an invoke request. * @param {Context} context The request context. * @param {string} fcn The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ invoke(context, fcn, args) { const method = 'invoke'; LOG.entry(method, context, fcn, args); if (this[fcn]) { LOG.debug(method, 'Initializing context'); return context.initialize({ function: fcn, arguments: args, container: this.getContainer() }) .then(() =&gt; { return context.transactionStart(false); }) .then(() =&gt; { LOG.debug(method, 'Calling engine function', fcn); return this[fcn](context, args); }) .then((result) =&gt; { return context.transactionPrepare() .then(() =&gt; { return context.transactionCommit(); }) .then(() =&gt; { return context.transactionEnd(); }) .then(() =&gt; { return result; }); }) .catch((error) =&gt; { LOG.error(method, 'Caught error, rethrowing', error); return context.transactionRollback() .then(() =&gt; { return context.transactionEnd(); }) .then(() =&gt; { throw error; }); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } else { LOG.error(method, 'Unsupported function', fcn, args); throw new Error(util.format('Unsupported function &quot;%s&quot; with arguments &quot;%j&quot;', fcn, args)); } } /** * Handle an invoke request. * @private * @param {Context} context The request context. * @param {string} fcn The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @param {function} callback The callback function to call when complete. */ _invoke(context, fcn, args, callback) { this.invoke(context, fcn, args) .then((result) =&gt; { callback(null, result); }) .catch((error) =&gt; { callback(error, null); }); } /** * Handle a query request. * @param {Context} context The request context. * @param {string} fcn The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ query(context, fcn, args) { const method = 'query'; LOG.entry(method, context, fcn, args); if (this[fcn]) { LOG.debug(method, 'Initializing context'); return context.initialize({ function: fcn, arguments: args, container: this.getContainer() }) .then(() =&gt; { return context.transactionStart(true); }) .then(() =&gt; { LOG.debug(method, 'Calling engine function', fcn); return this[fcn](context, args); }) .then((result) =&gt; { return context.transactionPrepare() .then(() =&gt; { return context.transactionCommit(); }) .then(() =&gt; { return context.transactionEnd(); }) .then(() =&gt; { return result; }); }) .catch((error) =&gt; { LOG.error(method, 'Caught error, rethrowing', error); return context.transactionRollback() .then(() =&gt; { return context.transactionEnd(); }) .then(() =&gt; { throw error; }); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } else { LOG.error(method, 'Unsupported function', fcn, args); throw new Error(util.format('Unsupported function &quot;%s&quot; with arguments &quot;%j&quot;', fcn, args)); } } /** * Handle a query request. * @private * @param {Context} context The request context. * @param {string} fcn The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @param {function} callback The callback function to call when complete. */ _query(context, fcn, args, callback) { this.query(context, fcn, args) .then((result) =&gt; { callback(null, result); }) .catch((error) =&gt; { callback(error, null); }); } /** * Handle a ping request. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ ping(context, args) { const method = 'ping'; LOG.entry(method, context, args); if (args.length !== 0) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'ping', [])); } let participantFQI = null; let participant = context.getParticipant(); if (participant) { participantFQI = participant.getFullyQualifiedIdentifier(); } let result = { version: this.container.getVersion(), participant: participantFQI }; LOG.exit(method, result); return Promise.resolve(result); } } /** * Add all of the methods of the source class to the engine class. * @private * @param {Object} sourceClass The source class to copy methods from. */ function mixin(sourceClass) { Object.getOwnPropertyNames(sourceClass.prototype).forEach((method) =&gt; { if (method !== 'constructor') { Engine.prototype[method] = sourceClass.prototype[method]; } }); } mixin(require('./engine.businessnetworks')); mixin(require('./engine.queries')); mixin(require('./engine.registries')); mixin(require('./engine.resources')); mixin(require('./engine.transactions')); mixin(require('./engine.logging')); module.exports = Engine; × Search results Close "},"composer-runtime_lib_engine.businessnetworks.js.html":{"id":"composer-runtime_lib_engine.businessnetworks.js.html","title":"Source: composer-runtime/lib/engine.businessnetworks.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/engine.businessnetworks.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const util = require('util'); const LOG = Logger.getLog('EngineBusinessNetworks'); /** * The JavaScript engine responsible for processing chaincode commands. * @protected * @memberof module:composer-runtime */ class EngineBusinessNetworks { /** * Get the business network archive. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ getBusinessNetwork(context, args) { const method = 'getBusinessNetwork'; LOG.entry(method, context, args); if (args.length !== 0) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'getBusinessNetwork', [])); } let dataService = context.getDataService(); let sysdata; let resource; return dataService.getCollection('$sysdata') .then((result) =&gt; { sysdata = result; return sysdata.get('metanetwork'); }) .then((result) =&gt; { resource = context.getSerializer().fromJSON(result); return context.getAccessController().check(resource, 'READ'); }) .then(() =&gt; { // convert to resource and then check pmerssions. return sysdata.get('businessnetwork'); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Undeploy the business network; * Doesn't actually undeploy the nework but merely puts it beyond use. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ undeployBusinessNetwork(context, args) { const method = 'undeployBusinessNetwork'; LOG.entry(method, context, args); if (args.length !== 0) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, method, [])); } let dataService = context.getDataService(); let sysdata; return dataService.getCollection('$sysdata') .then((sysdata_) =&gt; { sysdata = sysdata_; return sysdata.get('metanetwork'); }) .then((result) =&gt; { let resource = context.getSerializer().fromJSON(result); return context.getAccessController().check(resource, 'DELETE'); }) .then(() =&gt; { // Validate the business network arsysregistrieschive and store it. return sysdata.get('businessnetwork'); }) .then((businessNetwork) =&gt; { businessNetwork.undeployed = true; return sysdata.update('businessnetwork', businessNetwork); }) .then(() =&gt; { LOG.exit(method); }); } } module.exports = EngineBusinessNetworks; × Search results Close "},"composer-runtime_lib_engine.logging.js.html":{"id":"composer-runtime_lib_engine.logging.js.html","title":"Source: composer-runtime/lib/engine.logging.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/engine.logging.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const LOG = Logger.getLog('EngineLogging'); /** * The JavaScript engine responsible for processing chaincode commands. * @protected * @memberof module:composer-runtime */ class EngineLogging { /** * Get the current log level of the runtime. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ getLogLevel(context, args) { const method = 'getLogLevel'; LOG.entry(method, context, args); let dataService = context.getDataService(); let sysdata; let resource; return dataService.getCollection('$sysdata') .then((result) =&gt; { sysdata = result; return sysdata.get('metanetwork'); }) .then((result) =&gt; { resource = context.getSerializer().fromJSON(result); return context.getAccessController().check(resource, 'READ'); }) .then(() =&gt; { let ll = context.getLoggingService().getLogLevel(); LOG.exit(method,'loglevel',ll); return ll; }); } } module.exports = EngineLogging; × Search results Close "},"composer-runtime_lib_engine.queries.js.html":{"id":"composer-runtime_lib_engine.queries.js.html","title":"Source: composer-runtime/lib/engine.queries.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/engine.queries.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const Registry = require('./registry'); const util = require('util'); const LOG = Logger.getLog('EngineQueries'); /** * The JavaScript engine responsible for processing chaincode commands. * @protected * @memberof module:composer-runtime */ class EngineQueries { /** * Execute a query. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ executeQuery(context, args) { const method = 'executeQuery'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'executeQuery', ['queryType', 'query', 'parameters'])); } // Process the parameters. const queryType = args[0], query = args[1], parametersAsJSON = args[2]; LOG.debug(method, 'queryType', queryType); // Validate the query type. if (queryType !== 'build' &amp;&amp; queryType !== 'named') { throw new Error(util.format('Invalid argument &quot;queryType&quot; with value &quot;%s&quot;, expecting &quot;build&quot; or &quot;named&quot;', [queryType])); } // Build the query if necessary. let identifier; if (queryType === 'build') { identifier = context.getCompiledQueryBundle().buildQuery(query); } else { identifier = query; } // Parse the parameters. const parameters = JSON.parse(parametersAsJSON); // Execute the query. const dataService = context.getDataService(); const serializer = context.getSerializer(); const accessController = context.getAccessController(); return context.getCompiledQueryBundle().execute(dataService, identifier, parameters) .then((objects) =&gt; { return objects.map((object) =&gt; { object = Registry.removeInternalProperties(object); return serializer.fromJSON(object); }).reduce((resources, resource) =&gt; { return resources.then((resources) =&gt; { return accessController.check(resource, 'READ') .then(() =&gt; { resources.push(resource); return resources; }) .catch((error) =&gt; { return resources; }); }); }, Promise.resolve([])); }) .then((resources) =&gt; { resources = resources.map((resource) =&gt; { return serializer.toJSON(resource); }); LOG.exit(method, resources); return resources; }); } } module.exports = EngineQueries; × Search results Close "},"composer-runtime_lib_engine.registries.js.html":{"id":"composer-runtime_lib_engine.registries.js.html","title":"Source: composer-runtime/lib/engine.registries.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/engine.registries.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const util = require('util'); const LOG = Logger.getLog('EngineRegistries'); /** * The JavaScript engine responsible for processing chaincode commands. * @protected * @memberof module:composer-runtime */ class EngineRegistries { /** * Get all registries. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ getAllRegistries(context, args) { const method = 'getAllRegistries'; LOG.entry(method, context, args); if (args.length !== 2) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'getAllRegistries', ['registryType','includeSystem'])); } let registryType = args[0]; let includeSystem = (args[1] === 'true'); return context.getRegistryManager().getAll(registryType,includeSystem) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Get the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ getRegistry(context, args) { const method = 'getRegistry'; LOG.entry(method, context, args); if (args.length !== 2) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'getRegistry', ['registryType', 'registryId'])); } let registryType = args[0]; let registryId = args[1]; return context.getRegistryManager().get(registryType, registryId) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Determine whether an asset registry exists. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved with a boolean indicating * whether the asset registry exists. */ existsRegistry(context, args) { const method = 'existsRegistry'; LOG.entry(method, context, args); if (args.length !== 2) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'existsRegistry', ['registryType', 'registryId'])); } let registryType = args[0]; let registryId = args[1]; return context.getRegistryManager().exists(registryType, registryId) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Add a new registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ addRegistry(context, args) { const method = 'addRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'addRegistry', ['registryType', 'registryId', 'registryName'])); } let registryType = args[0]; let registryId = args[1]; let registryName = args[2]; LOG.debug(method,'Adding registry',registryType,registryId,registryName); return context.getRegistryManager().add(registryType, registryId, registryName) .then(() =&gt; { LOG.exit(method); }); } } module.exports = EngineRegistries; × Search results Close "},"composer-runtime_lib_engine.resources.js.html":{"id":"composer-runtime_lib_engine.resources.js.html","title":"Source: composer-runtime/lib/engine.resources.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/engine.resources.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const util = require('util'); const LOG = Logger.getLog('EngineResources'); /** * The JavaScript engine responsible for processing chaincode commands. * @protected * @memberof module:composer-runtime */ class EngineResources { /** * Get all resources in the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ getAllResourcesInRegistry(context, args) { const method = 'getAllResourcesInRegistry'; LOG.entry(method, context, args); if (args.length !== 2) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'getAllResourcesInRegistry', ['registryType', 'registryId'])); } let registryType = args[0]; let registryId = args[1]; return context.getRegistryManager().get(registryType, registryId) .then((registryManager) =&gt; { return registryManager.getAll(); }) .then((resources) =&gt; { return resources.map((resource) =&gt; { return context.getSerializer().toJSON(resource); }); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Get the specified resource in the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ getResourceInRegistry(context, args) { const method = 'getResourceInRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'getResourceInRegistry', ['registryType', 'registryId', 'resourceId'])); } let registryType = args[0]; let registryId = args[1]; let resourceId = args[2]; return context.getRegistryManager().get(registryType, registryId) .then((registry) =&gt; { return registry.get(resourceId); }) .then((resource) =&gt; { return context.getSerializer().toJSON(resource); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Determine whether the specified resource exists in the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved with a boolean indicating whether * the resource exists in the registry. */ existsResourceInRegistry(context, args) { const method = 'existsResourceInRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'existsResourceInRegistry', ['registryType', 'registryId', 'resourceId'])); } let registryType = args[0]; let registryId = args[1]; let resourceId = args[2]; return context.getRegistryManager().get(registryType, registryId) .then((registry) =&gt; { return registry.exists(resourceId); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Get all resources in the specified registry, and recursively resolve all * their relationships to other resources. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ resolveAllResourcesInRegistry(context, args) { const method = 'resolveAllResourcesInRegistry'; LOG.entry(method, context, args); if (args.length !== 2) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'resolveAllResourcesInRegistry', ['registryType', 'registryId'])); } let registryType = args[0]; let registryId = args[1]; return context.getRegistryManager().get(registryType, registryId) .then((registryManager) =&gt; { return registryManager.getAll(); }) .then((resources) =&gt; { let resolver = context.getResolver(); return resources.reduce((result, resource) =&gt; { return result.then((resources) =&gt; { LOG.debug(method, 'Resolving resource', resource.getFullyQualifiedIdentifier()); return resolver.resolve(resource) .then((resolved) =&gt; { resources.push(resolved); return resources; }); }); }, Promise.resolve([])); }) .then((resources) =&gt; { return resources.map((resource) =&gt; { return context.getSerializer().toJSON(resource, { permitResourcesForRelationships: true }); }); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Get the specified resource in the specified registry, and recursively resolve * all its relationships to other resources. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ resolveResourceInRegistry(context, args) { const method = 'resolveResourceInRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'resolveResourceInRegistry', ['registryType', 'registryId', 'resourceId'])); } let registryType = args[0]; let registryId = args[1]; let resourceId = args[2]; return context.getRegistryManager().get(registryType, registryId) .then((registry) =&gt; { return registry.get(resourceId); }) .then((resource) =&gt; { let resolver = context.getResolver(); LOG.debug(method, 'Resolving resource', resource.getFullyQualifiedIdentifier()); return resolver.resolve(resource); }) .then((resource) =&gt; { return context.getSerializer().toJSON(resource, { permitResourcesForRelationships: true }); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } } module.exports = EngineResources; × Search results Close "},"composer-runtime_lib_engine.transactions.js.html":{"id":"composer-runtime_lib_engine.transactions.js.html","title":"Source: composer-runtime/lib/engine.transactions.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/engine.transactions.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const util = require('util'); const LOG = Logger.getLog('EngineTransactions'); /** * The JavaScript engine responsible for processing chaincode commands. * @protected * @memberof module:composer-runtime */ class EngineTransactions { /** * Submit a transaction for execution. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ submitTransaction(context, args) { const method = 'submitTransaction'; LOG.entry(method, context, args); if (args.length !== 1) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'submitTransaction', [ 'serializedResource'])); } // Find the default transaction registry. let registryManager = context.getRegistryManager(); let transaction = null; let historian = null; let txRegistry = null; // Parse the transaction from the JSON string.. LOG.debug(method, 'Parsing transaction from JSON'); let transactionData = JSON.parse(args[0]); // Now we need to convert the JavaScript object into a transaction resource. LOG.debug(method, 'Parsing transaction from parsed JSON object'); // First we parse *our* copy, that is not resolved. This is the copy that gets added to the // transaction registry, and is the one in the context (for adding log entries). transaction = context.getSerializer().fromJSON(transactionData); // Store the transaction in the context. context.setTransaction(transaction); // This is the count of transaction processor functions executed. let totalCount = 0; let txClass = transaction.getFullyQualifiedType(); LOG.debug(method, 'Getting default transaction registry for '+txClass); // Resolve the users copy of the transaction. LOG.debug(method, 'Parsed transaction, resolving it', transaction); let resolvedTransaction; return context.getResolver().resolve(transaction) .then((resolvedTransaction_) =&gt; { // Save the resolved transaction. resolvedTransaction = resolvedTransaction_; // Execute any system transaction processor functions. const api = context.getApi(); return context.getTransactionHandlers().reduce((promise, transactionHandler) =&gt; { return promise.then(() =&gt; { return transactionHandler.execute(api, resolvedTransaction) .then((count) =&gt; { totalCount += count; }); }); }, Promise.resolve()); }) .then(() =&gt; { // Execute any user transaction processor functions. const api = context.getApi(); return context.getCompiledScriptBundle().execute(api, resolvedTransaction) .then((count) =&gt; { totalCount += count; }); }) .then(() =&gt; { // Check that a transaction processor function was executed. if (totalCount === 0) { const error = new Error(`Could not find any functions to execute for transaction ${resolvedTransaction.getFullyQualifiedIdentifier()}`); LOG.error(method, error); throw error; } // Get the historian. LOG.debug(method, 'Getting historian'); return registryManager.get('Asset', 'org.hyperledger.composer.system.HistorianRecord'); }) .then((result) =&gt; { historian = result; LOG.debug(method, 'Getting default transaction registry for '+txClass); return registryManager.get('Transaction', txClass); }) .then((result) =&gt; { txRegistry = result; // Store the transaction in the transaction registry. LOG.debug(method, 'Storing executed transaction in transaction registry'); return txRegistry.add(transaction); }) .then(()=&gt;{ return this.createHistorianRecord(transaction,context); }) .then((result) =&gt; { // Store the transaction in the transaction registry. LOG.debug(method, 'Storing historian record in the registry'); return historian.add(result); }) .then(() =&gt; { context.clearTransaction(); LOG.exit(method); }); } /** * Creates the Historian Record for a given transaction * @param {Transaction} transaction originally submitted transaction * @param {Context} context of the transaction * @return {Promise} resolved with the Historian Record * @private */ createHistorianRecord(transaction,context) { const method = 'createHistorianRecord'; LOG.entry(method,transaction,context); // For reference the historian record looks like this // asset HistorianRecord identified by transactionId { // o String transactionId // --&gt; Transaction transactionInvoked // --&gt; Participant participantInvoking // --&gt; Identity identityUsed // o Event[] eventsEmitted // o DateTime tranactionTimestamp // } // create a record from the factory let factory = context.getFactory(); let record = factory.newResource('org.hyperledger.composer.system', 'HistorianRecord', transaction.getIdentifier()); LOG.info(method,'created historian record'); // Get the current participant &amp; create a relationship let participant = context.getParticipant(); if (!participant){ record.participantInvoking = null; } else { record.participantInvoking = factory.newRelationship(participant.getNamespace(),participant.getType(),participant.getIdentifier()); } // Get the transaction in question and also create a relationship record.transactionInvoked = factory.newRelationship(transaction.getNamespace(),transaction.getType(),transaction.getIdentifier()); record.transactionTimestamp = transaction.timestamp; record.transactionType = transaction.getFullyQualifiedType(); // Get the events that are generated - getting these as Resources let evtSvr = context.getEventService(); record.eventsEmitted = []; if(evtSvr) { let s = evtSvr.getEvents(); if (s) { s.forEach((element) =&gt; { let r = context.getSerializer().fromJSON(element); record.eventsEmitted.push(r); } ); } } // get the cached indentity // TODO there is the issue with the Admin userid that will be resolved in due course let id = context.getIdentity(); if (id){ record.identityUsed = factory.newRelationship(id.getNamespace(),id.getType(),id.getIdentifier()); } else { LOG.debug(method, 'assuming admin userid again'); } return Promise.resolve(record); } } module.exports = EngineTransactions; × Search results Close "},"composer-runtime_lib_eventservice.js.html":{"id":"composer-runtime_lib_eventservice.js.html","title":"Source: composer-runtime/lib/eventservice.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/eventservice.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const Service = require('./service'); const LOG = Logger.getLog('EventService'); /** * Base class representing the event service provided by a {@link Container}. * @protected * @abstract * @memberof module:composer-runtime */ class EventService extends Service { /** * Constructor. */ constructor() { super(); this.eventBuffer = []; } /** * Add an event to the buffer * @param {Resource} event The event to be emitted * when complete, or rejected with an error. */ emit(event) { const method = 'emit'; LOG.entry(method, event); this.eventBuffer.push(event); LOG.debug(method, this.eventBuffer); LOG.exit(method); } /** * Get an array of emitted events * @return {Resource[]} - An array of emitted events */ getEvents() { const method = 'getEvents'; LOG.entry(method); LOG.exit(method, this.eventBuffer); return this.eventBuffer; } /** * Called at the start of a transaction. * @param {boolean} readOnly Is the transaction read-only? * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionStart(readOnly) { return super.transactionStart(readOnly) .then(() =&gt; { this.eventBuffer = []; }); } } module.exports = EventService; × Search results Close "},"composer-runtime_lib_api_factory.js.html":{"id":"composer-runtime_lib_api_factory.js.html","title":"Source: composer-runtime/lib/api/factory.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/api/factory.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const LOG = Logger.getLog('Factory'); /** * Do not attempt to create an instance of this class.&lt;br&gt; * You must use the {@link module:composer-runtime#getFactory getFactory} * method instead. * * @class Factory * @classdesc A factory creates new instances of assets, participants, transactions, * and relationships. * @memberof module:composer-runtime * @public */ class Factory { /** * Constructor. * @param {Factory} factory The factory to use. * @private */ constructor(factory) { const method = 'constructor'; LOG.entry(method, factory); /** * Create a new resource (an instance of an asset, participant, or transaction). The * properties of the new instance should be set as standard JavaScript * object properties. The new instance can then be stored in a registry * using the appropriate registry APIs, for example {@link * module:composer-runtime.AssetRegistry AssetRegistry}. * @example * // Get the factory. * var factory = getFactory(); * // Create a new vehicle. * var vehicle = factory.newResource('org.acme', 'Vehicle', 'VEHICLE_1'); * // Set the properties of the new vehicle. * vehicle.colour = 'BLUE'; * vehicle.manufacturer = 'Toyota'; * @public * @method module:composer-runtime.Factory#newResource * @param {string} ns The namespace of the resource to create. * @param {string} type The type of the resource to create. * @param {string} id The identifier of the new resource. * @return {Resource} The new instance of the resource. * @throws {Error} If the specified type (specified by the namespace and * type) is not defined in the current version of the business network. */ this.newResource = function newResource(ns, type, id) { return factory.newResource(ns, type, id); }; /** * Create a new relationship with a given namespace, type, and identifier. * A relationship is a typed pointer to an instance. For example, a new * relationship with namespace 'org.acme', type 'Vehicle' and identifier * 'VEHICLE_1' creates` a pointer that points at an existing instance of * org.acme.Vehicle with the identifier 'VEHICLE_1'. * @example * // The existing driver of the vehicle. * var driver; * // Get the factory. * var factory = getFactory(); * // Create a new relationship to the vehicle. * var vehicle = factory.newRelationship('org.acme', 'Vehicle', 'VEHICLE_1'); * // Set the relationship as the value of the vehicle property of the driver. * driver.vehicle = vehicle; * @public * @method module:composer-runtime.Factory#newRelationship * @param {string} ns The namespace of the resource referenced by the relationship. * @param {string} type The type of the resource referenced by the relationship. * @param {string} id The identifier of the resource referenced by the relationship. * @return {Relationship} The new instance of the relationship. * @throws {Error} If the specified type (specified by the namespace and * type) is not defined in the current version of the business network. */ this.newRelationship = function newRelationship(ns, type, id) { return factory.newRelationship(ns, type, id); }; /** * Create a new concept with a given namespace, type, and identifier. * A concept is an advanced data structure * @example * // The existing driver of the vehicle. * var person; * // Get the factory. * var factory = getFactory(); * // Create a new relationship to the vehicle. * var record = factory.newConcept('org.acme', 'Record'); * // Add the record to the persons array of records. * person.records.push(record); * @public * @method module:composer-runtime.Factory#newConcept * @param {string} ns The namespace of the concept. * @param {string} type The type of the concept. * @return {Concept} The new instance of the concept. * @throws {Error} If the specified type (specified by the namespace and * type) is not defined in the current version of the business network. */ this.newConcept = function newConcept(ns, type) { return factory.newConcept(ns, type); }; /** * Create a new type with a given namespace and type * @public * @method module:composer-runtime.Factory#newEvent * @param {string} ns The namespace of the event. * @param {string} type The type of the event. * @return {Resource} The new instance of the event. * @throws {Error} If the specified type (specified by the namespace and * type) is not defined in the current version of the business network. */ this.newEvent = function newEvent(ns, type) { return factory.newEvent(ns, type); }; Object.freeze(this); LOG.exit(method); } } module.exports = Factory; × Search results Close "},"composer-runtime_lib_httpservice.js.html":{"id":"composer-runtime_lib_httpservice.js.html","title":"Source: composer-runtime/lib/httpservice.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/httpservice.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const Service = require('./service'); const LOG = Logger.getLog('HTTPService'); /** * Base class representing the http service provided by a {@link Container}. * @protected * @abstract * @memberof module:composer-runtime */ class HTTPService extends Service { /** * HTTP POST of a typed instance to a URL. The instance is serialized to JSON * and the JSON text is in the body of the HTTP POST. * @param {string} url - the URL to post data to * @param {Object} data - the data to POST. Data must be an object capable of being converted to a JSON string. * @return {Promise} A JS object that captures the statusCode and body of the HTTP POST response. An HTTP status code that is not 200 will cause the Promise to be rejected. The runtime will attempt to convert * the body to a JS object using JSON.parse. */ post(url,data) { const method = 'post'; LOG.entry(method, url, data); this.url = url; this.data = data; return this._post() .then((responseThing) =&gt; { let response = null; if(typeof responseThing === 'string' ) { response = JSON.parse(responseThing); } else { response = responseThing; } LOG.info(method, 'Reponse from URL ' + url, JSON.stringify(response)); if(response.statusCode &gt;= 200 &amp;&amp; response.statusCode &lt; 300) { if(response.body &amp;&amp; typeof response.body === 'string') { try { response.body = JSON.parse(response.body); } catch(err) { LOG.warn(method, 'Body data could not be converted to JS object', response.body); } } return Promise.resolve(response); } else { LOG.error(method, 'Error statusCode ', response.statusCode); return Promise.reject(JSON.stringify(response)); } }) .then((response) =&gt; { LOG.exit(method); return Promise.resolve(response); }); } /** * Post data * @abstract * @return {Promise} A Promise that return the JSON text for the HTTP POST. It captures the status code, header and body of the HTTP POST. The body must also be returned as embedded JSON text. * @throws {Error} throws an error if there is an issue */ _post() { throw new Error('abstract function called'); } } module.exports = HTTPService; × Search results Close "},"composer-runtime_lib_identityservice.js.html":{"id":"composer-runtime_lib_identityservice.js.html","title":"Source: composer-runtime/lib/identityservice.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/identityservice.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Service = require('./service'); /** * Base class representing the identity service provided by a {@link Container}. * @protected * @abstract * @memberof module:composer-runtime */ class IdentityService extends Service { /** * Get a unique identifier for the identity used to submit the transaction. * @abstract * @return {string} A unique identifier for the identity used to submit the transaction. */ getIdentifier() { throw new Error('abstract function called'); } /** * Get the name of the identity used to submit the transaction. * @abstract * @return {string} The name of the identity used to submit the transaction. */ getName() { throw new Error('abstract function called'); } /** * Get the issuer of the identity used to submit the transaction. * @abstract * @return {string} The issuer of the identity used to submit the transaction. */ getIssuer() { throw new Error('abstract function called'); } /** * Get the certificate for the identity used to submit the transaction. * @abstract * @return {string} The certificate for the identity used to submit the transaction. */ getCertificate() { throw new Error('abstract function called'); } } module.exports = IdentityService; × Search results Close "},"composer-runtime_lib_loggingservice.js.html":{"id":"composer-runtime_lib_loggingservice.js.html","title":"Source: composer-runtime/lib/loggingservice.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/loggingservice.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Service = require('./service'); /** * Base class representing the logging service provided by a {@link Container}. * @protected * @abstract * @memberof module:composer-runtime */ class LoggingService extends Service { /** * Write a critical message to the log. * @abstract * @param {string} message The message to write to the log. */ logCritical(message) { throw new Error('abstract function called'); } /** * Write a debug message to the log. * @abstract * @param {string} message The message to write to the log. */ logDebug(message) { throw new Error('abstract function called'); } /** * Write an error message to the log. * @abstract * @param {string} message The message to write to the log. */ logError(message) { throw new Error('abstract function called'); } /** * Write a informational message to the log. * @abstract * @param {string} message The message to write to the log. */ logInfo(message) { throw new Error('abstract function called'); } /** * Write a notice message to the log. * @abstract * @param {string} message The message to write to the log. */ logNotice(message) { throw new Error('abstract function called'); } /** * Write a warning message to the log. * @abstract * @param {string} message The message to write to the log. */ logWarning(message) { throw new Error('abstract function called'); } /** * Set the log level for the runtime. * @abstract * @param {string} newLogLevel The new log level to apply. */ setLogLevel(newLogLevel) { throw new Error('abstract function called'); } /** * Get the current log level for the runtime. * @abstract */ getLogLevel() { throw new Error('abstract function called'); } } module.exports = LoggingService; × Search results Close "},"composer-runtime_lib_api_participantregistry.js.html":{"id":"composer-runtime_lib_api_participantregistry.js.html","title":"Source: composer-runtime/lib/api/participantregistry.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/api/participantregistry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const LOG = Logger.getLog('ParticipantRegistry'); /** * Do not attempt to create an instance of this class.&lt;br&gt; * You must use the {@link module:composer-runtime#getParticipantRegistry getParticipantRegistry} * method instead. * * @class ParticipantRegistry * @classdesc An participant registry manages a set of participants. * @memberof module:composer-runtime * @public */ class ParticipantRegistry { /** * Constructor. * @param {Registry} registry The registry to use. * @private */ constructor(registry) { const method = 'constructor'; LOG.entry(method, registry); /** * Get a list of all of the existing participants in this participant registry. * @example * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (participantRegistry) { * // Get all of the drivers in the driver participant registry. * return participantRegistry.getAll(); * }) * .then(function (drivers) { * // Process the array of driver objects. * drivers.forEach(function (driver) { * console.log(driver.driverId); * }); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#getAll * @return {Promise} A promise. The promise is resolved with an array of * {@link Resource} instances representing all of the participants stored in this * participant registry. If the participant registry does not exist, or the current * user does not have access to the participant registry, then the promise will * be rejected with an error that describes the problem. */ this.getAll = function getAll() { return registry.getAll(); }; /** * Get the specified participant in this participant registry using the unique identifier * of the participant. * @example * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (participantRegistry) { * // Get the specific driver from the driver participant registry. * return participantRegistry.get('VEHICLE_1'); * }) * .then(function (driver) { * // Process the the driver object. * console.log(driver.driverId); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#get * @param {string} id The ID of the participant. * @return {Promise} A promise. The promise is resolved with a {@link Resource} * instance representing the specified participant in this participant registry. If the * specified participant does not exist, or the current user does not have access * to the specified participant, then the promise will be rejected with an error * that describes the problem. */ this.get = function get(id) { return registry.get(id); }; /** * Determines whether a specific participant exists in this participant registry. * @example * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (participantRegistry) { * // Determine if the specific driver exists in the driver participant registry. * return participantRegistry.exists('VEHICLE_1'); * }) * .then(function (exists) { * // Process the the boolean result. * console.log('Driver exists', exists); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#exists * @param {string} id The ID of the participant. * @return {Promise} A promise. The promise is resolved with a boolean which * is true if the specified participant exists in this participant registry, * and false if the specified participant does not exist. */ this.exists = function exists(id) { return registry.exists(id); }; /** * Add all of the specified participants to this participant registry. * @example * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (participantRegistry) { * // Get the factory for creating new participant instances. * var factory = getFactory(); * // Create the first driver. * var driver1 = factory.newResource('org.acme', 'Driver', 'VEHICLE_1'); * driver1.location = 'Southampton'; * // Create the second driver. * var driver2 = factory.newResource('org.acme', 'Driver', 'VEHICLE_2'); * driver2.location = 'GREEN'; * // Add the drivers to the driver participant registry. * return participantRegistry.addAll([driver1, driver2]); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#addAll * @param {Resource[]} participants The participants to add to this participant registry. * @return {Promise} A promise. The promise is resolved when all of the * participants have been added to this participant registry. If the participants cannot be * added to this participant registry, or if the participants already exist in the * participant registry, then the promise will be rejected with an error * that describes the problem. */ this.addAll = function addAll(participants) { return registry.addAll(participants, { convertResourcesToRelationships: true }); }; /** * Add the specified participant to this participant registry. * @example * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (participantRegistry) { * // Get the factory for creating new participant instances. * var factory = getFactory(); * // Create the driver. * var driver = factory.newResource('org.acme', 'Driver', 'VEHICLE_1'); * driver.location = 'Southampton'; * // Add the driver to the driver participant registry. * return participantRegistry.add(driver); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#add * @param {Resource} participant The participants to add to this participant registry. * @return {Promise} A promise. The promise is resolved when the participant has * been added to this participant registry. If the participant cannot be added to this * participant registry, or if the participant already exists in the participant registry, * then the promise will be rejected with an error that describes the problem. */ this.add = function add(participant) { return registry.add(participant, { convertResourcesToRelationships: true }); }; /** * Update all of the specified participants in this participant registry. * @example * // The existing drivers that have come from elsewhere. * var driver1; * var driver2; * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (participantRegistry) { * // Get the factory for creating new participant instances. * var factory = getFactory(); * // Modify the properties of the first driver. * driver1.location = 'Hursley'; * // Modify the properties of the second driver. * driver2.location = 'London'; * // Update the drivers in the driver participant registry. * return participantRegistry.updateAll([driver1, driver2]); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#updateAll * @param {Resource[]} participants The participants to update in this participant registry. * @return {Promise} A promise. The promise is resolved when all of the * participants have been updated in this participant registry. If the participants cannot be * updated in this participant registry, or if the participants do not exist in the * participant registry, then the promise will be rejected with an error that * describes the problem. */ this.updateAll = function updateAll(participants) { return registry.updateAll(participants, { convertResourcesToRelationships: true }); }; /** * Update the specified participant in this participant registry. * @example * // The existing driver that has come from elsewhere. * var driver; * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (participantRegistry) { * // Get the factory for creating new participant instances. * var factory = getFactory(); * // Modify the properties of the driver. * driver.location = 'Hursley'; * // Update the driver in the driver participant registry. * return participantRegistry.update(driver); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#update * @param {Resource} participant The participant to update in this participant registry. * @return {Promise} A promise. The promise is resolved when the participant * have been updated in this participant registry. If the participant cannot be * updated in this participant registry, or if the participant does not exist in the * participant registry, then the promise will be rejected with an error that * describes the problem. */ this.update = function update(participant) { return registry.update(participant, { convertResourcesToRelationships: true }); }; /** * Remove all of the specified participants from this participant registry. * @example * // The existing drivers that have come from elsewhere. * var driver1; * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (participantRegistry) { * // Get the factory for creating new participant instances. * var factory = getFactory(); * // Remove the drivers from the driver participant registry. Note that * // one driver is specified as a driver instance, and the other * // driver is specified by the ID of the driver. * return participantRegistry.removeAll([driver1, 'VEHICLE_2']); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#removeAll * @param {string[]|Resource[]} participants The participants, or the IDs of the participants, * to remove from this participant registry. * @return {Promise} A promise. The promise is resolved when all of the * participants have been removed from this participant registry. If the participants cannot be * removed from this participant registry, or if the participants do not exist in the * participant registry, then the promise will be rejected with an error that * describes the problem. */ this.removeAll = function removeAll(participants) { return registry.removeAll(participants); }; /** * Remove the specified participant from this participant registry. * @example * // The existing driver that has come from elsewhere. * var driver; * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (participantRegistry) { * // Get the factory for creating new participant instances. * var factory = getFactory(); * // Remove the driver from the driver participant registry. * return participantRegistry.remove(driver); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#remove * @param {string|Resource} participant The participant, or ID of the participant, to remove * from this participant registry. * @return {Promise} A promise. The promise is resolved when the participant * has been removed from this participant registry. If the participant cannot be * removed from this participant registry, or if the participant does not exist in the * participant registry, then the promise will be rejected with an error that * describes the problem. */ this.remove = function remove(participant) { return registry.remove(participant); }; Object.freeze(this); LOG.exit(method); } } module.exports = ParticipantRegistry; × Search results Close "},"composer-runtime_lib_api_query.js.html":{"id":"composer-runtime_lib_api_query.js.html","title":"Source: composer-runtime/lib/api/query.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/api/query.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const LOG = Logger.getLog('Query'); /** * Do not attempt to create an instance of this class.&lt;br&gt; * You must use the {@link module:composer-runtime#buildQuery buildQuery} * method instead. * * @class Query * @classdesc A query represents a built query. * @memberof module:composer-runtime * @public */ class Query { /** * Constructor. * @param {string} identifier The identifier of the built query. * @private */ constructor(identifier) { const method = 'constructor'; LOG.entry(method, identifier); /** * Get the identifier for this built query. * @private * @method module:composer-runtime.Query#getIdentifier * @return {string} The identifier for this built query. */ this.getIdentifier = function getIdentifier() { return identifier; }; Object.freeze(this); LOG.exit(method); } } module.exports = Query; × Search results Close "},"composer-runtime_lib_resolver.js.html":{"id":"composer-runtime_lib_resolver.js.html","title":"Source: composer-runtime/lib/resolver.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/resolver.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AssetDeclaration = require('composer-common').AssetDeclaration; const CallbackRelationship = require('./callbackrelationship'); const Concept = require('composer-common').Concept; const InvalidRelationship = require('./invalidrelationship'); const Logger = require('composer-common').Logger; const ParticipantDeclaration = require('composer-common').ParticipantDeclaration; const Relationship = require('composer-common').Relationship; const Resource = require('composer-common').Resource; const TransactionDeclaration = require('composer-common').TransactionDeclaration; const LOG = Logger.getLog('Resolver'); /** * A class for resolving resources and their relationships to other resources. * @protected * @abstract * @memberof module:composer-runtime */ class Resolver { /** * Constructor. * @param {Factory} factory The factory to use. * @param {Introspector} introspector The introspector to use. * @param {RegistryManager} registryManager The registry manager to use. */ constructor(factory, introspector, registryManager) { const method = 'constructor'; LOG.entry(method, registryManager); this.factory = factory; this.introspector = introspector; this.registryManager = registryManager; LOG.exit(method); } /** * @callback prepareCallback * @protected * @param {Promise} promise A promise that is resolved when resolving is complete. */ /** * Prepare the specified resource and all of its relationships. This means that all * relationships will be replaced with wrappers that lazily trigger the resolving process. * @param {Resource|Relationship} identifiable The identifiable to resolve. * @param {prepareCallback} callback The callback to call if and when resolving occurs. * @return {Promise} A promise that is resolved immediately. */ prepare(identifiable, callback) { const method = 'prepare'; LOG.entry(method, identifiable.toString()); let resolveState = { cachedResources: new Map(), prepare: true, prepareCallback: callback, preparePromise: Promise.resolve() }; if (identifiable instanceof Resource) { return this.resolveResourceOrConcept(identifiable, resolveState) .then((result) =&gt; { LOG.exit(method, result.toString()); return result; }); } else { LOG.error(method, 'unsupported type for identifiable'); throw new Error('unsupported type for identifiable'); } } /** * Resolve the specified resource or relationship and all of its relationships. * @param {Resource|Relationship} identifiable The identifiable to resolve. * @return {Promise} A promise that is resolved with the resolved {@link Resource} * object when the resource is resolved, or rejected with an error. */ resolve(identifiable) { const method = 'resolve'; LOG.entry(method, identifiable.toString()); let resolveState = { cachedResources: new Map() }; if (identifiable instanceof Resource) { return this.resolveResourceOrConcept(identifiable, resolveState) .then((result) =&gt; { LOG.exit(method, result.toString()); return result; }); } else if (identifiable instanceof Relationship) { return this.resolveRelationship(identifiable, resolveState) .then((result) =&gt; { LOG.exit(method, result.toString()); return result; }); } else { LOG.error(method, 'unsupported type for identifiable'); throw new Error('unsupported type for identifiable'); } } /** * Resolve the specified resource. * @private * @param {Resource} resource The resource to resolve. * @param {Object} resolveState The current resolve state. * @param {Map} resolveState.cachedResources The cache of resolved resources. * @return {Promise} A promise that is resolved with a {@link Resource} object, * or rejected with an error. */ resolveResourceOrConcept(resource, resolveState) { const method = 'resolveResourceOrConcept'; LOG.entry(method, resource.toString(), resolveState); // Create a new resource, we don't want to modify the original. let newResource; if (resource instanceof Resource) { // Check we haven't cached this resource already. let fqi = resource.getFullyQualifiedIdentifier(); if (resolveState.cachedResources.has(fqi)) { LOG.debug(method, 'Target resource is already present in cache', fqi); let resource = resolveState.cachedResources.get(fqi); LOG.exit(method, resource.toString()); return Promise.resolve(resource); } // Create a new resource and cache that. newResource = this.factory.newResource(resource.getNamespace(), resource.getType(), resource.getIdentifier()); resolveState.cachedResources.set(fqi, newResource); } else { newResource = this.factory.newConcept(resource.getNamespace(), resource.getType()); } // Iterate over all the properties of the resource. let classDeclaration = resource.getClassDeclaration(); return classDeclaration.getProperties().reduce((result, property) =&gt; { // Get the property value. LOG.debug(method, 'Looking at property', property.getName()); let value = resource[property.getName()]; // Shortcut if the value is not set. if (value === undefined) { return result; } // Process the value accordingly based on its type. if (value instanceof Resource) { // Replace the property value with the resolved resource. LOG.debug(method, 'Property value is a resource, resolving', value.toString()); return result.then(() =&gt; { return this.resolveResourceOrConcept(value, resolveState); }).then((newValue) =&gt; { newResource[property.getName()] = newValue; }); } else if (value instanceof Concept) { // Replace the property value with the resolved resource. LOG.debug(method, 'Property value is a concept, resolving', value.toString()); return result.then(() =&gt; { return this.resolveResourceOrConcept(value, resolveState); }).then((newValue) =&gt; { newResource[property.getName()] = newValue; }); } else if (value instanceof Relationship) { // If we are called as part of prepare, we set up a lazy relationship. if (resolveState.prepare) { const newValue = new CallbackRelationship(value, (propertyName) =&gt; { LOG.debug(method, 'Relationship callback, resolving', newValue, propertyName); const result = resolveState.preparePromise.then(() =&gt; { return this.resolveRelationship(newValue, resolveState); }).then((resolvedValue) =&gt; { LOG.debug(method, 'Relationship callback, resolved', resolvedValue, propertyName); newResource[property.getName()] = resolvedValue; return resolvedValue[propertyName]; }); resolveState.preparePromise = result; resolveState.prepareCallback(result); return result; }); newResource[property.getName()] = newValue; return result; } // Replace the property value with the resolved relationship. LOG.debug(method, 'Property value is a relationship, resolving', value.toString()); return result.then(() =&gt; { return this.resolveRelationship(value, resolveState); }).then((newValue) =&gt; { newResource[property.getName()] = newValue; }); } else if (Array.isArray(value)) { // Go through each item in the array. LOG.debug(method, 'Property value is an array, iterating over values', value.length); return result.then(() =&gt; { return this.resolveArray(value, resolveState); }) .then((newValue) =&gt; { newResource[property.getName()] = newValue; }); } else { // Copy the original value across. LOG.debug(method, 'Property value is neither a resource or a relationship, ignoring', value); newResource[property.getName()] = value; return result; } }, Promise.resolve()) .then(() =&gt; { LOG.exit(method, resource.toString()); return newResource; }); } /** * Resolve all of the elements in the specified array. * @private * @param {*} array The array to resolve. * @param {Object} resolveState The current resolve state. * @param {Map} resolveState.cachedResources The cache of resolved resources. * @return {Promise} A promise that is resolved with an array of resolved objects, * or rejected with an error. */ resolveArray(array, resolveState) { const method = 'resolveArray'; LOG.entry(method, array, resolveState); return array.reduce((promise, item, index) =&gt; { // Check the type of the item in the array. if (item instanceof Resource) { // Replace the property value with the resolved resource. LOG.debug(method, 'Array item is a resource, resolving', item.toString()); return promise.then((newArray) =&gt; { return this.resolveResourceOrConcept(item, resolveState) .then((newItem) =&gt; { newArray.push(newItem); return newArray; }); }); } else if (item instanceof Concept) { // Replace the property value with the resolved concept. LOG.debug(method, 'Array item is a concept, resolving', item.toString()); return promise.then((newArray) =&gt; { return this.resolveResourceOrConcept(item, resolveState) .then((newItem) =&gt; { newArray.push(newItem); return newArray; }); }); } else if (item instanceof Relationship) { // Replace the property value with the resolved relationship. LOG.debug(method, 'Property value is a relationship, resolving', item.toString()); return promise.then((newArray) =&gt; { // If we are called as part of prepare, we set up a lazy relationship. if (resolveState.prepare) { const newIndex = newArray.length; const newItem = new CallbackRelationship(item, (propertyName) =&gt; { LOG.debug(method, 'Relationship callback, resolving', newItem, propertyName); const result = resolveState.preparePromise.then(() =&gt; { return this.resolveRelationship(newItem, resolveState); }).then((resolvedItem) =&gt; { newArray[newIndex] = resolvedItem; return resolvedItem[propertyName]; }); resolveState.preparePromise = result; resolveState.prepareCallback(result); return result; }); newArray.push(newItem); return newArray; } return this.resolveRelationship(item, resolveState) .then((newItem) =&gt; { newArray.push(newItem); return newArray; }); }); } else { // Copy the original value across. LOG.debug(method, 'Array item is neither a resource or a relationship, ignoring', item); return promise.then((newArray) =&gt; { newArray.push(item); return newArray; }); } }, Promise.resolve([])) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Get the registry for the specified relationship. * @private * @param {Relationship} relationship The relationship to resolve. * @return {Promise} A promise that is resolved with a {@link Registry} object, * or rejected with an error. */ getRegistryForRelationship(relationship) { const method = 'getRegistryForRelationship'; LOG.entry(method, relationship.toString()); let registryId = relationship.getFullyQualifiedType(); let classDeclaration = this.introspector.getClassDeclaration(registryId); LOG.debug(method, 'Got class declaration', classDeclaration); let classType; if (classDeclaration instanceof AssetDeclaration) { classType = 'Asset'; } else if (classDeclaration instanceof ParticipantDeclaration) { classType = 'Participant'; } else if (classDeclaration instanceof TransactionDeclaration) { classType = 'Transaction'; } else { throw new Error('Unsupported class declaration type ' + classDeclaration.toString()); } LOG.debug(method, 'Getting registry', registryId); return this.registryManager.get(classType, registryId) .then((registry) =&gt; { LOG.exit(method, registry); return registry; }); } /** * Resolve the specified relationship. * @private * @param {Relationship} relationship The relationship to resolve. * @param {Object} resolveState The current resolve state. * @param {Map} resolveState.cachedResources The cache of resolved resources. * @param {boolean} [resolveState.skipRecursion] Set to true to skip resolving the resolved resource. * @return {Promise} A promise that is resolved with a {@link Resource} object, * or rejected with an error. */ resolveRelationship(relationship, resolveState) { const method = 'resolveRelationship'; LOG.entry(method, relationship.toString(), resolveState); // Check the cache for an existing resolved relationship. let fqi = relationship.getFullyQualifiedIdentifier(); if (resolveState.cachedResources.has(fqi)) { LOG.debug(method, 'Target resource is already present in cache', fqi); let resource = resolveState.cachedResources.get(fqi); LOG.exit(method, resource.toString()); return Promise.resolve(resource); } // Nope, need to resolve it! return this.getRegistryForRelationship(relationship) .then((registry) =&gt; { let resourceId = relationship.getIdentifier(); LOG.debug(method, 'Getting resource in registry', resourceId); return registry.get(resourceId); }) .then((resource) =&gt; { if (resolveState.skipRecursion) { LOG.debug(method, 'Got resource from registry, but skipping resolve'); resolveState.cachedResources.set(fqi, resource); return resource; } else { LOG.debug(method, 'Got resource from registry, resolving'); return this.resolveResourceOrConcept(resource, resolveState); } }) .then((resource) =&gt; { LOG.exit(method, resource.toString()); return resource; }) .catch((error) =&gt; { LOG.error(method, 'Failed to resolve relationship', error); const invalid = new InvalidRelationship(relationship, error); LOG.exit(method, invalid); return invalid; }); } } module.exports = Resolver; × Search results Close "},"composer-runtime_lib_api_serializer.js.html":{"id":"composer-runtime_lib_api_serializer.js.html","title":"Source: composer-runtime/lib/api/serializer.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/api/serializer.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const LOG = Logger.getLog('Serializer'); /** * Do not attempt to create an instance of this class.&lt;br&gt; * You must use the {@link module:composer-runtime#getSerializer getSerializer} * method instead. * * @class Serializer * @classdesc A serializer serializes instances of assets, participants, transactions, * and relationships to and from a JSON serialization format. * @memberof module:composer-runtime * @public */ class Serializer { /** * Constructor. * @param {Serializer} serializer The serializer to use. * @private */ constructor(serializer) { const method = 'constructor'; LOG.entry(method, serializer); /** * Convert a {@link Resource} to a JavaScript object suitable for long-term * peristent storage. * @example * // Get the serializer. * var serializer = getSerializer(); * // Serialize a vehicle. * var json = serializer.toJSON(vehicle); * @public * @method module:composer-runtime.Serializer#toJSON * @param {Resource} resource The resource instance to convert to JSON. * @param {Object} [options] The optional serialization options. * @param {boolean} [options.validate] Validate the structure of the resource * with its model prior to serialization, true by default. * @param {boolean} [options.convertResourcesToRelationships] Convert resources that * are specified for relationship fields into relationships, false by default. * @param {boolean} [options.permitResourcesForRelationships] Permit resources in the * place of relationships (serializing them as resources), false by default. * @return {Object} The JavaScript object that represents the resource * @throws {Error} If the specified resource is not an instance of * {@link Resource} or if it fails validation during serialization. */ this.toJSON = function toJSON(resource, options) { return serializer.toJSON(resource, options); }; /** * Create a {@link Resource} from a JavaScript object representation. * The JavaScript object should have been created by calling the * {@link Serializer#toJSON toJSON} API. * The {@link Resource} is populated based on the JavaScript object. * @example * // Get the serializer. * var serializer = getSerializer(); * // Serialize a vehicle. * var vehicle = serializer.fromJSON(json); * @public * @method module:composer-runtime.Serializer#fromJSON * @param {Object} json The JavaScript object for the resource. * @param {Object} [options] The optional serialization options. * @param {boolean} [options.acceptResourcesForRelationships] Handle JSON objects * in the place of strings for relationships, false by default. * @return {Resource} The resource. * @throws {Error} If the specified resource is not an instance of * {@link Resource} or if it fails validation during serialization. */ this.fromJSON = function fromJSON(json, options) { return serializer.fromJSON(json, options); }; Object.freeze(this); LOG.exit(method); } } module.exports = Serializer; × Search results Close "},"composer-runtime_lib_service.js.html":{"id":"composer-runtime_lib_service.js.html","title":"Source: composer-runtime/lib/service.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/service.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Base class for all services provided by a {@link Container}. * @protected * @abstract * @memberof module:composer-runtime */ class Service { /** * Constructor. */ constructor() { } /** * Called at the start of a transaction. * @abstract * @param {boolean} readOnly Is the transaction read-only? * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionStart(readOnly) { return new Promise((resolve, reject) =&gt; { this._transactionStart(readOnly, (error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback transactionStartCallback * @protected * @param {Error} error The error if any. */ /** * Called at the start of a transaction. * @abstract * @param {boolean} readOnly Is the transaction read-only? * @param {transactionStartCallback} callback The callback function to call when complete. */ _transactionStart(readOnly, callback) { callback(); } /** * Called when a transaction is preparing to commit. * @abstract * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionPrepare() { return new Promise((resolve, reject) =&gt; { this._transactionPrepare((error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback transactionPrepareCallback * @protected * @param {Error} error The error if any. */ /** * Called when a transaction is preparing to commit. * @abstract * @param {transactionPrepareCallback} callback The callback function to call when complete. */ _transactionPrepare(callback) { callback(); } /** * Called when a transaction is rolling back. * @abstract * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionRollback() { return new Promise((resolve, reject) =&gt; { this._transactionRollback((error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback transactionRollbackCallback * @protected * @param {Error} error The error if any. */ /** * Called when a transaction is rolling back * @abstract * @param {transactionRollbackCallback} callback The callback function to call when complete. */ _transactionRollback(callback) { callback(); } /** * Called when a transaction is committing. * @abstract * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionCommit() { return new Promise((resolve, reject) =&gt; { this._transactionCommit((error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback transactionCommitCallback * @protected * @param {Error} error The error if any. */ /** * Called when a transaction is committing. * @abstract * @param {transactionCommitCallback} callback The callback function to call when complete. */ _transactionCommit(callback) { callback(); } /** * Called at the end of a transaction. * @abstract * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionEnd() { return new Promise((resolve, reject) =&gt; { this._transactionEnd((error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback transactionEndCallback * @protected * @param {Error} error The error if any. */ /** * Called at the end of a transaction. * @abstract * @param {transactionEndCallback} callback The callback function to call when complete. */ _transactionEnd(callback) { callback(); } } module.exports = Service; × Search results Close "},"composer-runtime_lib_transactionlogger.js.html":{"id":"composer-runtime_lib_transactionlogger.js.html","title":"Source: composer-runtime/lib/transactionlogger.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/transactionlogger.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const jsonpatch = require('fast-json-patch'); const Logger = require('composer-common').Logger; const LOG = Logger.getLog('TransactionLogger'); /* istanbul ignore next */ /** * A class for logging the changes made by a transaction. * @protected * @abstract * @memberof module:composer-runtime */ class TransactionLogger { /** * Create a logger for the specified transaction. * @param {Resource} transaction The transaction. * @param {RegistryManager} registryManager The registry manager. * @param {Serializer} serializer The serializer. */ constructor(transaction, registryManager, serializer) { const method = 'constructor'; LOG.entry(method, transaction, registryManager, serializer); this.transaction = transaction; this.registryManager = registryManager; this.serializer = serializer; registryManager.on('resourceadded', this.onResourceAdded.bind(this)); registryManager.on('resourceupdated', this.onResourceUpdated.bind(this)); registryManager.on('resourceremoved', this.onResourceRemoved.bind(this)); LOG.exit(method); } /** * Handle a resource being added to a registry. * @param {Registry#resourceadded} event The resource added event. */ onResourceAdded(event) { const method = 'onResourceAdded'; LOG.entry(method, event); LOG.exit(method); } /** * Handle a resource being added to a registry. * @param {Registry#resourceupdated} event The resource added event. */ onResourceUpdated(event) { const method = 'onResourceUpdated'; LOG.entry(method, event); // Serialize both the old and new resources. let oldJSON = this.serializer.toJSON(event.oldResource, { convertResourcesToRelationships: true }); LOG.debug(method, 'Serialized old resource'); let newJSON = this.serializer.toJSON(event.newResource, { convertResourcesToRelationships: true }); LOG.debug(method, 'Serialized new resource'); // Generate a JSON Patch from the two resources. let patches = jsonpatch.compare(oldJSON, newJSON); LOG.debug(method, 'Generated JSON Patch', patches); LOG.exit(method); } /** * Handle a resource being added to a registry. * @param {Registry#resourceremoved} event The resource added event. */ onResourceRemoved(event) { const method = 'onResourceRemoved'; LOG.entry(method, event); LOG.exit(method); } } module.exports = TransactionLogger; × Search results Close "},"composer-runtime_lib_api.js.html":{"id":"composer-runtime_lib_api.js.html","title":"Source: composer-runtime/lib/api.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/api.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AssetRegistry = require('./api/assetregistry'); const Factory = require('./api/factory'); const Logger = require('composer-common').Logger; const ParticipantRegistry = require('./api/participantregistry'); const Query = require('./api/query'); const Registry = require('./registry'); const Serializer = require('./api/serializer'); const LOG = Logger.getLog('Api'); /** * A class that contains the root of the transaction processor API. Methods in this * class are made available as global functions which can be called by transaction * processor functions. The transaction processor API should expose no internal * properties or internal methods which could be accessed or misused. * @private * @class * @memberof module:composer-runtime */ class Api { /** * The runtime API method names. * @private * @returns {String[]} The runtime API method names. */ static getMethodNames() { return [ 'getFactory', 'getSerializer', 'getAssetRegistry', 'getParticipantRegistry', 'getCurrentParticipant', 'post', 'emit', 'buildQuery', 'query' ]; } /** * Constructor. * @param {Context} context The transaction context. * @private */ constructor(context) { const method = 'constructor'; LOG.entry(method, context); // Get all the things from the context. const factory = context.getFactory(); const serializer = context.getSerializer(); const participant = context.getParticipant(); const registryManager = context.getRegistryManager(); const httpService = context.getHTTPService(); const eventService = context.getEventService(); const dataService = context.getDataService(); const accessController = context.getAccessController(); /** * Get the factory. The factory can be used to create new instances of * assets, participants, and transactions for storing in registries. The * factory can also be used for creating relationships to assets, particpants, * and transactions. * @example * // Get the factory. * var factory = getFactory(); * @method module:composer-runtime#getFactory * @public * @return {module:composer-runtime.Factory} The factory. */ this.getFactory = function getFactory() { const method = 'getFactory'; LOG.entry(method); let result = new Factory(factory); LOG.exit(method, result); return result; }; /** * Get the serializer. The serializer can be used to create new instances of * assets, participants, and transactions from a JavaScript object, or to create * a JavaScript object suitable for long-lived persistence. * @example * // Get the serializer. * var ser = getSerializer(); * @method module:composer-runtime#getSerializer * @public * @return {module:composer-common.Serializer} The serializer. */ this.getSerializer = function getSerializer() { const method = 'getSerializer'; LOG.entry(method); let result = new Serializer(serializer); LOG.exit(method, result); return result; }; /** * Get an existing asset registry using the unique identifier of the asset * registry. An asset registry can be used to retrieve, update, or delete * existing assets, or create new assets. * @example * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Call methods on the vehicle asset registry. * }) * .catch(function (error) { * // Add optional error handling here. * }); * @method module:composer-runtime#getAssetRegistry * @public * @param {string} id The ID of the asset registry. * @return {Promise} A promise. The promise is resolved with an {@link * module:composer-runtime.AssetRegistry AssetRegistry} instance * representing the asset registry if it exists. If the asset registry * does not exist, or the current user does not have access to the asset * registry, then the promise will be rejected with an error that describes * the problem. */ this.getAssetRegistry = function getAssetRegistry(id) { const method = 'getAssetRegistry'; LOG.entry(method, id); return registryManager.get('Asset', id) .then((registry) =&gt; { let result = new AssetRegistry(registry); LOG.exit(method, result); return result; }); }; /** * Get an existing participant registry using the unique identifier of the participant * registry. An participant registry can be used to retrieve, update, or delete * existing participants, or create new participants. * @example * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (driverParticipantRegistry) { * // Call methods on the driver participant registry. * }) * .catch(function (error) { * // Add optional error handling here. * }); * @method module:composer-runtime#getParticipantRegistry * @public * @param {string} id The ID of the participant registry. * @return {Promise} A promise. The promise is resolved with an {@link * module:composer-runtime.ParticipantRegistry ParticipantRegistry} instance * representing the participant registry if it exists. If the participant registry * does not exist, or the current user does not have access to the participant * registry, then the promise will be rejected with an error that describes * the problem. */ this.getParticipantRegistry = function getParticipantRegistry(id) { const method = 'getParticipantRegistry'; LOG.entry(method, id); return registryManager.get('Participant', id) .then((registry) =&gt; { let result = new ParticipantRegistry(registry); LOG.exit(method, result); return result; }); }; /** * Get the current participant. The current participant is determined by * the identity that was used to submit the current transaction. * @example * // Get the current participant. * var currentParticipant = getCurrentParticipant(); * // Check to see if the current participant is a driver. * if (currentParticipant.getFullyQualifiedType() !== 'org.acme.Driver') { * // Throw an error as the current participant is not a driver. * throw new Error('Current participant is not a driver'); * } * // Check to see if the current participant is the first driver. * if (currentParticipant.getFullyQualifiedIdentifier() !== 'org.acme.Driver#DRIVER_1') { * // Throw an error as the current participant is not a driver. * throw new Error('Current participant is not the first driver'); * } * @method module:composer-runtime#getCurrentParticipant * @public * @return {module:composer-common.Resource} The current participant, * or null if the transaction was submitted using an identity that does * not map to a participant. */ this.getCurrentParticipant = function getCurrentParticipant() { const method = 'getCurrentParticipant'; LOG.entry(method); let result = participant; LOG.exit(method, result); return result; }; /** * Post a typed instance to a HTTP URL * @method module:composer-runtime#post * @param {string} url The URL to post the data to * @param {Typed} typed The typed instance to be posted. The instance will be serialized to JSON. * @param {object} options The options that are passed to Serializer.toJSON * @return {Promise} A promise. The promise is resolved with a HttpResponse * that represents the result of the HTTP POST. * @public */ this.post = function post(url, typed, options) { const method = 'post'; LOG.entry(method, url, typed); const data = serializer.toJSON(typed, options); LOG.debug(method, typed.getFullyQualifiedType(), data); return httpService.post(url, data) .then((response) =&gt; { LOG.exit(method); return Promise.resolve(response); }); }; /** * Emit an event defined in the transaction * @method module:composer-runtime#emit * @param {Resource} event The event to be emitted * @public */ this.emit = function emit(event) { const method = 'emit'; LOG.entry(method, event); event.setIdentifier(context.getTransaction().getIdentifier() + '#' + context.getEventNumber()); event.timestamp = context.getTransaction().timestamp; let serializedEvent = serializer.toJSON(event, { convertResourcesToRelationships: true }); context.incrementEventNumber(); LOG.debug(method, event.getFullyQualifiedIdentifier(), serializedEvent); eventService.emit(serializedEvent); LOG.exit(method); }; /** * Build a query ready for later execution. The specified query string must be written * in the Composer query language. * * This functionality is Blockchain platform dependent. For example, when a Composer * business network is deployed to Hyperledger Fabric v1.0, Hyperledger Fabric must be * configured with the CouchDB database for the world state. * @example * // Build a query. * var query = buildQuery('SELECT org.acme.sample.SampleAsset WHERE (value == _$inputValue)'); * // Execute the query. * return query(query, { inputValue: 'blue' }) * .then(function (assets) { * assets.forEach(function (asset) { * // Process each asset. * }); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @method module:composer-runtime#buildQuery * @param {string} query The query string, written using the Composer query language. * @return {Query} The built query, which can be passed in a call to query. * @public */ this.buildQuery = function buildQuery(query) { const method = 'buildQuery'; LOG.entry(method, query); const identifier = context.getCompiledQueryBundle().buildQuery(query); const result = new Query(identifier); LOG.exit(method, result); return result; }; /** * Execute a query defined in a Composer query file, or execute a query built with buildQuery. * * This functionality is Blockchain platform dependent. For example, when a Composer * business network is deployed to Hyperledger Fabric v1.0, Hyperledger Fabric must be * configured with the CouchDB database for the world state. * @example * // Execute the query. * return query('Q1', { inputValue: 'blue' }) * .then(function (assets) { * assets.forEach(function (asset) { * // Process each asset. * }); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @method module:composer-runtime#query * @param {string|Query} query The name of the query, or a built query. * @param {Object} [parameters] The parameters for the query. * @return {Promise} A promise that will be resolved with an array of * {@link module:composer-common.Resource Resource} representing the * resources returned by the query. * @public */ this.query = function query(query, parameters) { const method = 'query'; LOG.entry(method, query); let identifier; if (query instanceof Query) { identifier = query.getIdentifier(); } else if (typeof query === 'string') { identifier = query; } else { throw new Error('Invalid query; expecting a built query or the name of a query'); } return context.getCompiledQueryBundle().execute(dataService, identifier, parameters) .then((objects) =&gt; { return objects.map((object) =&gt; { object = Registry.removeInternalProperties(object); return serializer.fromJSON(object); }).reduce((resources, resource) =&gt; { return resources.then((resources) =&gt; { return accessController.check(resource, 'READ') .then(() =&gt; { resources.push(resource); return resources; }) .catch((error) =&gt; { return resources; }); }); }, Promise.resolve([])); }) .then((resources) =&gt; { LOG.exit(method, resources); return resources; }); }; Object.freeze(this); LOG.exit(method); } } module.exports = Api; × Search results Close "},"composer-runtime_lib_networkmanager.js.html":{"id":"composer-runtime_lib_networkmanager.js.html","title":"Source: composer-runtime/lib/networkmanager.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/networkmanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BusinessNetworkDefinition = require('composer-common').BusinessNetworkDefinition; const Context = require('./context'); const createHash = require('sha.js'); const Logger = require('composer-common').Logger; const TransactionHandler = require('./transactionhandler'); const LOG = Logger.getLog('IdentityManager'); /** * A class for managing networks. * @protected */ class NetworkManager extends TransactionHandler { /** * Constructor. * @param {Context} context The request context. */ constructor(context) { super(); this.context = context; LOG.info('&lt;ResourceManager&gt;', 'Binding in the tx names and impl'); this.bind( 'org.hyperledger.composer.system.StartBusinessNetwork', this.startBusinessNetwork ); this.bind( 'org.hyperledger.composer.system.UpdateBusinessNetwork', this.updateBusinessNetwork ); this.bind( 'org.hyperledger.composer.system.ResetBusinessNetwork', this.resetBusinessNetwork ); this.bind( 'org.hyperledger.composer.system.SetLogLevel', this.setLogLevel ); } /** * Set the log level for the runtime. * @param {api} api The request context. * @param {Transaction} transaction The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ setLogLevel(api, transaction) { const method = 'setLogLevel'; LOG.entry(method, transaction); let dataService = this.context.getDataService(); let sysdata, resource; return dataService.getCollection('$sysdata') .then((result) =&gt; { sysdata = result; return sysdata.get('metanetwork'); }) .then((result) =&gt; { resource = this.context.getSerializer().fromJSON(result); return this.context.getAccessController().check(resource, 'UPDATE'); }) .then(() =&gt; { return this.context.getLoggingService().setLogLevel(transaction.newLogLevel); }); } /** * Start the business network archive. * @param {api} api The request context. * @param {Transaction} transaction The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ startBusinessNetwork(api, transaction) { const method = 'startBusinessNetwork'; LOG.entry(method, transaction); LOG.exit(method); return Promise.resolve(); } /** * Update the business network archive. * @param {api} api The request context. * @param {Transaction} transaction The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ updateBusinessNetwork(api, transaction) { const method = 'updateBusinessNetwork'; LOG.entry(method, transaction); let dataService = this.context.getDataService(); let businessNetworkBase64, businessNetworkHash, businessNetworkDefinition; let compiledScriptBundle, compiledQueryBundle, compiledAclBundle; let sysdata, resource; return dataService.getCollection('$sysdata') .then((result) =&gt; { sysdata = result; return sysdata.get('metanetwork'); }) .then((result) =&gt; { resource = this.context.getSerializer().fromJSON(result); return this.context.getAccessController().check(resource, 'UPDATE'); }) // return Promise.resolve() .then(() =&gt; { // Load, validate, and hash the business network definition. LOG.debug(method, 'Loading business network definition'); businessNetworkBase64 = transaction.businessNetworkArchive; let businessNetworkArchive = Buffer.from(businessNetworkBase64, 'base64'); let sha256 = createHash('sha256'); businessNetworkHash = sha256.update(businessNetworkBase64, 'utf8').digest('hex'); LOG.debug(method, 'Calculated business network definition hash', businessNetworkHash); return BusinessNetworkDefinition.fromArchive(businessNetworkArchive); }) .then((businessNetworkDefinition_) =&gt; { // // Cache the business network. businessNetworkDefinition = businessNetworkDefinition_; LOG.debug(method, 'Loaded business network definition, storing in cache'); Context.cacheBusinessNetwork(businessNetworkHash, businessNetworkDefinition); // Cache the compiled script bundle. compiledScriptBundle = this.context.getScriptCompiler().compile(businessNetworkDefinition.getScriptManager()); LOG.debug(method, 'Loaded compiled script bundle, storing in cache'); Context.cacheCompiledScriptBundle(businessNetworkHash, compiledScriptBundle); // Cache the compiled query bundle. compiledQueryBundle = this.context.getQueryCompiler().compile(businessNetworkDefinition.getQueryManager()); LOG.debug(method, 'Loaded compiled query bundle, storing in cache'); Context.cacheCompiledQueryBundle(businessNetworkHash, compiledQueryBundle); // Cache the compiled ACL bundle. compiledAclBundle = this.context.getAclCompiler().compile(businessNetworkDefinition.getAclManager(), businessNetworkDefinition.getScriptManager()); LOG.debug(method, 'Loaded compiled ACL bundle, storing in cache'); Context.cacheCompiledAclBundle(businessNetworkHash, compiledAclBundle); // Get the sysdata collection where the business network definition is stored. LOG.debug(method, 'Loaded business network definition, storing in $sysdata collection'); // Update the business network definition in the sysdata collection. return sysdata.update('businessnetwork', { data: businessNetworkBase64, hash: businessNetworkHash }); }) .then(() =&gt; { // Reinitialize the context to reload the business network. LOG.debug(method, 'Reinitializing context'); return this.context.initialize({ businessNetworkDefinition: businessNetworkDefinition, compiledScriptBundle: compiledScriptBundle, compiledQueryBundle: compiledQueryBundle, compiledAclBundle: compiledAclBundle, reinitialize: true }); }) .then(() =&gt; { // Create all other default registries. LOG.debug(method, 'Creating default registries'); let registryManager = this.context.getRegistryManager(); return registryManager.createDefaults(); }) .then(() =&gt; { LOG.exit(method); }); } /** * Reset the business network by clearing all data. * @param {api} api The request context. * @param {Transaction} transaction The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ resetBusinessNetwork(api, transaction) { const method = 'resetBusinessNetwork'; LOG.entry(method, transaction); let dataService = this.context.getDataService(); let sysdata, resource; return dataService.getCollection('$sysdata') .then((result) =&gt; { sysdata = result; return sysdata.get('metanetwork'); }) .then((result) =&gt; { resource = this.context.getSerializer().fromJSON(result); return this.context.getAccessController().check(resource, 'UPDATE'); }) .then( ()=&gt;{ return this._resetRegistries( 'Asset'); }) .then(() =&gt; { return this._resetRegistries( 'Participant'); }) .then(() =&gt; { return this._resetRegistries( 'Transaction'); }) .then ( ()=&gt; { // force creation of defaults as we know the don't exist // Create all other default registries. LOG.debug(method, 'Creating default registries'); let registryManager = this.context.getRegistryManager(); return registryManager.createDefaults(true); }) .then(() =&gt; { LOG.exit(method); }); } /** * Reset all registries of the specified type by clearing all data. * @param {String} type of the registry to reset * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ _resetRegistries(type) { const method = '_resetRegistries'; LOG.entry(method, type); let registryManager = this.context.getRegistryManager(); return registryManager.getAll(type) .then((registries) =&gt; { return registries.reduce((promise, registry) =&gt; { return promise.then(() =&gt; { if (registry.system) { LOG.debug(method, 'Not removing system registry', type, registry.id); return; } LOG.debug(method, 'Removing registry', type, registry.id); return registryManager.remove(type, registry.id); }); }, Promise.resolve()); }) .then(() =&gt; { LOG.exit(method); }); } } module.exports = NetworkManager; × Search results Close "},"composer-common_lib_query_queryanalyzer.js.html":{"id":"composer-common_lib_query_queryanalyzer.js.html","title":"Source: composer-common/lib/query/queryanalyzer.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/query/queryanalyzer.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Limit = require('./limit'); const Logger = require('../log/logger'); const OrderBy = require('./orderby'); const Query = require('./query'); const Select = require('./select'); const Skip = require('./skip'); const Where = require('./where'); const RelationshipDeclaration = require('../introspect/relationshipdeclaration'); const LOG = Logger.getLog('QueryAnalyzer'); /** * The query analyzer visits a query and extracts the names and types of all parameters * @private */ class QueryAnalyzer { /** * Create an Query from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {Query} query - the composer query for process * @throws {IllegalModelException} */ constructor(query) { if (!query) { throw new Error('Invalid query'); } this.query = query; } /** * Extract the names and types of query parameters * @return {object[]} The names and types of the query parameters */ analyze() { const method = 'analyze'; LOG.entry(method); const result = this.query.accept(this, {}); LOG.exit(method, result); return result; } /** * Visitor design pattern; handle all objects from the query manager. * @param {Object} thing The object being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visit(thing, parameters) { const method = 'visit'; LOG.entry(method, thing, parameters); let result = null; if (thing instanceof Query) { result = this.visitQuery(thing, parameters); } else if (thing instanceof Select) { result = this.visitSelect(thing, parameters); } else if (thing instanceof Where) { result = this.visitWhere(thing, parameters); } else if (thing instanceof OrderBy) { result = this.visitOrderBy(thing, parameters); } else if (thing instanceof Limit) { result = this.visitLimit(thing, parameters); } else if (thing instanceof Skip) { result = this.visitSkip(thing, parameters); } else if (thing.type === 'BinaryExpression') { result = this.visitBinaryExpression(thing, parameters); } else if (thing.type === 'Identifier') { result = this.visitIdentifier(thing, parameters); } else if (thing.type === 'Literal') { result = this.visitLiteral(thing, parameters); } else if (thing.type === 'MemberExpression') { result = this.visitMemberExpression(thing, parameters); } else { throw new Error('Unrecognised type: ' + typeof thing + ', value: ' + JSON.stringify(thing)); } LOG.exit(method, result); return result; } /** * Visitor design pattern; handle a query by visiting the select statement. * @param {Query} query The query being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitQuery(query, parameters) { const method = 'visitQuery'; LOG.entry(method, query, parameters); // Process the select statement, which will return a Mango query. const select = query.getSelect(); const requiredParameters = []; parameters.requiredParameters = requiredParameters; const parametersToUse = {}; parameters.parametersToUse = parametersToUse; const result = select.accept(this, parameters); LOG.exit(method, result); return result; } /** * Visitor design pattern; handle a select statement. * @param {Select} select The select statement being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitSelect(select, parameters) { const method = 'visitSelect'; LOG.entry(method, select, parameters); let results = []; // Handle the where clause, if it exists. const where = select.getWhere(); if (where) { results = results.concat(where.accept(this, parameters)); } // Handle the order by clause, if it exists. const orderBy = select.getOrderBy(); if (orderBy) { results = results.concat(orderBy.accept(this, parameters)); } // Handle the limit clause, if it exists. Note that the limit // clause can reference a parameter. const limit = select.getLimit(); if (limit) { results = results.concat(limit.accept(this, parameters)); } // Handle the skip clause, if it exists. Note that the skip // clause can reference a parameter. const skip = select.getSkip(); if (skip) { results = results.concat(skip.accept(this, parameters)); } LOG.exit(method, results); return results; } /** * Visitor design pattern; handle a where statement. * @param {Where} where The where statement being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitWhere(where, parameters) { const method = 'visitWhere'; LOG.entry(method, where, parameters); // Simply visit the AST, which will generate a selector. // The root of the AST is probably a binary expression. const result = this.visit(where.getAST(), parameters); LOG.exit(method, result); return result; } /** * Visitor design pattern; handle an order by statement. * @param {OrderBy} orderBy The order by statement being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitOrderBy(orderBy, parameters) { const method = 'visitOrderBy'; LOG.entry(method, orderBy, parameters); const result = []; LOG.exit(method, result); return result; } /** * Visitor design pattern; handle a limit statement. * @param {Limit} limit The limit statement being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitLimit(limit, parameters) { const method = 'visitLimit'; LOG.entry(method, limit, parameters); // Get the limit value from the AST. const result = this.visit(limit.getAST(), parameters); if (result.length &gt; 0) { result[0].type = 'Integer'; } LOG.exit(method, result); return result; } /** * Visitor design pattern; handle a skip statement. * @param {Skip} skip The skip statement being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitSkip(skip, parameters) { const method = 'visitSkip'; LOG.entry(method, skip, parameters); // Get the skip value from the AST. const result = this.visit(skip.getAST(), parameters); if (result.length &gt; 0) { result[0].type = 'Integer'; } LOG.exit(method, result); return result; } /** * Visitor design pattern; handle a binary expression. * @param {Object} ast The abstract syntax tree being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitBinaryExpression(ast, parameters) { const method = 'visitBinaryExpression'; LOG.entry(method, ast, parameters); // Binary expressions are handled differently in Mango based on the type, // so figure out the type and handle it appropriately. const arrayCombinationOperators = ['AND', 'OR']; let result; if (arrayCombinationOperators.indexOf(ast.operator) !== -1) { result = this.visitArrayCombinationOperator(ast, parameters); } else { result = this.visitConditionOperator(ast, parameters); } LOG.exit(method, result); return result; } /** * Visitor design pattern; handle an array combination operator. * Array combination operators are operators that act on two or more pieces * of data, such as 'AND' and 'OR'. * @param {Object} ast The abstract syntax tree being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitArrayCombinationOperator(ast, parameters) { const method = 'visitArrayCombinationOperator'; LOG.entry(method, ast, parameters); let result = []; result = result.concat(this.visit(ast.left, parameters)); result = result.concat(this.visit(ast.right, parameters)); LOG.exit(method, result); return result; } /** * Visitor design pattern; handle a condition operator. * Condition operators are operators that compare two pieces of data, such * as '&gt;=' and '!='. * @param {Object} ast The abstract syntax tree being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitConditionOperator(ast, parameters) { const method = 'visitConditionOperator'; LOG.entry(method, ast, parameters); let result = []; // Grab both side of the expression. const rhs = this.visit(ast.right, parameters); const lhs = this.visit(ast.left, parameters); // if the rhs is a string, it is the name of a property // and we infer the type of the lhs from the model // if the lhs is a parameter if (typeof rhs === 'string' &amp;&amp; (lhs instanceof Array &amp;&amp; lhs.length &gt; 0)) { lhs[0].type = this.getParameterType(rhs); result = result.concat(lhs); } // if the lhs is a string, it is the name of a property // and we infer the type of the rhs from the model // if the rhs is a parameter if (typeof lhs === 'string' &amp;&amp; (rhs instanceof Array &amp;&amp; rhs.length &gt; 0)) { rhs[0].type = this.getParameterType(lhs); result = result.concat(rhs); } LOG.exit(method, result); return result; } /** * Visitor design pattern; handle an identifier. * Identifiers are either references to properties in the data being queried, * or references to a query parameter (these are of the format _$varname). * @param {Object} ast The abstract syntax tree being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitIdentifier(ast, parameters) { const method = 'visitIdentifier'; LOG.entry(method, ast, parameters); // Check to see if this is a parameter reference. const parameterMatch = ast.name.match(/^_\\$(.+)/); if (parameterMatch) { const parameterName = parameterMatch[1]; LOG.exit(method, parameterName); // We return a parameter object with a null type // performing the type inference in the parent visit return [{ name: parameterName, type: null }]; } // Otherwise it's a property name. const selector = ast.name; LOG.exit(method, selector); return selector; } /** * Visitor design pattern; handle a literal. * Literals are just plain old literal values ;-) * @param {Object} ast The abstract syntax tree being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitLiteral(ast, parameters) { const method = 'visitLiteral'; LOG.entry(method, ast, parameters); const result = []; LOG.exit(method, result); return result; } /** * Visitor design pattern; handle a member expression. * @param {Object} ast The abstract syntax tree being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitMemberExpression(ast, parameters) { const method = 'visitMemberExpression'; LOG.entry(method, ast, parameters); const property = this.visit(ast.property, parameters); const object = this.visit(ast.object, parameters); const selector = `${object}.${property}`; LOG.exit(method, selector); return selector; } /** * Get the parameter type for a property path on a resource * @param {string} parameterName The parameter name or name with nested structure e.g A.B.C * @return {string} The type to use for the parameter * @throws {Error} if the property does not exist or is of an unsupported type * @private */ getParameterType(parameterName) { const method = 'getParameterType'; LOG.entry(method, parameterName); const classDeclaration = this.query.getSelect().getResourceClassDeclaration(); const property = classDeclaration.getNestedProperty(parameterName); let result = null; // enums and relationships are represented as strings if (property.isTypeEnum() || property instanceof RelationshipDeclaration) { result = 'String'; } else if (property.isPrimitive()) { // primities are returned as-is result = property.getType(); } else { // anything else is not supported throw new Error('Unsupported property type ' + property.getFullyQualifiedName()); } LOG.exit(method, result); return result; } } module.exports = QueryAnalyzer; × Search results Close "},"composer-runtime_lib_querycompiler.js.html":{"id":"composer-runtime_lib_querycompiler.js.html","title":"Source: composer-runtime/lib/querycompiler.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/querycompiler.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AssetDeclaration = require('composer-common').AssetDeclaration; const CompiledQueryBundle = require('./compiledquerybundle'); const createHash = require('sha.js'); const Limit = require('composer-common').Limit; const Logger = require('composer-common').Logger; const OrderBy = require('composer-common').OrderBy; const ParticipantDeclaration = require('composer-common').ParticipantDeclaration; const Query = require('composer-common').Query; const QueryFile = require('composer-common').QueryFile; const QueryManager = require('composer-common').QueryManager; const Select = require('composer-common').Select; const Skip = require('composer-common').Skip; const TransactionDeclaration = require('composer-common').TransactionDeclaration; const Where = require('composer-common').Where; const LOG = Logger.getLog('QueryCompiler'); /** * A query compiler compiles all queries in a query manager into a compiled * query bundle that can easily be called by the runtime. * @protected */ class QueryCompiler { /** * Compile all the queries in the specified query manager into a compiled * query bundle for use by the runtime. * @param {QueryManager} queryManager The query manager to process. * @return {CompiledQueryBundle} The compiled query bundle. */ compile(queryManager) { const method = 'compile'; LOG.entry(method, queryManager); const compiledQueries = queryManager.accept(this, {}); const result = new CompiledQueryBundle(this, queryManager, compiledQueries); LOG.exit(method, result); return result; } /** * Visitor design pattern; handle all objects from the query manager. * @param {Object} thing The object being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visit(thing, parameters) { const method = 'visit'; LOG.entry(method, thing, parameters); let result = null; if (thing instanceof QueryManager) { result = this.visitQueryManager(thing, parameters); } else if (thing instanceof QueryFile) { result = this.visitQueryFile(thing, parameters); } else if (thing instanceof Query) { result = this.visitQuery(thing, parameters); } else if (thing instanceof Select) { result = this.visitSelect(thing, parameters); } else if (thing instanceof Where) { result = this.visitWhere(thing, parameters); } else if (thing instanceof OrderBy) { result = this.visitOrderBy(thing, parameters); } else if (thing instanceof Limit) { result = this.visitLimit(thing, parameters); } else if (thing instanceof Skip) { result = this.visitSkip(thing, parameters); } else if (thing.type === 'BinaryExpression') { result = this.visitBinaryExpression(thing, parameters); } else if (thing.type === 'Identifier') { result = this.visitIdentifier(thing, parameters); } else if (thing.type === 'Literal') { result = this.visitLiteral(thing, parameters); } else if (thing.type === 'MemberExpression') { result = this.visitMemberExpression(thing, parameters); } else { throw new Error('Unrecognised type: ' + typeof thing + ', value: ' + JSON.stringify(thing)); } LOG.exit(method, result); return result; } /** * Visitor design pattern; handle a query manager by visiting all of the query files. * @param {QueryManager} queryManager The query manager being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitQueryManager(queryManager, parameters) { const method = 'visitQueryManager'; LOG.entry(method, queryManager, parameters); // Compile all of the query files in this query manager. let compiledQueries = []; const queryFile = queryManager.getQueryFile(); if (queryFile) { compiledQueries = queryManager.getQueryFile().accept(this, parameters); } LOG.exit(method, compiledQueries); return compiledQueries; } /** * Visitor design pattern; handle a query file by visiting all of the queries. * @param {QueryFile} queryFile The query file being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitQueryFile(queryFile, parameters) { const method = 'visitQueryFile'; LOG.entry(method, queryFile, parameters); // Compile all of the queries in this query file. const compiledQueries = queryFile.getQueries().map((query) =&gt; { return query.accept(this, parameters); }); LOG.exit(method, compiledQueries); return compiledQueries; } /** * Visitor design pattern; handle a query by visiting the select statement. * @param {Query} query The query being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitQuery(query, parameters) { const method = 'visitQuery'; LOG.entry(method, query, parameters); // Process the select statement, which will return a Mango query. const select = query.getSelect(); const requiredParameters = []; parameters.requiredParameters = requiredParameters; const parametersToUse = {}; parameters.parametersToUse = parametersToUse; const compiledQuery = select.accept(this, parameters); // If there are no required parameters, then we can use a trivial generator function. let compiledQueryGenerator; if (requiredParameters.length === 0) { // Serialize the compiled query string and always return that. compiledQueryGenerator = this.buildTrivialCompiledQueryGenerator(compiledQuery); // Otherwise we have to build a more complex generator function. } else { // No short cuts here! compiledQueryGenerator = this.buildComplexCompiledQueryGenerator(compiledQuery, requiredParameters, parametersToUse); } // Generate a hash for the query. const hash = this.generateQueryHash(query); // Generate a result object containing all the data. const result = { name: query.getName(), text: select.getText(), hash: hash, generator: compiledQueryGenerator }; LOG.exit(method, result); return result; } /** * Build a trivial (no parameters) compiled query generator. * @param {Object} compiledQuery The compiled query. * @return {Function} The compiled query generator. */ buildTrivialCompiledQueryGenerator(compiledQuery) { const compiledQueryString = JSON.stringify(compiledQuery); return (inputParameters) =&gt; { if (Object.keys(inputParameters).length !== 0) { throw new Error('No parameters should be specified for this query'); } return compiledQueryString; }; } /** * Build a complex (one or more parameters) compiled query generator. * @param {Object} compiledQuery The compiled query. * @param {string[]} requiredParameters The required parameters. * @param {Object} parametersToUse The parameters to use. * @return {Function} The compiled query generator. */ buildComplexCompiledQueryGenerator(compiledQuery, requiredParameters, parametersToUse) { return (inputParameters) =&gt; { // Check for all required parameters. requiredParameters.forEach((requiredParameter) =&gt; { if (inputParameters[requiredParameter] === undefined) { throw new Error('Required parameter ' + requiredParameter + ' has not been specified'); } }); // Check for any extraneous parameters. Object.keys(inputParameters).forEach((inputParameter) =&gt; { if (requiredParameters.indexOf(inputParameter) === -1) { throw new Error('Invalid or extraneous parameter ' + inputParameter + ' has been specified'); } }); // Delete all parameters from the last execution. Object.keys(parametersToUse).forEach((parameterToUse) =&gt; { delete parametersToUse[parameterToUse]; }); // Assign the input parameters and serialize the compiled query string. // Note that this will fire all the functions which look up parameters // from the parameters to use object. Object.assign(parametersToUse, inputParameters); return JSON.stringify(compiledQuery); }; } /** * Generate a unique hash for the query. * @param {Query} query The query. * @return {string} A unique hash for the query. */ generateQueryHash(query) { const text = query.getSelect().getText(); const sha256 = createHash('sha256'); return sha256.update(text, 'utf8').digest('hex'); } /** * Visitor design pattern; handle a select statement. * @param {Select} select The select statement being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitSelect(select, parameters) { const method = 'visitSelect'; LOG.entry(method, select, parameters); // Handle the resource clause, which will always exist. const resource = select.getResource(); const query = { selector: {} }; query.selector.$class = resource; // Look up the type for this resource. const modelManager = select.getQuery().getQueryFile().getModelManager(); const classDeclaration = modelManager.getType(resource); if (classDeclaration instanceof AssetDeclaration) { query.selector.$registryType = 'Asset'; } else if (classDeclaration instanceof ParticipantDeclaration) { query.selector.$registryType = 'Participant'; } else if (classDeclaration instanceof TransactionDeclaration) { query.selector.$registryType = 'Transaction'; } else { throw new Error('The query compiler does not support resources of this type'); } // Handle the from clause, if it exists. const registry = select.getRegistry(); if (registry) { query.selector.$registryId = registry; } else { query.selector.$registryId = resource; } // Handle the where clause, if it exists. const where = select.getWhere(); if (where) { const queryAdditions = where.accept(this, parameters); Object.assign(query.selector, queryAdditions.selector); } // Handle the order by clause, if it exists. const orderBy = select.getOrderBy(); if (orderBy) { const queryAdditions = orderBy.accept(this, parameters); Object.assign(query, queryAdditions); } // Handle the limit clause, if it exists. Note that the limit // clause can reference a parameter. const limit = select.getLimit(); if (limit) { const queryAdditions = limit.accept(this, parameters); Object.keys(queryAdditions).forEach((key) =&gt; { const prop = Object.getOwnPropertyDescriptor(queryAdditions, key); Object.defineProperty(query, key, prop); }); } // Handle the skip clause, if it exists. Note that the skip // clause can reference a parameter. const skip = select.getSkip(); if (skip) { const queryAdditions = skip.accept(this, parameters); Object.keys(queryAdditions).forEach((key) =&gt; { const prop = Object.getOwnPropertyDescriptor(queryAdditions, key); Object.defineProperty(query, key, prop); }); } LOG.exit(method, JSON.stringify(query)); return query; } /** * Visitor design pattern; handle a where statement. * @param {Where} where The where statement being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitWhere(where, parameters) { const method = 'visitWhere'; LOG.entry(method, where, parameters); // Simply visit the AST, which will generate a selector. // The root of the AST is probably a binary expression. const selector = this.visit(where.getAST(), parameters); const result = { selector }; LOG.exit(method, result); return result; } /** * Visitor design pattern; handle an order by statement. * @param {OrderBy} orderBy The order by statement being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitOrderBy(orderBy, parameters) { const method = 'visitOrderBy'; LOG.entry(method, orderBy, parameters); // Iterate over the sort criteria. const result = { sort: [] }; orderBy.getSortCriteria().forEach((sort) =&gt; { const temp = {}; temp[sort.getPropertyPath()] = sort.getDirection().toLowerCase(); result.sort.push(temp); }); LOG.exit(method, result); return result; } /** * Visitor design pattern; handle a limit statement. * @param {Limit} limit The limit statement being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitLimit(limit, parameters) { const method = 'visitLimit'; LOG.entry(method, limit, parameters); // Get the limit value from the AST. const limitValue = this.visit(limit.getAST(), parameters); // Define a limit property on the query; if the limit value is a parameter, // then define a getter to read the current parameter setting. const property = { enumerable: true, configurable: false }; if (typeof limitValue === 'function') { property.get = limitValue; } else { property.value = limitValue; } const result = {}; Object.defineProperty(result, 'limit', property); LOG.exit(method, result); return result; } /** * Visitor design pattern; handle a skip statement. * @param {Skip} skip The skip statement being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitSkip(skip, parameters) { const method = 'visitSkip'; LOG.entry(method, skip, parameters); // Get the skip value from the AST. const skipValue = this.visit(skip.getAST(), parameters); // Define a skip property on the query; if the skip value is a parameter, // then define a getter to read the current parameter setting. const property = { enumerable: true, configurable: false }; if (typeof skipValue === 'function') { property.get = skipValue; } else { property.value = skipValue; } const result = {}; Object.defineProperty(result, 'skip', property); LOG.exit(method, result); return result; } /** * Visitor design pattern; handle a binary expression. * @param {Object} ast The abstract syntax tree being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitBinaryExpression(ast, parameters) { const method = 'visitBinaryExpression'; LOG.entry(method, ast, parameters); // Binary expressions are handled differently in Mango based on the type, // so figure out the type and handle it appropriately. const arrayCombinationOperators = [ 'AND', 'OR' ]; const conditionOperators = [ '&lt;', '&lt;=', '&gt;', '&gt;=', '==', '!=' ]; let result; if (arrayCombinationOperators.indexOf(ast.operator) !== -1) { result = this.visitArrayCombinationOperator(ast, parameters); } else if (conditionOperators.indexOf(ast.operator) !== -1) { result = this.visitConditionOperator(ast, parameters); } else { throw new Error('The query compiler does not support this binary expression'); } LOG.exit(method, result); return result; } /** * Visitor design pattern; handle an array combination operator. * Array combination operators are operators that act on two or more pieces * of data, such as 'AND' and 'OR'. * @param {Object} ast The abstract syntax tree being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitArrayCombinationOperator(ast, parameters) { const method = 'visitArrayCombinationOperator'; LOG.entry(method, ast, parameters); // Map the input operator to the Mango operator. const validOperators = { AND: '$and', OR: '$or' }; const operator = validOperators[ast.operator]; if (!operator) { throw new Error('The query compiler does not support this operator'); } // Build the Mango selector for this operator. const result = {}; result[operator] = [ this.visit(ast.left, parameters), this.visit(ast.right, parameters) ]; LOG.exit(method, result); return result; } /** * Visitor design pattern; handle a condition operator. * Condition operators are operators that compare two pieces of data, such * as '&gt;=' and '!='. * @param {Object} ast The abstract syntax tree being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitConditionOperator(ast, parameters) { const method = 'visitConditionOperator'; LOG.entry(method, ast, parameters); // Map the input operator to the Mango operator. const validOperators = { '&lt;': '$lt', '&lt;=': '$lte', '&gt;': '$gt', '&gt;=': '$gte', '==': '$eq', '!=': '$ne' }; let operator = validOperators[ast.operator]; if (!operator) { throw new Error('The query compiler does not support this operator'); } // Grab the left hand side of this expression. let left = this.visit(ast.left, parameters); const leftIsIdentifier = (ast.left.type === 'Identifier' &amp;&amp; typeof left !== 'function'); const leftIsMemberExpression = (ast.left.type === 'MemberExpression'); const leftIsVariable = leftIsIdentifier || leftIsMemberExpression; const leftIsLiteral = (ast.left.type === 'Literal' || typeof left === 'function'); // Grab the right hand side of this expression. let right = this.visit(ast.right, parameters); const rightIsIdentifier = (ast.right.type === 'Identifier' &amp;&amp; typeof right !== 'function'); const rightIsMemberExpression = (ast.right.type === 'MemberExpression'); const rightIsVariable = rightIsIdentifier || rightIsMemberExpression; const rightIsLiteral = (ast.right.type === 'Literal' || typeof right === 'function'); // Check for invalid left and right expressions. if (leftIsLiteral === rightIsLiteral || leftIsVariable === rightIsVariable) { // Either two literals or two identifiers. throw new Error('The query compiler cannot compile condition operators that do not have an identifier and a literal'); } // Check for a conditional with a literal on the left, and swap the operands. if (leftIsLiteral) { // Since we are going to swap the operands around, we also need to change the operator. const mirrorOperators = { '&lt;': '$gt', // a &lt; b becomes b &gt; a '&lt;=': '$gte', // a &lt;= b becomes b &gt;= a '&gt;': '$lt', // a &gt; b becomes b &lt; a '&gt;=': '$lte', // a &gt;= b becomes b &lt;= a '==': '$eq', // no change '!=': '$ne' // no change }; operator = mirrorOperators[ast.operator]; // Swap the operands around. const temp = left; left = right; right = temp; } // Validate the right hand side; it can be any primitive value. if (right !== null &amp;&amp; typeof right === 'object') { throw new Error('The query compiler cannot compile a condition with a complex value literal'); } // Build the Mango selector for this operator. const result = {}; result[left] = {}; const property = { enumerable: true, configurable: false }; if (typeof right === 'function') { property.get = right; } else { property.value = right; } Object.defineProperty(result[left], operator, property); LOG.exit(method, result); return result; } /** * Visitor design pattern; handle an identifier. * Identifiers are either references to properties in the data being queried, * or references to a query parameter (these are of the format _$varname). * @param {Object} ast The abstract syntax tree being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitIdentifier(ast, parameters) { const method = 'visitIdentifier'; LOG.entry(method, ast, parameters); // Check to see if this is a parameter reference. const parameterMatch = ast.name.match(/^_\\$(.+)/); if (parameterMatch) { const parameterName = parameterMatch[1]; parameters.requiredParameters.push(parameterName); const parametersToUse = parameters.parametersToUse; const selector = () =&gt; { return parametersToUse[parameterName]; }; LOG.exit(method, selector); return selector; } // Otherwise it's a property name. // TODO: We should validate that it is a property name! const selector = ast.name; LOG.exit(method, selector); return selector; } /** * Visitor design pattern; handle a literal. * Literals are just plain old literal values ;-) * @param {Object} ast The abstract syntax tree being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitLiteral(ast, parameters) { const method = 'visitLiteral'; LOG.entry(method, ast, parameters); const selector = ast.value; LOG.exit(method, selector); return selector; } /** * Visitor design pattern; handle a member expression. * @param {Object} ast The abstract syntax tree being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitMemberExpression(ast, parameters) { const method = 'visitMemberExpression'; LOG.entry(method, ast, parameters); const property = this.visit(ast.property, parameters); const object = this.visit(ast.object, parameters); const selector = `${object}.${property}`; LOG.exit(method, selector); return selector; } } module.exports = QueryCompiler; × Search results Close "},"composer-runtime_lib_registrymanager.js.html":{"id":"composer-runtime_lib_registrymanager.js.html","title":"Source: composer-runtime/lib/registrymanager.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/registrymanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AssetDeclaration = require('composer-common').AssetDeclaration; const EventEmitter = require('events'); const Logger = require('composer-common').Logger; const ParticipantDeclaration = require('composer-common').ParticipantDeclaration; const TransactionDeclaration = require('composer-common').TransactionDeclaration; const Registry = require('./registry'); const LOG = Logger.getLog('RegistryManager'); // Do not add additional types to these constants. All system types are assets. const TYPE_MAP = { Asset : 'AssetRegistry', Participant : 'ParticipantRegistry', Transaction : 'TransactionRegistry', Network : 'Network' }; // This is a list of non-abstract system types that we do not want registries created for. const VIRTUAL_TYPES = [ 'Network' ]; /** * A class for managing and persisting registries. * @protected */ class RegistryManager extends EventEmitter { /** * Constructor. * @param {DataService} dataService The data service to use. * @param {Introspector} introspector The introspector to use. * @param {Serializer} serializer The serializer to use. * @param {AccessController} accessController The access controller to use. * @param {DataCollection} sysregistries The system registries collection to use. * @param {Factory} factory The factory to create new resources */ constructor(dataService, introspector, serializer, accessController, sysregistries, factory) { super(); this.dataService = dataService; this.introspector = introspector; this.serializer = serializer; this.accessController = accessController; this.sysregistries = sysregistries; this.factory = factory; this.sysregistryCache = {}; } /** * Create a new registry instance and subscribe to its events. * @private * @param {DataCollection} dataCollection The data collection. * @param {Serializer} serializer The serializer. * @param {AccessController} accessController The access controller. * @param {string} type The type. * @param {string} id The ID. * @param {string} name The name. * @param {boolean} system True if the registry is for a system type, false otherwise. * @return {Registry} The new registry instance. */ createRegistry(dataCollection, serializer, accessController, type, id, name, system) { let registry = new Registry(dataCollection, serializer, accessController, type, id, name, system); ['resourceadded', 'resourceupdated', 'resourceremoved'].forEach((event) =&gt; { registry.on(event, (data) =&gt; { this.emit(event, data); }); }); return registry; } /** * Create the default regsitries * @param {Boolean} force if set to true, will add without checking for existence# * @returns {Promise} A promise that is resolved once all default registries * have been created, or rejected with an error. */ createDefaults(force) { return this.createSystemDefaults(force).then(() =&gt; { return this.createNetworkDefaults(force); }); } /** * Ensure that the default *network* registries exist. * @param {boolean} force if set to true, will add without checking for existence * @returns {Promise} A promise that is resolved once all default registries * have been created, or rejected with an error. */ createNetworkDefaults(force) { const method = 'createNetworkDefaults'; LOG.entry(method, force); return this.introspector.getClassDeclarations() .filter((classDeclaration) =&gt; { return !classDeclaration.isAbstract(); }) .filter((classDeclaration) =&gt; { return (classDeclaration instanceof AssetDeclaration) || (classDeclaration instanceof ParticipantDeclaration) || (classDeclaration instanceof TransactionDeclaration); }) .filter((classDeclaration) =&gt; { return !(classDeclaration.isSystemType()); }) .reduce((promise, classDeclaration) =&gt; { return promise.then(() =&gt; { const type = classDeclaration.getSystemType(); const fqn = classDeclaration.getFullyQualifiedName(); LOG.debug(method, 'Creating registry', type, fqn); if (force) { return this.add(type, fqn, `${type} registry for ${fqn}`, true); } else { return this.ensure(type, fqn, `${type} registry for ${fqn}`); } }).then((result) =&gt; { // we need to cache these as the network registries will cause entries to appear here this.sysregistryCache[result.type + ':' + result.id] = result; }); }, Promise.resolve()) .then(() =&gt; { LOG.exit(method); }); } /** * Ensure that the default *system* registries exist. * @param {boolean} force if set to true, will add without checking for existence * @returns {Promise} A promise that is resolved once all default registries * have been created, or rejected with an error. */ createSystemDefaults(force) { const method = 'createSystemDefaults'; LOG.entry(method, force); this.dirty = true; return this.introspector.getClassDeclarations() .filter((classDeclaration) =&gt; { return !classDeclaration.isAbstract(); }) .filter((classDeclaration) =&gt; { return (classDeclaration instanceof AssetDeclaration) || (classDeclaration instanceof ParticipantDeclaration) || (classDeclaration instanceof TransactionDeclaration); }) .filter((classDeclaration) =&gt; { return (classDeclaration.isSystemType() &amp;&amp; !(VIRTUAL_TYPES.indexOf(classDeclaration.getName()) &gt; -1)); }) .reduce((promise, classDeclaration) =&gt; { return promise.then(() =&gt; { const type = classDeclaration.getSystemType(); const fqn = classDeclaration.getFullyQualifiedName(); const systemType = classDeclaration.isSystemType(); // console.log('Creating System registry', type, fqn, systemType); LOG.debug(method, 'Creating registry', type, fqn, systemType); if (force) { return this.add(type, fqn, `${type} registry for ${fqn}`, true, systemType); } else { return this.ensure(type, fqn, `${type} registry for ${fqn}`, systemType); } }).then((result) =&gt; { // we need to cache these as the network registries will cause entries to appear here this.sysregistryCache[result.type + ':' + result.id] = result; }); }, Promise.resolve()) .then(() =&gt; { LOG.exit(method); }); } /** * Get all of the registries. * @param {string} type The type of the registry. * @param {boolean} includeSystem true if system registries should be included (optional, default is false) * @return {Promise} A promise that is resolved with an array of {@link Registry} * objects when complete, or rejected with an error. */ getAll(type, includeSystem) { const method = 'getAll'; includeSystem = includeSystem || false; LOG.entry(method, type); return this.sysregistries.getAll() .then((registries) =&gt; { registries = registries.filter((registry) =&gt; { return registry.type === type; }); LOG.debug(method, 'Filtered registries down to', registries.length); return registries.reduce((prev, registry) =&gt; { return prev.then((result) =&gt; { return this.get(registry.type, registry.registryId) .then((r) =&gt; { LOG.debug(method, 'reducing', r.name); result.push(r); return result; }) .catch(() =&gt; { LOG.debug(method, 'not worried about access failure'); return result; }); }); }, Promise.resolve([])); }) .then((registries) =&gt; { if (!includeSystem) { registries = registries.filter((registry) =&gt; { return !registry.system; }); } LOG.exit(method, registries); return registries; }); } /** * Get a registry with the specified type, and ID. * @param {string} type The type of the registry. * @param {string} id The ID of the registry. * @return {Promise} A promise that is resolved with a {@link Registry} * objects when complete, or rejected with an error. */ get(type, id) { let collectionID = type + ':' + id; let resource; let simpledata; LOG.entry('get', collectionID); // During business network start/update, new registries may be created. Unfortunately we can't directly // read them, so we look them up in the registry cache instead. let registry = this.sysregistryCache[collectionID]; if (registry) { return Promise.resolve(registry); } // go to the sysregistries datacollection and get the 'resource' for the registry we are interested in return this.sysregistries.get(collectionID) .then((result) =&gt; { simpledata = result; // do we have permission to be looking at this?? resource = this.serializer.fromJSON(result); return this.accessController.check(resource, 'READ'); }) .then(() =&gt; { // if we got here then, we the accessController.check was OK, get the dataCollection with the actual information // for the require registry return this.dataService.getCollection(collectionID); }) .then((dataCollection) =&gt; { // and form up the actual registry object // TODO: Does this really need to take the the 3 parametrs type,registryId and name?? // TODO: this really doens't seem right return this.createRegistry(dataCollection, this.serializer, this.accessController, simpledata.type, simpledata.registryId, simpledata.name, simpledata.system); }); } /** * Determine whether a registry with the specified type and ID exists. * @param {string} type The type of the registry. * @param {string} id The ID of the registry. * @return {Promise} A promise that is resolved with a boolean indicating * whether the registry exists. */ exists(type, id) { let collectionID = type + ':' + id; let resource; // form this up into a resource and check if we are able to read this. let litmusResource = this.factory.newResource('org.hyperledger.composer.system', TYPE_MAP[type], id); return this.accessController.check(litmusResource, 'READ') .then(() =&gt; { return this.sysregistries.exists(collectionID); }) .then((result) =&gt; { if (result) { // yes we can see this type of registry - in theory return this.sysregistries.get(collectionID) .then((result) =&gt; { // do we REALLY have permission to be looking at this?? resource = this.serializer.fromJSON(result); return this.accessController.check(resource, 'READ'); }) .then(() =&gt; { // well we got here! so the resource is there and we can really really access it return true; }); } else { // the registry doesn't exist return false; } }); } /** * An event signalling that a registry has been added. * @event RegistryManager#registryadded * @protected * @type {object} * @param {Registry} registry The registry. * @param {string} registryType The type of the registry. * @param {string} registryId The ID of the registry. * @param {string} registryName The name of the registry. */ /** * Add a new registry with the specified type, ID, and name. * @param {string} type The type of the registry. * @param {string} id The ID of the registry. * @param {string} name The name of the registry. * @param {boolean} force True to force the creation of the collection without checking. * @param {boolean} system True if the registry is for a system type, false otherwise. * @return {Promise} A promise that is resolved when complete, or rejected * with an error. */ add(type, id, name, force, system) { let collectionID = type + ':' + id; // form this up into a resource and check if we are able to create this. let resource = this.factory.newResource('org.hyperledger.composer.system', TYPE_MAP[type], id); resource.name = name; resource.type = type; resource.system = !!system; return this.accessController.check(resource, 'CREATE') .then(() =&gt; { // yes we can create an instance of this type; now add that to the sysregistries collection // Note we haven't checked if we have update permission on the sysregristries collection // but that is going a bit far really...resource.type+':org.hyperledger.composer.system.'+resource.type+'Registry' return this.sysregistries.add(collectionID, this.serializer.toJSON(resource), force); }).then(() =&gt; { if (!resource.system) { let srid = 'Asset:org.hyperledger.composer.system.' + resource.type + 'Registry'; let registry = this.sysregistryCache[srid]; if (!registry) { return this.get('Asset', 'org.hyperledger.composer.system.' + resource.type + 'Registry') .then((result) =&gt; { return result.add(resource); }); } else { return registry.add(resource, {forceAdd : force}); } } else { return; } }) .then((result) =&gt; { // create the collection that will hold the actual data in this registry return this.dataService.createCollection(collectionID, force); }) .then((dataCollection) =&gt; { // and create the registry instance to be used let result = this.createRegistry(dataCollection, this.serializer, this.accessController, type, id, name); // event emitting // TODO: not checked event emission privaledge. this.emit('registryadded', { registry : result, registryType : type, registryId : id, registryName : name }); return result; }); } /** * Check to see if the specified registry exists, and create it if it does not. * @param {string} type The type of the registry. * @param {string} id The ID of the registry. * @param {string} name The name of the registry. * @param {boolean} system True if the registry is for a system type, false otherwise. * @return {Promise} A promise that is resolved when complete, or rejected * with an error. */ ensure(type, id, name, system) { const method = 'ensure'; LOG.entry(method, type, id, name, system); return this.get(type, id) .catch((error) =&gt; { LOG.debug(method, 'The registry does not exist, creating'); return this.add(type, id, name, false, system); }) .then((registry) =&gt; { LOG.exit(method, registry); return registry; }); } /** * Clear the contents of the specified registry. * @param {string} type The type of the registry. * @param {string} id The ID of the registry. * @return {Promise} A promise that is resolved when complete, or rejected * with an error. */ clear(type, id) { const method = 'clear'; LOG.entry(method, type, id); let collectionID = type + ':' + id; return this.dataService.deleteCollection(collectionID) .then(() =&gt; { LOG.exit(method); }); } /** * Remove the specified registry. * @param {string} type The type of the registry. * @param {string} id The ID of the registry. * @return {Promise} A promise that is resolved when complete, or rejected * with an error. */ remove(type, id) { const method = 'remove'; LOG.entry(method, type, id); let collectionID = type + ':' + id; return this.clear(type, id) .then(() =&gt; { let srid = 'Asset:org.hyperledger.composer.system.' + type + 'Registry'; let registry = this.sysregistryCache[srid]; if (!registry) { return this.get('Asset', 'org.hyperledger.composer.system.' + type + 'Registry'); } return registry; }) .then((registry) =&gt; { return registry.remove(id); }) .then(() =&gt; { return this.sysregistries.remove(collectionID); }) .then(() =&gt; { LOG.exit(method); }); } } module.exports = RegistryManager; × Search results Close "},"composer-runtime_lib_resourcemanager.js.html":{"id":"composer-runtime_lib_resourcemanager.js.html","title":"Source: composer-runtime/lib/resourcemanager.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/resourcemanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const TransactionHandler = require('./transactionhandler'); const LOG = Logger.getLog('IdentityManager'); // Do not add additional types to these constants. All system types are assets. const TYPE_MAP = { AssetRegistry: 'Asset', ParticipantRegistry: 'Participant', TransactionRegistry : 'Transaction', Network : 'Network' }; /** * A class for managing and persisting identities. * @protected */ class ResourceManager extends TransactionHandler { /** * Constructor. * @param {Context} context The request context. */ constructor(context) { super(); const method = 'constructor'; LOG.entry(method, context); this.registryManager = context.getRegistryManager(); this.bind( 'org.hyperledger.composer.system.AddAsset', this.addResources ); this.bind( 'org.hyperledger.composer.system.RemoveAsset', this.removeResources ); this.bind( 'org.hyperledger.composer.system.UpdateAsset', this.updateResources ); this.bind( 'org.hyperledger.composer.system.AddParticipant', this.addResources ); this.bind( 'org.hyperledger.composer.system.RemoveParticipant', this.removeResources ); this.bind( 'org.hyperledger.composer.system.UpdateParticipant', this.updateResources ); LOG.exit(method); } /** * The org.hyperledger.composer.system.AddAllResources transaction * @param {Api} api The API to use. * @param {org.hyperledger.composer.system.IssueIdentity} transaction The transaction. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ addResources(api, transaction) { const method = 'addResources'; LOG.entry(method, transaction.registryType, transaction.registryId); const registryType = TYPE_MAP[transaction.targetRegistry.getType()]; const registryId = transaction.targetRegistry.getIdentifier(); return this.registryManager.get(registryType, registryId) .then(registry =&gt; { return registry.addAll(transaction.resources,{ convertResourcesToRelationships: true }); }) .then(() =&gt; { LOG.exit(method); }); } /** * The org.hyperledger.composer.system.AddAllResources transaction * @param {Api} api The API to use. * @param {org.hyperledger.composer.system.IssueIdentity} transaction The transaction. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ updateResources(api, transaction) { const method = 'updateResources'; LOG.entry(method, transaction.registryType, transaction.registryId); const registryType = TYPE_MAP[transaction.targetRegistry.getType()]; const registryId = transaction.targetRegistry.getIdentifier(); return this.registryManager.get(registryType, registryId) .then(registry =&gt; { return registry.updateAll(transaction.resources,{ convertResourcesToRelationships: true }); }) .then(() =&gt; { LOG.exit(method); }); } /** * The org.hyperledger.composer.system.AddAllResources transaction * @param {Api} api The API to use. * @param {org.hyperledger.composer.system.IssueIdentity} transaction The transaction. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ removeResources(api, transaction) { const method = 'removeResources'; LOG.entry(method, transaction.registryType, transaction.registryId); const registryType = TYPE_MAP[transaction.targetRegistry.getType()]; const registryId = transaction.targetRegistry.getIdentifier(); return this.registryManager.get(registryType, registryId) .then(registry =&gt; { return registry.removeAll(transaction.resourceIds); }) .then(() =&gt; { LOG.exit(method); }); } } module.exports = ResourceManager; × Search results Close "},"composer-runtime_lib_scriptcompiler.js.html":{"id":"composer-runtime_lib_scriptcompiler.js.html","title":"Source: composer-runtime/lib/scriptcompiler.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/scriptcompiler.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Api = require('./api'); const assert = require('assert'); const CompiledScriptBundle = require('./compiledscriptbundle'); const Logger = require('composer-common').Logger; const SourceMapConsumer = require('source-map').SourceMapConsumer; const SourceMapGenerator = require('source-map').SourceMapGenerator; const SourceNode = require('source-map').SourceNode; const LOG = Logger.getLog('ScriptCompiler'); /** * A script compiler compiles all scripts in a script manager into a compiled * script bundle that can easily be called by the runtime. * @protected */ class ScriptCompiler { /** * Compile all the scripts in the specified script manager into a compiled * script bundle for use by the runtime. * @param {ScriptManager} scriptManager The script manager to process. * @return {CompiledScriptBundle} The compiled script bundle. */ compile(scriptManager) { const method = 'compile'; LOG.entry(method, scriptManager); // Create the compiler context. const rootNode = new SourceNode(null, null, null); const functionDeclarations = []; const context = { rootNode: rootNode, functionDeclarations: functionDeclarations }; // Define the globals. const globals = { assert: assert }; // Add the start section. rootNode.add('function __generator(__globals, __api) {\\n'); Object.keys(globals).forEach((globalName) =&gt; { LOG.debug(method, 'Adding global', globalName); rootNode.add(` var ${globalName} = __globals.${globalName};\\n`); }); Api.getMethodNames().forEach((methodName) =&gt; { LOG.debug(method, 'Adding API method', methodName); rootNode.add(` var ${methodName} = __api.${methodName}.bind(__api);\\n`); }); rootNode.add(' __globals = __api = null;\\n'); // Process the script manager. this.processScriptManager(context, scriptManager); // Add the end section. rootNode.add(' return {\\n'); context.functionDeclarations.forEach((functionDeclaration) =&gt; { LOG.debug(method, 'Adding function declaration', functionDeclaration.getName()); rootNode.add(` '${functionDeclaration.getName()}': ${functionDeclaration.getName()},\\n`); }); rootNode.add(' };'); rootNode.add('}\\n'); rootNode.add('__generator;\\n'); // Generate the combined source code and source map. const combined = rootNode.toStringWithSourceMap(); const sourceCode = combined.code; const sourceMap = combined.map; // Serialize the source map as base64. const sourceMapBase64 = Buffer.from(sourceMap.toString()).toString('base64'); // Combine the source code and the serialized source map. const finalSourceCode = sourceCode + '\\n//# sourceMappingURL=data:application/json;base64,' + sourceMapBase64; // Compile the source code into a generator function. // The &quot;new Function('return eval')&quot; hack stops the generator function getting access // to all our local variables. We could just use &quot;new Function&quot;, but that screws up // the source maps so they all need to be offset by 2. let generatorFunction = new Function('__generatorSource', 'return eval(__generatorSource)')(finalSourceCode); generatorFunction = generatorFunction.bind(null, globals); let result = new CompiledScriptBundle(functionDeclarations, generatorFunction); LOG.exit(method, result); return result; } /** * Process the specified script manager by processing the scripts in the script manager. * @param {Object} context The compiler context. * @param {ScriptManager} scriptManager The script manager to process. */ processScriptManager(context, scriptManager) { const method = 'processScriptManager'; LOG.entry(method, context, scriptManager); // Process all of the scripts in the script manager. scriptManager.getScripts().forEach((script) =&gt; { LOG.debug(method, 'Processing script', script.getIdentifier()); this.processScript(context, script); }); LOG.exit(method); } /** * Process the specified script by processing the function declarations in the script, * then convert the script into a script node and add it to the root node. * @param {Object} context The compiler context. * @param {Script} script The script to process. */ processScript(context, script) { const method = 'processScript'; LOG.entry(method, context, script); // Convert the script into a script node, and add it to the root node. const scriptNode = this.convertScriptToScriptNode(context, script); context.rootNode.add(scriptNode); // Store all the function declarations in this script. script.getFunctionDeclarations().forEach((functionDeclaration) =&gt; { LOG.debug(method, 'Adding function declaration', functionDeclaration.getName()); context.functionDeclarations.push(functionDeclaration); }); LOG.exit(method); } /** * Convert the specified script into a source map. * @param {Object} context The compiler context. * @param {Script} script The function declaration to process. * @return {String} The source map. */ convertScriptToSourceMap(context, script) { const method = 'convertScriptToSourceMap'; LOG.entry(method, context, script); // Create a new source map generator. const sourceMapGenerator = new SourceMapGenerator({ file: script.getIdentifier(), sourceRoot: process.cwd() }); // Get the parser tokens for the script. const tokens = script.getTokens(); // Add mappings for all of the tokens into the source map. tokens.forEach((token) =&gt; { sourceMapGenerator.addMapping({ source: script.getIdentifier(), original: token.loc.start, generated: token.loc.start }); }); // Inline the contents of the script into the source map. sourceMapGenerator.setSourceContent(script.getIdentifier(), script.getContents()); // Return the source map. const result = sourceMapGenerator.toString(); LOG.exit(method, result); return result; } /** * Convert the specified script into a script node with a source map. * @param {Object} context The compiler context. * @param {Script} script The function declaration to process. * @return {SourceNode} The script node. */ convertScriptToScriptNode(context, script) { const method = 'convertScriptToScriptNode'; LOG.entry(method, context, script); // Convert the script into a source map. let sourceFileName = script.getIdentifier(); let sourceCode = script.getContents(); let sourceMap = this.convertScriptToSourceMap(context, script); // Allow someone else to post-process the converted script. const transformedScript = this.transformScript(sourceFileName, sourceCode, sourceMap); sourceFileName = transformedScript.sourceFileName; sourceCode = transformedScript.sourceCode; sourceMap = transformedScript.sourceMap; // Create a new source node from the script contents and source map const sourceMapConsumer = new SourceMapConsumer(sourceMap); const result = SourceNode.fromStringWithSourceMap(sourceCode, sourceMapConsumer); LOG.exit(method, result); return result; } /** * Optional hook to transform a script into another format, for example * by using a code coverage instrumenter. * @param {String} sourceFileName The file name for the script. * @param {String} sourceCode The source code for the script. * @param {String} sourceMap The source map for the script. * @return {Object} The transformed script. */ transformScript(sourceFileName, sourceCode, sourceMap) { const method = 'transformScript'; LOG.entry(method, sourceFileName, sourceCode, sourceMap); const result = { sourceFileName: sourceFileName, sourceCode: sourceCode, sourceMap: sourceMap }; LOG.exit(method, result); return result; } } module.exports = ScriptCompiler; × Search results Close "},"composer-common_lib_wallet.js.html":{"id":"composer-common_lib_wallet.js.html","title":"Source: composer-common/lib/wallet.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/wallet.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Currently we have a wallet singleton, but this is temporary until * we decide how wallets fit into the administrative and client APIs. */ let theWallet = null; /** * Base class representing a wallet (a container of credentials). * @protected * @abstract */ class Wallet { /** * Get the wallet singleton. * @return {Wallet} The wallet singleton, or null if one * has not been specified. */ static getWallet() { return theWallet; } /** * Set the wallet singleton. * @param {Wallet} wallet The new wallet singleton. */ static setWallet(wallet) { theWallet = wallet; } /** * List all of the credentials in the wallet. * @abstract * @return {Promise} A promise that is resolved with * an array of credential names, or rejected with an * error. */ list() { throw new Error('abstract function called'); } /** * Check to see if the named credentials are in * the wallet. * @abstract * @param {string} name The name of the credentials. * @return {Promise} A promise that is resolved with * a boolean; true if the named credentials are in the * wallet, false otherwise. */ contains(name) { throw new Error('abstract function called'); } /** * Get the named credentials from the wallet. * @abstract * @param {string} name The name of the credentials. * @return {Promise} A promise that is resolved with * the named credentials, or rejected with an error. */ get(name) { throw new Error('abstract function called'); } /** * Add a new credential to the wallet. * @abstract * @param {string} name The name of the credentials. * @param {string} value The credentials. * @return {Promise} A promise that is resolved when * complete, or rejected with an error. */ add(name, value) { throw new Error('abstract function called'); } /** * Update existing credentials in the wallet. * @abstract * @param {string} name The name of the credentials. * @param {string} value The credentials. * @return {Promise} A promise that is resolved when * complete, or rejected with an error. */ update(name, value) { throw new Error('abstract function called'); } /** * Remove existing credentials from the wallet. * @abstract * @param {string} name The name of the credentials. * @return {Promise} A promise that is resolved when * complete, or rejected with an error. */ remove(name) { throw new Error('abstract function called'); } } module.exports = Wallet; × Search results Close "},"composer-runtime_lib_transactionhandler.js.html":{"id":"composer-runtime_lib_transactionhandler.js.html","title":"Source: composer-runtime/lib/transactionhandler.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/transactionhandler.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const LOG = Logger.getLog('TransactionHandler'); /** * A transaction handler class can bind transaction processor functions which are * then executed when the bound transaction type is submitted. * @abstract * @protected */ class TransactionHandler { /** * Constructor. */ constructor() { this.handlers = {}; } /** * Bind the specified transaction processor function to the specified transaction * type, so that it is executed when the specified transaction is submitted.. * @protected * @param {string} transactionFQT The fully qualified type of the transaction. * @param {Function} handler The transaction processor function. */ bind(transactionFQT, handler) { const method = 'bind'; LOG.entry(method, transactionFQT, handler); if (this.handlers[transactionFQT]) { LOG.debug(method, 'Found existing handlers array'); this.handlers[transactionFQT].push(handler); } else { LOG.debug(method, 'Creating new handlers array'); this.handlers[transactionFQT] = [handler]; } LOG.exit(method); } /** * Execute the specified transaction. * @param {Api} api The API to use. * @param {Resource} resolvedTransaction The resolved transaction to execute. * @return {Promise} A promise that is resolved when the transaction has been * executed, or rejected with an error. */ execute(api, resolvedTransaction) { const method = 'execute'; LOG.entry(method, api, resolvedTransaction); const fqt = resolvedTransaction.getFullyQualifiedType(); const handlers = this.handlers[fqt] || []; return handlers.reduce((promise, handler) =&gt; { return promise.then(() =&gt; { LOG.debug(method, 'Calling handler'); return handler.call(this, api, resolvedTransaction); }); }, Promise.resolve()) .then(() =&gt; { LOG.exit(method, handlers.length); return handlers.length; }); } } module.exports = TransactionHandler; × Search results Close "},"composer-common_lib_log_tree.js.html":{"id":"composer-common_lib_log_tree.js.html","title":"Source: composer-common/lib/log/tree.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/log/tree.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Node = require('./node.js'); /** Specific tree implementation to work with the inclusion/exclusion log statements * * @private */ class Tree { /** Create the tree and setup the root node */ constructor(){ this.root = new Node('composer',false); } /** Mark the root to be included - defaults to false */ setRootInclusion(){ this.root.setIncluded(); } /** * Add a new node to the tree * * @param {String} name name of the node to add * @param {boolean} include should this be included or not * @return {Node} the new node created */ addNode(name, include){ return this._insertChildNode(name,include,this.root); } /** * Find inclusion property for a given node * @param {String} name name of the node to search the tree for * @return {boolean} inclusion policy - true or false */ getInclusion(name){ return this._findNode(name,this.root); } /** * @param {String} name name of the node to search the tree for * @param {Node} parent parent node to start searching from * @return {boolean} inclusion policy - true or false * * @private */ _findNode(name, parent){ // split the name up based on the marker / let details = name.split(/\\//); let newNodeName = details.shift(); let foundNode = parent.findChild(newNodeName); if ( typeof foundNode === 'undefined' ){ return parent.isIncluded(); } else { return this._findNode(details.join('/'),foundNode); } } /** * Insert a new node based on this parent * @param {String} name name of the node to add * @param {boolean} include should this be included or not * @param {Node} parent node to use as the parent for the children * @return {Node} newly inserted node * * @private */ _insertChildNode(name, include, parent){ // split the name up based on the marker / let details = name.split(/\\//); let newNodeName = details.shift(); // Look to see if the node is in the parent already let child = parent.findChild(newNodeName); if (typeof child === 'undefined' ){ if (details.length === 0) { let newNode = new Node(newNodeName,include); parent.addChildNodeAtStart(newNode); // at the leaf node return the new node created return newNode; } else { let newNode = new Node(newNodeName,parent.isIncluded()); parent.addChildNodeAtStart(newNode); // request another new node to be created. return this._insertChildNode(details.join('/'),include,newNode); } } else { // we have found a node already that matches the name. return this._insertChildNode(details.join('/'),include,child); } } } module.exports = Tree; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Global Members theWallet Currently we have a wallet singleton, but this is temporary untilwe decide how wallets fit into the administrative and client APIs. Source: composer-common/lib/wallet.js, line 21 Methods getLogger(config, configElements) This the default core logger that is used for Hyperledger-Composer. This functionsetups up the Winston logging for both file and console output. Parameters: Name Type Description config Object JSON structure with specific configuration information configElements Array JSON struction with the DEBUG env variables for composer Source: composer-common/lib/log/winstonInjector.js, line 29 Returns: object that is the logger to use Type Object × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Modules Classes ConsoleLogger AdminConnection AssetRegistry BusinessNetworkConnection Historian IdentityRegistry ParticipantRegistry Query Query Registry TransactionRegistry BaseException BaseFileException BusinessNetworkDefinition BusinessNetworkMetadata Concept Factory Identifiable IllegalModelException Introspector InvalidQueryException ParseException Relationship Resource SecurityContext SecurityException Serializer Typed TypeNotFoundException ValidatedConcept ValidatedResource ValidationException AssetRegistry Factory ParticipantRegistry Query Serializer × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Classes Classes ConsoleLogger AdminConnection AssetRegistry BusinessNetworkConnection Historian IdentityRegistry ParticipantRegistry Query Query Registry TransactionRegistry BaseException BaseFileException BusinessNetworkDefinition BusinessNetworkMetadata Concept Factory Identifiable IllegalModelException Introspector InvalidQueryException ParseException Relationship Resource SecurityContext SecurityException Serializer Typed TypeNotFoundException ValidatedConcept ValidatedResource ValidationException AssetRegistry Factory ParticipantRegistry Query Serializer × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Hyperledger Composer APIHyperledger Composer is an application development framework for building Blockchain applications based on Hyperledger. This is the JavaScript documentation for the Hyperledger Composer Client, Admin, and Runtime JavaScript APIs. OverviewThe major components of Hyperledger Composer are: The Hyperledger Composer language for describing the structure of resources (assets, participantsand transactions) that participate in a blockchain backed business network. JavaScript APIs to query, create, update and delete resources and submit transactionsfrom client applications. Hyperledger Composer resources are stored on the Blockchain. JavaScript transaction processor functions that runs on Hyperledger Fabric when transactions aresubmitted for processing. These functions may update the state of resourcesstored on the Blockchain via server-side Hyperledger Composer APIs. Resources Documentation npm modules GitHub repositories ContributingTo read more about the community and guidelines for submitting pull requests,please read the Contributing document. × Search results Close "},"ConsoleLogger.html":{"id":"ConsoleLogger.html","title":"Class: ConsoleLogger","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: ConsoleLogger ConsoleLogger A functional logger implementation that simply writes to the console. new ConsoleLogger() Source: composer-common/lib/log/consolelogger.js, line 22 Methods format(method, msg [, args]) Called to format. Parameters: Name Type Argument Description method string The method. msg string The message. args * &lt;optional&gt; The arguments. Source: composer-common/lib/log/consolelogger.js, line 31 Returns: The formatted message. Type string log(level, method, msg [, args]) Called to log. Parameters: Name Type Argument Description level string The logging level. method string The method. msg string The message. args * &lt;optional&gt; The arguments. Source: composer-common/lib/log/consolelogger.js, line 59 × Search results Close "},"module-composer-admin.html":{"id":"module-composer-admin.html","title":"Module: composer-admin","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Module: composer-admin The composer-admin module. Defines the administration API for Hyperledger Composer.Hyperledger Composer is a framework for creating blockchain backed digital networks andexchanging assets between participants via processing transactions. Source: composer-admin/index.js, line 25 Classes AdminConnection × Search results Close "},"module-composer-admin.AdminConnection.html":{"id":"module-composer-admin.AdminConnection.html","title":"Class: AdminConnection","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: AdminConnection composer-admin. AdminConnection This class creates an administration connection to a Hyperledger Composer runtime. Theconnection can then be used to: Deploy BusinessNetworkDefinitions Undeploy BusinessNetworkDefinitions Update BusinessNetworkDefinitions Send a ping message to the runtime to ensure it is running andcorrectly configured. Store a connection profile document in the connection profile storeNote: that the methods on this class take the 'businessNetworkIdentifier'; this has to matchthe name given on the create call. An AdminConnection that has been connected to network-A canonly be used to adminster network-A. Instances of AdminConnections can be reused for different networks. Call disconnect(..) then connect(..).Calling an api after disconnect and before connect will give an error. new AdminConnection( [options]) Create an instance of the AdminConnection class. Parameters: Name Type Argument Description options Object &lt;optional&gt; an optional set of options to configure the instance. Properties Name Type Argument Description connectionProfileStore ConnectionProfileStore &lt;optional&gt; specify a connection profile store to use. fs Object &lt;optional&gt; specify an fs implementation to use. Source: composer-admin/lib/adminconnection.js, line 48 Methods connect(connectionProfile, enrollmentID, enrollmentSecret, businessNetworkIdentifier) Connects and logs in to the Hyperledger Fabric using a named connectionprofile. The connection profile must exist in the profile store. Parameters: Name Type Description connectionProfile string The name of the connection profile enrollmentID string the enrollment ID of the user enrollmentSecret string the enrollment secret of the user businessNetworkIdentifier string the id of the network (for update) or null Source: composer-admin/lib/adminconnection.js, line 193 Returns: A promise that indicates the connection is complete Type Promise Example // Connect to Hyperledger Fabric var adminConnection = new AdminConnection(); adminConnection.connect('testprofile', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(){ // Connected. }) .catch(function(error){ // Add optional error handling here. }); createProfile(connectionProfile, data) Stores a connection profile into the profile store being used by thisAdminConnection. Parameters: Name Type Description connectionProfile string The name of the connection profile data Object The connection profile data Source: composer-admin/lib/adminconnection.js, line 109 Returns: A promise that indicates that the connection profile is deployed Type Promise Example // Create a connection profile var adminConnection = new AdminConnection(); var adminOptions = { type: 'hlf', keyValStore: '/tmp/keyValStore', membershipServicesURL: 'grpc://membersrvc:7054', peerURL: 'grpc://vp0:7051', eventHubURL: 'grpc://vp0:7053' }; return adminConnection.createProfile('testprofile', adminOptions) .then(function(){ // Created profile }) .catch(function(error){ // Add optional error handling here. }); deleteProfile(connectionProfile) Deletes the specified connection profile from the profile store being used by thisAdminConnection. Parameters: Name Type Description connectionProfile string The name of the connection profile Source: composer-admin/lib/adminconnection.js, line 129 Returns: A promise that indicates that the connection profile is deployed Type Promise Example // Delete a connection profile var adminConnection = new AdminConnection(); return adminConnection.deleteProfile('testprofile') .then(function(){ // Deleted profile }) .catch(function(error){ // Add optional error handling here. }); deploy(businessNetworkDefinition, deployOptions) Deploys a new BusinessNetworkDefinition to the Hyperledger Fabric. The connection mustbe connected for this method to succeed. Parameters: Name Type Description businessNetworkDefinition BusinessNetworkDefinition The business network to deploy deployOptions Object connector specific deployment options Source: composer-admin/lib/adminconnection.js, line 439 Returns: A promise that will be fufilled when the business network has beendeployed. Type Promise Example // Deploy a Business Network Definition var adminConnection = new AdminConnection(); var businessNetworkDefinition = BusinessNetworkDefinition.fromArchive(myArchive); return adminConnection.deploy(businessNetworkDefinition) .then(function(){ // Business network definition deployed }) .catch(function(error){ // Add optional error handling here. }); disconnect() Disconnects this connection.securityContext Source: composer-admin/lib/adminconnection.js, line 222 Returns: A promise that will be resolved when the connection isterminated. Type Promise Example // Disconnect from a Business Network var adminConnection = new AdminConnection(); return adminConnection.disconnect() .then(function(){ // Disconnected. }) .catch(function(error){ // Add optional error handling here. }); exportIdentity(connectionProfileName, id) Obtain the credentials associated with a given identity. Parameters: Name Type Description connectionProfileName String Name of the connection profile. id String Name of the identity. Source: composer-admin/lib/adminconnection.js, line 801 Returns: Resolves to credentials in the form { certificate: String, privateKey: String }. Type Promise getAllProfiles() Retrieve all connection profiles from the profile store being used by thisAdminConnection. Source: composer-admin/lib/adminconnection.js, line 166 Returns: A promise that is resolved with the connection profile data. Type Promise Example // Retrieve all the connection profiles. const adminConnection = new AdminConnection(); return adminConnection.getAllProfiles() .then((profiles) =&gt; { // Retrieved profiles for (let profile in profiles) { console.log(profile, profiles[profile]); } }); getProfile(connectionProfile) Retrieve the specified connection profile from the profile store beingused by this AdminConnection. Parameters: Name Type Description connectionProfile string The name of the connection profile Source: composer-admin/lib/adminconnection.js, line 147 Returns: A promise that is resolved with the connection profile data. Type Promise Example // Retrieve the connection profile. const adminConnection = new AdminConnection(); return adminConnection.getProfile('testprofile') .then((profile) =&gt; { // Retrieved profile console.log(profile); }); importIdentity(connectionProfile, id, certificate, privateKey) Import an identity into a profiles' wallet. No connection needs to be establishedfor this method to succeed. Parameters: Name Type Description connectionProfile string Name of the connection profile id string The id to associate with this identity certificate string The signer cert in PEM format privateKey string The private key in PEM format Source: composer-admin/lib/adminconnection.js, line 740 Returns: A promise which is resolved when the identity is imported Type Promise Example // Import an identity into a profiles' wallet var adminConnection = new AdminConnection(); return adminConnection.importIdentity('hlfv1', 'PeerAdmin', certificate, privateKey) .then(() =&gt; { // Identity imported console.log('identity imported successfully'); }) .catch(function(error){ // Add optional error handling here. }); install(businessNetworkIdentifier, installOptions) Installs the Hyperledger Composer runtime to the Hyperledger Fabric in preparationfor the business network to be started. The connection mustbe connected for this method to succeed.You must pass the name of the business network that is defined in your archive that thisruntime will be started with. Parameters: Name Type Description businessNetworkIdentifier BusinessNetworkIdentifier The name of business network which will be used to start this runtime. installOptions Object connector specific install options Source: composer-admin/lib/adminconnection.js, line 254 Returns: A promise that will be fufilled when the business network has beendeployed. Type Promise Example // Install the Hyperledger Composer runtime var adminConnection = new AdminConnection(); var businessNetworkDefinition = BusinessNetworkDefinition.fromArchive(myArchive); return adminConnection.install(businessNetworkDefinition.getName()) .then(function(){ // Business network definition installed }) .catch(function(error){ // Add optional error handling here. }); list() List all of the deployed business networks. The connection mustbe connected for this method to succeed. Source: composer-admin/lib/adminconnection.js, line 712 Returns: A promise that will be resolved with an array ofbusiness network identifiers, or rejected with an error. Type Promise Example // List all of the deployed business networks. var adminConnection = new AdminConnection(); return adminConnection.list() .then((businessNetworks) =&gt; { // Connection has been tested return businessNetworks.forEach((businessNetwork) =&gt; { console.log('Deployed business network', businessNetwork); }); }) .catch(function(error){ // Add optional error handling here. }); ping() Test the connection to the runtime and verify that the version of theruntime is compatible with this level of the node.js module. Source: composer-admin/lib/adminconnection.js, line 580 Returns: A promise that will be fufilled when the connection hasbeen tested. The promise will be rejected if the version is incompatible. Type Promise Example // Test the connection to the runtime var adminConnection = new AdminConnection(); return adminConnection.ping() .then(function(){ // Connection has been tested }) .catch(function(error){ // Add optional error handling here. }); requestIdentity(connectionProfile, enrollmentID, enrollmentSecret) Request the certificates for an identity. No connection needs to be establishedfor this method to succeed. Parameters: Name Type Description connectionProfile string Name of the connection profile enrollmentID string The ID to enroll enrollmentSecret string The secret for the ID Source: composer-admin/lib/adminconnection.js, line 780 Returns: A promise which is resolved when the identity is imported Type Promise Example // Request the cryptographic material for am identity of a hlf v1 environment. var adminConnection = new AdminConnection(); return adminConnection.requestIdentity('hlfv1', 'admin', 'adminpw') .then((response) =&gt; { // Identity returned console.log('public signing certificate:'); console.log(response.certificate); console.log('private key:'); console.log(response.key); console.log('ca root certificate:'); console.log(response.rootCertificate); }) .catch(function(error){ // Add optional error handling here. }); reset(businessNetworkIdentifier) Resets an existing BusinessNetworkDefinition on the Hyperledger Fabric. The BusinessNetworkDefinitionmust have been previously deployed. Note this will remove ALL the contents of the network registries, but not any system registries Parameters: Name Type Description businessNetworkIdentifier BusinessNetworkIdentifier The name of business network that will be reset Source: composer-admin/lib/adminconnection.js, line 527 Returns: A promise that will be fufilled when the business network has beenupdated. Type Promise Example // Updates a Business Network Definition var adminConnection = new AdminConnection(); var businessNetworkDefinition = BusinessNetworkDefinition.fromArchive(myArchive); return adminConnection.reset(businessNetworkDefinition) .then(function(){ // Business network definition updated }) .catch(function(error){ // Add optional error handling here. }); start(businessNetworkDefinition [, startOptions]) Starts a business network within the runtime previously installed to the Hyperledger Fabric withthe same name as the business network to be started. The connection must be connected for thismethod to succeed. Parameters: Name Type Argument Description businessNetworkDefinition BusinessNetworkDefinition The business network to start startOptions Object &lt;optional&gt; connector specific start options Source: composer-admin/lib/adminconnection.js, line 402 Returns: A promise that will be fufilled when the business network has beendeployed. Type Promise Example // Start a Business Network Definition var adminConnection = new AdminConnection(); var businessNetworkDefinition = BusinessNetworkDefinition.fromArchive(myArchive); return adminConnection.start(businessNetworkDefinition) .then(function(){ // Business network definition is started }) .catch(function(error){ // Add optional error handling here. }); undeploy(businessNetworkIdentifier) Undeploys a BusinessNetworkDefinition from the Hyperledger Fabric. The business network will nolonger be able to process transactions. Parameters: Name Type Description businessNetworkIdentifier BusinessNetworkIdentifier The name of business network that will be used to start this runtime. Source: composer-admin/lib/adminconnection.js, line 474 Returns: A promise that will be fufilled when the business network has beenundeployed. Type Promise Example // Undeploy a Business Network Definition var adminConnection = new AdminConnection(); return adminConnection.undeploy('identifier') .then(function(){ // Undeployed Business Network Definition }) .catch(function(error){ // Add optional error handling here. }) update(businessNetworkDefinition) Updates an existing BusinessNetworkDefinition on the Hyperledger Fabric. The BusinessNetworkDefinitionmust have been previously deployed. Parameters: Name Type Description businessNetworkDefinition BusinessNetworkDefinition The new BusinessNetworkDefinition Source: composer-admin/lib/adminconnection.js, line 499 Returns: A promise that will be fufilled when the business network has beenupdated. Type Promise Example // Updates a Business Network Definition var adminConnection = new AdminConnection(); var businessNetworkDefinition = BusinessNetworkDefinition.fromArchive(myArchive); return adminConnection.update(businessNetworkDefinition) .then(function(){ // Business network definition updated }) .catch(function(error){ // Add optional error handling here. }); × Search results Close "},"module-composer-client.html":{"id":"module-composer-client.html","title":"Module: composer-client","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Module: composer-client The composer-client module. Defines the client API for Composer.Composer is a framework for creating blockchain backed digital networks andexchanging assets between participants via processing transactions.Applications interact with the framework by instantiating the BusinessNetworkConnectionclass. Source: composer-client/index.js, line 26 Classes AssetRegistry BusinessNetworkConnection Historian IdentityRegistry ParticipantRegistry Query Query Registry TransactionRegistry × Search results Close "},"module-composer-client.AssetRegistry.html":{"id":"module-composer-client.AssetRegistry.html","title":"Class: AssetRegistry","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: AssetRegistry composer-client. AssetRegistry The AssetRegistry is used to manage a set of assets stored on the Blockchain. new AssetRegistry(id, name, securityContext, modelManager, factory, serializer, bnc) Create an asset registry. Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkConnection Parameters: Name Type Description id string The unique identifier of the asset registry. name string The display name for the asset registry. securityContext SecurityContext The security context to use for this asset registry. modelManager ModelManager The ModelManager to use for this asset registry. factory Factory The factory to use for this asset registry. serializer Serializer The Serializer to use for this asset registry. bnc BusinessNetworkConnection Instance of the BusinessNetworkConnection Source: composer-client/lib/assetregistry.js, line 30 See: See Registry Extends Registry Methods add(resource [, options]) Add the specified resource to this registry. Parameters: Name Type Argument Description resource Resource The resource to add to this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. forceAdd boolean &lt;optional&gt; Forces adding the object even if it present (default to false) Inherited From: Registry#add Source: composer-runtime/lib/registry.js, line 174 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise addAll(resources [, options]) Add all of the specified resources to this registry. Parameters: Name Type Argument Description resources Array.&lt;Resource&gt; The resources to add to this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. forceAdd boolean &lt;optional&gt; Forces adding the object even if it present (default to false) Inherited From: Registry#addAll Source: composer-runtime/lib/registry.js, line 155 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise addInternalProperties(json) Add any internal properties to the specified JSON object beforepersisting it into a data collection. Parameters: Name Type Description json Object The JSON object. Inherited From: Registry#addInternalProperties Source: composer-runtime/lib/registry.js, line 324 Returns: The JSON object. Type Object exists(id) Determine whether the specified resource exists in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#exists Source: composer-runtime/lib/registry.js, line 115 Returns: A promise that will be resolved with a booleanindicating whether the asset exists. Type Promise get(id) Get the specified resource in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#get Source: composer-runtime/lib/registry.js, line 94 Returns: A promise that will be resolved with a Resourceobject when complete, or rejected with an error. Type Promise getAll() Get all the resources in this registry. Inherited From: Registry#getAll Source: composer-runtime/lib/registry.js, line 67 Returns: A promise that will be resolved with an array of {@linkResource} objects when complete, or rejected with an error. Type Promise remove(resource) Remove the specified resource from this registry. Parameters: Name Type Description resource string | Resource The resource to remove from this registry. Inherited From: Registry#remove Source: composer-runtime/lib/registry.js, line 286 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise removeAll(resources) Remove all of the specified resources from this registry. Parameters: Name Type Description resources Array.&lt;string&gt; | Array.&lt;Resource&gt; The resources to remove from this registry. Inherited From: Registry#removeAll Source: composer-runtime/lib/registry.js, line 272 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise toJSON() Return an object suitable for serialization. Inherited From: Registry#toJSON Source: composer-runtime/lib/registry.js, line 337 Returns: An object suitable for serialization. Type Object update(resource [, options]) Update the specified resource in this registry. Parameters: Name Type Argument Description resource Resource The resource to update in this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. Inherited From: Registry#update Source: composer-runtime/lib/registry.js, line 230 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise updateAll(resources [, options]) Update all of the specified resources in this registry. Parameters: Name Type Argument Description resources Array.&lt;Resource&gt; The resources to update in this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. Inherited From: Registry#updateAll Source: composer-runtime/lib/registry.js, line 212 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise × Search results Close "},"module-composer-client.BusinessNetworkConnection.html":{"id":"module-composer-client.BusinessNetworkConnection.html","title":"Class: BusinessNetworkConnection","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: BusinessNetworkConnection composer-client. BusinessNetworkConnection Use this class to connect to and then interact with a deployed BusinessNetworkDefinition.Use the AdminConnection class in the composer-admin module to deploy BusinessNetworksDefinitions. new BusinessNetworkConnection( [options]) Create an instance of the BusinessNetworkConnection class.must be called to connect to a deployed BusinessNetworkDefinition. Parameters: Name Type Argument Description options Object &lt;optional&gt; an optional set of options to configure the instance. Properties Name Type Argument Description connectionProfileStore ConnectionProfileStore &lt;optional&gt; specify a connection profile store to use. fs Object &lt;optional&gt; specify an fs implementation to use. Source: composer-client/lib/businessnetworkconnection.js, line 47 Extends EventEmitter Methods addAssetRegistry(id, name) Add a new asset registry. Parameters: Name Type Description id string The unique identifier of the asset registry name string The name of the asset registry Source: composer-client/lib/businessnetworkconnection.js, line 183 Returns: A promise that will be resolved with the new assetregistry after it has been added. Type Promise Example // Add a new asset registry var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.addAssetRegistry('registryId','registryName'); }); addParticipantRegistry(id, name) Add a new participant registry. Parameters: Name Type Description id string The unique identifier of the participant registry name string The name of the participant registry Source: composer-client/lib/businessnetworkconnection.js, line 269 Returns: A promise that will be resolved with the new participantregistry after it has been added. Type Promise Example // Add a new participant registry var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.addParticipantRegistry('registryId','registryName'); }); assetRegistryExists(id) Determine whether a asset registry exists. Parameters: Name Type Description id string The unique identifier of the asset registry Source: composer-client/lib/businessnetworkconnection.js, line 164 Returns: A promise that will be resolved with a boolean indicating whether the assetregistry exists. Type Promise Example // Determine whether an asset registry exists var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.assetRegistryExists('businessNetworkIdentifier.registryId'); }) .then(function(exists){ // if (exists === true) { // logic here... //} }); bindIdentity(participant, certificate) Bind an existing identity to the specified participant. Parameters: Name Type Description participant Resource | string The participant, or the fully qualifiedidentifier of the participant. The participant must already exist. certificate string The certificate for the existing identity. Source: composer-client/lib/businessnetworkconnection.js, line 786 Returns: A promise that will be fulfilled when the identity hasbeen added to the specified participant. The promise will be rejected ifthe participant does not exist, or if the identity is already mapped toanother participant. Type Promise buildQuery(query) Build a query ready for later execution. The specified query string must be writtenin the Composer query language. This functionality is Blockchain platform dependent. For example, when a Composerbusiness network is deployed to Hyperledger Fabric v1.0, Hyperledger Fabric must beconfigured with the CouchDB database for the world state. Parameters: Name Type Description query string The query string, written using the Composer query language. Source: composer-client/lib/businessnetworkconnection.js, line 582 Returns: The built query, which can be passed in a call to query. Type Query Example // Build and execute a query. var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function () { var query = businessNetwork.buildQuery('SELECT org.acme.sample.SampleAsset WHERE (value == _$inputValue)'); return businessNetwork.query(query, { inputValue: 'blue' }) }) .then(function (assets) { assets.forEach(function (asset) { // Process each asset. }); }) .catch(function (error) { // Add optional error handling here. }); connect(connectionProfile, businessNetwork, enrollmentID, enrollmentSecret [, additionalConnectOptions]) Connects to a business network using a connection profile, and authenticates to the Hyperledger Fabric. Parameters: Name Type Argument Description connectionProfile string The name of the connection profile businessNetwork string The identifier of the business network enrollmentID string the enrolment ID of the user enrollmentSecret string the enrolment secret of the user additionalConnectOptions Object &lt;optional&gt; Additional configuration options suppliedat runtime that override options set in the connection profile.which will override those in the specified connection profile. Source: composer-client/lib/businessnetworkconnection.js, line 412 Returns: A promise to a BusinessNetworkDefinition that indicates the connection is complete Type Promise Example // Connect and log in to HLF var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ // Connected }); disconnect() Disconnects from the Hyperledger Fabric. Source: composer-client/lib/businessnetworkconnection.js, line 495 Returns: A promise that will be resolved when the connection isterminated. Type Promise Example // Disconnects from HLF var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.disconnect(); }) .then(function(){ // Disconnected. }); getAllAssetRegistries( [includeSystem]) Get a list of all existing asset registries. Parameters: Name Type Argument Description includeSystem boolean &lt;optional&gt; if true the returned list will include the system transaction registries (optional, default to false) Source: composer-client/lib/businessnetworkconnection.js, line 119 Returns: A promise that will be resolved with a list of existingasset registries Type Promise Example // Get all asset registries var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.getAllAssetRegistries(); }) .then(function(assetRegistries){ // Retrieved Asset Registries }); getAllParticipantRegistries( [includeSystem]) Get a list of all existing participant registries. Parameters: Name Type Argument Description includeSystem boolean &lt;optional&gt; if true the returned list will include the system transaction registries (optional, default to false) Source: composer-client/lib/businessnetworkconnection.js, line 205 Returns: A promise that will be resolved with a list of existingparticipant registries Type Promise Example // Get all participant registries var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.getAllParticipantRegistries(); }) .then(function(participantRegistries){ // Retrieved Participant Registries }); getAllTransactionRegistries( [includeSystem]) Get all transaction registries. Parameters: Name Type Argument Description includeSystem boolean &lt;optional&gt; if true the returned list will include the system transaction registries (optional, default to false) Source: composer-client/lib/businessnetworkconnection.js, line 309 Returns: A promise that will be resolved to the TransactionRegistry Type Promise Example // Get the transaction registry var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.getAllTransactionRegistries(); }) .then(function(transactionRegistries){ // Retrieved transaction Registries }); getAssetRegistry(id) Get an existing asset registry. Parameters: Name Type Description id string The unique identifier of the asset registry Source: composer-client/lib/businessnetworkconnection.js, line 141 Returns: A promise that will be resolved with the existing assetregistry, or rejected if the asset registry does not exist. Type Promise Example // Get a asset registry var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.getAssetRegistry('businessNetworkIdentifier.registryId'); }) .then(function(assetRegistry){ // Retrieved Asset Registry }); getBusinessNetwork() Returns the currently connected BusinessNetworkDefinition Source: composer-client/lib/businessnetworkconnection.js, line 99 Returns: the business network Type BusinessNetworkDefinition Example // Get the Business Network Definition var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.getBusinessNetwork(); }) .then(function(BusinessNetworkDefinition){ // Retrieved Business Network Definition }); getHistorian() Get the historian Source: composer-client/lib/businessnetworkconnection.js, line 354 Returns: A promise that will be resolved to the Historian Type Promise Example // Get the historian var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.getHistorian(); }) .then(function(historian){ // Retrieved historian }); getIdentityRegistry() Get the identity registry. Source: composer-client/lib/businessnetworkconnection.js, line 381 Returns: A promise that will be resolved to the IdentityRegistry Type Promise Example // Get the identity registry var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.getIdentityRegistry(); }) .then(function(identityRegistry){ // Retrieved identity registry }); getParticipantRegistry(id) Get an existing participant registry. Parameters: Name Type Description id string The unique identifier of the participant registry Source: composer-client/lib/businessnetworkconnection.js, line 227 Returns: A promise that will be resolved with the existing participantregistry, or rejected if the participant registry does not exist. Type Promise Example // Get a participant registry var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.getParticipantRegistry('businessNetworkIdentifier.registryId'); }) .then(function(participantRegistry){ // Retrieved Participant Registry }); getRegistry(fullyQualifiedName) Given a fully qualified name, works out and looks up the registry that this resource will be found in.This only gives back the default registry - it does not look in any application defined registry. Parameters: Name Type Description fullyQualifiedName String The fully qualified name of the resources Source: composer-client/lib/businessnetworkconnection.js, line 462 Returns: resolved with the registry that this fqn could be found in by default Type Promise Example // Locate the registry for a fully qualififed name var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetwork){ var sampleAssetRegistry = businessNetwork.getRegistry('org.acme.sampleAsset'); var sampleTransactionRegistry = businessNetwork.getRegistry('org.acme.sampleTransaction'); var sampleParticipantRegistry = businessNetwork.getRegistry('org.acme.sampleParticipant'); }); getTransactionRegistry(id) Get the transaction registry. Parameters: Name Type Description id string The unique identifier of the transaction registry Source: composer-client/lib/businessnetworkconnection.js, line 289 Returns: A promise that will be resolved to the TransactionRegistry Type Promise Example // Get the transaction registry var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.getTransactionRegistry('org.acme.exampleTransaction'); }) .then(function(transactionRegistry){ // Retrieved transaction registry. }); issueIdentity(participant, identityName [, options]) Issue an identity with the specified name and map it to the specifiedparticipant. Parameters: Name Type Argument Description participant Resource | Relationship | string The participant, arelationship to the participant, or the fully qualified identifier ofthe participant. The participant must already exist. identityName string The name for the new identity. options object &lt;optional&gt; Options for the new identity. Properties Name Type Argument Description issuer boolean &lt;optional&gt; Whether or not the new identity should havepermissions to create additional new identities. False by default. Source: composer-client/lib/businessnetworkconnection.js, line 735 Returns: A promise that will be fulfilled when the identity hasbeen added to the specified participant. The promise will be rejected ifthe participant does not exist, or if the identity is already mapped toanother participant. Type Promise participantRegistryExists(id) Determine whether a participant registry exists. Parameters: Name Type Description id string The unique identifier of the participant registry Source: composer-client/lib/businessnetworkconnection.js, line 250 Returns: A promise that will be resolved with a boolean indicating whether the participantregistry exists. Type Promise Example // Determine whether an asset registry exists var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.participantRegistryExists('businessNetworkIdentifier.registryId'); }) .then(function(exists){ // if (exists === true) { // logic here... //} }); ping() Test the connection to the runtime and verify that the version of theruntime is compatible with this level of the client node.js module. Source: composer-client/lib/businessnetworkconnection.js, line 662 Returns: A promise that will be fulfilled when the connection hasbeen tested. The promise will be rejected if the version is incompatible. Type Promise Example // Test the connection to the runtime var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetwork.ping(); }) .then(function(){ // Connection tested. }); query(query [, parameters]) Execute a query defined in a Composer query file, or execute a query built with buildQuery. This functionality is Blockchain platform dependent. For example, when a Composerbusiness network is deployed to Hyperledger Fabric v1.0, Hyperledger Fabric must beconfigured with the CouchDB database for the world state. Parameters: Name Type Argument Description query string | Query The name of the query, or a built query. parameters Object &lt;optional&gt; The parameters for the query. Source: composer-client/lib/businessnetworkconnection.js, line 619 Returns: A promise that will be resolved with an array ofResource representing theresources returned by the query. Type Promise Example // Execute the query. var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function () { return query('Q1', { inputValue: 'blue' }) }) .then(function (assets) { assets.forEach(function (asset) { // Process each asset. }); }) .catch(function (error) { // Add optional error handling here. }); revokeIdentity(identity) Revoke the specified identity by removing any existing mapping to a participant. Parameters: Name Type Description identity Resource | string The identity, or the identifier of the identity. Source: composer-client/lib/businessnetworkconnection.js, line 821 Returns: A promise that will be fulfilled when the identity hasbeen removed from the specified participant. The promise will be rejected ifthe participant does not exist, or if the identity is not mapped to theparticipant. Type Promise submitTransaction(transaction) Submit a transaction for processing by the currently connected business network. Parameters: Name Type Description transaction Resource The transaction to submit. Use {@linkFactory#newTransaction newTransaction} to create this object. Source: composer-client/lib/businessnetworkconnection.js, line 533 Returns: A promise that will be fulfilled when the transaction hasbeen processed. Type Promise Example // Submits a transaction var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ var factory = businessNetworkDefinition.getBusinessNetwork().getFactory(); var transaction = factory.newTransaction('network.transactions', 'TransactionType'); return businessNetworkDefinition.submitTransaction(transaction); }) .then(function(){ // Submitted a transaction. }); transactionRegistryExists(id) Determine whether a transaction registry exists. Parameters: Name Type Description id string The unique identifier of the transaction registry Source: composer-client/lib/businessnetworkconnection.js, line 334 Returns: A promise that will be resolved with a boolean indicating whether the transactionregistry exists. Type Promise Example // Determine whether an transaction registry exists var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetwork){ return businessNetwork.transactionRegistryExists('businessNetworkIdentifier.registryId'); }) .then(function(exists){ // if (exists === true) { // logic here... //} }); × Search results Close "},"module-composer-client.Historian.html":{"id":"module-composer-client.Historian.html","title":"Class: Historian","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Historian composer-client. Historian The Historian records the history of actions taken using Composer.It is a registry that stores HistorianRecords; each record is created in responseto a transaction being executred. As well as the transactions that are defined in the Network model other actions suchas adding assets are treated as transactions so are therefore recorded. Details of these are in the system model. new Historian(id, name, securityContext, modelManager, factory, serializer) Create a historian.Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkConnection Parameters: Name Type Description id string The unique identifier of the transaction registry. name string The display name for the transaction registry. securityContext SecurityContext The security context to use for this asset registry. modelManager ModelManager The ModelManager to use for this transaction registry. factory Factory The factory to use for this transaction registry. serializer Serializer The Serializer to use for this transaction registry. Source: composer-client/lib/historian.js, line 36 See: See Registry Extends Registry Methods &lt;static&gt; getHistorian(securityContext, modelManager, factory, serializer) Get an existing historian. Parameters: Name Type Description securityContext SecurityContext The user's security context. modelManager ModelManager The ModelManager to use for this historian. factory Factory The factory to use for this historian. serializer Serializer The Serializer to use for this historian. Source: composer-client/lib/historian.js, line 48 Returns: A promise that will be resolved with a IdentityRegistryinstance representing the historian. Type Promise addInternalProperties(json) Add any internal properties to the specified JSON object beforepersisting it into a data collection. Parameters: Name Type Description json Object The JSON object. Inherited From: Registry#addInternalProperties Source: composer-runtime/lib/registry.js, line 324 Returns: The JSON object. Type Object exists(id) Determine whether the specified resource exists in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#exists Source: composer-runtime/lib/registry.js, line 115 Returns: A promise that will be resolved with a booleanindicating whether the asset exists. Type Promise get(id) Get the specified resource in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#get Source: composer-runtime/lib/registry.js, line 94 Returns: A promise that will be resolved with a Resourceobject when complete, or rejected with an error. Type Promise getAll() Get all the resources in this registry. Inherited From: Registry#getAll Source: composer-runtime/lib/registry.js, line 67 Returns: A promise that will be resolved with an array of {@linkResource} objects when complete, or rejected with an error. Type Promise toJSON() Return an object suitable for serialization. Inherited From: Registry#toJSON Source: composer-runtime/lib/registry.js, line 337 Returns: An object suitable for serialization. Type Object × Search results Close "},"module-composer-client.IdentityRegistry.html":{"id":"module-composer-client.IdentityRegistry.html","title":"Class: IdentityRegistry","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: IdentityRegistry composer-client. IdentityRegistry The IdentityRegistry is used to store a set of identities on the blockchain. new IdentityRegistry(id, name, securityContext, modelManager, factory, serializer) Create an identity registry.Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkConnection Parameters: Name Type Description id string The unique identifier of the identity registry. name string The display name for the identity registry. securityContext SecurityContext The security context to use for this asset registry. modelManager ModelManager The ModelManager to use for this identity registry. factory Factory The factory to use for this identity registry. serializer Serializer The Serializer to use for this identity registry. Source: composer-client/lib/identityregistry.js, line 30 See: See Registry Extends Registry Methods &lt;static&gt; getIdentityRegistry(securityContext, modelManager, factory, serializer) Get an existing identity registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. modelManager ModelManager The ModelManager to use for this identity registry. factory Factory The factory to use for this identity registry. serializer Serializer The Serializer to use for this identity registry. Source: composer-client/lib/identityregistry.js, line 42 Returns: A promise that will be resolved with a IdentityRegistryinstance representing the identity registry. Type Promise addInternalProperties(json) Add any internal properties to the specified JSON object beforepersisting it into a data collection. Parameters: Name Type Description json Object The JSON object. Inherited From: Registry#addInternalProperties Source: composer-runtime/lib/registry.js, line 324 Returns: The JSON object. Type Object exists(id) Determine whether the specified resource exists in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#exists Source: composer-runtime/lib/registry.js, line 115 Returns: A promise that will be resolved with a booleanindicating whether the asset exists. Type Promise get(id) Get the specified resource in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#get Source: composer-runtime/lib/registry.js, line 94 Returns: A promise that will be resolved with a Resourceobject when complete, or rejected with an error. Type Promise getAll() Get all the resources in this registry. Inherited From: Registry#getAll Source: composer-runtime/lib/registry.js, line 67 Returns: A promise that will be resolved with an array of {@linkResource} objects when complete, or rejected with an error. Type Promise toJSON() Return an object suitable for serialization. Inherited From: Registry#toJSON Source: composer-runtime/lib/registry.js, line 337 Returns: An object suitable for serialization. Type Object × Search results Close "},"module-composer-client.ParticipantRegistry.html":{"id":"module-composer-client.ParticipantRegistry.html","title":"Class: ParticipantRegistry","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: ParticipantRegistry composer-client. ParticipantRegistry The ParticipantRegistry is used to manage a set of participants stored on the blockchain. new ParticipantRegistry(id, name, securityContext, modelManager, factory, serializer, bnc) Create an participant registry. Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkConnection Parameters: Name Type Description id string The unique identifier of the participant registry. name string The display name for the participant registry. securityContext SecurityContext The security context to use for this participant registry. modelManager ModelManager The ModelManager to use for this participant registry. factory Factory The factory to use for this participant registry. serializer Serializer The Serializer to use for this participant registry. bnc BusinessNetworkConnection BusinessNetworkConnection to use Source: composer-client/lib/participantregistry.js, line 30 See: See Registry Extends Registry Methods add(resource [, options]) Add the specified resource to this registry. Parameters: Name Type Argument Description resource Resource The resource to add to this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. forceAdd boolean &lt;optional&gt; Forces adding the object even if it present (default to false) Inherited From: Registry#add Source: composer-runtime/lib/registry.js, line 174 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise addAll(resources [, options]) Add all of the specified resources to this registry. Parameters: Name Type Argument Description resources Array.&lt;Resource&gt; The resources to add to this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. forceAdd boolean &lt;optional&gt; Forces adding the object even if it present (default to false) Inherited From: Registry#addAll Source: composer-runtime/lib/registry.js, line 155 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise addInternalProperties(json) Add any internal properties to the specified JSON object beforepersisting it into a data collection. Parameters: Name Type Description json Object The JSON object. Inherited From: Registry#addInternalProperties Source: composer-runtime/lib/registry.js, line 324 Returns: The JSON object. Type Object exists(id) Determine whether the specified resource exists in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#exists Source: composer-runtime/lib/registry.js, line 115 Returns: A promise that will be resolved with a booleanindicating whether the asset exists. Type Promise get(id) Get the specified resource in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#get Source: composer-runtime/lib/registry.js, line 94 Returns: A promise that will be resolved with a Resourceobject when complete, or rejected with an error. Type Promise getAll() Get all the resources in this registry. Inherited From: Registry#getAll Source: composer-runtime/lib/registry.js, line 67 Returns: A promise that will be resolved with an array of {@linkResource} objects when complete, or rejected with an error. Type Promise remove(resource) Remove the specified resource from this registry. Parameters: Name Type Description resource string | Resource The resource to remove from this registry. Inherited From: Registry#remove Source: composer-runtime/lib/registry.js, line 286 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise removeAll(resources) Remove all of the specified resources from this registry. Parameters: Name Type Description resources Array.&lt;string&gt; | Array.&lt;Resource&gt; The resources to remove from this registry. Inherited From: Registry#removeAll Source: composer-runtime/lib/registry.js, line 272 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise toJSON() Return an object suitable for serialization. Inherited From: Registry#toJSON Source: composer-runtime/lib/registry.js, line 337 Returns: An object suitable for serialization. Type Object update(resource [, options]) Update the specified resource in this registry. Parameters: Name Type Argument Description resource Resource The resource to update in this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. Inherited From: Registry#update Source: composer-runtime/lib/registry.js, line 230 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise updateAll(resources [, options]) Update all of the specified resources in this registry. Parameters: Name Type Argument Description resources Array.&lt;Resource&gt; The resources to update in this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. Inherited From: Registry#updateAll Source: composer-runtime/lib/registry.js, line 212 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise × Search results Close "},"module-composer-client.Query.html":{"id":"module-composer-client.Query.html","title":"Class: Query","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Query composer-client. Query A query represents a built query. new Query() Do not attempt to create an instance of this class.You must use the buildQuerymethod instead. Source: composer-client/lib/query.js, line 21 Class: Query composer-client. Query The Query class represents a built query. A built query has been parsed and validated.Do not attempt to create an instance of this class.You must use the buildQuerymethod instead. new Query(identifier) Constructor. Parameters: Name Type Description identifier string The identifier of the built query. Source: composer-client/lib/query.js, line 40 × Search results Close "},"module-composer-client.Registry.html":{"id":"module-composer-client.Registry.html","title":"Class: Registry","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Registry composer-client. Registry Class representing an Abstract Registry. &lt;abstract&gt; new Registry(registryType, id, name, securityContext, modelManager, factory, serializer, bnc) Create a registry. Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkConnection Parameters: Name Type Description registryType string The type of this registry. id string The unique identifier of the registry. name string The display name for the registry. securityContext SecurityContext The users security context. modelManager ModelManager The ModelManager to use for this registry. factory Factory The factory to use for this registry. serializer Serializer The Serializer to use for this registry. bnc BusinessNetworkConnection Instance of the BusinessNetworkConnectionTODO: Rationalize the bnc with the other objects - as the bnc contains these other arguments Source: composer-client/lib/registry.js, line 27 Methods add(resource) Adds a new resource to the registry. Parameters: Name Type Description resource Resource The resource to be added to the registry. Source: composer-client/lib/registry.js, line 200 Returns: A promise that will be resolved when the resource isadded to the registry. Type Promise addAll(resources) Adds a list of new resources to the registry. Parameters: Name Type Description resources Array.&lt;Resource&gt; The resources to be added to the registry. Source: composer-client/lib/registry.js, line 176 Returns: A promise that will be resolved when the resource isadded to the registry. Type Promise exists(id) Determines whether a specific resource exists in the registry. Parameters: Name Type Description id string The unique identifier of the resource. Source: composer-client/lib/registry.js, line 333 Returns: A promise that will be resolved with true/false depending on whether the resource exists. Type Promise get(id) Get a specific resource in the registry. Parameters: Name Type Description id string The unique identifier of the resource. Source: composer-client/lib/registry.js, line 313 Returns: A promise that will be resolved with a JSON objectrepresenting the resource. Type Promise getAll() Get all of the resources in the registry. Source: composer-client/lib/registry.js, line 292 Returns: A promise that will be resolved with an array of JSONobjects representing the resources. Type Promise remove(resource) Remove an asset with a given type and id from the registry. Parameters: Name Type Description resource Resource | string The resource, or the unique identifier of the resource. Source: composer-client/lib/registry.js, line 278 Returns: A promise that will be resolved when the resource isremoved from the registry. Type Promise removeAll(resources) Removes a list of resources from the registry. Parameters: Name Type Description resources Array.&lt;Resource&gt; | Array.&lt;string&gt; The resources, or the unique identifiers of the resources. Source: composer-client/lib/registry.js, line 250 Returns: A promise that will be resolved when the resource isadded to the registry. Type Promise resolve(id) Get a specific resource in the registry, and resolve all of its relationshipsto other assets, participants, and transactions. The result is a JavaScriptobject, and should only be used for visualization purposes. You cannot usethe add or update functions with a resolved resource. Parameters: Name Type Description id string The unique identifier of the asset. Source: composer-client/lib/registry.js, line 371 Returns: A promise that will be resolved with a JavaScript objectrepresenting the resource and all of its resolved relationships. Type Promise resolveAll() Get all of the resources in the registry, and resolve all of their relationshipsto other assets, participants, and transactions. The result is a JavaScriptobject, and should only be used for visualization purposes. You cannot usethe add or update functions with a resolved resource. Source: composer-client/lib/registry.js, line 353 Returns: A promise that will be resolved with an array of JavaScriptobjects representing the resources and all of their resolved relationships. Type Promise update(resource) Updates a resource in the registry. Parameters: Name Type Description resource Resource The resource to be updated in the registry. Source: composer-client/lib/registry.js, line 235 Returns: A promise that will be resolved when the resource isupdated in the registry. Type Promise updateAll(resources) Updates a list of resources in the registry. Parameters: Name Type Description resources Array.&lt;Resource&gt; The resources to be updated in the asset registry. Source: composer-client/lib/registry.js, line 215 Returns: A promise that will be resolved when the resource isadded to the registry. Type Promise × Search results Close "},"module-composer-client.TransactionRegistry.html":{"id":"module-composer-client.TransactionRegistry.html","title":"Class: TransactionRegistry","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: TransactionRegistry composer-client. TransactionRegistry The TransactionRegistry is used to store a set of transactions on the blockchain. new TransactionRegistry(id, name, securityContext, modelManager, factory, serializer) Create an transaction registry.Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkConnection Parameters: Name Type Description id string The unique identifier of the transaction registry. name string The display name for the transaction registry. securityContext SecurityContext The security context to use for this asset registry. modelManager ModelManager The ModelManager to use for this transaction registry. factory Factory The factory to use for this transaction registry. serializer Serializer The Serializer to use for this transaction registry. Source: composer-client/lib/transactionregistry.js, line 30 See: See Registry Extends Registry Methods &lt;static&gt; addTransactionRegistry(securityContext, id, name, modelManager, factory, serializer) Add a new transaction registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the transaction registry. name string The name of the transaction registry. modelManager ModelManager The ModelManager to use for this transaction registry. factory Factory The factory to use for this transaction registry. serializer Serializer The Serializer to use for this transaction registry. Source: composer-client/lib/transactionregistry.js, line 101 Returns: A promise that will be resolved with a TransactionRegistryinstance representing the new transaction registry. Type Promise &lt;static&gt; getAllTransactionRegistries(securityContext, modelManager, factory, serializer, bnc, systemRegistry) Get a list of all existing transaction registries. Parameters: Name Type Description securityContext SecurityContext The user's security context. modelManager ModelManager The ModelManager to use for this transaction registry. factory Factory The factory to use for this transaction registry. serializer Serializer The Serializer to use for this transaction registry. bnc BusinessNetworkConnection BusinessNetworkConnection to use systemRegistry Boolean True if system transaction registries should be included in the list. Source: composer-client/lib/transactionregistry.js, line 44 Returns: A promise that will be resolved with a list of TransactionRegistryinstances representing the transaction registries. Type Promise &lt;static&gt; getTransactionRegistry(securityContext, id, modelManager, factory, serializer) Get an existing transaction registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the transaction registry. modelManager ModelManager The ModelManager to use for this transaction registry. factory Factory The factory to use for this transaction registry. serializer Serializer The Serializer to use for this transaction registry. Source: composer-client/lib/transactionregistry.js, line 72 Returns: A promise that will be resolved with a TransactionRegistryinstance representing the transaction registry. Type Promise addInternalProperties(json) Add any internal properties to the specified JSON object beforepersisting it into a data collection. Parameters: Name Type Description json Object The JSON object. Inherited From: Registry#addInternalProperties Source: composer-runtime/lib/registry.js, line 324 Returns: The JSON object. Type Object exists(id) Determine whether the specified resource exists in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#exists Source: composer-runtime/lib/registry.js, line 115 Returns: A promise that will be resolved with a booleanindicating whether the asset exists. Type Promise get(id) Get the specified resource in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#get Source: composer-runtime/lib/registry.js, line 94 Returns: A promise that will be resolved with a Resourceobject when complete, or rejected with an error. Type Promise getAll() Get all the resources in this registry. Inherited From: Registry#getAll Source: composer-runtime/lib/registry.js, line 67 Returns: A promise that will be resolved with an array of {@linkResource} objects when complete, or rejected with an error. Type Promise toJSON() Return an object suitable for serialization. Inherited From: Registry#toJSON Source: composer-runtime/lib/registry.js, line 337 Returns: An object suitable for serialization. Type Object × Search results Close "},"module-composer-common.html":{"id":"module-composer-common.html","title":"Module: composer-common","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Module: composer-common Hyperledger-Composer module. Hyperledger-Composer is a framework for creatingblockchain backed digital networks and exchanging assets between participantsvia processing transactions. Source: composer-common/index.js, line 17 Classes BaseException BaseFileException BusinessNetworkDefinition BusinessNetworkMetadata Concept Factory Identifiable IllegalModelException Introspector InvalidQueryException ParseException Relationship Resource SecurityContext SecurityException Serializer Typed TypeNotFoundException ValidatedConcept ValidatedResource ValidationException Methods &lt;inner&gt; nodeHasNewBufferVersion() Check whether we're running in a version of node which has the updated Buffer implementationUsed above to fall back to the old version if needed. Source: composer-common/index.js, line 29 Returns: whether the new version is supported Type boolean × Search results Close "},"module-composer-common.BaseException.html":{"id":"module-composer-common.BaseException.html","title":"Class: BaseException","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: BaseException composer-common. BaseException A base class for all Composer exceptions new BaseException(message) Create the BaseException. Parameters: Name Type Description message string The exception message. Source: composer-common/lib/baseexception.js, line 24 Extends Error × Search results Close "},"module-composer-common.BaseFileException.html":{"id":"module-composer-common.BaseFileException.html","title":"Class: BaseFileException","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: BaseFileException composer-common. BaseFileException Exception throws when a composer file is semantically invalid new BaseFileException(message, fileLocation, fullMessage) Create an IllegalModelException Parameters: Name Type Description message string the message for the exception fileLocation string the optional file location associated with the exception fullMessage string the optional full message text Source: composer-common/lib/basefileexception.js, line 26 See: See BaseException Extends BaseException Methods getFileLocation() Returns the file location associated with the exception or null Source: composer-common/lib/basefileexception.js, line 44 Returns: the optional location associated with the exception Type string getShortMessage() Returns the error message without the location of the error Source: composer-common/lib/basefileexception.js, line 52 Returns: the error message Type string × Search results Close "},"module-composer-common.BusinessNetworkDefinition.html":{"id":"module-composer-common.BusinessNetworkDefinition.html","title":"Class: BusinessNetworkDefinition","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: BusinessNetworkDefinition composer-common. BusinessNetworkDefinition A BusinessNetworkDefinition defines a set of Participants that exchange Assets bysending Transactions. This class manages the metadata and domain-specific types forthe network as well as a set of executable scripts. new BusinessNetworkDefinition(identifier, description, packageJson, readme) Create the BusinessNetworkDefinition. Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkDefinition.fromArchive Parameters: Name Type Description identifier String the identifier of the business network. Theidentifier is formed from a business network name + '@' + version. Theversion is a semver valid version string. If package.json is passed this is ignored. description String the description of the business network. If package.json is passed then this is ignored. packageJson object the JS object for package.json (optional) readme String the readme in markdown for the business network (optional) Source: composer-common/lib/businessnetworkdefinition.js, line 65 Methods &lt;static&gt; fromArchive(Buffer) Create a BusinessNetworkDefinition from an archive. Parameters: Name Type Description Buffer Buffer the Buffer to a zip archive Source: composer-common/lib/businessnetworkdefinition.js, line 169 Returns: a Promise to the instantiated business network Type Promise &lt;static&gt; fromDirectory(path [, options]) Builds a BusinessNetworkDefintion from the contents of a directory.The directory must include a package.json in the root (used to specifythe name, version and description of the business network). This methodis designed to work with business networks that refer to external modelsusing npm dependencies as well as business networks that staticallypackage their model files. If package.json contains a dependencies property then this method will search formodel (CTO) files under the node_modules directory for each dependency thatpasses the options.dependencyGlob pattern.If the network depends on an npm module its dependencies (transitive closure)will also be scanned for model (CTO) files.The directory may optionally contain a README.md file which is accessible from theBusinessNetworkMetadata.getREADME method.In addition all model files will be added that are not under node_modulesand that pass the options.modelFileGlob pattern. By default you should putmodel files under a directory called 'models'.All script (js) files will be added that are not under node_modules andthat pass the options.scriptGlob pattern. By default you should put Javascriptfiles under the 'lib' directory. Parameters: Name Type Argument Description path String to a local directory options Object &lt;optional&gt; an optional set of options to configure the instance. Properties Name Type Argument Description dependencyGlob Object &lt;optional&gt; specify the glob pattern used to matchthe npm dependencies to process. Defaults to ** modelFileGlob boolean &lt;optional&gt; specify the glob pattern used to matchthe model files to include. Defaults to \\/models/\\/*.cto scriptGlob boolean &lt;optional&gt; specify the glob pattern used to matchthe script files to include. Defaults to \\/lib/\\/*.js Source: composer-common/lib/businessnetworkdefinition.js, line 594 Returns: a Promise to the instantiated business network Type Promise getDescription() Returns the description for this business network Source: composer-common/lib/businessnetworkdefinition.js, line 160 Returns: the description of this business network Type String getFactory() Provides access to the Factory for this business network. The Factoryis used to create the types defined in this business network. Source: composer-common/lib/businessnetworkdefinition.js, line 720 Returns: the Factory for this business network Type Factory getIdentifier() Returns the identifier for this business network Source: composer-common/lib/businessnetworkdefinition.js, line 126 Returns: the identifier of this business network Type String getIntrospector() Provides access to the Introspector for this business network. The Introspectoris used to reflect on the types defined within this business network. Source: composer-common/lib/businessnetworkdefinition.js, line 711 Returns: the Introspector for this business network Type Introspector getMetadata() Returns the metadata for this business network Source: composer-common/lib/businessnetworkdefinition.js, line 134 Returns: the metadata for this business network Type BusinessNetworkMetadata getName() Returns the name for this business network Source: composer-common/lib/businessnetworkdefinition.js, line 142 Returns: the name of this business network Type String getSerializer() Provides access to the Serializer for this business network. The Serializeris used to serialize instances of the types defined within this business network. Source: composer-common/lib/businessnetworkdefinition.js, line 729 Returns: the Serializer for this business network Type Serializer getVersion() Returns the version for this business network Source: composer-common/lib/businessnetworkdefinition.js, line 151 Returns: the version of this business network. Use semver moduleto parse. Type String toArchive( [options]) Store a BusinessNetworkDefinition as an archive. Parameters: Name Type Argument Description options Object &lt;optional&gt; JSZip options Source: composer-common/lib/businessnetworkdefinition.js, line 295 Returns: buffer - the zlib buffer Type Buffer × Search results Close "},"module-composer-common.BusinessNetworkMetadata.html":{"id":"module-composer-common.BusinessNetworkMetadata.html","title":"Class: BusinessNetworkMetadata","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: BusinessNetworkMetadata composer-common. BusinessNetworkMetadata Defines the metadata for a BusinessNeworkDefinition. This includes: package.json README.md (optional) new BusinessNetworkMetadata(packageJson, readme) Create the BusinessNetworkMetadata. Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkDefinition Parameters: Name Type Description packageJson object the JS object for package.json (required) readme String the README.md for the business network (may be null) Source: composer-common/lib/businessnetworkmetadata.js, line 31 Methods getDescription() Returns the description for this business network. Source: composer-common/lib/businessnetworkmetadata.js, line 115 Returns: the description of the business network Type string getIdentifier() Returns the identifier for this business network, formed from name@version. Source: composer-common/lib/businessnetworkmetadata.js, line 131 Returns: the identifier of the business network Type string getName() Returns the name for this business network. Source: composer-common/lib/businessnetworkmetadata.js, line 107 Returns: the name of the business network Type string getPackageJson() Returns the package.json for this business network. Source: composer-common/lib/businessnetworkmetadata.js, line 99 Returns: the Javascript object for package.json Type object getREADME() Returns the README.md for this business network. This may be null if the business network does not have a README.md Source: composer-common/lib/businessnetworkmetadata.js, line 91 Returns: the README.md file for the business network or null Type String getVersion() Returns the version for this business network. Source: composer-common/lib/businessnetworkmetadata.js, line 123 Returns: the description of the business network Type string × Search results Close "},"module-composer-common.Concept.html":{"id":"module-composer-common.Concept.html","title":"Class: Concept","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Concept composer-common. Concept Resource is an instance that has a type. The type of the resourcespecifies a set of properites (which themselves have types).Type information in Composer is used to validate the structure ofResource instances and for serialization.Resources are used in Composer to represent Assets, Participants, Transactions andother domain classes that can be serialized for long-term persistent storage. new Concept(modelManager, ns, type) This constructor should not be called directly. Note: Only to be called by framework code. Applications shouldretrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. Source: composer-common/lib/model/concept.js, line 38 See: See Resource Extends Identifiable Methods isConcept() Determine if this typed is a concept. Source: composer-common/lib/model/concept.js, line 61 Returns: True if this typed is a concept,false if not. Type boolean × Search results Close "},"module-composer-common.Factory.html":{"id":"module-composer-common.Factory.html","title":"Class: Factory","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Factory composer-common. Factory Use the Factory to create instances of Resource: transactions, participantsand assets. new Factory(modelManager) Create the factory. Note: Only to be called by framework code. Applications shouldretrieve instances from Hyperledger-Composer Parameters: Name Type Description modelManager ModelManager The ModelManager to use for this registry Source: composer-common/lib/factory.js, line 45 Methods newConcept(ns, type [, options]) Create a new Concept with a given namespace and type name Parameters: Name Type Argument Description ns string the namespace of the Concept type string the type of the Concept options Object &lt;optional&gt; an optional set of options Properties Name Type Argument Description disableValidation boolean &lt;optional&gt; pass true if you want the factory toreturn a Concept instead of a ValidatedConcept. Defaults to false. generate string &lt;optional&gt; Pass one of: samplereturn a resource instance with generated sample data. emptyreturn a resource instance with empty property values. includeOptionalFields boolean &lt;optional&gt; if options.generateis specified, whether optional fields should be generated. Source: composer-common/lib/factory.js, line 140 Throws: if the type is not registered with the ModelManager Type TypeNotFoundException Returns: the new instance Type Resource newEvent(ns, type [, id] [, options]) Create a new event object. The identifier of the event isset to a UUID. Parameters: Name Type Argument Description ns string the namespace of the event. type string the type of the event. id string &lt;optional&gt; an optional identifier for the event; if you do not specifyone then an identifier will be automatically generated. options Object &lt;optional&gt; an optional set of options Properties Name Type Argument Description generate string &lt;optional&gt; Pass one of: samplereturn a resource instance with generated sample data. emptyreturn a resource instance with empty property values. includeOptionalFields boolean &lt;optional&gt; if options.generateis specified, whether optional fields should be generated. Source: composer-common/lib/factory.js, line 242 Returns: A resource for the new event. Type Resource newRelationship(ns, type, id) Create a new Relationship with a given namespace, type and identifier.A relationship is a typed pointer to an instance. I.e the relationshipwith namespace = 'org.acme', type = 'Vehicle' and id = 'ABC' creates`a pointer that points at an instance of org.acme.Vehicle with the idABC. Parameters: Name Type Description ns string the namespace of the Resource type string the type of the Resource id string the identifier Source: composer-common/lib/factory.js, line 184 Throws: if the type is not registered with the ModelManager Type TypeNotFoundException Returns: the new relationship instance Type Relationship newResource(ns, type, id [, options]) Create a new Resource with a given namespace, type name and id Parameters: Name Type Argument Description ns string the namespace of the Resource type string the type of the Resource id string the identifier options Object &lt;optional&gt; an optional set of options Properties Name Type Argument Description disableValidation boolean &lt;optional&gt; pass true if you want the factory toreturn a Resource instead of a ValidatedResource. Defaults to false. generate string &lt;optional&gt; Pass one of: samplereturn a resource instance with generated sample data. emptyreturn a resource instance with empty property values. includeOptionalFields boolean &lt;optional&gt; if options.generateis specified, whether optional fields should be generated. Source: composer-common/lib/factory.js, line 75 Throws: if the type is not registered with the ModelManager Type TypeNotFoundException Returns: the new instance Type Resource newTransaction(ns, type [, id] [, options]) Create a new transaction object. The identifier of the transaction isset to a UUID. Parameters: Name Type Argument Description ns string the namespace of the transaction. type string the type of the transaction. id string &lt;optional&gt; an optional identifier for the transaction; if you do not specifyone then an identifier will be automatically generated. options Object &lt;optional&gt; an optional set of options Properties Name Type Argument Description generate string &lt;optional&gt; Pass one of: samplereturn a resource instance with generated sample data. emptyreturn a resource instance with empty property values. includeOptionalFields boolean &lt;optional&gt; if options.generateis specified, whether optional fields should be generated. Source: composer-common/lib/factory.js, line 207 Returns: A resource for the new transaction. Type Resource × Search results Close "},"module-composer-common.Identifiable.html":{"id":"module-composer-common.Identifiable.html","title":"Class: Identifiable","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Identifiable composer-common. Identifiable Identifiable is an entity with a namespace, type and an identifier. This class is abstract. &lt;abstract&gt; new Identifiable(modelManager, ns, type, id) Create an instance. Note: Only to be called by framework code. Applications shouldretrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. id string The identifier of this instance. Source: composer-common/lib/model/identifiable.js, line 28 Methods getFullyQualifiedIdentifier() Get the fully qualified identifier of this instance.(namespace '.' type '#' identifier). Source: composer-common/lib/model/identifiable.js, line 72 Returns: the fully qualified identifier of this instance Type string getIdentifier() Get the identifier of this instance Source: composer-common/lib/model/identifiable.js, line 51 Returns: The identifier for this object Type string isRelationship() Determine if this identifiable is a relationship. Source: composer-common/lib/model/identifiable.js, line 89 Returns: True if this identifiable is a relationship,false if not. Type boolean isResource() Determine if this identifiable is a resource. Source: composer-common/lib/model/identifiable.js, line 98 Returns: True if this identifiable is a resource,false if not. Type boolean setIdentifier(id) Set the identifier of this instance Parameters: Name Type Description id string the new identifier for this object Source: composer-common/lib/model/identifiable.js, line 59 toString() Returns the string representation of this class Source: composer-common/lib/model/identifiable.js, line 80 Returns: the string representation of the class Type String toURI() Returns a URI representation of a reference to this identifiable Source: composer-common/lib/model/identifiable.js, line 106 Returns: the URI for the identifiable Type String × Search results Close "},"module-composer-common.IllegalModelException.html":{"id":"module-composer-common.IllegalModelException.html","title":"Class: IllegalModelException","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: IllegalModelException composer-common. IllegalModelException Exception throws when a composer file is semantically invalid new IllegalModelException(message [, modelFile] [, fileLocation]) Create an IllegalModelException. Parameters: Name Type Argument Description message String the message for the exception modelFile ModelFile &lt;optional&gt; the optional modelfile associated with the exception fileLocation Object &lt;optional&gt; location details of the error within the model file. Properties Name Type Description start.line String start line of the error location. start.column String start column of the error location. end.line String end line of the error location. end.column String end column of the error location. Source: composer-common/lib/introspect/illegalmodelexception.js, line 26 See: See BaseFileException Extends BaseFileException Methods getModelFile() Returns the modelfile associated with the exception or null Source: composer-common/lib/introspect/illegalmodelexception.js, line 62 Returns: the optional filename associated with the model Type string × Search results Close "},"module-composer-common.Introspector.html":{"id":"module-composer-common.Introspector.html","title":"Class: Introspector","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Introspector composer-common. Introspector Provides access to the structure of transactions, assets and participants. new Introspector(modelManager) Create the Introspector. Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkDefinition Parameters: Name Type Description modelManager ModelManager the ModelManager that backs this Introspector Source: composer-common/lib/introspect/introspector.js, line 24 Methods getClassDeclaration(fullyQualifiedTypeName) Returns the class declaration with the given fully qualified name.Throws an error if the class declaration does not exist. Parameters: Name Type Description fullyQualifiedTypeName String the fully qualified name of the type Source: composer-common/lib/introspect/introspector.js, line 69 Throws: if the class declaration does not exist Type Error Returns: the class declaration Type ClassDeclaration getClassDeclarations() Returns all the class declarations for the business network. Source: composer-common/lib/introspect/introspector.js, line 52 Returns: the array of class declarations Type Array.&lt;ClassDeclaration&gt; × Search results Close "},"module-composer-common.InvalidQueryException.html":{"id":"module-composer-common.InvalidQueryException.html","title":"Class: InvalidQueryException","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: InvalidQueryException composer-common. InvalidQueryException Exception thrown for invalid queries new InvalidQueryException(message [, queryFile] [, fileLocation]) Create an InvalidQueryException. Parameters: Name Type Argument Description message String the message for the exception queryFile QueryFile &lt;optional&gt; the optional queryFile associated with the exception fileLocation Object &lt;optional&gt; location details of the error within the model file. Properties Name Type Description start.line String start line of the error location. start.column String start column of the error location. end.line String end line of the error location. end.column String end column of the error location. Source: composer-common/lib/query/invalidqueryexception.js, line 26 See: See BaseFileException Extends BaseFileException Methods getQueryFile() Returns the query file associated with the exception or null Source: composer-common/lib/query/invalidqueryexception.js, line 62 Returns: the optional query file associated with the exception Type QueryFile × Search results Close "},"module-composer-common.ParseException.html":{"id":"module-composer-common.ParseException.html","title":"Class: ParseException","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: ParseException composer-common. ParseException Exception throws when a Composer file is syntactically invalid new ParseException(message, fileLocation) Create an ParseException Parameters: Name Type Description message string the message for the exception fileLocation string the optional file location associated with the exception Source: composer-common/lib/introspect/parseexception.js, line 26 See: See BaseFileException Extends BaseFileException × Search results Close "},"module-composer-common.Relationship.html":{"id":"module-composer-common.Relationship.html","title":"Class: Relationship","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Relationship composer-common. Relationship A Relationship is a typed pointer to an instance. I.e the relationshipwith namespace = 'org.acme', type = 'Vehicle' and id = 'ABC' createsa pointer that points at an instance of org.acme.Vehicle with the idABC. new Relationship(modelManager, ns, type, id) Create an asset. Use the Factory to create instances. Note: Only to be called by framework code. Applications shouldretrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. id string The identifier of this instance. Source: composer-common/lib/model/relationship.js, line 31 See: See Identifiable Extends Identifiable Methods &lt;static&gt; fromURI(modelManager, uriAsString [, defaultNamespace] [, defaultType]) Contructs a Relationship instance from a URI representation (created using toURI). Parameters: Name Type Argument Description modelManager ModelManager the model manager to bind the relationship to uriAsString String the URI as a string, generated using Identifiable.toURI() defaultNamespace String &lt;optional&gt; default namespace to use for backwards compatability (optional) defaultType String &lt;optional&gt; default type to use for backwards compatability (optional) Source: composer-common/lib/model/relationship.js, line 76 Returns: the relationship Type Relationship isRelationship() Determine if this identifiable is a relationship. Source: composer-common/lib/model/relationship.js, line 64 Returns: True if this identifiable is a relationship,false if not. Type boolean toString() Returns the string representation of this class Source: composer-common/lib/model/relationship.js, line 55 Returns: the string representation of the class Type String × Search results Close "},"module-composer-common.Resource.html":{"id":"module-composer-common.Resource.html","title":"Class: Resource","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Resource composer-common. Resource Resource is an instance that has a type. The type of the resourcespecifies a set of properites (which themselves have types).Type information in Composer is used to validate the structure ofResource instances and for serialization.Resources are used in Composer to represent Assets, Participants, Transactions andother domain classes that can be serialized for long-term persistent storage. new Resource(modelManager, ns, type, id) This constructor should not be called directly. Note: Only to be called by framework code. Applications shouldretrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. id string The identifier of this instance. Source: composer-common/lib/model/resource.js, line 37 See: See Resource Extends Identifiable Methods isResource() Determine if this identifiable is a resource. Source: composer-common/lib/model/resource.js, line 68 Returns: True if this identifiable is a resource,false if not. Type boolean toString() Returns the string representation of this class Source: composer-common/lib/model/resource.js, line 59 Returns: the string representation of the class Type String × Search results Close "},"module-composer-common.SecurityContext.html":{"id":"module-composer-common.SecurityContext.html","title":"Class: SecurityContext","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: SecurityContext composer-common. SecurityContext SecurityContext is used to authenticate and manageuser credentials to the underlying blockchain fabric. &lt;abstract&gt; new SecurityContext(connection, user) Create the SecurityContext.Note: Only to be called by framework code. Applications shouldretrieve instances by calling login Parameters: Name Type Description connection Connection The owning connection. user string The user identifier. Source: composer-common/lib/securitycontext.js, line 25 Methods getConnection() Get the owning connection. Source: composer-common/lib/securitycontext.js, line 43 Returns: The owning connection. Type Connection &lt;abstract&gt; getUser() Get the current username. Source: composer-common/lib/securitycontext.js, line 52 Returns: The username Type string × Search results Close "},"module-composer-common.SecurityException.html":{"id":"module-composer-common.SecurityException.html","title":"Class: SecurityException","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: SecurityException composer-common. SecurityException Class representing a security exception new SecurityException(message) Create the SecurityException. Parameters: Name Type Description message string The exception message. Source: composer-common/lib/securityexception.js, line 27 See: See BaseException Extends BaseException × Search results Close "},"module-composer-common.Serializer.html":{"id":"module-composer-common.Serializer.html","title":"Class: Serializer","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Serializer composer-common. Serializer Serialize Resources instances to/from various formats for long-term storage(e.g. on the blockchain). new Serializer(factory, modelManager) Create a Serializer.Note: Only to be called by framework code. Applications shouldretrieve instances from Composer Parameters: Name Type Description factory Factory The Factory to use to create instances modelManager ModelManager The ModelManager to use for validation etc. Source: composer-common/lib/serializer.js, line 34 Methods fromJSON(jsonObject, options) Create a Resource from a JavaScript Object representation.The JavaScript Object should have been created by calling thetoJSON API. The Resource is populated based on the JavaScript object. Parameters: Name Type Description jsonObject Object The JavaScript Object for a Resource options Object the optional serialization options Properties Name Type Description acceptResourcesForRelationships boolean handle JSON objectsin the place of strings for relationships, defaults to false. validate boolean validate the structure of the Resourcewith its model prior to serialization (default to true) Source: composer-common/lib/serializer.js, line 135 Returns: The new populated resource Type Resource toJSON(resource, options) Convert a Resource to a JavaScript object suitable for long-termperistent storage. Parameters: Name Type Description resource Resource The instance to convert to JSON options Object the optional serialization options. Properties Name Type Description validate boolean validate the structure of the Resourcewith its model prior to serialization (default to true) convertResourcesToRelationships boolean Convert resources thatare specified for relationship fields into relationships, false by default. permitResourcesForRelationships boolean Permit resources in theplace of relationships (serializing them as resources), false by default. deduplicateResources boolean Generate $id for resources andif a resources appears multiple times in the object graph only the first instance isserialized in full, subsequent instances are replaced with a reference to the $id Source: composer-common/lib/serializer.js, line 75 Throws: throws an exception if resource is not an instance ofResource or fails validation. Type Error Returns: The Javascript Object that represents the resource Type Object × Search results Close "},"module-composer-common.Typed.html":{"id":"module-composer-common.Typed.html","title":"Class: Typed","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Typed composer-common. Typed Object is an instance with a namespace and a type. This class is abstract. &lt;abstract&gt; new Typed(modelManager, ns, type) Create an instance. Note: Only to be called by framework code. Applications shouldretrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. Source: composer-common/lib/model/typed.js, line 28 Methods addArrayValue(propName, value) Adds a value to an array property on this Resource Parameters: Name Type Description propName string the name of the field value string the value of the property Source: composer-common/lib/model/typed.js, line 130 getFullyQualifiedType() Get the fully-qualified type name of the instance (including namespace). Source: composer-common/lib/model/typed.js, line 79 Returns: The fully-qualified type name of this object Type string getNamespace() Get the namespace of the instance. Source: composer-common/lib/model/typed.js, line 87 Returns: The namespace of this object Type string getType() Get the type of the instance (a short name, not including namespace). Source: composer-common/lib/model/typed.js, line 71 Returns: The type of this object Type string instanceOf(fqt) Check to see if this instance is an instance of the specified fully qualifiedtype name. Parameters: Name Type Description fqt String The fully qualified type name. Source: composer-common/lib/model/typed.js, line 180 Returns: True if this instance is an instance of the specified fullyqualified type name, false otherwise. Type boolean setPropertyValue(propName, value) Sets a property on this Resource Parameters: Name Type Description propName string the name of the field value string the value of the property Source: composer-common/lib/model/typed.js, line 121 × Search results Close "},"module-composer-common.TypeNotFoundException.html":{"id":"module-composer-common.TypeNotFoundException.html","title":"Class: TypeNotFoundException","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: TypeNotFoundException composer-common. TypeNotFoundException Error thrown when a Composer type does not exist. new TypeNotFoundException(typeName [, message]) Constructor. If the optional 'message' argument is not supplied, it will be set to a default value thatincludes the type name. Parameters: Name Type Argument Description typeName String fully qualified type name. message String &lt;optional&gt; error message. Source: composer-common/lib/typenotfoundexception.js, line 27 See: See BaseException Extends BaseException Methods getTypeName() Get the name of the type that was not found. Source: composer-common/lib/typenotfoundexception.js, line 50 Returns: fully qualified type name. Type string × Search results Close "},"module-composer-common.ValidatedConcept.html":{"id":"module-composer-common.ValidatedConcept.html","title":"Class: ValidatedConcept","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: ValidatedConcept composer-common. ValidatedConcept Resource is an instance that has a type. The type of the resourcespecifies a set of properites (which themselves have types).Type information in Composer is used to validate the structure ofResource instances and for serialization.Resources are used in Composer to represent Assets, Participants, Transactions andother domain classes that can be serialized for long-term persistent storage. new ValidatedConcept(modelManager, ns, type, resourceValidator) This constructor should not be called directly. Note: Only to be called by framework code. Applications shouldretrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. resourceValidator ResourceValidator The validator to use for this instance Source: composer-common/lib/model/validatedconcept.js, line 38 See: See Resource Extends Identifiable Methods addArrayValue(propName, value) Adds an array property value, validating that it does not violate the model Parameters: Name Type Description propName string the name of the field value string the value of the property Source: composer-common/lib/model/validatedconcept.js, line 89 Throws: if the value is not compatible with the model definition for the field Type Error setPropertyValue(propName, value) Sets a property, validating that it does not violate the model Parameters: Name Type Description propName string the name of the field value string the value of the property Source: composer-common/lib/model/validatedconcept.js, line 63 Throws: if the value is not compatible with the model definition for the field Type Error validate() Validates the instance against its model. Source: composer-common/lib/model/validatedconcept.js, line 121 Throws: if the instance if invalid with respect to the model Type Error × Search results Close "},"module-composer-common.ValidatedResource.html":{"id":"module-composer-common.ValidatedResource.html","title":"Class: ValidatedResource","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: ValidatedResource composer-common. ValidatedResource ValidatedResource is a Resource that can validate that propertychanges (or the whole instance) do not violate the structure ofthe type information associated with the instance. new ValidatedResource(modelManager, ns, type, id, resourceValidator) This constructor should not be called directly.Use the Factory class to create instances. Note: Only to be called by framework code. Applications shouldretrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. id string The identifier of this instance. resourceValidator ResourceValidator The validator to use for this instance Source: composer-common/lib/model/validatedresource.js, line 29 See: See Resource Extends Resource Methods addArrayValue(propName, value) Adds an array property value, validating that it does not violate the model Parameters: Name Type Description propName string the name of the field value string the value of the property Source: composer-common/lib/model/validatedresource.js, line 83 Throws: if the value is not compatible with the model definition for the field Type Error setPropertyValue(propName, value) Sets a property, validating that it does not violate the model Parameters: Name Type Description propName string the name of the field value string the value of the property Source: composer-common/lib/model/validatedresource.js, line 56 Throws: if the value is not compatible with the model definition for the field Type Error validate() Validates the instance against its model. Source: composer-common/lib/model/validatedresource.js, line 117 Throws: if the instance if invalid with respect to the model Type Error × Search results Close "},"module-composer-common.ValidationException.html":{"id":"module-composer-common.ValidationException.html","title":"Class: ValidationException","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: ValidationException composer-common. ValidationException Exception thrown when a resource fails to model against the model new ValidationException(message) Create an ParseException Parameters: Name Type Description message string the message for the exception Source: composer-common/lib/serializer/validationexception.js, line 26 See: See BaseException Extends BaseException × Search results Close "},"module-composer-runtime.html":{"id":"module-composer-runtime.html","title":"Module: composer-runtime","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Module: composer-runtime The runtime module provides the API that is made available to transactionprocessing functions. Source: composer-runtime/index.js, line 17 Classes AssetRegistry Factory ParticipantRegistry Query Serializer Methods buildQuery(query) Build a query ready for later execution. The specified query string must be writtenin the Composer query language. This functionality is Blockchain platform dependent. For example, when a Composerbusiness network is deployed to Hyperledger Fabric v1.0, Hyperledger Fabric must beconfigured with the CouchDB database for the world state. Parameters: Name Type Description query string The query string, written using the Composer query language. Source: composer-runtime/lib/api.js, line 256 Returns: The built query, which can be passed in a call to query. Type Query Example // Build a query. var query = buildQuery('SELECT org.acme.sample.SampleAsset WHERE (value == _$inputValue)'); // Execute the query. return query(query, { inputValue: 'blue' }) .then(function (assets) { assets.forEach(function (asset) { // Process each asset. }); }) .catch(function (error) { // Add optional error handling here. }); emit(event) Emit an event defined in the transaction Parameters: Name Type Description event Resource The event to be emitted Source: composer-runtime/lib/api.js, line 236 getAssetRegistry(id) Get an existing asset registry using the unique identifier of the assetregistry. An asset registry can be used to retrieve, update, or deleteexisting assets, or create new assets. Parameters: Name Type Description id string The ID of the asset registry. Source: composer-runtime/lib/api.js, line 115 Returns: A promise. The promise is resolved with an {@linkmodule:composer-runtime.AssetRegistry AssetRegistry} instancerepresenting the asset registry if it exists. If the asset registrydoes not exist, or the current user does not have access to the assetregistry, then the promise will be rejected with an error that describesthe problem. Type Promise Example // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Call methods on the vehicle asset registry. }) .catch(function (error) { // Add optional error handling here. }); getCurrentParticipant() Get the current participant. The current participant is determined bythe identity that was used to submit the current transaction. Source: composer-runtime/lib/api.js, line 183 Returns: The current participant,or null if the transaction was submitted using an identity that doesnot map to a participant. Type module:composer-common.Resource Example // Get the current participant. var currentParticipant = getCurrentParticipant(); // Check to see if the current participant is a driver. if (currentParticipant.getFullyQualifiedType() !== 'org.acme.Driver') { // Throw an error as the current participant is not a driver. throw new Error('Current participant is not a driver'); } // Check to see if the current participant is the first driver. if (currentParticipant.getFullyQualifiedIdentifier() !== 'org.acme.Driver#DRIVER_1') { // Throw an error as the current participant is not a driver. throw new Error('Current participant is not the first driver'); } getFactory() Get the factory. The factory can be used to create new instances ofassets, participants, and transactions for storing in registries. Thefactory can also be used for creating relationships to assets, particpants,and transactions. Source: composer-runtime/lib/api.js, line 76 Returns: The factory. Type module:composer-runtime.Factory Example // Get the factory. var factory = getFactory(); getParticipantRegistry(id) Get an existing participant registry using the unique identifier of the participantregistry. An participant registry can be used to retrieve, update, or deleteexisting participants, or create new participants. Parameters: Name Type Description id string The ID of the participant registry. Source: composer-runtime/lib/api.js, line 149 Returns: A promise. The promise is resolved with an {@linkmodule:composer-runtime.ParticipantRegistry ParticipantRegistry} instancerepresenting the participant registry if it exists. If the participant registrydoes not exist, or the current user does not have access to the participantregistry, then the promise will be rejected with an error that describesthe problem. Type Promise Example // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (driverParticipantRegistry) { // Call methods on the driver participant registry. }) .catch(function (error) { // Add optional error handling here. }); getSerializer() Get the serializer. The serializer can be used to create new instances ofassets, participants, and transactions from a JavaScript object, or to createa JavaScript object suitable for long-lived persistence. Source: composer-runtime/lib/api.js, line 96 Returns: The serializer. Type module:composer-common.Serializer Example // Get the serializer. var ser = getSerializer(); post(url, typed, options) Post a typed instance to a HTTP URL Parameters: Name Type Description url string The URL to post the data to typed Typed The typed instance to be posted. The instance will be serialized to JSON. options object The options that are passed to Serializer.toJSON Source: composer-runtime/lib/api.js, line 213 Returns: A promise. The promise is resolved with a HttpResponsethat represents the result of the HTTP POST. Type Promise query(query [, parameters]) Execute a query defined in a Composer query file, or execute a query built with buildQuery. This functionality is Blockchain platform dependent. For example, when a Composerbusiness network is deployed to Hyperledger Fabric v1.0, Hyperledger Fabric must beconfigured with the CouchDB database for the world state. Parameters: Name Type Argument Description query string | Query The name of the query, or a built query. parameters Object &lt;optional&gt; The parameters for the query. Source: composer-runtime/lib/api.js, line 290 Returns: A promise that will be resolved with an array ofResource representing theresources returned by the query. Type Promise Example // Execute the query. return query('Q1', { inputValue: 'blue' }) .then(function (assets) { assets.forEach(function (asset) { // Process each asset. }); }) .catch(function (error) { // Add optional error handling here. }); × Search results Close "},"module-composer-runtime.AssetRegistry.html":{"id":"module-composer-runtime.AssetRegistry.html","title":"Class: AssetRegistry","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: AssetRegistry composer-runtime. AssetRegistry An asset registry manages a set of assets. new AssetRegistry() Do not attempt to create an instance of this class.You must use the getAssetRegistrymethod instead. Source: composer-runtime/lib/api/assetregistry.js, line 22 Methods add(asset) Add the specified asset to this asset registry. Parameters: Name Type Description asset Resource The assets to add to this asset registry. Source: composer-runtime/lib/api/assetregistry.js, line 163 Returns: A promise. The promise is resolved when the asset hasbeen added to this asset registry. If the asset cannot be added to thisasset registry, or if the asset already exists in the asset registry,then the promise will be rejected with an error that describes the problem. Type Promise Example // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get the factory for creating new asset instances. var factory = getFactory(); // Create the vehicle. var vehicle = factory.newResource('org.acme', 'Vehicle', 'VEHICLE_1'); vehicle.colour = 'BLUE'; // Add the vehicle to the vehicle asset registry. return vehicleAssetRegistry.add(vehicle); }) .catch(function (error) { // Add optional error handling here. }); addAll(assets) Add all of the specified assets to this asset registry. Parameters: Name Type Description assets Array.&lt;Resource&gt; The assets to add to this asset registry. Source: composer-runtime/lib/api/assetregistry.js, line 130 Returns: A promise. The promise is resolved when all of theassets have been added to this asset registry. If the assets cannot beadded to this asset registry, or if the assets already exist in theasset registry, then the promise will be rejected with an errorthat describes the problem. Type Promise Example // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get the factory for creating new asset instances. var factory = getFactory(); // Create the first vehicle. var vehicle1 = factory.newResource('org.acme', 'Vehicle', 'VEHICLE_1'); vehicle1.colour = 'BLUE'; // Create the second vehicle. var vehicle2 = factory.newResource('org.acme', 'Vehicle', 'VEHICLE_2'); vehicle2.colour = 'GREEN'; // Add the vehicles to the vehicle asset registry. return vehicleAssetRegistry.addAll([vehicle1, vehicle2]); }) .catch(function (error) { // Add optional error handling here. }); exists(id) Determines whether a specific asset exists in this asset registry. Parameters: Name Type Description id string The ID of the asset. Source: composer-runtime/lib/api/assetregistry.js, line 103 Returns: A promise. The promise is resolved with a boolean whichis true if the specified asset exists in this asset registry, and falseif the specified participant does not exist. Type Promise Example // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Determine if the specific vehicle exists in the vehicle asset registry. return assetRegistry.exists('VEHICLE_1'); }) .then(function (exists) { // Process the the boolean result. console.log('Vehicle exists', exists); }) .catch(function (error) { // Add optional error handling here. }); get(id) Get the specified asset in this asset registry using the unique identifierof the asset. Parameters: Name Type Description id string The ID of the asset. Source: composer-runtime/lib/api/assetregistry.js, line 73 Returns: A promise. The promise is resolved with a Resourceinstance representing the specified asset in this asset registry. If thespecified asset does not exist, or the current user does not have accessto the specified asset, then the promise will be rejected with an errorthat describes the problem. Type Promise Example // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get the specific vehicle from the vehicle asset registry. return assetRegistry.get('VEHICLE_1'); }) .then(function (vehicle) { // Process the the vehicle object. console.log(vehicle.vehicleId); }) .catch(function (error) { // Add optional error handling here. }); getAll() Get a list of all of the existing assets in this asset registry. Source: composer-runtime/lib/api/assetregistry.js, line 43 Returns: A promise. The promise is resolved with an array ofResource instances representing all of the assets stored in thisasset registry. If the asset registry does not exist, or the currentuser does not have access to the asset registry, then the promise willbe rejected with an error that describes the problem. Type Promise Example // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get all of the vehicles in the vehicle asset registry. return assetRegistry.getAll(); }) .then(function (vehicles) { // Process the array of vehicle objects. vehicles.forEach(function (vehicle) { console.log(vehicle.vehicleId); }); }) .catch(function (error) { // Add optional error handling here. }); remove(asset) Remove the specified asset from this asset registry. Parameters: Name Type Description asset string | Resource The asset, or ID of the asset, to removefrom this asset registry. Source: composer-runtime/lib/api/assetregistry.js, line 289 Returns: A promise. The promise is resolved when the assethas been removed from this asset registry. If the asset cannot beremoved from this asset registry, or if the asset does not exist in theasset registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing vehicle that has come from elsewhere. var vehicle; // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get the factory for creating new asset instances. var factory = getFactory(); // Remove the vehicle from the vehicle asset registry. return vehicleAssetRegistry.remove(vehicle); }) .catch(function (error) { // Add optional error handling here. }); removeAll(assets) Remove all of the specified assets from this asset registry. Parameters: Name Type Description assets Array.&lt;string&gt; | Array.&lt;Resource&gt; The assets, or the IDs of the assets,to remove from this asset registry. Source: composer-runtime/lib/api/assetregistry.js, line 257 Returns: A promise. The promise is resolved when all of theassets have been removed from this asset registry. If the assets cannot beremoved from this asset registry, or if the assets do not exist in theasset registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing vehicles that have come from elsewhere. var vehicle1; // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get the factory for creating new asset instances. var factory = getFactory(); // Remove the vehicles from the vehicle asset registry. Note that // one vehicle is specified as a vehicle instance, and the other // vehicle is specified by the ID of the vehicle. return vehicleAssetRegistry.removeAll([vehicle1, 'VEHICLE_2']); }) .catch(function (error) { // Add optional error handling here. }); update(asset) Update the specified asset in this asset registry. Parameters: Name Type Description asset Resource The asset to update in this asset registry. Source: composer-runtime/lib/api/assetregistry.js, line 226 Returns: A promise. The promise is resolved when the assethave been updated in this asset registry. If the asset cannot beupdated in this asset registry, or if the asset does not exist in theasset registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing vehicle that has come from elsewhere. var vehicle; // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get the factory for creating new asset instances. var factory = getFactory(); // Modify the properties of the vehicle. vehicle.colour = 'PURPLE'; // Update the vehicle in the vehicle asset registry. return vehicleAssetRegistry.update(vehicle); }) .catch(function (error) { // Add optional error handling here. }); updateAll(assets) Update all of the specified assets in this asset registry. Parameters: Name Type Description assets Array.&lt;Resource&gt; The assets to update in this asset registry. Source: composer-runtime/lib/api/assetregistry.js, line 192 Returns: A promise. The promise is resolved when all of theassets have been updated in this asset registry. If the assets cannot beupdated in this asset registry, or if the assets do not exist in theasset registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing vehicles that have come from elsewhere. var vehicle1; var vehicle2; // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get the factory for creating new asset instances. var factory = getFactory(); // Modify the properties of the first vehicle. vehicle1.colour = 'PURPLE'; // Modify the properties of the second vehicle. vehicle2.colour = 'ORANGE'; // Update the vehicles in the vehicle asset registry. return vehicleAssetRegistry.updateAll([vehicle1, vehicle2]); }) .catch(function (error) { // Add optional error handling here. }); × Search results Close "},"module-composer-runtime.Factory.html":{"id":"module-composer-runtime.Factory.html","title":"Class: Factory","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Factory composer-runtime. Factory A factory creates new instances of assets, participants, transactions,and relationships. new Factory() Do not attempt to create an instance of this class.You must use the getFactorymethod instead. Source: composer-runtime/lib/api/factory.js, line 22 Methods newConcept(ns, type) Create a new concept with a given namespace, type, and identifier.A concept is an advanced data structure Parameters: Name Type Description ns string The namespace of the concept. type string The type of the concept. Source: composer-runtime/lib/api/factory.js, line 99 Throws: If the specified type (specified by the namespace andtype) is not defined in the current version of the business network. Type Error Returns: The new instance of the concept. Type Concept Example // The existing driver of the vehicle. var person; // Get the factory. var factory = getFactory(); // Create a new relationship to the vehicle. var record = factory.newConcept('org.acme', 'Record'); // Add the record to the persons array of records. person.records.push(record); newEvent(ns, type) Create a new type with a given namespace and type Parameters: Name Type Description ns string The namespace of the event. type string The type of the event. Source: composer-runtime/lib/api/factory.js, line 123 Throws: If the specified type (specified by the namespace andtype) is not defined in the current version of the business network. Type Error Returns: The new instance of the event. Type Resource newRelationship(ns, type, id) Create a new relationship with a given namespace, type, and identifier.A relationship is a typed pointer to an instance. For example, a newrelationship with namespace 'org.acme', type 'Vehicle' and identifier'VEHICLE_1' creates` a pointer that points at an existing instance oforg.acme.Vehicle with the identifier 'VEHICLE_1'. Parameters: Name Type Description ns string The namespace of the resource referenced by the relationship. type string The type of the resource referenced by the relationship. id string The identifier of the resource referenced by the relationship. Source: composer-runtime/lib/api/factory.js, line 71 Throws: If the specified type (specified by the namespace andtype) is not defined in the current version of the business network. Type Error Returns: The new instance of the relationship. Type Relationship Example // The existing driver of the vehicle. var driver; // Get the factory. var factory = getFactory(); // Create a new relationship to the vehicle. var vehicle = factory.newRelationship('org.acme', 'Vehicle', 'VEHICLE_1'); // Set the relationship as the value of the vehicle property of the driver. driver.vehicle = vehicle; newResource(ns, type, id) Create a new resource (an instance of an asset, participant, or transaction). Theproperties of the new instance should be set as standard JavaScriptobject properties. The new instance can then be stored in a registryusing the appropriate registry APIs, for example {@linkmodule:composer-runtime.AssetRegistry AssetRegistry}. Parameters: Name Type Description ns string The namespace of the resource to create. type string The type of the resource to create. id string The identifier of the new resource. Source: composer-runtime/lib/api/factory.js, line 44 Throws: If the specified type (specified by the namespace andtype) is not defined in the current version of the business network. Type Error Returns: The new instance of the resource. Type Resource Example // Get the factory. var factory = getFactory(); // Create a new vehicle. var vehicle = factory.newResource('org.acme', 'Vehicle', 'VEHICLE_1'); // Set the properties of the new vehicle. vehicle.colour = 'BLUE'; vehicle.manufacturer = 'Toyota'; × Search results Close "},"module-composer-runtime.ParticipantRegistry.html":{"id":"module-composer-runtime.ParticipantRegistry.html","title":"Class: ParticipantRegistry","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: ParticipantRegistry composer-runtime. ParticipantRegistry An participant registry manages a set of participants. new ParticipantRegistry() Do not attempt to create an instance of this class.You must use the getParticipantRegistrymethod instead. Source: composer-runtime/lib/api/participantregistry.js, line 21 Methods add(participant) Add the specified participant to this participant registry. Parameters: Name Type Description participant Resource The participants to add to this participant registry. Source: composer-runtime/lib/api/participantregistry.js, line 162 Returns: A promise. The promise is resolved when the participant hasbeen added to this participant registry. If the participant cannot be added to thisparticipant registry, or if the participant already exists in the participant registry,then the promise will be rejected with an error that describes the problem. Type Promise Example // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (participantRegistry) { // Get the factory for creating new participant instances. var factory = getFactory(); // Create the driver. var driver = factory.newResource('org.acme', 'Driver', 'VEHICLE_1'); driver.location = 'Southampton'; // Add the driver to the driver participant registry. return participantRegistry.add(driver); }) .catch(function (error) { // Add optional error handling here. }); addAll(participants) Add all of the specified participants to this participant registry. Parameters: Name Type Description participants Array.&lt;Resource&gt; The participants to add to this participant registry. Source: composer-runtime/lib/api/participantregistry.js, line 129 Returns: A promise. The promise is resolved when all of theparticipants have been added to this participant registry. If the participants cannot beadded to this participant registry, or if the participants already exist in theparticipant registry, then the promise will be rejected with an errorthat describes the problem. Type Promise Example // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (participantRegistry) { // Get the factory for creating new participant instances. var factory = getFactory(); // Create the first driver. var driver1 = factory.newResource('org.acme', 'Driver', 'VEHICLE_1'); driver1.location = 'Southampton'; // Create the second driver. var driver2 = factory.newResource('org.acme', 'Driver', 'VEHICLE_2'); driver2.location = 'GREEN'; // Add the drivers to the driver participant registry. return participantRegistry.addAll([driver1, driver2]); }) .catch(function (error) { // Add optional error handling here. }); exists(id) Determines whether a specific participant exists in this participant registry. Parameters: Name Type Description id string The ID of the participant. Source: composer-runtime/lib/api/participantregistry.js, line 102 Returns: A promise. The promise is resolved with a boolean whichis true if the specified participant exists in this participant registry,and false if the specified participant does not exist. Type Promise Example // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (participantRegistry) { // Determine if the specific driver exists in the driver participant registry. return participantRegistry.exists('VEHICLE_1'); }) .then(function (exists) { // Process the the boolean result. console.log('Driver exists', exists); }) .catch(function (error) { // Add optional error handling here. }); get(id) Get the specified participant in this participant registry using the unique identifierof the participant. Parameters: Name Type Description id string The ID of the participant. Source: composer-runtime/lib/api/participantregistry.js, line 72 Returns: A promise. The promise is resolved with a Resourceinstance representing the specified participant in this participant registry. If thespecified participant does not exist, or the current user does not have accessto the specified participant, then the promise will be rejected with an errorthat describes the problem. Type Promise Example // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (participantRegistry) { // Get the specific driver from the driver participant registry. return participantRegistry.get('VEHICLE_1'); }) .then(function (driver) { // Process the the driver object. console.log(driver.driverId); }) .catch(function (error) { // Add optional error handling here. }); getAll() Get a list of all of the existing participants in this participant registry. Source: composer-runtime/lib/api/participantregistry.js, line 42 Returns: A promise. The promise is resolved with an array ofResource instances representing all of the participants stored in thisparticipant registry. If the participant registry does not exist, or the currentuser does not have access to the participant registry, then the promise willbe rejected with an error that describes the problem. Type Promise Example // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (participantRegistry) { // Get all of the drivers in the driver participant registry. return participantRegistry.getAll(); }) .then(function (drivers) { // Process the array of driver objects. drivers.forEach(function (driver) { console.log(driver.driverId); }); }) .catch(function (error) { // Add optional error handling here. }); remove(participant) Remove the specified participant from this participant registry. Parameters: Name Type Description participant string | Resource The participant, or ID of the participant, to removefrom this participant registry. Source: composer-runtime/lib/api/participantregistry.js, line 288 Returns: A promise. The promise is resolved when the participanthas been removed from this participant registry. If the participant cannot beremoved from this participant registry, or if the participant does not exist in theparticipant registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing driver that has come from elsewhere. var driver; // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (participantRegistry) { // Get the factory for creating new participant instances. var factory = getFactory(); // Remove the driver from the driver participant registry. return participantRegistry.remove(driver); }) .catch(function (error) { // Add optional error handling here. }); removeAll(participants) Remove all of the specified participants from this participant registry. Parameters: Name Type Description participants Array.&lt;string&gt; | Array.&lt;Resource&gt; The participants, or the IDs of the participants,to remove from this participant registry. Source: composer-runtime/lib/api/participantregistry.js, line 256 Returns: A promise. The promise is resolved when all of theparticipants have been removed from this participant registry. If the participants cannot beremoved from this participant registry, or if the participants do not exist in theparticipant registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing drivers that have come from elsewhere. var driver1; // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (participantRegistry) { // Get the factory for creating new participant instances. var factory = getFactory(); // Remove the drivers from the driver participant registry. Note that // one driver is specified as a driver instance, and the other // driver is specified by the ID of the driver. return participantRegistry.removeAll([driver1, 'VEHICLE_2']); }) .catch(function (error) { // Add optional error handling here. }); update(participant) Update the specified participant in this participant registry. Parameters: Name Type Description participant Resource The participant to update in this participant registry. Source: composer-runtime/lib/api/participantregistry.js, line 225 Returns: A promise. The promise is resolved when the participanthave been updated in this participant registry. If the participant cannot beupdated in this participant registry, or if the participant does not exist in theparticipant registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing driver that has come from elsewhere. var driver; // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (participantRegistry) { // Get the factory for creating new participant instances. var factory = getFactory(); // Modify the properties of the driver. driver.location = 'Hursley'; // Update the driver in the driver participant registry. return participantRegistry.update(driver); }) .catch(function (error) { // Add optional error handling here. }); updateAll(participants) Update all of the specified participants in this participant registry. Parameters: Name Type Description participants Array.&lt;Resource&gt; The participants to update in this participant registry. Source: composer-runtime/lib/api/participantregistry.js, line 191 Returns: A promise. The promise is resolved when all of theparticipants have been updated in this participant registry. If the participants cannot beupdated in this participant registry, or if the participants do not exist in theparticipant registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing drivers that have come from elsewhere. var driver1; var driver2; // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (participantRegistry) { // Get the factory for creating new participant instances. var factory = getFactory(); // Modify the properties of the first driver. driver1.location = 'Hursley'; // Modify the properties of the second driver. driver2.location = 'London'; // Update the drivers in the driver participant registry. return participantRegistry.updateAll([driver1, driver2]); }) .catch(function (error) { // Add optional error handling here. }); × Search results Close "},"module-composer-runtime.Query.html":{"id":"module-composer-runtime.Query.html","title":"Class: Query","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Query composer-runtime. Query A query represents a built query. new Query() Do not attempt to create an instance of this class.You must use the buildQuerymethod instead. Source: composer-runtime/lib/api/query.js, line 21 × Search results Close "},"module-composer-runtime.Serializer.html":{"id":"module-composer-runtime.Serializer.html","title":"Class: Serializer","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.Historiancomposer-client.IdentityRegistrycomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseFileExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.InvalidQueryExceptioncomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Serializer composer-runtime. Serializer A serializer serializes instances of assets, participants, transactions,and relationships to and from a JSON serialization format. new Serializer() Do not attempt to create an instance of this class.You must use the getSerializermethod instead. Source: composer-runtime/lib/api/serializer.js, line 21 Methods fromJSON(json [, options]) Create a Resource from a JavaScript object representation.The JavaScript object should have been created by calling thetoJSON API.The Resource is populated based on the JavaScript object. Parameters: Name Type Argument Description json Object The JavaScript object for the resource. options Object &lt;optional&gt; The optional serialization options. Properties Name Type Argument Description acceptResourcesForRelationships boolean &lt;optional&gt; Handle JSON objectsin the place of strings for relationships, false by default. Source: composer-runtime/lib/api/serializer.js, line 69 Throws: If the specified resource is not an instance ofResource or if it fails validation during serialization. Type Error Returns: The resource. Type Resource Example // Get the serializer. var serializer = getSerializer(); // Serialize a vehicle. var vehicle = serializer.fromJSON(json); toJSON(resource [, options]) Convert a Resource to a JavaScript object suitable for long-termperistent storage. Parameters: Name Type Argument Description resource Resource The resource instance to convert to JSON. options Object &lt;optional&gt; The optional serialization options. Properties Name Type Argument Description validate boolean &lt;optional&gt; Validate the structure of the resourcewith its model prior to serialization, true by default. convertResourcesToRelationships boolean &lt;optional&gt; Convert resources thatare specified for relationship fields into relationships, false by default. permitResourcesForRelationships boolean &lt;optional&gt; Permit resources in theplace of relationships (serializing them as resources), false by default. Source: composer-runtime/lib/api/serializer.js, line 43 Throws: If the specified resource is not an instance ofResource or if it fails validation during serialization. Type Error Returns: The JavaScript object that represents the resource Type Object Example // Get the serializer. var serializer = getSerializer(); // Serialize a vehicle. var json = serializer.toJSON(vehicle); × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
