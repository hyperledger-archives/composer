<!--
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<!doctype html>
<html lang="en">
<!--
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
  
  
  

<!--
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<head>
  <meta charset="utf-8">
  
    <title>Hyperledger Composer - Search | Hyperledger Composer</title>
  
  <meta name="viewport" content="width=device-width">
  <link rel="icon" type="image/x-icon" href="/composer/latest/favicon.ico">
  <meta name="google-site-verification" content="fBQRJ6h7MV7_TJ7grbgq4P-d-07NRfDWPe4pqEEoH5w">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

  

  
    <link href="/composer/latest/assets/css/normalize.css" rel="stylesheet">
    <link href="/composer/latest/assets/css/new-style.min.css" rel="stylesheet">
    <link href="/composer/latest/assets/css/grid-layout.min.css" rel="stylesheet">
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.6.0/clipboard.min.js"></script>
  
</head>


<body class="">

  
  <!-- % include navbar.html % -->
  

  <div class="SiteWrapper">
    
      <!--
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<div class="content">
    <article class="docs-container">
        <!-- If there's a sidebar, divide into 2 columns -->
        
        <div class="page-sidebar-grid" id="off-canvas">
          <!-- <a class="toggle close" href="#">close</a> -->
          <div class="docs-pagenav-grid">
            <!--
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<!-- Navigation -->
  <nav class="navbar-docs" role="navigation">
        <!-- Brand and toggle get grouped for better mobile display -->
            <a class="navbar-brand" href="/composer/latest/index.html"><b>Hyperledger</b> Composer</a>
        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <div class="top-nav-docs">
                <!-- <li>
                    <a href="services.html">Composer</a>
                </li> -->
                <!-- <li>
                    <a href="https://composer-playground.mybluemix.net/">Playground</a>
                </li> -->
                    <a href="../tutorials/tutorials.html">Tutorials</a>
                    <a href="../introduction/introduction.html">Docs</a>
                    <a href="../support/support-index.html">Community</a>
            </div>
        </div>
</nav>

          </div>

          <select id="version" name="version" onchange="location = this.options[this.selectedIndex].value;">
              <option>Select version</option>
              <option value="/composer/latest/introduction/introduction.html" title="The most stable version of Composer">Latest</option>
              <option value="/composer/unstable/introduction/introduction.html" title="The version that will replace Latest">Latest-unstable</option>
          </select>

            <div class="search-form">
              <form action="/composer/latest/search/search.html" method="get">
                <!-- <label for="search-box">Search</label> -->

                <input type="text" id="search-box"  class="search-box" name="query" placeholder="Search here...">
                <input type="submit" class="submit-input hide" value="">

                <div class="search-icon">
                  <img src="/composer/latest/assets/img/Search_Icon_1.svg" class="trigger" type="submit">
                </div>
              </form>
            </div>

          <div class="docs-current-page-grid">
          <p>Hyperledger Composer - Search</p>
          </div>

          <nav class="context-nav">
            
            
              <ul>
<li><p><a href="/composer/latest/introduction/introduction"><b>Introduction</b><img src="/composer/latest/assets/img/Caret_SW_2.svg" class="caret"></a></p>

<ul>
<li><a href="/composer/latest/introduction/key-concepts">Key Concepts</a></li>
<li><a href="/composer/latest/introduction/solution-architecture">Typical Solution Architecture</a></li>
</ul></li>
<li><p><a href="/composer/latest/installing/installing-index"><b>Installing</b><img src="/composer/latest/assets/img/Caret_SW_2.svg" class="caret"></a></p>

<ul>
<li><a href="/composer/latest/installing/installing-prereqs">Installing pre-requisites</a></li>
<li><a href="/composer/latest/installing/development-tools">Installing the development environment</a></li>
<li><a href="/composer/latest/installing/update-dev-env">Updating the development environment</a></li>
<li><a href="/composer/latest/installing/uninstall-dev-env">Uninstalling the development environment</a></li>
</ul></li>
<li><p><a href="/composer/latest/tutorials/tutorials"><b>Tutorials</b><img src="/composer/latest/assets/img/Caret_SW_2.svg" class="caret"></a></p>

<ul>
<li><a href="/composer/latest/tutorials/playground-tutorial">Playground Tutorial</a></li>
<li><a href="/composer/latest/tutorials/developer-tutorial">Developer Tutorial</a></li>
<li><a href="/composer/latest/tutorials/queries">Queries Tutorial</a></li>
<li><a href="/composer/latest/tutorials/deploy-to-fabric-single-org">Deploying to a single organization Hyperledger Fabric</a></li>
<li><a href="/composer/latest/tutorials/deploy-to-fabric-multi-org">Deploying to a multi-organization Hyperledger Fabric</a></li>
<li><a href="/composer/latest/tutorials/invoke-composer-network">Interacting with other business networks</a></li>
<li><a href="/composer/latest/tutorials/acl-trading">Access Control Tutorial - Commodity Trading</a></li>
<li><a href="/composer/latest/tutorials/google_oauth2_rest">Using Google OAUTH2.0 with a Composer REST server</a></li>
</ul></li>
<li><p><a href="/composer/latest/playground/playground-index"><b>Using Playground</b><img src="/composer/latest/assets/img/Caret_SW_2.svg" class="caret"></a></p>

<ul>
<li><a href="/composer/latest/playground/id-cards-playground">Business Network Cards</a></li>
</ul></li>
<li><p><a href="/composer/latest/business-network/business-network-index"><b>Developing Business Networks</b><img src="/composer/latest/assets/img/Caret_SW_2.svg" class="caret"></a></p>

<ul>
<li><a href="/composer/latest/business-network/businessnetworkdefinition">Business Network Definitions</a></li>
<li><a href="/composer/latest/business-network/bnd-create">Create a Business Network Definition</a></li>
<li><a href="/composer/latest/business-network/bnd-deploy">Deploying Business Networks</a></li>
<li><a href="/composer/latest/business-network/publishing-events">Emitting Events</a></li>
<li><a href="/composer/latest/business-network/testing">Testing Business Networks</a></li>
<li><a href="/composer/latest/business-network/bnd-publish">Publish Models or Business Network Definitions</a></li>
<li><a href="/composer/latest/business-network/upgrading-bna">Upgrading a deployed business network</a></li>
<li><a href="/composer/latest/business-network/query">Using Queries and Filters with Business Network Data</a></li>
<li><a href="/composer/latest/business-network/programmatic-access-control">Programmatic access control</a></li>
<li><a href="/composer/latest/business-network/historian">Hyperledger Composer Historian</a></li>
<li><a href="/composer/latest/business-network/cloud-wallets">Customising card stores</a></li>
</ul></li>
<li><p><a href="/composer/latest/applications/applications-index"><b>Developing Applications</b><img src="/composer/latest/assets/img/Caret_SW_2.svg" class="caret"></a></p>

<ul>
<li><a href="/composer/latest/applications/node">Writing a Node.js application</a></li>
<li><a href="/composer/latest/applications/web">Writing Web applications</a></li>
<li><a href="/composer/latest/applications/subscribing-to-events">Subscribing to events</a></li>
</ul></li>
<li><p><a href="/composer/latest/integrating/integrating-index"><b>Integrating Existing Systems</b><img src="/composer/latest/assets/img/Caret_SW_2.svg" class="caret"></a></p>

<ul>
<li><a href="/composer/latest/integrating/getting-started-rest-api">Generating a REST API</a></li>
<li><a href="/composer/latest/integrating/publishing-events">Publishing events from the REST server</a></li>
<li><a href="/composer/latest/integrating/enabling-rest-authentication">Enabling authentication for the REST server</a></li>
<li><a href="/composer/latest/integrating/enabling-multiuser">Enabling multiple user mode for the REST server</a></li>
<li><a href="/composer/latest/integrating/securing-the-rest-server">Securing the REST server using HTTPS and TLS</a></li>
<li><a href="/composer/latest/integrating/deploying-the-rest-server">Deploying the REST server for a business network</a></li>
<li><a href="/composer/latest/integrating/customizing-the-rest-server">Customizing the REST server for a business network</a></li>
<li><a href="/composer/latest/integrating/node-red">Integrating with Node-RED</a></li>
<li><a href="/composer/latest/integrating/call-out">Calling external HTTP or REST services</a></li>
</ul></li>
<li><p><a href="/composer/latest/managing/managingindex"><b>Managing a Deployed Business Network</b><img src="/composer/latest/assets/img/Caret_SW_2.svg" class="caret"></a></p>

<ul>
<li><a href="/composer/latest/managing/participantsandidentities">Participants and identities</a></li>
<li><a href="/composer/latest/managing/participant-add">Adding participants</a></li>
<li><a href="/composer/latest/managing/id-cards-playground">Creating, Exporting, and Importing Business Network Cards</a></li>
<li><a href="/composer/latest/managing/identity-issue">Issuing a new identity to a participant</a></li>
<li><a href="/composer/latest/managing/identity-bind">Binding an existing identity to a participant</a></li>
<li><a href="/composer/latest/managing/identity-list">Listing all identities in a business network</a></li>
<li><a href="/composer/latest/managing/identity-revoke">Revoking an identity from a participant</a></li>
<li><a href="/composer/latest/managing/connector-information">Interacting with Hyperledger Fabric</a></li>
</ul></li>
<li><p><a href="/composer/latest/problems/diagnostics"><b>Diagnosing Problems</b><img src="/composer/latest/assets/img/Caret_SW_2.svg" class="caret"></a></p></li>
<li><p><a href="/composer/latest/reference/reference-index"><b>Reference</b><img src="/composer/latest/assets/img/Caret_SW_2.svg" class="caret"></a></p>

<ul>
<li><a href="/composer/latest/reference/MeetTheModules">Hyperledger Composer npm Modules</a></li>
<li><a href="/composer/latest/reference/cto_language">Modeling Language</a></li>
<li><a href="/composer/latest/reference/acl_language">Access Control Language</a></li>
<li><a href="/composer/latest/reference/query-language">Query Language</a></li>
<li><a href="/composer/latest/reference/model-compatibility">Model Compatibility</a></li>
<li><a href="/composer/latest/reference/connectionprofile">Connection Profiles</a></li>
<li><a href="/composer/latest/reference/js_scripts">Transaction Processor Functions</a></li>
<li><a href="/composer/latest/reference/commands">Hyperledger Composer CLI Commands</a></li>
<li><a href="/composer/latest/reference/rest-server">Hyperledger Composer REST Server</a></li>
<li><a href="/composer/latest/reference/glossary">Hyperledger Composer Glossary of Terms</a></li>
</ul></li>
<li><p><a href="/composer/latest/support/support-index"><b>Support</b><img src="/composer/latest/assets/img/Caret_SW_2.svg" class="caret"></a></p></li>
<li><p><a href="/composer/latest/api/api-doc-index"><b>API Reference</b><img src="/composer/latest/assets/img/Caret_SW_2.svg" class="caret"></a></p>

<ul>
<li><a href="/composer/latest/api/allData">API Class Index</a></li>
<li><a href="/composer/latest/api/admin-adminconnection">AdminConnection (Admin API)</a></li>
<li><a href="/composer/latest/api/client-assetregistry">AssetRegistry (Client API)</a></li>
<li><a href="/composer/latest/api/client-businessnetworkconnection">BusinessNetworkConnection (Client API)</a></li>
<li><a href="/composer/latest/api/client-historian">Historian (Client API)</a></li>
<li><a href="/composer/latest/api/client-identityregistry">IdentityRegistry (Client API)</a></li>
<li><a href="/composer/latest/api/client-participantregistry">ParticipantRegistry (Client API)</a></li>
<li><a href="/composer/latest/api/client-query">Query (Client API)</a></li>
<li><a href="/composer/latest/api/client-registry">Registry (Client API)</a></li>
<li><a href="/composer/latest/api/client-transactionregistry">TransactionRegistry (Client API)</a></li>
<li><a href="/composer/latest/api/common-assetdeclaration">AssetDeclaration (Common API)</a></li>
<li><a href="/composer/latest/api/common-businessnetworkcardstore">BusinessNetworkCardStore (Common API)</a></li>
<li><a href="/composer/latest/api/common-businessnetworkdefinition">BusinessNetworkDefinition (Common API)</a></li>
<li><a href="/composer/latest/api/common-businessnetworkmetadata">BusinessNetworkMetadata (Common API)</a></li>
<li><a href="/composer/latest/api/common-classdeclaration">ClassDeclaration (Common API)</a></li>
<li><a href="/composer/latest/api/common-conceptdeclaration">ConceptDeclaration (Common API)</a></li>
<li><a href="/composer/latest/api/common-concept">Concept (Common API)</a></li>
<li><a href="/composer/latest/api/common-decoratorfactory">DecoratorFactory (Common API)</a></li>
<li><a href="/composer/latest/api/common-decorator">Decorator (Common API)</a></li>
<li><a href="/composer/latest/api/common-enumdeclaration">EnumDeclaration (Common API)</a></li>
<li><a href="/composer/latest/api/common-enumvaluedeclaration">EnumValueDeclaration (Common API)</a></li>
<li><a href="/composer/latest/api/common-eventdeclaration">EventDeclaration (Common API)</a></li>
<li><a href="/composer/latest/api/common-factory">Factory (Common API)</a></li>
<li><a href="/composer/latest/api/common-functiondeclaration">FunctionDeclaration (Common API)</a></li>
<li><a href="/composer/latest/api/common-idcard">IdCard (Common API)</a></li>
<li><a href="/composer/latest/api/common-identifiable">Identifiable (Common API)</a></li>
<li><a href="/composer/latest/api/common-introspector">Introspector (Common API)</a></li>
<li><a href="/composer/latest/api/common-modelfile">ModelFile (Common API)</a></li>
<li><a href="/composer/latest/api/common-modelmanager">ModelManager (Common API)</a></li>
<li><a href="/composer/latest/api/common-participantdeclaration">ParticipantDeclaration (Common API)</a></li>
<li><a href="/composer/latest/api/common-property">Property (Common API)</a></li>
<li><a href="/composer/latest/api/common-relationshipdeclaration">RelationshipDeclaration (Common API)</a></li>
<li><a href="/composer/latest/api/common-relationship">Relationship (Common API)</a></li>
<li><a href="/composer/latest/api/common-resource">Resource (Common API)</a></li>
<li><a href="/composer/latest/api/common-serializer">Serializer (Common API)</a></li>
<li><a href="/composer/latest/api/common-transactiondeclaration">TransactionDeclaration (Common API)</a></li>
<li><a href="/composer/latest/api/common-typed">Typed (Common API)</a></li>
<li><a href="/composer/latest/api/common-validatedconcept">ValidatedConcept (Common API)</a></li>
<li><a href="/composer/latest/api/common-validatedresource">ValidatedResource (Common API)</a></li>
<li><a href="/composer/latest/api/runtime-api">Api (Runtime API)</a></li>
<li><a href="/composer/latest/api/runtime-assetregistry">AssetRegistry (Runtime API)</a></li>
<li><a href="/composer/latest/api/runtime-factory">Factory (Runtime API)</a></li>
<li><a href="/composer/latest/api/runtime-participantregistry">ParticipantRegistry (Runtime API)</a></li>
<li><a href="/composer/latest/api/runtime-query">Query (Runtime API)</a></li>
<li><a href="/composer/latest/api/runtime-serializer">Serializer (Runtime API)</a></li>
</ul></li>
<li><p><a href="/composer/latest/systemns/systemns-index"><b>System Namespace Reference</b><img src="/composer/latest/assets/img/Caret_SW_2.svg" class="caret"></a></p>

<ul>
<li><a href="/composer/latest/systemns/01_summary">Summary</a></li>
<li><a href="/composer/latest/systemns/02_assets">Assets</a></li>
<li><a href="/composer/latest/systemns/03_participants">Participants</a></li>
<li><a href="/composer/latest/systemns/04_transactions">Transactions</a></li>
<li><a href="/composer/latest/systemns/05_events">Events</a></li>
<li><a href="/composer/latest/systemns/06_enums">Enums</a></li>
</ul></li>
</ul>

            
                <div class="docs-footer-grid">
                <!--
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<div class="footer-bg-break docs-footer-break">
<div class="footer-container-break">
    <div class="footer-left-break">
      <p>Released under the Apache License v2.0</p>
    </div>
  <div class="footer-right-break">
    <ul>
      <li><a href="https://github.com/hyperledger/composer">GitHub</a></li>
      <li><a href="http://stackoverflow.com/questions/tagged/hyperledger-composer">Stack Overflow</a></li>
    </ul>
  </div>
</div>
</div>

                </div>
          </nav>
        </div>
        <div class="page-content-grid">
          <section class="content-chunk">
            <!-- <a class="toggle open" href="#nav">open</a> -->
            
              <!--
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<h1>Search Results</h1>

<p id="search-results"></p>

<script>
  window.store = {
    
      "systemns-01-summary": {
        "title": "Summary",
        "author": "",
        "category": "",
        "content": "SummaryAsset DefinitionNamespaceNameDescription| org.hyperledger.composer.system.Asset | Asset | An asset named Asset  || org.hyperledger.composer.system.Registry | Registry | An asset named Registry  || org.hyperledger.composer.system.AssetRegistry | AssetRegistry | An asset named AssetRegistry  || org.hyperledger.composer.system.ParticipantRegistry | ParticipantRegistry | An asset named ParticipantRegistry  || org.hyperledger.composer.system.TransactionRegistry | TransactionRegistry | An asset named TransactionRegistry  || org.hyperledger.composer.system.Network | Network | An asset named Network  || org.hyperledger.composer.system.HistorianRecord | HistorianRecord | An asset named HistorianRecord  || org.hyperledger.composer.system.Identity | Identity | An asset named Identity  |Transaction DefinitionNamespaceNameDescriptionorg.hyperledger.composer.system.TransactionTransactionA transaction named Transactionorg.hyperledger.composer.system.RegistryTransactionRegistryTransactionA transaction named RegistryTransactionorg.hyperledger.composer.system.AssetTransactionAssetTransactionA transaction named AssetTransactionorg.hyperledger.composer.system.ParticipantTransactionParticipantTransactionA transaction named ParticipantTransactionorg.hyperledger.composer.system.AddAssetAddAssetA transaction named AddAssetorg.hyperledger.composer.system.UpdateAssetUpdateAssetA transaction named UpdateAssetorg.hyperledger.composer.system.RemoveAssetRemoveAssetA transaction named RemoveAssetorg.hyperledger.composer.system.AddParticipantAddParticipantA transaction named AddParticipantorg.hyperledger.composer.system.UpdateParticipantUpdateParticipantA transaction named UpdateParticipantorg.hyperledger.composer.system.RemoveParticipantRemoveParticipantA transaction named RemoveParticipantorg.hyperledger.composer.system.IssueIdentityIssueIdentityA transaction named IssueIdentityorg.hyperledger.composer.system.BindIdentityBindIdentityA transaction named BindIdentityorg.hyperledger.composer.system.ActivateCurrentIdentityActivateCurrentIdentityA transaction named ActivateCurrentIdentityorg.hyperledger.composer.system.RevokeIdentityRevokeIdentityA transaction named RevokeIdentityorg.hyperledger.composer.system.StartBusinessNetworkStartBusinessNetworkA transaction named StartBusinessNetworkorg.hyperledger.composer.system.ResetBusinessNetworkResetBusinessNetworkA transaction named ResetBusinessNetworkorg.hyperledger.composer.system.SetLogLevelSetLogLevelA transaction named SetLogLevelParticipant DefinitionNamespaceNameDescriptionorg.hyperledger.composer.system.ParticipantParticipantAn participant named Participantorg.hyperledger.composer.system.NetworkAdminNetworkAdminAn participant named NetworkAdmin",
        "url": "/composer/latest/systemns/01_summary"
      }
      ,
    
      "systemns-02-assets": {
        "title": "Assets",
        "author": "",
        "category": "",
        "content": "Asset ModelAssetThe fully qualified name is org.hyperledger.composer.system.AssetAdditional InformationThe base asset is implicitly extended by all other assets. Asset is an abstract meaning that no instances of it can be created.abstract asset Asset {  }PropertiesNameTypeDescriptionReferencesRegistryThe fully qualified name is org.hyperledger.composer.system.RegistryAdditional InformationThe base registry is implicitly extended by all other registries. Registry is an abstract meaning that no instances of it can be created. All registries must have a registryId, a name, a type, and a boolean system property defining whether it is a system registry.abstract asset Registry identified by registryId {  o String registryId  o String name  o String type  o Boolean system}PropertiesNameTypeDescriptionregistryIdstringidentitynamestringName of the registrytypestringtype of the registrysystembooleanIs this a system registry?ReferencesAssetRegistryThe fully qualified name is org.hyperledger.composer.system.AssetRegistryAdditional InformationAssetRegistry is not an abstract so instances of it can be created. AssetRegistry extends the Registry type. As an extension of Registry, it includes the properties of Registry.asset AssetRegistry extends Registry { }PropertiesNameTypeDescriptionReferencesParticipantRegistryThe fully qualified name is org.hyperledger.composer.system.ParticipantRegistryAdditional InformationParticipantRegistry is not an abstract so instances of it can be created. ParticipantRegistry extends the Registry type. As an extension of Registry, it includes the properties of Registry.asset ParticipantRegistry extends Registry { }PropertiesNameTypeDescriptionReferencesTransactionRegistryThe fully qualified name is org.hyperledger.composer.system.TransactionRegistryAdditional InformationTransactionRegistry is not an abstract so instances of it can be created. TransactionRegistry extends the Registry type. As an extension of Registry, it includes the properties of Registry.asset TransactionRegistry extends Registry { }PropertiesNameTypeDescriptionReferencesNetworkThe fully qualified name is org.hyperledger.composer.system.NetworkAdditional InformationNetwork is a system asset, containing the networkId and runtimeVersion properties.asset Network identified by networkId {  o String networkId  o String runtimeVersion}PropertiesNameTypeDescriptionnetworkIdstringof the business networkruntimeVersionstringReferencesHistorianRecordThe fully qualified name is org.hyperledger.composer.system.HistorianRecordAdditional InformationHistorianRecord is a system asset which holds information from network transactions. HistorianRecord has the transactionId, transactionType, transactionInvoked, participantInvoking, identityUsed, eventsEmitted, and transactionTimestamp properties.asset HistorianRecord identified by transactionId {  o String        transactionId  o String        transactionType  --&gt; Transaction transactionInvoked  --&gt; Participant participantInvoking  optional  --&gt; Identity    identityUsed         optional  o Event[]       eventsEmitted        optional  o DateTime      transactionTimestamp}PropertiesNameTypeDescriptiontransactionIdstringUsing the transaction id as the uuidtransactionTypestringtransactionInvokedstringRelationship to transactionparticipantInvokingstringParticipant who invoked this transactionidentityUsedstringThe identity that was used by the participanteventsEmittedarrayThe events that were emitted by this transactionIdtransactionTimestampstringUse the transaction&#39;s timestampReferencesComposer DocumentationIdentityThe fully qualified name is org.hyperledger.composer.system.IdentityAdditional InformationIdentity is a system asset which is related to a participant. asset Identity identified by identityId {    o String identityId    o String name    o String issuer    o String certificate    o IdentityState state    --&gt; Participant participant}PropertiesNameTypeDescriptionidentityIdstringUnique IdentifiersnamestringName given to this identityissuerstringThe issuercertificatestringThe certificatestateobjectState the identity is inparticipantstringAssociated participantReferences",
        "url": "/composer/latest/systemns/02_assets"
      }
      ,
    
      "systemns-03-participants": {
        "title": "Participants",
        "author": "",
        "category": "",
        "content": "Participant ModelParticipantThe fully qualified name is org.hyperledger.composer.system.ParticipantAdditional InformationThe base participant is implicitly extended by all other participants. Participant is an abstract meaning that no instances of it can be created.abstract participant Participant {   }NameTypeDescriptionNetworkAdminThe fully qualified name is org.hyperledger.composer.system.NetworkAdminAdditional InformationNetworkAdmin is a system participant type used as an initial user in a network. NetworkAdmin extends participant and has the participantId property.participant NetworkAdmin identified by participantId {    o String participantId}NameTypeDescriptionparticipantIdstringIdentifier fields of the participant",
        "url": "/composer/latest/systemns/03_participants"
      }
      ,
    
      "systemns-04-transactions": {
        "title": "Transactions",
        "author": "",
        "category": "",
        "content": "Transaction Functions DetailTransactionThe fully qualified name is org.hyperledger.composer.system.TransactionAdditional InformationThe base transaction is implicitly extended by all other transactions. Transaction is an abstract meaning that no instances of it can be created, however, it does contain the transactionId and timestamp properties, which are extended to all other transactions.abstract transaction Transaction identified by transactionId {  o String transactionId  o DateTime timestampNameTypeDescriptiontransactionIdstringIdentifier for this transactiontimestampstringTimestamp for this transactionRegistryTransactionThe fully qualified name is org.hyperledger.composer.system.RegistryTransactionAdditional InformationRegistryTransaction is a system transaction for a transaction which affects a registry. RegistryTransaction is an abstract, meaning instances of it cannot be used. RegistryTransaction has the targetRegistry property, which contains a relationship to a registry.abstract transaction RegistryTransaction {  --&gt; Registry targetRegistry}NameTypeDescriptiontargetRegistrystringRegistry that will be manipulatedAssetTransactionThe fully qualified name is org.hyperledger.composer.system.AssetTransactionAdditional InformationAssetTransaction is a system transaction for a transaction which affects an asset. AssetTransaction is an abstract, meaning instances of it cannot be used. AssetTransaction has the resources property.abstract transaction AssetTransaction extends RegistryTransaction {   o Asset[] resources}NameTypeDescriptionresourcesarrayResources that will be manipulatedParticipantTransactionThe fully qualified name is org.hyperledger.composer.system.ParticipantTransactionAdditional InformationParticipantTransaction is a system transaction for a transaction which affects a participant. ParticipantTransaction is an abstract, meaning instances of it cannot be used. ParticipantTransaction has the resources property.abstract transaction ParticipantTransaction extends RegistryTransaction {  o Participant[] resources}NameTypeDescriptionresourcesarrayparticipants that will be manipulatedAddAssetThe fully qualified name is org.hyperledger.composer.system.AddAssetAdditional InformationNameTypeDescriptionUpdateAssetThe fully qualified name is org.hyperledger.composer.system.UpdateAssetAdditional InformationNameTypeDescriptionRemoveAssetThe fully qualified name is org.hyperledger.composer.system.RemoveAssetAdditional InformationNameTypeDescriptionresourceIdsarrayIdentifiers of the assets to removeAddParticipantThe fully qualified name is org.hyperledger.composer.system.AddParticipantAdditional InformationNameTypeDescriptionUpdateParticipantThe fully qualified name is org.hyperledger.composer.system.UpdateParticipantAdditional InformationNameTypeDescriptionRemoveParticipantThe fully qualified name is org.hyperledger.composer.system.RemoveParticipantAdditional InformationNameTypeDescriptionresourceIdsarrayIdentifiers of the participants to removeIssueIdentityThe fully qualified name is org.hyperledger.composer.system.IssueIdentityAdditional InformationIssueIdentity is a system transaction which issues an identity to a participant. transaction IssueIdentity {    --&gt; Participant participant    o String identityName}NameTypeDescriptionparticipantstringto issue the identity toidentityNamestringname to use for this identityBindIdentityThe fully qualified name is org.hyperledger.composer.system.BindIdentityAdditional InformationBindIdentity is a system transaction which binds an issued identity to a participant. BindIdentity contains a participant property, specifying a relationship to a participant. transaction BindIdentity {    --&gt; Participant participant    o String certificate}NameTypeDescriptionparticipantstringto issue bind identity tocertificatestringto useActivateCurrentIdentityThe fully qualified name is org.hyperledger.composer.system.ActivateCurrentIdentityAdditional InformationActivateCurrentIdentity* is a system transaction which activates the identity currently being used.transaction ActivateCurrentIdentity { }NameTypeDescriptionRevokeIdentityThe fully qualified name is org.hyperledger.composer.system.RevokeIdentityAdditional InformationRevokeIdentity is a system transaction which revokes a specified identity.transaction RevokeIdentity {    --&gt; Identity identity}NameTypeDescriptionidentitystringto revokeStartBusinessNetworkThe fully qualified name is org.hyperledger.composer.system.StartBusinessNetworkAdditional InformationStartBusinessNetwork is a system transaction that starts a business network. Both the logLevel and bootstrapTransactions properties are optional.transaction StartBusinessNetwork {  o String logLevel optional  o Transaction[] bootstrapTransactions optional}NameTypeDescriptionlogLevelstringLog level to use optionallybootstrapTransactionsarrayoptional transactions to use to bootstrap the networkResetBusinessNetworkThe fully qualified name is org.hyperledger.composer.system.ResetBusinessNetworkAdditional InformationResetBusinessNetwork is a system transaction which deletes all data in a business network, while leaving the business network definition intact.transaction ResetBusinessNetwork {}NameTypeDescriptionSetLogLevelThe fully qualified name is org.hyperledger.composer.system.SetLogLevelAdditional InformationSetLogLevel is a system transaction which sets the logging level for the business network. The possible logging levels can be found in the problem diagnosis documentation.transaction SetLogLevel {  o String newLogLevel}NameTypeDescriptionnewLogLevelstringa valid debug string",
        "url": "/composer/latest/systemns/04_transactions"
      }
      ,
    
      "systemns-05-events": {
        "title": "Events",
        "author": "",
        "category": "",
        "content": "Events DetailEventThe fully qualified name is org.hyperledger.composer.system.EventAdditional InformationThe base event is implicitly extended by all other events. Event is an abstract meaning that no instances of it can be created, however, it does contain the eventId and timestamp properties, which are extended to all other events.abstract event Event identified by eventId {  o String eventId  o DateTime timestamp}NameTypeDescriptioneventIdstringIdentifier for this eventtimestampstringTimestamp for this event",
        "url": "/composer/latest/systemns/05_events"
      }
      ,
    
      "systemns-06-enums": {
        "title": "Enums",
        "author": "",
        "category": "",
        "content": "Enumeration DetailIdentityStateThe fully qualified name is org.hyperledger.composer.system.IdentityStateAdditional InformationIdentityState is an enumerated list of the four states an Identity can hold. The identity lifecycle is as follows, first an identity is issued, then bound to a participant. When that identity is first used it becomes activated and will remain activated until it is revoked.enum IdentityState {    o ISSUED    o BOUND    o ACTIVATED    o REVOKED}NameISSUEDBOUNDACTIVATEDREVOKED",
        "url": "/composer/latest/systemns/06_enums"
      }
      ,
    
      "404": {
        "title": "Page Not Found :(",
        "author": "",
        "category": "404",
        "content": "          Oh no!…there’s no blockchain here :(    If you fancy telling us about this please raise an issue on our Github  ",
        "url": "/composer/latest/404"
      }
      ,
    
      "reference-jsdoc-readme": {
        "title": "API Documentation",
        "author": "",
        "category": "",
        "content": "Hyperledger Composer APIHyperledger Composer  is an application development framework for building Blockchain applications based on Hyperledger. This is the JavaScript documentation for the Hyperledger Composer Client, Admin, and Runtime JavaScript APIs.OverviewThe major components of Hyperledger Composer are:The Hyperledger Composer language for describing the structure of resources (assets, participantsand transactions) that participate in a blockchain backed business network.JavaScript APIs to query, create, update and delete resources and submit transactionsfrom client applications. Hyperledger Composer resources are stored on the Blockchain.JavaScript transaction processor functions that runs on Hyperledger Fabric when transactions aresubmitted for processing. These functions may update the state of resourcesstored on the Blockchain via server-side Hyperledger Composer APIs.ResourcesDocumentationnpm modulesGitHub repositoriesContributingTo read more about the community and guidelines for submitting pull requests,please read the Contributing document.",
        "url": "/composer/latest/reference/JSDOC-README"
      }
      ,
    
      "reference-meetthemodules": {
        "title": "Hyperledger Composer npm Modules",
        "author": "",
        "category": "",
        "content": "Hyperledger Composer npm ModulesHyperledger Composer has 3 main modules for application developers. If you are writing an application this is your entry point.composer-clientcomposer-admincomposer-clicomposer-client and composer-admin are the two modules that provide APIs for applications. node.js applications should only use APIs that come from these modules. If there are other APIs that are need please contact us.Details of all the APIs have been documented in JSDocs (see reference).composer-clientThis module would usually be installed as a local dependency of an application. It provides the API that is used by business applications to connect to a business network to access assets, participants and submitting transactions. When in production this is only module that needs to be added as a direct dependency of the application.npm install --save composer-clientcomposer-adminThis module would usually be installed as a local dependency of administrative applications. This API permits the creation of and deployment of business network definitions.npm install --save composer-admincomposer-cliThis provides command line tools to provide the ability to deploy and managed business network definitions. This would normally be installed as a global modulenpm install -g composer-cliIf you wish however you can instgall this as a local dependancy, but you could need to access the cli.js node class directly rather than used the composer command.composer-reportThis provides a basic command line tool to collect diagnostic reports. This would normally only be required if composer-cli could not be installed for any reason.See the composer report command for more information.",
        "url": "/composer/latest/reference/MeetTheModules"
      }
      ,
    
      "tutorials-acl-trading": {
        "title": "Access Control Tutorial - Commodity Trading",
        "author": "",
        "category": "tutorials",
        "content": "Access Control in Hyperledger Composer  - TutorialAccess control and authorization are a very important part of Hyperledger Composer and the security architecture of a business network shared by member organisations on the blockchain. Hyperledger Composer enables an administrator control what resources or data a participant, or indeed participant role - is authorized to see or do, in a business network. These participants will typically operate or transact from inside their respective member organisations and each will have their own access control requirements on the ledger, whilst at the same time allowing controlled access to shared data or data that may be common to all member organisations - or specific members interacting on the same business network.  This tutorial explores one such business network - the Commodity Trading network - seen elsewhere in our tutorials and sample networks and shows examples of ACLs in action in this sample network.Access control rules (the language that defines ACLs) fall into two main areas:authority to access system, network or administrative resources and operations in the System namespace (governing Network and System operations) ;  andauthority to access resources or perform operations within a given business network itself (like Create, Read, Update assets),  via domain specific business network ACLs.The tutorial uses the online Playground to try out some simple and conditional access rules. In doing so, you will interact with the sample network as various identities - ultimately,  it is the users of the blockchain that we want to apply access control to. We&#39;ll also see how a Participant role can be used to control access, where multiple identities can be mapped to a designated Participant role (such as a Regulator). Its important to note that in a real blockchain network, all operations, whether from a Node JS application, CLI or indeed REST operations are subject to and controlled by the ACLs that govern a business network. Accountability is seen at an identity level.If you wish, you can also apply the rules in this tutorial against an existing Hyperledger Composer you&#39;ve deployed. You just need to grab and deploy the sample Commodity Trading business network used in the Developer Tutorial - remembering to remove the global trading network ACL rule mentioned earlier - and you&#39;re ready to start working with that environment.PrerequisitesNone - just an internet connection, which you have right now :-)Step One: Access the Online Playground and select your business networkWe&#39;ll use the sample business network (trade-network) sourced from the Composer sample networks repository.Go to the Online Playground and if necessary clear local storage when prompted. Accept the Welcome logo, you are ready to start.Click on the Deploy a new business network modal / icon.Scroll down and click on the trade-network sample - when you scroll back up,  it should populate name, description and network admin card fields for you.With the Deploy button active (confirm that the name is trade-network) - click on Deploy to deploy the business network.Lastly, click on &#39;Connect Now&#39; to connect to the deployed business network (the default id - its shown top right).The &#39;Trade Network&#39; README file should be active and you can see the components of the business network listed in the left column - one of these is the ACLs file permissions.acl which controls the access to resources. Out of the box, the sample business networks have &#39;all access&#39; turned on, which would of course, ultimately be different to that for a production style environment.Create Trader ParticipantsClick on the &#39;Test&#39; tab near the top of the screen. This is where we create sample Trader participants.Click on Trader on the left - Create New Participant (top right) as follows - the example below is &#39;TRADER1&#39;:1st record:{      \"$class\": \"org.example.trading.Trader\",      \"tradeId\": \"TRADER1\",      \"firstName\": \"Jenny\",      \"lastName\": \"Jones\"}Repeat step 2 and create 5 additional Trader participants (&#39;TRADER2&#39; through &#39;TRADER6&#39;) using the sample data above (change the names as appropriate). We have provided &#39;TRADER2&#39;, and &#39;TRADER3&#39; as an example below.2nd record:{    \"$class\": \"org.example.trading.Trader\",    \"tradeId\": \"TRADER2\",    \"firstName\": \"Jack\",    \"lastName\": \"Sock\"}3rd record:{  \"$class\": \"org.example.trading.Trader\",  \"tradeId\": \"TRADER3\",  \"firstName\": \"Rainer\",  \"lastName\": \"Valens\"}4th record:{  \"$class\": \"org.example.trading.Trader\",  \"tradeId\": \"TRADER4\",  \"firstName\": \"Davor\",  \"lastName\": \"Dolittle\"}5th record:{  \"$class\": \"org.example.trading.Trader\",  \"tradeId\": \"TRADER5\",  \"firstName\": \"Steve\",  \"lastName\": \"Alonso\"}6th record:{  \"$class\": \"org.example.trading.Trader\",  \"tradeId\": \"TRADER6\",  \"firstName\": \"Lars\",  \"lastName\": \"Graf\"}Create Commodity AssetsStill in the &#39;Test&#39; panel, create some Commodity records by selecting &#39;Commodity&#39; on the left - the ownership (owner field) relates back to the &#39;Trader&#39; participant for the purposes of this tutorial. Note that owner is a relationship field.1st record:{  \"$class\": \"org.example.trading.Commodity\",  \"tradingSymbol\": \"EMA\",  \"description\": \"Corn\",  \"mainExchange\": \"EURONEXT\",  \"quantity\": 10,  \"owner\": \"resource:org.example.trading.Trader#TRADER1\"}2nd record:{  \"$class\": \"org.example.trading.Commodity\",  \"tradingSymbol\": \"CC\",  \"description\": \"Cocoa\",  \"mainExchange\": \"ICE\",  \"quantity\": 80,  \"owner\": \"resource:org.example.trading.Trader#TRADER2\"}3rd record:{  \"$class\": \"org.example.trading.Commodity\",  \"tradingSymbol\": \"HO\",  \"description\": \"Heating Oil\",  \"mainExchange\": \"NYMEX\",  \"quantity\": 40,  \"owner\": \"resource:org.example.trading.Trader#TRADER3\"}4th record:{  \"$class\": \"org.example.trading.Commodity\",  \"tradingSymbol\": \"HG\",  \"description\": \"Copper\",  \"mainExchange\": \"COMEX\",  \"quantity\": 100,  \"owner\": \"resource:org.example.trading.Trader#TRADER4\"}5th record:{  \"$class\": \"org.example.trading.Commodity\",  \"tradingSymbol\": \"SM\",  \"description\": \"Soybean Meal\",  \"mainExchange\": \"CBOT\",  \"quantity\": 70,  \"owner\": \"resource:org.example.trading.Trader#TRADER5\"}6th record:{  \"$class\": \"org.example.trading.Commodity\",  \"tradingSymbol\": \"AG\",  \"description\": \"Silver\",  \"mainExchange\": \"CBOT\",  \"quantity\": 60,  \"owner\": \"resource:org.example.trading.Trader#TRADER6\"}Create Identities to test ACLsNext, let&#39;s create some trader identities - we need to issue identities for the Traders (TRADER1 - 6) so that we can test those identities&#39; access (each being mapped to their respective Trader participant record)Click on admin (top right) and select &#39;ID Registry&#39; from the drop-downClick &#39;Issue new ID&#39; top right and it will present an &#39;Issue New Identity&#39; dialogIn the ID Name field - enter tid1 as the identity we&#39;ll use for TRADER1In the Participant field - enter TRADER1 to search for the Participant - and select the fully-qualified participant nameClick on &#39;Create New&#39;  to continue.Repeat the &#39;Issue new ID&#39; sequence (step 2 through 5 above) for identities tid2, tid3, tid4, tid5 and tid6 respectively, mapping these to their respective TRADER participants.Now we&#39;re ready to start creating our access control rules.Important: if you are issuing new identities for a Hyperledger Composer based environment (as opposed to the online environment), be sure to add each issued identity to your wallet using the &#39;Add to Wallet&#39; option.Add Commodity Trading network access control rulesThe standard &#39;Commodity Trade network&#39; sample network you deployed comes with standard System and Network ACL rules, that govern the participants of the business network to enable accessing registries like asset registries or ability to reviewing historical records in the ledger.But we want to add some Trading-specific access control rules - let&#39;s start by defining what we want to achieve first ! The golden rule with ACLs is that access to resources inside a business network are by default implicitly &#39;DENIED&#39; to Participants, unless explicitly ALLOWED.You will note from reviewing the current ACLs in permissions.acl that certain &#39;system&#39; or &#39;administrator&#39; type rules are defined in the ACLs file - this is to allow participants to be able to use Composer system operations such as being able to write to the Composer system Historian registry.Before we begin, we will need to remove one &#39;global&#39; rule in permissions.acl for our trading network which, because its ordinarily used as a sample network, must now be removed. This is the rule to REMOVE (up to - and including - the final curly bracket):rule Default {    description: \"Allow all participants access to all resources\"    participant: \"ANY\"    operation: ALL    resource: \"org.example.trading.*\"    action: ALLOW}Having removed this from the permissions.acl file (leaving the &#39;system&#39; or &#39;administrator&#39; rules behind, click on the UPDATE button (bottom left) for the changes to take effect.In terms of our rule objectives - these are the policies we want to apply:Everyday activities - rule objectives:1a. Traders can see and update their own profile only (participant record)1b. Allow Traders access to all operations on their own assets (Commodities)Restrict Participants of type &#39;Trader&#39; such that only they can submit Trade transactions (as there may be several transactions defined in the model, over time, in an &#39;live&#39;/operational business network)Historical records  - rule objectives:Ensure Traders can only see the history of transactions they have created.Allow a Participant of type REG (Regulator) the authority to see the history of all historical transactions committed by Traders (as well as working with their own participant profile) - there are two rule subsets for this - 4a and 4b.It is important to note at this point that the namespace org.example.trading (our Commodity Trading business network) has no business network ACLS defined (just has system ones) and therefore access to resources inside that business network are implicity &#39;denied&#39; by default.Rule 1a - Trader profile restriction ruleFirst up - rule to restrict Traders to only see and update their own record.Switch identity to tid1 (click the current identity top right and choose ID Registry, select to &#39;use now&#39; for tid1) - and click on the &#39;Test&#39; tabConfirm that you do not see any Trader records.Switch identity to the &#39;admin&#39; user (top right, &#39;ID Registry&#39;), then go to the &#39;Define&#39;  tab and click on &#39;Access Control&#39; (permissions.acl) on the left.Paste the following rule into the top of your edit session, after the comment lines and ensure you have pasted above, the existing 3 &#39;System&#39; and &#39;Network&#39; system rules:Rule:rule R1a_TraderSeeUpdateThemselvesOnly {  description: \"Trader can see and update their own record only\"  participant(t): \"org.example.trading.Trader\"  operation: READ, UPDATE  resource(v): \"org.example.trading.Trader\"  condition: (v.getIdentifier() == t.getIdentifier())  action: ALLOW}Then click on the UPDATE button on the bottom left to update the business network.This rule will allow the current Trader Participant (mapped to the current identity whether in playground (here) or indeed in your application) to READ and UPDATE their own target Trader record.TEST THE ACL: Switch user to identity tid1 (top right, &#39;ID Registry&#39;) and click on the &#39;Test&#39; tab - check that TRADER1 record only, is visible to this identity.Rule 1b - Trader Asset Ownership - allow update by owners onlyBy default, a Trader cannot see or update any of the Commodities created earlier.We need a rule to enable a Trader access Commodities for which they are the designated &#39;owner&#39;.Switch identity to tid1 (click the current identity top right and choose ID Registry, select to &#39;use now&#39; for tid1) - and click on the &#39;Test&#39; tabConfirm that you do not see any Commodity records.Switch identity back to the &#39;admin&#39; user (top right, &#39;ID Registry&#39;), then go to the &#39;Define&#39;  tab and click on &#39;Access Control&#39; (permissions.acl) on the left.Paste the following rule in line 1 in your edit session, pasted above the existing rules:Rule:rule R1b_TraderSeeTheirCommodities {  description: \"Trader can see/work with their own Commodities\"  participant(t): \"org.example.trading.Trader\"  operation: ALL  resource(c): \"org.example.trading.Commodity\"  condition: (c.owner.getIdentifier() == t.getIdentifier())  action: ALLOW}Then click on the UPDATE button on the bottom left to update the business network.This rule will allow the current Trader Participant all operations on target Commodity resources that it &#39;owns&#39;.TEST THE ACL: Switch user to identity tid1 (top right, &#39;ID Registry&#39;) and click on the &#39;Test&#39; tab - confirm that there is one Commodity owned by TRADER1 participant and is visible/editable (icon) to this identity.Implicitly, this Trader TRADER1 has no ability to see or update other Trader&#39;s assets (Commodities) at this point - we don&#39;t need a rule for this, but there may in the real world be a business policy to allow specific senior Traders to &#39;see&#39; other Commodities, albeit they are not owners for same.Rule 2 - Restrictive rule: Only &#39;Trader&#39; participants can submit Trade smart contract transactionsBy default, a Trader cannot submit a Trade transaction (defined in our model and for which we have smart contract logic written in our Script file) to update a Commodity he owns.We need a rule to enable a Trader to submit Trade transactions for which they are the designated &#39;owner&#39;. The Trade transaction enables the current owner to change the ownership of a Commodity to another Trader.Switch identity to tid1 (click the current identity top right and choose ID Registry, select to &#39;use now&#39; for tid1) - and click on the &#39;Test&#39; tabConfirm that you cannot submit a Trade transaction (&#39;Submit Transaction&#39; - copy and paste the transaction below) to try change the ownership of a Commodity - you will get a message that you do not have CREATE ability to do submit the transaction.JSON to copy:{  \"$class\": \"org.example.trading.Trade\",  \"commodity\": \"resource:org.example.trading.Commodity#EMA\",  \"newOwner\": \"resource:org.example.trading.Trader#TRADER2\"}Switch identity back to the &#39;admin&#39; user (top right, &#39;ID Registry&#39;), then go to the &#39;Define&#39;  tab and click on &#39;Access Control&#39; (permissions.acl) on the left.Paste the following rule in line 1 in your edit session, pasted above the existing rules:Rule:rule R2_EnableTradeTxn {    description: \"Enable Traders to submit transactions\"    participant: \"org.example.trading.Trader\"    operation: ALL    resource: \"org.example.trading.Trade\"    action: ALLOW}Then click on the UPDATE button on the bottom left to update the business network.That&#39;s it. We know already that the participant can only work with their own Commodity(ies). This will allow only Trader participants to submit transactions of type Trade (we could have many different participant types in a business network).TEST THE ACL: Switch user to identity tid1 (top right, &#39;ID Registry&#39;) - the owner of Commodity with id EMAa. Click on the &#39;Test&#39; tab. Submit a Trade Transaction copying and pasting this transaction, replacing current contents with the transaction provided below:JSON to copy:{  \"$class\": \"org.example.trading.Trade\",  \"commodity\": \"resource:org.example.trading.Commodity#EMA\",  \"newOwner\": \"resource:org.example.trading.Trader#TRADER2\"}b. Confirm that the transaction has now been submitted by going to &#39;All Transactions&#39; (on the left) and the first record in the Historian shows a TRADE transaction confirms the transfer. Participant TRADER1 no longer owns the commodity. By contrast, a switch to identity tid2 will reveal it has two Commodity records as TRADER2 was the recipient owner.Rule 3 - Enabling rule: Allow Traders to see their own historical records onlyBy default, due to the System ACLs (a part of which is the registry for the Historian records), each Trader (eg. and related tid1, tid2 etc identities) can see the history of all Transactions - an example is the UpgradeBusinessNetwork performed by admin.We will lock down access to the Historian such that Traders only see transactions they submitted in Historian.Switch identity to tid3 (click the current identity top right and choose ID Registry, select to &#39;use now&#39; for tid3) - and click on the &#39;Test&#39; tabConfirm that you can see transactions relating to &#39;system&#39; activities, but also the other traders (TRADER1 and TRADER2).Switch identity back to the &#39;admin&#39; user (top right, &#39;ID Registry&#39;), then go to the &#39;Define&#39;  tab and click on &#39;Access Control&#39; (permissions.acl) on the left.Paste the following rule in line 1 in your edit session, pasted above the existing rules:Rule:rule R3_TradersSeeOwnHistoryOnly {  description: \"Traders should be able to see the history of their own transactions only\"  participant(t): \"org.example.trading.Trader\"  operation: READ  resource(v): \"org.hyperledger.composer.system.HistorianRecord\"  condition: (v.participantInvoking.getIdentifier() != t.getIdentifier())  action: DENY}This rule restricts the current Trader participant to seeing only transactions he/she invoked on the blockchain.Then click on the UPDATE button on the bottom left to update the business network.TEST THE ACL:a. Switch user to identity tid3 (top right, &#39;ID Registry&#39;) - you will only see &#39;Identity Activation&#39; type entries but nothing about the history of transactions that were submitted relating to TRADER1 and TRADER2. This is what we would expect.b. Next, switch to identity tid1 - you will see the history of transactions (including the &#39;TRADE&#39; transaction submitted earlier) relating to tid1 only - in particular the transfer of Commodity &#39;CC&#39; ownership to TRADER2 (By contrast, identity tid2 , the transferee, will not see the historial &#39;TRADE&#39; transaction submitted by tid1 - only the Commodity asset, that was transferred).Rule 4a &amp; 4b - Enabling rule: Allow Regulators to see their own profile and all historical activity,  including TradesIt stands to reason that a regulator would want to review/audit historical transactions carried out in the business network. They won&#39;t necessarily need access to things like Participants or Assets per se (depending on the use case or policy), but rather, the activities relating to these.We don&#39;t yet have a &#39;Regulator&#39; in our &#39;Commodity Trading&#39; business network model, so we will add this as a separate participant type and then proceed to define rules that allow someone that has the regulator &#39;role&#39;, to access historical records. Remember that one or more identities can be mapped to a participant instance, and &#39;Regulator&#39; is a good example of that.Switch identity to admin if you haven&#39;t already done so  - and then click on &#39;Define&#39; (top)Click on the Model file and add a new Participant type (add it below the Trader participant) as follows:Model:participant Regulator identified by regId {    o String regId    o String firstName    o String lastName}Ensure you click on the UPDATE button to update the network.Switch to the &#39;Test&#39; tab (still as &#39;admin&#39;)  and create a participant Regulator as follows:Create the record:{  \"$class\": \"org.example.trading.Regulator\",  \"regId\": \"Reg101\",  \"firstName\": \"Jon\",  \"lastName\": \"Doe\"}Create an Identity in the ID registry  for an identity with ID 101 and map it to the Participant regulator &#39;Reg101&#39; created above.At this point, the Regulator can now see the history of system transactions in Composer&#39;s Historian, due to the system ACL rules defined earlier. But at this point, he cannot see his own participant profile.Add the following rule:Rule:rule R4a_RegulatorSeeThemselves {  description: \"Regulators can see and update their own record\"  participant: \"org.example.trading.Regulator\"  operation: READ, UPDATE  resource: \"org.example.trading.Regulator\"  action: ALLOW}This rule merely allows a Regulator participant to update their own profile record (should they wish to update it - you can test this out if you wish; we had done something similar earlier).Then click on the UPDATE button on the bottom left to update the business network with the new rule.Next, switch identity (in the Id Registry) to  the Regulator identity 101 and click &#39;Use Now&#39;Check you can indeed see the Historical records (which shows our previous transactions - then click on &#39;view record&#39; for any system type transaction activity such as AddAsset or AddParticipant - as someone that is a Regulator, you should be able to see this activity.Next click &#39;view record&#39; for a TRADE transaction- there&#39;s an issue - nothing happens. You (regulator) currently do not have authority (via ACLs) able to view the transaction recordSwitch identity back to &#39;admin&#39; as good practice for rule changes.Add the following Regulator authorisation rule (insert the rule in the permissions.acl file at the top ):Rule:rule R4b_RegTransView {    description: \"Grant Regulator full access to Trade Transactions\"    participant: \"org.example.trading.Regulator\"    operation: ALL    resource: \"org.example.trading.Trade\"    action: ALLOW}Then click on the UPDATE button on the bottom left to update the business network.This rule enables a Regulator to access the Trade transaction resources, such that it can view the Trade transactions from Historian&#39;s &#39;view record&#39;).This rule also applies to any subsequent identity mapped to the regulator role and in the Regulator participant registry.TEST the ACL - now go to a trade transaction again and check that you can indeed now view the recordIn this tutorial, you have experimented with creating ACL rules incrementally, only permitting the requisite access controls that should be accorded to participants of this example Commodity Trading business network.  We have seen how ACL rules provide authorisation and access control to resources as applied to participants (or indeed participant roles). ACLs govern the access control to resources and transactions, whether that&#39;s the ability to create, delete or update resources or execute transactions. We have also the power of the Access Control Language and rules, in defining the conditions or criteria as to: &#39;who&#39; has the ability to do &#39;what&#39; on the ledger.",
        "url": "/composer/latest/tutorials/acl-trading"
      }
      ,
    
      "reference-acl-language": {
        "title": "Access Control Language",
        "author": "",
        "category": "",
        "content": "Hyperledger Composer Access Control LanguageHyperledger Composer includes an access control language (ACL) that provides declarative access control over the elements of the domain model. By defining ACL rules you can determine which users/roles are permitted to create, read, update or delete elements in a business network&#39;s domain model.Network Access ControlHyperledger Composer differentiates between access control for resources within a business network (business access control) and access control for network administrative changes (network access control). Business access control and network access control are both defined in the access control file (.acl) for a business network.Network access control uses the system namespace, which is implicitly extended by all resources in a business network; and grants or denies access to specific actions as defined below, and is intended to allow for more nuanced access to certain network-level operations.What does network access control allow or disallow?Network access control affects the following CLI commands:Composer Networkcomposer network downloadNetwork access is required to use the READ operation for registries and networks.composer network listNetwork access is required to use the READ operation for registries and networks.composer network loglevelNetwork access is required to use the UPDATE operation for networks.composer network pingNetwork access is required to use the READ operation on registries and networks.Composer Identitycomposer identity importNetwork access is required to use the UPDATE operation on identity registries or the CREATE operation on identities.composer identity issueNetwork access is required to use the UPDATE operation on identity registries or the CREATE operation on identities.composer identity revokeNetwork access is required to use the UPDATE operation on identity registries or the DELETE operation on identities.Composer Participantcomposer participant addNetwork access is required to use the CREATE operation on participants or the UPDATE operation on participant registries.Granting network access controlNetwork access is granted using the system namespace. The system namespace is always org.hyperledger.composer.system.Network for network access, and org.hyperledger.composer.system for all access. The following access control rules gives the NetworkControl participant the authority to use all operations with network commands.rule NetworkControlPermission {  description:  \"NetworkControl can access network commands\"  participant: \"org.example.basic.NetworkControl\"  operation: ALL  resource: \"org.hyperledger.composer.system.Network\"  action: ALLOW}The following access control rule will give all participants access to all operations and commands in the business network, including network access and business access.rule AllAccess {  description: \"AllAccess - grant everything to everybody\"  participant: \"org.hyperledger.composer.system.Participant\"  operation: ALL  resource: \"org.hyperledger.composer.system.**\"  action: ALLOW}Evaluation of Access Control RulesAccess control for a business network is defined by an ordered set of ACL rules. The rules are evaluated in order, and the first rule whose condition matches determines whether access is granted or denied. If no rule match then access is denied.ACL rules are defined in a file called permissions.acl in the root of the business network. If this file is missing from the business network then all access is permitted.Access Control Rule GrammarThere are two types of ACL rules: simple ACL rules and conditional ACL rules. Simple rules are used to control access to a namespace or asset by a participant type or participant instance.For example, the rule below states that any instance of the org.example.SampleParticipant type can perform ALL operations on all instances of org.example.SampleAsset.rule SimpleRule {    description: \"Description of the ACL rule\"    participant: \"org.example.SampleParticipant\"    operation: ALL    resource: \"org.example.SampleAsset\"    action: ALLOW}Conditional ACL rules introduce variable bindings for the participant and the resource being accessed, and a Boolean JavaScript expression, which, when true, can either ALLOW or DENY access to the resource by the participant.For example, the rule below states that any instance of the org.example.SampleParticipant type can perform ALL operations on all instances of org.example.SampleAsset IF the participant is the owner of the asset.rule SampleConditionalRule {    description: \"Description of the ACL rule\"    participant(m): \"org.example.SampleParticipant\"    operation: ALL    resource(v): \"org.example.SampleAsset\"    condition: (v.owner.getIdentifier() == m.getIdentifier())    action: ALLOW}Conditional ACL rules can also specify an optional transaction clause. When the transaction clause is specified, the ACL rule only allows access to the resource by the participant if the participant submitted a transaction, and that transaction is of the specified type.For example, the rule below states that any instance of the org.example.SampleParticipant type can perform ALL operations on all instances of org.example.SampleAsset IF the participant is the owner of the asset AND the participant submitted a transaction of the org.example.SampleTransaction type to perform the operation.rule SampleConditionalRuleWithTransaction {    description: \"Description of the ACL rule\"    participant(m): \"org.example.SampleParticipant\"    operation: READ, CREATE, UPDATE    resource(v): \"org.example.SampleAsset\"    transaction(tx): \"org.example.SampleTransaction\"    condition: (v.owner.getIdentifier() == m.getIdentifier())    action: ALLOW}Multiple ACL rules may be defined that conceptually define a decision table. The actions of the decision tree define access control decisions (ALLOW or DENY). If the decision table fails to match then by default access is denied.Resource defines the things that the ACL rule applies to. This can be a class, all classes within a namespace, or all classes under a namespace. It can also be an instance of a class.Resource Examples:Namespace: org.example.*Namespace (recursive): org.example.**Class in namespace: org.example.CarInstance of a class: org.example.Car#ABC123Operation identifies the action that the rule governs. Four actions are supported: CREATE, READ, UPDATE, and DELETE. You can use ALL to specify that the rule governs all supported actions. Alternatively, you can use a comma separated list to specify that the rule governs a set of supported actions.Participant defines the person or entity that has submitted a transaction for processing. If a Participant is specified they must exist in the Participant Registry. The PARTICIPANT may optionally be bound to a variable for use in a PREDICATE. The special value &#39;ANY&#39; may be used to denote that participant type checking is not enforced for a rule.Transaction defines the transaction that the participant must have submitted in order to perform the specified operation against the specified resource. If this clause is specified, and the participant did not submit a transaction of this type - for example, they are using the CRUD APIs - then the ACL rule does not allow access.Condition is a Boolean JavaScript expression over bound variables. Any JavaScript expression that is legal within an if(...) expression may be used here. JavaScript expressions used for the condition of an ACL rule can refer to JavaScript utility functions in a script file. This allows a user to easily implement complex access control logic, and re-use the same access control logic functions across multiple ACL rules.Action identifies the action of the rule. It must be one of: ALLOW, DENY.ExamplesExample ACL rules (in evaluation order):rule R1 {    description: \"Fred can DELETE the car ABC123\"    participant: \"org.example.Driver#Fred\"    operation: DELETE    resource: \"org.example.Car#ABC123\"    action: ALLOW}rule R2 {    description: \"regulator with ID Bill can not update a Car if they own it\"    participant(r): \"org.example.Regulator#Bill\"    operation: UPDATE    resource(c): \"org.example.Car\"    condition: (c.owner == r)    action: DENY}rule R3 {    description: \"regulators can perform all operations on Cars\"    participant: \"org.example.Regulator\"    operation: ALL    resource: \"org.example.Car\"    action: ALLOW}rule R4 {    description: \"Everyone can read all resources in the org.example namespace\"    participant: \"ANY\"    operation: READ    resource: \"org.example.*\"    action: ALLOW}rule R5 {    description: \"Everyone can read all resources under the org.example namespace\"    participant: \"ANY\"    operation: READ    resource: \"org.example.**\"    action: ALLOW}Rules are evaluated from top (most specific) to bottom (least specific). As soon as the Participant, Operation and Resource match for a rule then subsequent rules are not evaluated.This ordering makes the decision table faster to scan for both humans and computers. If no ACL rule fires then the access control decision is DENY.",
        "url": "/composer/latest/reference/acl_language"
      }
      ,
    
      "api-admin-adminconnection": {
        "title": "AdminConnection (Admin API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIAdminConnectionThis class creates an administration connection to a Hyperledger Composer runtime. Theconnection can then be used to:Deploy BusinessNetworkDefinitionsUndeploy BusinessNetworkDefinitionsUpdate BusinessNetworkDefinitionsSend a ping message to the runtime to ensure it is running and correctly configured.Store a connection profile document in the connection profile storeNote: that the methods on this class take the &#39;businessNetworkIdentifier&#39;; this has to matchthe name given on the create call. An AdminConnection that has been connected to network-A canonly be used to adminster network-A.Instances of AdminConnections can be reused for different networks. Call disconnect(..) then connect(..).Calling an api after disconnect and before connect will give an error.DetailsModule adminMethod SummaryNameReturnsDescriptionconnectvoidConnects and logs in to the Hyperledger Fabric using a named connection profileconstructorvoidCreate an instance of the AdminConnection classdeleteCardPromiseDelete an existing carddisconnectPromiseDisconnects this connectionexportCardPromiseExports an network cardgetAllCardsPromiseList all Business Network cardsgetLogLevelPromiseGet the current logging level of a business networkgetNativeAPIvoidGet the native API for this connectionhasCardPromiseHas a existing cardimportCardPromiseImport a business network cardinstallPromiseInstalls a business network as chaincode to Hyperledger Fabric in preparation for the business network to be startedlistPromiseList all of the deployed business networkspingPromiseTest the connection to the runtime and verify that the version of the runtime is compatible with this level of the noderesetPromiseResets an existing BusinessNetworkDefinition on the Hyperledger FabricsetLogLevelPromiseSet the logging level of a business networkstartPromiseStarts a business network within the runtime previously installed to the Hyperledger Fabric with the same name as the business network to be startedundeployPromiseUndeploys a business networkupgradePromiseUpgrades an existing business network to a later levelMethod Detailsnew AdminConnection()Create an instance of the AdminConnection class.The default cardstore is a filesystem based one that stores files in ~/.composerParametersNameTypeMandatoryDescriptionoptionsObjectYesan optional set of options to configure the instance.Sub-optionsNameTypeMandatoryDescriptionoptions.cardStoreBusinessNetworkCardStoreYesspecify a card store implementation to use.importCardPromise importCard( String name, IdCard card )Import a business network card. If a card of this name exists, it is replaced.ReturnsPromise - Resolved when the card is imported, resolves to true if updated, false if added.ParametersNameTypeMandatoryDescriptionnameStringYesName by which this card should be referredcardIdCardYesThe card to importexportCardPromise exportCard( String cardname )Exports an network card. Should the card not actually contain the certificates in the card, a exportIdentity will be performed to get the details of the cardsReturnsPromise - resolved with an instance of the network id card populatedParametersNameTypeMandatoryDescriptioncardNameStringYesThe name of the card that needs to be exportedgetAllCardsPromise getAllCards(  )List all Business Network cards.ReturnsPromise - resolved with a  Map of idcard objects keyed by their  String names.ParametersNo parametersdeleteCardPromise deleteCard( String name )Delete an existing card.ReturnsPromise - Resolves true if deleted, false if not deleted, is rejected if an error occurs.ParametersNameTypeMandatoryDescriptionnameStringYesName of the card to delete.hasCardPromise hasCard( String name )Has a existing card.ReturnsPromise - Resolves with true if the card with the name exists, resolved with false if notParametersNameTypeMandatoryDescriptionnameStringYesName of the card to check.connectconnect( String cardname )Connects and logs in to the Hyperledger Fabric using a named connection profile.The connection profile must exist in the profile store.ParametersNameTypeMandatoryDescriptioncardNameStringYesThe name of the business network cardExample// Connect to Hyperledger Fabriclet adminConnection = new AdminConnection();try {  await adminConnection.connect('userCard@network')  // Connected.} catch(error){    // Add optional error handling here.}disconnectPromise disconnect(  )Disconnects this connection.securityContextReturnsPromise - A promise that will be resolved when the connection is terminated.ParametersNo parametersExample// Disconnect from a Business Networklet adminConnection = new AdminConnection();try {  await adminConnection.connect('userCard@network')  // Connected  await adminConnection.disconnect()  // and now disconnected.} catch(error){    // Add optional error handling here.}installPromise install( String businessnetworkdefinition, Object installoptions )Installs a business network as chaincode to Hyperledger Fabric in preparation for the business network to be started.The connection must be connected for this method to succeed.ReturnsPromise - A promise that will be fufilled when the business network has been installedParametersNameTypeMandatoryDescriptionbusinessNetworkDefinitionStringYesThe business network to be installedinstallOptionsObjectYesconnector specific install optionsExample// Install the Hyperledger Composer runtimelet adminConnection = new AdminConnection();let businessNetworkDefinition = BusinessNetworkDefinition.fromArchive(myArchive);try {   await adminConnection.connect('adminCard@hlfv1')   await adminConnection.install(businessNetworkDefinition);   // Business network installed} catch (error) {    // Add optional error handling here.}startPromise start( String networkname, String networkversion, [Object startoptions] )Starts a business network within the runtime previously installed to the Hyperledger Fabric with the same name as the business network to be started. The connection must be connected for this method to succeed.ReturnsPromise - A promise that will be fufilled when the business network has been deployed - with a MAP of cards key is nameParametersNameTypeMandatoryDescriptionnetworkNameStringYesName of the business network to startnetworkVersionStringYesVersion of the business network to startstartOptionsObjectYesconnector specific start options                  networkAdmins:   [ { userName, certificate, privateKey } , { userName, enrollmentSecret  }]Example// Start a Business Network Definitionlet adminConnection = new AdminConnection();try {    await adminConnection.connect('userCard@network')    await adminConnection.start(networkName, networkVersion,             { networkAdmins:                 [ {userName : 'admin', enrollmentSecret:'adminpw'} ]             }    // Business network definition is started} catch(error){    // Add optional error handling here.}resetPromise reset( String businessnetworkname )Resets an existing BusinessNetworkDefinition on the Hyperledger Fabric. The BusinessNetworkDefinition must have been previously deployed.Note this will remove ALL the contents of the network registries, but not any system registriesReturnsPromise - A promise that will be fufilled when the business network has been updated.ParametersNameTypeMandatoryDescriptionbusinessNetworkNameStringYesThe name of business network that will be resetExample// Resets a Business Network Definitionlet adminConnection = new AdminConnection();let businessNetworkDefinition = BusinessNetworkDefinition.fromArchive(myArchive);try {   await adminConnection.connect('userCard@network')   await adminConnection.reset('network-name')   // Business network data removed} catch(error){    // Add error handling here.}upgradePromise upgrade( string businessnetworkname, string businessnetworkversion, [object upgradeoptions] )Upgrades an existing business network to a later level.ReturnsPromise - A promise that will be fufilled when the composer runtime has been upgraded, or rejected otherwise.ParametersNameTypeMandatoryDescriptionbusinessNetworkNamestringYesThe name of the business networkbusinessNetworkVersionstringYesThe version of the business networkupgradeOptionsobjectYesconnector specific optionsExample// Upgrade the Hyperledger Composer runtimelet adminConnection = new AdminConnection();try {   await adminConnection.connect('PeerAdmin@hlfv1')   await adminConnection.upgrade('digitalproperty-network', '2.0.0');   // Business network definition upgraded} catch(error) =&gt; {   // Add error handling here.}undeployPromise undeploy( String businessnetworkname )Undeploys a business network.  Note: this this currently not supported with Hyperledger Fabric and will throw an error.ReturnsPromise - A promise that will be fufilled when the business network has been undeployed.ParametersNameTypeMandatoryDescriptionbusinessNetworkNameStringYesThe name of business network to remove.pingPromise ping(  )Test the connection to the runtime and verify that the version of the runtime is compatible with this level of the node.js module.ReturnsPromise - A promise that will be fufilled when the connection has been tested. The promise will be rejected if the version is incompatible.ParametersNo parametersExample// Test the connection to the runtimelet adminConnection = new AdminConnection();try {   await adminConnection.connect('userCard@network');   await adminConnection.ping();    // Connection has been tested} catch(error){    // Add error handling here.}setLogLevelPromise setLogLevel( any newloglevel )Set the logging level of a business network. The connection must be connected for this method to succeed.ReturnsPromise - A promise that resolves if successful.ParametersNameTypeMandatoryDescriptionnewLogLevelanyYesnew logging levelExample// Set the logging level of a business network.let adminConnection = new AdminConnection();try {   await adminConnection.connect('userCard@network')   await adminConnection.setLogLevel('DEBUG')   console.log('log level set to DEBUG');} catch(error){    // Add error handling here.}getLogLevelPromise getLogLevel(  )Get the current logging level of a business network. The connection must be connected for this method to succeed.ReturnsPromise - A promise that resolves with the current logging level if successful.ParametersNo parametersExample// Get the current logging level of a business network.let adminConnection = new AdminConnection();try {   await adminConnection.connect('userCard@network');   let currentLogLevel = await adminConnection.getLogLevel();    console.log('current log level is ' + currentLogLevel);} catch(error){    // Add error handling here.}listPromise list(  )List all of the deployed business networks. The connection must be connected for this method to succeed.ReturnsPromise - A promise that will be resolved with an array of business network identifiers, or rejected with an error.ParametersNo parametersExample// List all of the deployed business networks.let adminConnection = new AdminConnection();try {   await adminConnection.connect('userCard@network');   let businessNetworks = await adminConnection.list();   businessNetworks.forEach((businessNetwork) =&gt; {      console.log('Deployed business network', businessNetwork);   });} catch(error){    // Add error handling here.}getNativeAPIgetNativeAPI(  )Get the native API for this connection. The native API returned is specific to the underlying blockchain platform, and may throw an error if there is no native API available.ParametersNo parametersInherited methods",
        "url": "/composer/latest/api/admin-adminconnection"
      }
      ,
    
      "api-alldata": {
        "title": "API Class Index",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIIndex of ClassesCommon APIClient APIAdmin APIRuntime APICommon APINameDescriptionAssetDeclarationAssetDeclaration defines the schema (aka model or class) for an AssetBusinessNetworkCardStoreManages persistence of business network cardsBusinessNetworkDefinitionA BusinessNetworkDefinition defines a set of Participants that exchange Assets bysending Transactions.BusinessNetworkMetadataDefines the metadata for a BusinessNeworkDefinitionClassDeclarationClassDeclaration defines the structure (model/schema) of composite dataConceptResource is an instance that has a typeConceptDeclarationConceptDeclaration defines the schema (aka model or class) for an ConceptDecoratorDecorator encapsulates a decorator (annotation) on a class or propertyDecoratorFactoryAn interface for a class that processes a decorator and returns a specific implementation class for that decoratorEnumDeclarationEnumDeclaration defines an enumeration of static valuesEnumValueDeclarationClass representing a value from a set of enumerated valuesEventDeclarationClass representing the definition of an EventFactoryUse the Factory to create instances of Resource: transactions, participants and assetsFunctionDeclarationFunctionDeclaration defines a function that has been defined in a model fileIdCardBusiness Network Card to connect to a business networkIdentifiableIdentifiable is an entity with a namespace, type and an identifierIntrospectorProvides access to the structure of transactions, assets and participantsModelFileClass representing a Model FileModelManagerManages the Composer model filesParticipantDeclarationClass representing the definition of a ParticipantPropertyProperty representing an attribute of a class declaration, either a Field or a RelationshipRelationshipA Relationship is a typed pointer to an instanceRelationshipDeclarationClass representing a relationship between model elementsResourceResource is an instance that has a typeSerializerSerialize Resources instances to/from various formats for long-term storage (eTransactionDeclarationClass representing the definition of an TransactionTypedObject is an instance with a namespace and a typeValidatedConceptResource is an instance that has a typeValidatedResourceValidatedResource is a Resource that can validate that property changes (or the whole instance) do not violate the structure of the type information associated with the instanceClient APINameDescriptionAssetRegistryThe AssetRegistry is used to manage a set of assets stored on the BlockchainBusinessNetworkConnectionUse this class to connect to and then interact with a deployed {@link module:composer-commonHistorianThe Historian records the history of actions taken using ComposerIdentityRegistryThe IdentityRegistry is used to store a set of identities on the blockchainParticipantRegistryThe ParticipantRegistry is used to manage a set of participants stored on the blockchainQueryThe Query class represents a built queryRegistryClass representing an Abstract RegistryTransactionRegistryThe TransactionRegistry is used to store a set of transactions on the blockchainAdmin APINameDescriptionAdminConnectionThis class creates an administration connection to a Hyperledger Composer runtimeRuntime APINameDescriptionApiA class that contains the root of the transaction processor APIAssetRegistryAn asset registry manages a set of assets.FactoryA factory creates new instances of assets, participants, transactions,and relationships.ParticipantRegistryAn participant registry manages a set of participants.QueryA query represents a built query.SerializerA serializer serializes instances of assets, participants, transactions,and relationships to and from a JSON serialization format.",
        "url": "/composer/latest/api/allData"
      }
      ,
    
      "api-api-doc-index": {
        "title": "API Reference",
        "author": "",
        "category": "",
        "content": "Common API  -  Client API  -  Admin API  -  Runtime APIHyperledger Composer APIHyperledger Composer  is an application development framework for building Blockchain applications based on Hyperledger. This is the JavaScript documentation for the Hyperledger Composer Client, Admin, and Runtime JavaScript APIs.OverviewAll the classes are listed in the Class IndexThe major components of Hyperledger Composer are:The Hyperledger Composer language for describing the structure of resources (assets, participantsand transactions) that participate in a blockchain backed business network.JavaScript APIs to query, create, update and delete resources and submit transactionsfrom client applications. Hyperledger Composer resources are stored on the Blockchain.JavaScript transaction processor functions that runs on Hyperledger Fabric when transactions aresubmitted for processing. These functions may update the state of resourcesstored on the Blockchain via server-side Hyperledger Composer APIs.JavaScript language supportApplications that are using the client, admin APIs, or running inside a transaction function can be written to use ES6.As an example, it allows the use of the async/await syntax.  // connect using the 'newUserCard', create an asset, add it to a registry and get all assets.  try{    await businessNetworkConnection.connect('newUserCard');    let newAsset = factory.newAsset('org.example.basic','SampleAsset','1148');    await assestRegistry.add(newAsset);    result = await assetRegistry.getAll();    LOG.info(result);    await businessNetworkConnection.disconnect();  } catch (error){      // error handling  }The promise chain syntax can also be used however it is highly recommended to use async/await.Using promises the example above would be:  // connect using the 'newUserCard', create an asset, add it to a registry and get all assets.  return businessNetworkConnection.connect('newUserCard')    .then( function()  {        var newAsset = factory.newAsset('org.example.basic','SampleAsset','1148');        return assetRegistry.add(newAsset);    })    .then( function() {       return assetRegistry.getAll();    })    .then( function(result) {        LOG.info(result);        return businessNetworkConnection.disconnect();    })    .catch( function (error){      // error handling    });Admin and Client APIThese APIs are specifically used to obtain connect to a Business Network Connection to either administer it, or obtain the resources to perform business operations. Business operations could be to add assets, or submit transaction functions.The starting point for these APIs are the AdminConnection or BusinessNetworkConnection. Both APIs follow a similar pattern to connect.A name of an already imported business network card is needed. By default these cards are ready from the file system card store.const AdminConnection = require('composer-admin').AdminConnection;let adminConnection = new AdminConnection();await adminConnection.connect('cardNameToUse');//const BusinessNetworkConnection = require('composer-client').BusinessNetworkConnection;let bizNetConnection = new BusinessNetworkConnection();let businessNetworkDefintion = await bizNetConnection.connect('cardNameToUse');RegistriesA key part of the Client API is are the Regsitry classes. There are the AssetRegsitry, ParticipantRegistry, IdentityRegistry, TransactionRegistries and the Historian. Each of these have a common super type of Registry.The Registry supports accessing a registry to obtain resources.Add one or more resourcesUpdate one or more resourcesRemove one or all resourcesGet one or all resourcesCheck if a resource existsResolve one or all resourcesThe difference between resolve and get are that get will no resolve any relationships that are defined in the resource. A reference to the resource will be supplied. A resolve call will iterate over all the relationships.Registries are automatically created for each asset, participnat, and transaction. Additional registries can be created if required using the addRegistry call.Common APIThe Common API contains the APIs used to obtain information about the Business Network you are conencted to and to create new assets, participants, transactions and events. It also provides APIs to find out information about these resources.For example to create a new assetlet factory = this.businessNetworkDefinition.getFactory();owner = factory.newResource('net.biz.digitalPropertyNetwork', 'Person', 'PID:1234567890');owner.firstName = 'Fred';owner.lastName = 'Bloggs';Runtime APIThe Runtime API is the available API to all transaction functions. It allows access to APIs to- build and issue queries- emit events- get registries of all types- get the current participant- get the serializer to create resources from JavaScript objects- post HTTP REST callsThe Common API calls are also available to interact with resources, together with the Registry APIs. For each// Get the driver participant registry.try {    let driverParticipantRegistry = await getParticipantRegistry('org.example.Driver');    // Call methods on the driver participant registry.} catch(error) {    // Add optional error handling here.}Transaction FunctionsThe transaction function is the part of Composer that can be considered to be the smart contract execution. It will invoked from a client application application (or via a REST API). It will work on the state of assets, participant etc as held within the underling blockchain worldstate. The operations performed by the transaction function, will then be subject to the endorsment and order protocols as established by the the same underlying blockchain. As such the source of truth of the assets is maintained.Definition of the transaction functions is within the .cto model file.namespace net.biz.digitalPropertyNetworktransaction RegisterPropertyForSale identified by transactionId{  o String transactionId  --&gt; LandTitle title}This is then linked to the implementation of the transaction function by annotations in the comment of the function.  @transaction marks this function as a transaction function. @param connects this transaction to the RegisterPropertyForSale defined in the model./** * @param {net.biz.digitalPropertyNetwork} registryProperty * @transaction */function codeToImplementatTheTransactionFunction(registryProperty){ //}The function argument registryProperty for sale will be a fully resolved copy of the transaction resource. The --&gt; LandTitle title in this example would be a fully resolved LandTitle resource.RestrictionsTransaction functions should not try to write non deterministic values to the world state. These include but are not limited to random numbers and date/time valuesAdditional transactions can not be submitted from the implementation of a transaction function. Other functions can be called but will be considered as part the same transaction. This is irrespective of the annotations of the function called.Always use getCurrentParticipant() to get the details of the invoking participant",
        "url": "/composer/latest/api/api-doc-index"
      }
      ,
    
      "applications-applications-index": {
        "title": "Developing Applications",
        "author": "",
        "category": "start",
        "content": "Developing ApplicationsHyperledger Composer supports creating web, mobile or native Node.js applications. It includes the composer-rest-server (itself based on LoopBack technology) to automatically generate a REST API for a business network, and the hyperledger-composer code generation plugin for the Yeoman framework to generate a skeleton Angular application.In addition it includes a rich set of JavaScript APIs to build native Node.js applications.Writing a Node.js applicationDeveloping Node.js applications to work with Hyperledger Composer allows you to  programmatically connect to a deployed business network, create, read, update and delete assets and participants and to submit transactions.Writing Web applicationsWeb applications that need to interact with deployed business networks should make calls to a REST API. The easiest way to create the REST API is to use the composer-rest-server to dynamically generate a REST API from the deployed business network.Subscribing to eventsNode.js applications can subscribe to events from a business network by using the composer-client.BusinessNetworkConnection.on API call. Events are defined in the business network model file and are emitted by specified transactions in the transaction processor function file.ReferencesYeoman Code GeneratorAngular Framework",
        "url": "/composer/latest/applications/applications-index"
      }
      ,
    
      "business-network-bnd-create": {
        "title": "Create a Business Network Definition",
        "author": "",
        "category": "tasks",
        "content": "Create a Business Network DefinitionA business network definition has the following layout:models/ (optional)lib/permissions.acl (optional)package.jsonREADME.md (optional)The easiest way to create a new business network definition is to either git clone an example, or to use the Hyperledger Composer Yeoman generator to create a skeleton business network.README.mdA description of the purpose of the business network using the Markdown mark-up language.Package.jsonA Business Network Definition has a name (limited to basic ASCII alphanumeric characters and -), a human-readable description and a version number. The version number for the network should take the form Major.Minor.Micro andSemantic Versioning principles should be used when incrementing the version number.The identifier of the network is formed from its name, the - character and its version number. A valid identifier (and example) is therefore mybusinessnetwork-1.0.3.The metadata for a business network definition is read from package.json, meaning that business network definitions may also be valid npm packages.ModelsThe set of domain models for a business network definition define the types that are valid within the network and outside the network when it is integrated with external systems (for example systems that submit transactions to the network).A domain model may either be packaged within the business network definition (typically stored under the models directory), or may be declared in package.json as an external dependency. You refer to models via an npm dependency if you wanted to share them across business network definitions.ScriptsThe scripts for a business network definition are typically stored under the lib directory and are packaged within the business network definition. The scripts are written in ES 5 JavaScript and refer to the types that are defined in the domain models for the business network.Permissions.aclThe permissions for the business network expressed are expressed in an optional permissions.acl file.Cloning an Example Business Network DefinitionThe sample business network definitions are stored on GitHub at https://github.com/hyperledger/composer-sample-networks. You can git clone this repository to pull down all the sample networks. Each sample network is stored under the packages directory.Generating a Business Network DefinitionGenerationyo hyperledger-composer? Please select the type of project: (Use arrow keys)❯ Angular  Business Network  ModelAnd select Business NetorkAnswer all of the questionsWelcome to the Hyperledger Composer project generator? Please select the type of project: Business NetworkYou can run this generator using: 'yo hyperledger-composer:businessnetwork'Welcome to the business network generator? Business network name: mynetwork? Description: This is my test network? Author name:  Mr Conga? Author email: conga@congazone.org? License: Apache-2? Namespace: org.conga   create package.json   create permissions.acl   create README.md   create models/org.conga.cto   create .eslintrc.yml   create features/sample.feature   create features/support/index.js   create test/logic.js   create lib/logic.jsThis generates a skeleton business network with an asset, participant and transaction defined, as well as a mocha unit test.Also included, is a &#39;best practice&#39; eslint config file which defines sample linting rules for JS code.ReferencesModeling LanguageAccess Control LanguageTransaction Processor Functions",
        "url": "/composer/latest/business-network/bnd-create"
      }
      ,
    
      "business-network-bnd-deploy": {
        "title": "Deploying Business Networks",
        "author": "",
        "category": "tasks",
        "content": "Deploying Business NetworksBefore a business network definition can be deployed it must be packaged into a Business Network Archive (.bna) file. The composer archive create command is used to create a business network archive file from a business network definition folder on disk.Once the business network archive file has been created it can be deployed to Hyperledger Fabric using the composer network install command followed by a composer network start command.For example:composer network install --archiveFile tutorial-network@1.0.0.bna --card PeerAdmin@fabric-networkcomposer network start --networkName tutorial-network --networkVersion 1.0.0 --card PeerAdmin@fabric-network --networkAdmin admin --networkAdminEnrollSecret adminpwTo upgrade the business network definition for an already deployed business network use the composer network upgrade CLI command.Deploying business networks to Hyperledger Fabric v1.2In Hyperledger Fabric v1.2, peers enforce the concepts of administrators and members. Administrators have permission to install Hyperledger Fabric chaincode for a new business network onto peers. Members do not have permission to install chaincode. In order to deploy a business network to a set of peers, you must provide an identity that has administrative rights to all of those peers.To make that identity and its certificates available, you must create a Peer Admin business network card using the certificate and private key associated with the peer admin identity.Hyperledger Composer provides a sample Hyperledger Fabric v1.2 network. The peer administrator for this network is called PeerAdmin, and the identity is automatically imported for you when you use the sample scripts for starting the network. Please note that the peer administrator may be given a different name for other Hyperledger Fabric networks.Important: When deploying a business network to Hyperledger Fabric v1.2 a bootstrap registrar is defined in the Hyperledger Fabric Certificate Authority (CA) configuration. The Hyperledger Composer development environment contains a preconfigured instance of Hyperledger Fabric with a specific enrollment ID and enrollment secret for the bootstrap registrar.Business network administratorsWhen you deploy a business network, access controls are enforced as per the access control rules specified in the business network definition. Each business network must have at least one participant, and that participant must have a valid identity for accessing the business network. Otherwise, client applications cannot interact with the business network.A business network administrator is a participant who is responsible for configuring the business network for their organisation after the business network is deployed, and is responsible for on-boarding other participants from their organisation. Because business networks include multiple organisations, there should be multiple business network administrators for any given business network.A built-in participant type, org.hyperledger.composer.system.NetworkAdmin, representing a business network administrator is provided by Hyperledger Composer. This built-in participant type does not have any special permissions; they are still subject to the access control rules specified in the business network definition. For this reason, it is recommended that you start with the following sample access control rules that grant business network administrators full access to a business network:rule NetworkAdminUser {    description: \"Grant business network administrators full access to user resources\"    participant: \"org.hyperledger.composer.system.NetworkAdmin\"    operation: ALL    resource: \"**\"    action: ALLOW}rule NetworkAdminSystem {    description: \"Grant business network administrators full access to system resources\"    participant: \"org.hyperledger.composer.system.NetworkAdmin\"    operation: ALL    resource: \"org.hyperledger.composer.system.**\"    action: ALLOW}By default, Hyperledger Composer will automatically create a single business network administrator participant during deployment. The identity that is used for deploying the business network will also be bound to that business network administrator participant, so that identity can be used to interact with the business network after deployment.Hyperledger Fabric peer administrators may not have permission to issue new identities using the Hyperledger Fabric Certificate Authority (CA). This may restrict the ability of the business network administrator to on-board other participants from their organisation. For this reason, it may be preferable to create a business network administrator that does have permission to issue new identities using the Hyperledger Fabric Certificate Authority (CA).You can use additional options to the composer network start command to specify the business network administrators that should be created during the deployment of the business network.If the business network administrator has an enrollment ID and enrollment secret, you can use the -A (business network administrator) and -S (business network administrator uses enrollment secret) flags. For example, the following command will create a business network administrator for the existing admin enrollment ID:composer network start --networkName tutorial-network --networkVersion 1.0.0 --c PeerAdmin@fabric-network -A admin -S adminpwDeploying business networks using Playground locallyPlease note: When using a local Playground instance to deploy a business network to Hyperledger Fabric v1.2, as part of the deployment process you must choose how to provide credentials for the initial business network participant. The initial participant will be a NetworkAdmin.When deploying a business network using playground, you will be prompted to enter the credentials for the initial participant. Credentials can be provided either as a certificate or as a pre-defined enrollment ID and enrollment secret. If you are using the instance of Hyperledger Fabric set up in the Hyperledger Composer development environment, the bootstrap registrar enrollment ID is admin and the bootstrap registrar enrollment secret is adminpw.  This initial participant uses the credentials set for the bootstrap registrar in the Hyperledger Fabric Certificate Authority (CA), and will be a NetworkAdmin.When deploying a business network using Playground locally, you must have at least one business network card with the PeerAdmin role and at least one business network card with the ChannelAdmin role. Each of these business network cards must contain the correct admin certificates.ReferencesComposer CLI commands",
        "url": "/composer/latest/business-network/bnd-deploy"
      }
      ,
    
      "business-network-bnd-publish": {
        "title": "Publish Models or Business Network Definitions",
        "author": "",
        "category": "tasks",
        "content": "Publish Models or Business Network Definitions for use by applicationsHyperledger Composer can optionally use the npm package manager to publish both business networks, and models. By publishing business networks to npm applications that need to reference the business networks (for example to introspect them, or deploy them) can declare a binary package dependency on the published npm package. Using semantic versioning of the npm package for the business network also allows applications to specify their tolerance for accepting incompatible changes to the business network.The npm package manager is a powerful (Internet scale) mechanism to distribute any binaries, along with metadata expressed in a package.json file.Similarly, a set of Composer domain models (CTO files) may be packaged into an npm package for publication. The ability to publish models allows the models to be reused across multiple business networks (by declaring a package.json dependency), as well as ensures that semantic versioning can be used to control the evolution of the models themselves.However, publication to npm is not required to use Composer. You may bundle a business network inside an application, and simply manage its source files using version control software, such as git.The easiest way to publish a model or business network definition for use by applications it to push the business network definition to the npm package manager using the npm publish command. This will allow the applications that would like to use the business network definition (for example to deploy it via API) to reference the business network definition as a dependency in their package.json file.ReferencesExample business network published to npmExample model published to npm",
        "url": "/composer/latest/business-network/bnd-publish"
      }
      ,
    
      "business-network-business-network-index": {
        "title": "Developing Business Networks",
        "author": "",
        "category": "concepts",
        "content": "Developing Business NetworksDevelopers use Hyperledger Composer to digitize business networks. The business network is accessed by multiple participants in the network, some of which may be responsible for the maintenance (hosting) of the network itself, referred to as maintainers of the network.Typically each maintainer of the network will run several peer nodes (for crash fault tolerance) and Hyperledger Fabric replicates the distributed ledger across the set of peer nodes.ModelDevelopers work with business analysts to define the domain data model for the business network. The data model is expressed using the Composer Modeling Language and defines the structure of the resources that will be stored on the ledger, or processed as transactions.Once the domain model is in place, developers can capture smart contracts as executable transaction processor functions, written in JavaScript.Access ControlIn parallel developers or technical analysts can define the access control rules for the business network, to enforce which participants have access to the data on the ledger and under which conditions.DeployDevelopers package the models, scripts and access control rules into a deployable Business Network Archive and use command line tools to deploy the archive to a runtime for testing.TestLike all business logic, it is important to create unit and system tests for business networks. Developers can use popular JavaScript testing frameworks such as Mocha and Chai to run unit tests (against the Node.js embedded runtime) or run system tests against a Hyperledger Fabric.IntegrateOnce the business network is tested and in place, front-end applications need to be created. Use the  REST Server to automatically generate a REST API for a business network, and then a skeleton generate Angular application using the Yeoman code generator.The REST Server can be configured to authenticate the participants in the business network, ensuring that credentials and permissions are enforced.ReferencesModeling LanguageAccess Control LanguageTransaction Processor Functions",
        "url": "/composer/latest/business-network/business-network-index"
      }
      ,
    
      "introduction-businessnetworkdefinition": {
        "title": "Hyperledger Composer - Business Network Definition",
        "author": "",
        "category": "concepts",
        "content": "Business Network DefinitionBusiness Network Definitions are a key concept of the Hyperledger Composer programming model. They are represented by the BusinessNetworkDefinition class, defined in the composer-common module and exported by both composer-admin and composer-client.Business Network Definitions are composed of:a set of model filesa set of JavaScript filesThe model files defined the business domain for a business network, while the JavaScript files contain transaction processor functions. The transaction processor functions run on a Hyperledger Fabric and have access to the asset registries that are stored in the world state of the Hyperledger Fabric blockchain.The model files are typically created by business analysts, as they define the structure and relationships between model elements: assets, participants and transactions.The JavaScript files are typically created by developers who are implementing business requirements provided by business analysts.Once defined, a Business Network Definition can be packaged into an archive using the composer command line interface. These archives can then be deployed or updated on a Fabric, using the AdminConnection class from the composer-admin module.",
        "url": "/composer/latest/introduction/businessnetworkdefinition"
      }
      ,
    
      "business-network-businessnetworkdefinition": {
        "title": "Business Network Definitions",
        "author": "",
        "category": "concepts",
        "content": "Business Network DefinitionThe Business Network Definition is a key concept of the Hyperledger Composer programming model. They are represented by the BusinessNetworkDefinition class, defined in the composer-common module and exported by both composer-admin and composer-client.Business Network Definitions are composed of:a set of model filesa set of JavaScript filesan Access Control fileThe model files defined the business domain for a business network, while the JavaScript files contain transaction processor functions. The transaction processor functions run on a Hyperledger Fabric and have access to the asset registries that are stored in the world state of the Hyperledger Fabric blockchain.The model files are typically created by business analysts, as they define the structure and relationships between model elements: assets, participants and transactions.The JavaScript files are typically created by developers who are implementing business requirements provided by business analysts.The Access Control file contains a set of access control rules that define the rights of the different participants in the business network.Once defined, a Business Network Definition can be packaged into an archive using the composer command line interface. These archives can then be deployed or updated on a Fabric, using the AdminConnection class from the composer-admin module.ReferencesModeling LanguageAccess Control LanguageTransaction Processor Functions",
        "url": "/composer/latest/business-network/businessnetworkdefinition"
      }
      ,
    
      "integrating-call-out": {
        "title": "Calling external HTTP or REST services",
        "author": "",
        "category": "start",
        "content": "Calling an HTTP or REST API from Transaction Processor FunctionsIn some cases it is desirable to be able to call HTTP or REST APIs from transaction processor functions. This allows you to move complex or expensive computation from the blockchain to a centrally or peer hosted service.Alternatively, a transaction processor function may wish to call third party HTTP or REST APIs that provides external data. For example, a third party API may provide data about the current price of a stock, or the current weather and temperature, which can be used to determine whether or not the conditions of a contract have been fulfilled.Hyperledger Composer allows a transaction processor function developer to call an HTTP or REST API from within a transaction processor function.Please note that using this function can lead to errors that are caused by consensus failures, and should only be used with care. For more information, see Consensus considerations below.Using the request moduleThe request module (https://github.com/request/request), is a popular HTTP client used by many Node.js applications. Hyperledger Composer embeds the request module, so that transaction processor functions can use it to make calls to HTTP or REST APIs.The standard request module uses a callback oriented API. However, transaction processor functions are promise based, and callback oriented APIs result in a lot of unnecessary code to wrap the callbacks in promises. To make the experience easier for transaction processor function developers, we have exposed the promise based request-promise module (https://github.com/request/request-promise) instead.The request-promise module is automatically available to all transaction processor functions via the request global variable. You do not need to add the request or request-promise modules to your package.json file, nor do you need to use the require function to load the modules.The global request method and all of the convenience methods for the various HTTP methods (request.get, request.post, etc.) are available to transaction processor functions. These methods provide a full set of options for handling request bodies, response bodies, HTTP headers, authentication, cookies, proxies, and TLS/SSL.For detailed information on these methods and the options available, please review the documentation for the request and request-promise modules.ExamplesMake an HTTP GET request to an HTTP server that returns the current stock price as a string:/** * Buy a given amount of CONGA stocks. * @param {org.example.BuyStocks} transaction The transaction. * @transaction */async function buyStocks(transaction) {    // Look up the current price of the CONGA stock, and parse it into a float.    const priceAsStr = await request.get('http://stocks.org/CONGA');    const price = parseFloat(priceAsStr);    // Get the current participant, and update their stock and balance.    const participant = getCurrentParticipant();    const units = transaction.units;    participant.stockUnits += units;    participant.balance -= price * units;    // Update the current participant in the participant registry.    const participantRegistry = await getParticipantRegistry('org.example.Trader');    await participantRegistry.update(participant);}Make an HTTP GET request to an HTTP server that returns the current stock price as a JSON structure:/** * Buy a given amount of CONGA stocks. * @param {org.example.BuyStocks} transaction The transaction. * @transaction */async function buyStocks(transaction) {    // Look up the current price of the CONGA stock, and extract the price.    // The option \"json: true\" automatically parses JSON from the HTTP response.    const stock = await request.get({ uri: 'http://stocks.org/CONGA', json: true });    const price = stock.price;    // Get the current participant, and update their stock and balance.    const participant = getCurrentParticipant();    const units = transaction.units;    participant.stockUnits += units;    participant.balance -= price * units;    // Update the current participant in the participant registry.    const participantRegistry = await getParticipantRegistry('org.example.Trader');    await participantRegistry.update(participant);}Make an HTTP POST request to an HTTP server that includes the current participant as the HTTP request body, and returns the current stock price as a string:/** * Buy a given amount of CONGA stocks. * @param {org.example.BuyStocks} transaction The transaction. * @transaction */async function buyStocks(transaction) {    // Get the current participant.    const participant = getCurrentParticipant();    // Look up the current price of the CONGA stock, and extract the price.    // The option \"json\" sends the participant as the HTTP request body,    // and automatically parses JSON from the HTTP response.    const stock = await request.post({ uri: 'http://stocks.org/CONGA', json: participant });    const price = stock.price;    // Get the current participant, and update their stock and balance.    const units = transaction.units;    participant.stockUnits += units;    participant.balance -= price * units;    // Update the current participant in the participant registry.    const participantRegistry = await getParticipantRegistry('org.example.Trader');    await participantRegistry.update(participant);}Make an HTTP POST request to an HTTP server that returns a serialized instance of a stock asset:/** * Buy a given amount of CONGA stocks. * @param {org.example.BuyStocks} transaction The transaction. * @transaction */async function buyStocks(transaction) {    // Look up the current price of the CONGA stock, and extract the price.    // The option \"json: true\" automatically parses JSON from the HTTP response.    const json = await request.get({ uri: 'http://stocks.org/CONGA', json: true });    // Parse the JavaScript object into the stock asset.    const serializer = getSerializer();    const stock = serializer.fromJSON(json);    const price = stock.price;    // Get the current participant, and update their stock and balance.    const participant = getCurrentParticipant();    const units = transaction.units;    participant.stockUnits += units;    participant.balance -= price * units;    // Update the current participant in the participant registry.    const participantRegistry = await getParticipantRegistry('org.example.Trader');    await participantRegistry.update(participant);}Consensus considerationsIn Hyperledger Fabric, consensus in a business network is achieved by having peer nodes in multiple organisations endorse transactions. Transactions are endorsed by executing chaincode, and signing the results of that execution. In order for the transaction to be committed by the blockchain network, all peer nodes endorsing the transaction must produce the same results from executing chaincode.When a business network makes an HTTP request using the APIs described above, those HTTP requests will be executed on all peer nodes endorsing the transaction. This will result in n HTTP requests, where n is the number of peer nodes endorsing the transaction.In order for consensus to be achieved when business networks make HTTP requests, you must be careful to ensure that transaction processor functions make the same HTTP requests on all peer nodes, and then perform the same processing on the HTTP responses on all peer nodes.For example, consider a business network that uses an HTTP request to look up a stock price from an external symbol. The business network then uses the stock price to adjust the balance on a participants account. If different peer nodes receive different stock prices, then they will attempt to make different adjustments to the balance on the participants account. This will result in a consensus failure, and the transaction being rejected.HTTP requests may result in different responses for multiple reasons:Peer nodes in different organisations may run in different data centers, in different countries, in different time zones.Peer nodes in different organisations may not have access to the HTTP server depending on public internet access and firewall restrictions.Peer nodes in different organisations may authenticate to the HTTP server as different users, resulting in different HTTP responses.In order to minimize the risks of consensus failures when making HTTP requests from a transaction processor function, it is recommended you use make HTTP requests that are either:Safe, in that the HTTP request does not modify any state on the HTTP server.Idempotent, in that the same HTTP request can be made many times without different outcomes.CORS (Cross-Origin Resource Sharing)Business networks deployed to the Web Browser connection from the Hyperledger Composer Playground run inside the web browser. When transaction processor functions inside these business networks make HTTP requests using the APIs described above, those HTTP requests are handled using the HTTP client built into the web browser.HTTP clients built into the web browser require that the HTTP server is CORS (Cross-Origin Resource Sharing) compliant. If you deploy business networks to the Web Browser connection, then you must ensure that the HTTP server has been configured to be CORS compliant. For more information, see: https://enable-cors.orgDocker Network ResolutionBusiness networks deployed to Hyperledger Fabric run within a chaincode Docker container. This means that the business networks are subject to the DNS resolution and network services provided by Docker, instead of those services provided by the host machine. Additionally, the chaincode Docker container has its own IP address.This means that localhost resolves to the chaincode Docker container, rather than the host machine. Any HTTP requests made to localhost, for example http://localhost:3000/api/Vehicle, will not work as expected. The easiest workaround is to use a DNS name for your REST server that is publicly resolvable.",
        "url": "/composer/latest/integrating/call-out"
      }
      ,
    
      "api-client-assetregistry": {
        "title": "AssetRegistry (Client API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIAssetRegistryThe AssetRegistry is used to manage a set of assets stored on the Blockchain.Applications should retrieve instances from BusinessNetworkConnectionDetailsExtends RegistryModule clientSee alsoSee RegistryInherited Method SummarySupertypeNameReturnsDescriptionRegistryremovePromiseRemove an asset with a given type and id from the registryRegistryaddAllPromiseAdds a list of new resources to the registryRegistryupdateAllPromiseUpdates a list of resources in the registryRegistryupdatePromiseUpdates a resource in the registryRegistryremoveAllPromiseRemoves a list of resources from the registryRegistryaddPromiseAdds a new resource to the registryRegistrygetAllPromiseGet all of the resources in the registryRegistrygetPromiseGet a specific resource in the registryRegistryexistsPromiseDetermines whether a specific resource exists in the registryRegistryresolveAllPromiseGet all of the resources in the registry, and resolve all of their relationships to other assets, participants, and transactionsRegistryresolvePromiseGet a specific resource in the registry, and resolve all of its relationships to other assets, participants, and transactionsMethod DetailsInherited methodsaddAllPromise addAll(  resources )Inherited from:  RegistryAdds a list of new resources to the registry.ReturnsPromise - A promise that will be resolved when the resource is added to the registry.ParametersNameTypeMandatoryDescriptionresourcesYesThe resources to be added to the registry.addPromise add( Resource resource )Inherited from:  RegistryAdds a new resource to the registry.ReturnsPromise - A promise that will be resolved when the resource is added to the registry.ParametersNameTypeMandatoryDescriptionresourceResourceYesThe resource to be added to the registry.updateAllPromise updateAll(  resources )Inherited from:  RegistryUpdates a list of resources in the registry.ReturnsPromise - A promise that will be resolved when the resource is added to the registry.ParametersNameTypeMandatoryDescriptionresourcesYesThe resources to be updated in the asset registry.updatePromise update( Resource resource )Inherited from:  RegistryUpdates a resource in the registry.ReturnsPromise - A promise that will be resolved when the resource is updated in the registry.ParametersNameTypeMandatoryDescriptionresourceResourceYesThe resource to be updated in the registry.removeAllPromise removeAll( Resource[]; string[] resources )Inherited from:  RegistryRemoves a list of resources from the registry.ReturnsPromise - A promise that will be resolved when the resource is added to the registry.ParametersNameTypeMandatoryDescriptionresourcesResource[]; string[]YesThe resources, or the unique identifiers of the resources.removePromise remove( Resource; string resource )Inherited from:  RegistryRemove an asset with a given type and id from the registry.ReturnsPromise - A promise that will be resolved when the resource is removed from the registry.ParametersNameTypeMandatoryDescriptionresourceResource; stringYesThe resource, or the unique identifier of the resource.getAllPromise getAll(  )Inherited from:  RegistryGet all of the resources in the registry.ReturnsPromise - A promise that will be resolved with an array of JSON objects representing the resources.ParametersNo parametersgetPromise get( string id )Inherited from:  RegistryGet a specific resource in the registry.ReturnsPromise - A promise that will be resolved with a JSON object representing the resource.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the resource.existsPromise exists( string id )Inherited from:  RegistryDetermines whether a specific resource exists in the registry.ReturnsPromise - A promise that will be resolved with true/false depending on whether the resource exists.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the resource.resolveAllPromise resolveAll(  )Inherited from:  RegistryGet all of the resources in the registry, and resolve all of their relationships to other assets, participants, and transactions. The result is a JavaScript object, and should only be used for visualization purposes. You cannot use the add or update functions with a resolved resource.ReturnsPromise - A promise that will be resolved with an array of JavaScript objects representing the resources and all of their resolved relationships.ParametersNo parametersresolvePromise resolve( string id )Inherited from:  RegistryGet a specific resource in the registry, and resolve all of its relationships to other assets, participants, and transactions. The result is a JavaScript object, and should only be used for visualization purposes. You cannot use the  add or update functions with a resolved resource.ReturnsPromise - A promise that will be resolved with a JavaScript object representing the resource and all of its resolved relationships.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the asset.",
        "url": "/composer/latest/api/client-assetregistry"
      }
      ,
    
      "api-client-businessnetworkconnection": {
        "title": "BusinessNetworkConnection (Client API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIBusinessNetworkConnectionUse this class to connect to and then interact with a deployedBusiness Network Definition.Use the AdminConnection class in the composer-admin module to deployBusinessNetworksDefinitions.DetailsExtends EventEmitterModule clientMethod SummaryNameReturnsDescriptionaddAssetRegistryPromiseAdds a new asset registryaddParticipantRegistryPromiseAdds a new participant registryassetRegistryExistsPromiseDetermines whether an asset registry existsbindIdentityPromiseBind an existing identity to the specified participantbuildQueryQueryBuild a query ready for later executionconnectPromiseConnects to a business network using a business network card, and authenticates to the Hyperledger FabricconstructorvoidCreates an instance of the BusinessNetworkConnection classdisconnectPromiseDisconnects from the Hyperledger FabricgetAllAssetRegistriesPromiseGets a list of all existing asset registriesgetAllParticipantRegistriesPromiseGets a list of all existing participant registriesgetAllTransactionRegistriesPromiseGets a list of all existing transaction registriesgetAssetRegistryPromiseGets an existing asset registrygetBusinessNetworkBusinessNetworkDefinitionGets the currently connected business networkgetHistorianPromiseGets the historiangetIdentityRegistryPromiseGets the identity registrygetNativeAPIvoidGet the native API for this connectiongetParticipantRegistryPromiseGets an existing participant registrygetRegistryPromiseGiven a fully qualified name, works out and looks up the registry that this resource will be found ingetTransactionRegistryPromiseGets an existing transaction registryissueIdentityPromiseIssue an identity with the specified name and map it to the specified participantparticipantRegistryExistsPromiseDetermines whether a participant registry existspingPromiseTest the connection to the runtime and verify that the version of the runtime is compatible with this level of the client nodequeryPromiseExecute a query defined in a Composer query file, or execute a query built with buildQueryrevokeIdentityPromiseRevoke the specified identity by removing any existing mapping to a participantsubmitTransactionPromiseSubmit a transaction for processing by the currently connected business networktransactionRegistryExistsPromiseDetermines whether a transaction registry existsMethod Detailsnew BusinessNetworkConnection()Creates an instance of the BusinessNetworkConnection class. Must be called to connect to a deployed BusinessNetworkDefinition.ParametersNameTypeMandatoryDescriptionoptionsObjectYesan optional set of options to configure the instance.Sub-optionsNameTypeMandatoryDescriptionoptions.cardStoreBusinessNetworkCardStoreYesspecify a card store implementation to use.getBusinessNetworkBusinessNetworkDefinition getBusinessNetwork(  )Gets the currently connected business network. Business Network Definition.ReturnsBusinessNetworkDefinition - the business network definitionParametersNo parametersExampleconst connection = new BusinessNetworkConnection();const definition = await connection.connect('admin@network-name');console.log(definition === connection.getBusinessNetwork());  // truegetAllAssetRegistriesPromise getAllAssetRegistries( [boolean includesystem] )Gets a list of all existing asset registries.ReturnsPromise - A promise that will be resolved with a list of existing asset registries.ParametersNameTypeMandatoryDescriptionincludeSystembooleanYesif true the returned list will include the system transaction registries (optional, default to false)Exampleconst connection = new BusinessNetworkConnection();await connection.connect('admin@network-name');const assetRegistries = await connection.getAllAssetRegistries();getAssetRegistryPromise getAssetRegistry( string id )Gets an existing asset registry.ReturnsPromise - A promise that will be resolved with the existing AssetRegistry, or rejected if it does not exist.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the asset registryExampleconst connection = new BusinessNetworkConnection();await connection.connect('admin@network-name');const sampleAssetRegistry = await connection.getAssetRegistry('org.example.SampleAsset');assetRegistryExistsPromise assetRegistryExists( string id )Determines whether an asset registry exists.ReturnsPromise - A promise that will be resolved with a boolean indicating whether the AssetRegistry exists.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the asset registryExampleconst connection = new BusinessNetworkConnection();await connection.connect('admin@network-name');const exists = await connection.assetRegistryExists('org.example.SampleAsset');if (exists) {    // logic here...}addAssetRegistryPromise addAssetRegistry( string id, string name )Adds a new asset registry.ReturnsPromise - A promise that will be resolved with the new AssetRegistry after it has been added.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the asset registrynamestringYesThe name of the asset registryExampleconst connection = new BusinessNetworkConnection();await connection.connect('admin@network-name');await connection.addAssetRegistry('registryId', 'registryName');getAllParticipantRegistriesPromise getAllParticipantRegistries( [boolean includesystem] )Gets a list of all existing participant registries.ReturnsPromise - A promise that will be resolved with a list of existing participant registries.ParametersNameTypeMandatoryDescriptionincludeSystembooleanYesif true the returned list will include the system transaction registries (optional, default to false)Exampleconst connection = new BusinessNetworkConnection();await connection.connect('admin@network-name');const participantRegistries = await connection.getAllParticipantRegistries();getParticipantRegistryPromise getParticipantRegistry( string id )Gets an existing participant registry.ReturnsPromise - A promise that will be resolved with the existing ParticipantRegistry, or rejected if it does not exist.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the participant registryExampleconst connection = new BusinessNetworkConnection();await connection.connect('admin@network-name');const sampleParticipantRegistry = await connection.getParticipantRegistry('org.example.SampleParticipant');participantRegistryExistsPromise participantRegistryExists( string id )Determines whether a participant registry exists.ReturnsPromise - A promise that will be resolved with a boolean indicating whether the ParticipantRegistry exists.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the participant registryExampleconst connection = new BusinessNetworkConnection();await connection.connect('admin@network-name');const exists = await connection.participantRegistryExists('org.example.SampleParticipant');if (exists) {    // logic here...}addParticipantRegistryPromise addParticipantRegistry( string id, string name )Adds a new participant registry.ReturnsPromise - A promise that will be resolved with the new ParticipantRegistry after it has been added.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the participant registrynamestringYesThe name of the participant registryExampleconst connection = new BusinessNetworkConnection();await connection.connect('admin@network-name');await connection.addParticipantRegistry('registryId', 'registryName');getTransactionRegistryPromise getTransactionRegistry( string id )Gets an existing transaction registry.ReturnsPromise - A promise that will be resolved with the existing TransactionRegistry, or rejected if it does not exist.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the transaction registryExampleconst connection = new BusinessNetworkConnection();await connection.connect('admin@network-name');const sampleTransactionRegistry = await connection.getTransactionRegistry('org.example.SampleTransaction');getAllTransactionRegistriesPromise getAllTransactionRegistries( [boolean includesystem] )Gets a list of all existing transaction registries.ReturnsPromise - A promise that will be resolved with a list of existing transaction registries.ParametersNameTypeMandatoryDescriptionincludeSystembooleanYesif true the returned list will include the system transaction registries (optional, default to false)Exampleconst connection = new BusinessNetworkConnection();await connection.connect('admin@network-name');const transactionRegistries = await connection.getAllTransactionRegistries();transactionRegistryExistsPromise transactionRegistryExists( string id )Determines whether a transaction registry exists.ReturnsPromise - A promise that will be resolved with a boolean indicating whether the TransactionRegistry exists.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the transaction registryExampleconst connection = new BusinessNetworkConnection();await connection.connect('admin@network-name');const exists = await connection.transactionRegistryExists('org.example.SampleTransaction');if (exists) {    // logic here...}getHistorianPromise getHistorian(  )Gets the historian.ReturnsPromise - A promise that will be resolved with the Historian.ParametersNo parametersExampleconst connection = new BusinessNetworkConnection();await connection.connect('admin@network-name');const historian = await connection.getHistorian();getIdentityRegistryPromise getIdentityRegistry(  )Gets the identity registry.ReturnsPromise - A promise that will be resolved with the IdentityRegistry.ParametersNo parametersExampleconst connection = new BusinessNetworkConnection();await connection.connect('admin@network-name');const identityRegistry = await connection.getIdentityRegistry();connectPromise connect( String cardname, [Object additionalconnectoptions] )Connects to a business network using a business network card, and authenticates to the Hyperledger Fabric.ReturnsPromise - A promise that will be resolved with a BusinessNetworkDefinition that indicates the connection is completed.ParametersNameTypeMandatoryDescriptioncardNameStringYesbusinessNetworkCard Name (must have been imported already)additionalConnectOptionsObjectYesAdditional configuration options supplied at runtime that override options set in the connection profile, which will override those in the specified connection profile.Exampleconst connection = new BusinessNetworkConnection();const definition = await connection.connect('admin@network-name');getRegistryPromise getRegistry( String fullyqualifiedname )Given a fully qualified name, works out and looks up the registry that this resource will be found in. This only gives back the default registry - it does not look in any application defined registry.ReturnsPromise - A promise that will be resolved with the registry that this fully qualified name could be found in by default.ParametersNameTypeMandatoryDescriptionfullyQualifiedNameStringYesThe fully qualified name of the resource registryExampleconst connection = new BusinessNetworkConnection();await connection.connect('admin@network-name');const sampleAssetRegistry = await connection.getRegistry('org.example.SampleAsset');const sampleParticipantRegistry = await connection.getRegistry('org.example.SampleParticipant');const sampleTransactionRegistry = await connection.getRegistry('org.example.SampleTransaction');disconnectPromise disconnect(  )Disconnects from the Hyperledger Fabric.ReturnsPromise - A promise that will be resolved when the connection is terminated.ParametersNo parametersExampleconst connection = new BusinessNetworkConnection();await connection.connect('admin@network-name');// Connected.await connection.disconnect();// Disconnected.submitTransactionPromise submitTransaction( Resource transaction, [Object additionalconnectoroptions] )Submit a transaction for processing by the currently connected business network.ReturnsPromise - A promise that will be fulfilled when the transaction has been processed.ParametersNameTypeMandatoryDescriptiontransactionResourceYesThe transaction to submit. Use newTransaction to create this object.additionalConnectorOptionsObjectYesAdditional connector specific options for this transaction.Exampleconst connection = new BusinessNetworkConnection();const definition = await connection.connect('admin@network-name');const factory = definition.getFactory();const transaction = factory.newTransaction('org.example', 'SampleTransaction');await connection.submitTransaction(transaction);buildQueryQuery buildQuery( string query )Build a query ready for later execution. The specified query string must be written in the Composer Query Language.This functionality is Blockchain platform dependent. For example, when a Composer business network is deployed to Hyperledger Fabric v1.0, Hyperledger Fabric must be configured with the CouchDB database for the world state.ReturnsQuery - The built query, which can be passed in a call to query.ParametersNameTypeMandatoryDescriptionquerystringYesThe query string, written in the Composer Query Language.Exampleconst connection = new BusinessNetworkConnection();await connection.connect('admin@network-name');const query = connection.buildQuery('SELECT org.example.SampleAsset WHERE (value == _$inputValue)');const assets = await connection.query(query, { inputValue: 'blue' })queryPromise query( string; Query query, [Object parameters] )Execute a query defined in a Composer query file, or execute a query built with buildQuery.This functionality is Blockchain platform dependent. For example, when a Composer business network is deployed to Hyperledger Fabric v1.0, Hyperledger Fabric must be configured with the CouchDB database for the world state.ReturnsPromise - A promise that will be resolved with an array of Resource representing the resources returned by the query.ParametersNameTypeMandatoryDescriptionquerystring; QueryYesThe name of the query, or a built query.parametersObjectYesThe parameters for the query.Exampleconst connection = new BusinessNetworkConnection();await connection.connect('admin@network-name');const assets = await query('Q1', { inputValue: 'blue' })pingPromise ping(  )Test the connection to the runtime and verify that the version of the runtime is compatible with this level of the client node.js module.ReturnsPromise - A promise that will be fulfilled when the connection has been tested. The promise will be rejected if the version is incompatible.ParametersNo parametersExampleconst connection = new BusinessNetworkConnection();await connection.connect('admin@network-name');await connection.ping();issueIdentityPromise issueIdentity( Resource; Relationship; string participant, string identityname, [object options] )Issue an identity with the specified name and map it to the specified participant.ReturnsPromise - A promise that will be fulfilled when the identity has been added to the specified participant. The promise will be rejected if the participant does not exist, or if the identity is already mapped to another participant.ParametersNameTypeMandatoryDescriptionparticipantResource; Relationship; stringYesThe participant, a relationship to the participant, or the fully qualified identifier of the participant. The participant must already exist.identityNamestringYesThe name for the new identity.optionsobjectYesOptions for the new identity.Sub-optionsNameTypeMandatoryDescriptionoptions.issuerbooleanYesWhether or not the new identity should have permissions to create additional new identities. False by default.bindIdentityPromise bindIdentity( Resource; string participant, string certificate )Bind an existing identity to the specified participant.ReturnsPromise - A promise that will be fulfilled when the identity has been added to the specified participant. The promise will be rejected if the participant does not exist, or if the identity is already mapped to another participant.ParametersNameTypeMandatoryDescriptionparticipantResource; stringYesThe participant, or the fully qualified identifier of the participant. The participant must already exist.certificatestringYesThe certificate for the existing identity.revokeIdentityPromise revokeIdentity( Resource; string identity )Revoke the specified identity by removing any existing mapping to a participant.ReturnsPromise - A promise that will be fulfilled when the identity has been removed from the specified participant. The promise will be rejected if the participant does not exist, or if the identity is not mapped to the participant.ParametersNameTypeMandatoryDescriptionidentityResource; stringYesThe identity, or the identifier of the identity.getNativeAPIgetNativeAPI(  )Get the native API for this connection. The native API returned is specific to the underlying blockchain platform, and may throw an error if there is no native API available.ParametersNo parametersInherited methods",
        "url": "/composer/latest/api/client-businessnetworkconnection"
      }
      ,
    
      "api-client-historian": {
        "title": "Historian (Client API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIHistorianThe Historian records the history of actions taken using Composer.It is a registry that stores HistorianRecords; each record is created in responseto a transaction being executred.As well as the transactions that are defined in the Network model other actions suchas adding assets are treated as transactions so are therefore recorded.Details of these are in the system model.Applications should retrieve instances from BusinessNetworkConnectionDetailsExtends RegistryModule clientSee alsoSee RegistryMethod SummaryNameReturnsDescriptionaddvoidUnsupported operation; you cannot add a historian record to the historianaddAllvoidUnsupported operation; you cannot add a historian record to the historiangetHistorianPromiseGet an existing historianremovevoidUnsupported operation; you cannot remove a historian record from the historianremoveAllvoidUnsupported operation; you cannot remove a historian record from the historianupdatevoidUnsupported operation; you cannot update a historian record in the historianupdateAllvoidUnsupported operation; you cannot update a historian record in the historianInherited Method SummarySupertypeNameReturnsDescriptionRegistrygetAllPromiseGet all of the resources in the registryRegistrygetPromiseGet a specific resource in the registryRegistryexistsPromiseDetermines whether a specific resource exists in the registryRegistryresolveAllPromiseGet all of the resources in the registry, and resolve all of their relationships to other assets, participants, and transactionsRegistryresolvePromiseGet a specific resource in the registry, and resolve all of its relationships to other assets, participants, and transactionsMethod DetailsgetHistorianPromise getHistorian( SecurityContext securitycontext, ModelManager modelmanager, Factory factory, Serializer serializer )Get an existing historian.ReturnsPromise - A promise that will be resolved with a Historian instance representing the historian.ParametersNameTypeMandatoryDescriptionsecurityContextSecurityContextYesThe user&#39;s security context.modelManagerModelManagerYesThe ModelManager to use for this historian.factoryFactoryYesThe factory to use for this historian.serializerSerializerYesThe Serializer to use for this historian.addadd( Resource resource )Unsupported operation; you cannot add a historian record to the historian. This method will always throw an exception when called.ParametersNameTypeMandatoryDescriptionresourceResourceYesThe resource to be added to the registry.addAlladdAll(  resources )Unsupported operation; you cannot add a historian record to the historian. This method will always throw an exception when called.ParametersNameTypeMandatoryDescriptionresourcesYesThe resources to be added to the registry.updateupdate( Resource resource )Unsupported operation; you cannot update a historian record in the historian. This method will always throw an exception when called.ParametersNameTypeMandatoryDescriptionresourceResourceYesThe resource to be updated in the registry.updateAllupdateAll(  resources )Unsupported operation; you cannot update a historian record in the historian. This method will always throw an exception when called.ParametersNameTypeMandatoryDescriptionresourcesYesThe resources to be updated in the asset registry.removeremove( Resource; string resource )Unsupported operation; you cannot remove a historian record from the historian. This method will always throw an exception when called.ParametersNameTypeMandatoryDescriptionresourceResource; stringYesThe resource, or the unique identifier of the resource.removeAllremoveAll( Resource[]; string[] resources )Unsupported operation; you cannot remove a historian record from the historian. This method will always throw an exception when called.ParametersNameTypeMandatoryDescriptionresourcesResource[]; string[]YesThe resources, or the unique identifiers of the resources.Inherited methodsgetAllPromise getAll(  )Inherited from:  RegistryGet all of the resources in the registry.ReturnsPromise - A promise that will be resolved with an array of JSON objects representing the resources.ParametersNo parametersgetPromise get( string id )Inherited from:  RegistryGet a specific resource in the registry.ReturnsPromise - A promise that will be resolved with a JSON object representing the resource.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the resource.existsPromise exists( string id )Inherited from:  RegistryDetermines whether a specific resource exists in the registry.ReturnsPromise - A promise that will be resolved with true/false depending on whether the resource exists.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the resource.resolveAllPromise resolveAll(  )Inherited from:  RegistryGet all of the resources in the registry, and resolve all of their relationships to other assets, participants, and transactions. The result is a JavaScript object, and should only be used for visualization purposes. You cannot use the add or update functions with a resolved resource.ReturnsPromise - A promise that will be resolved with an array of JavaScript objects representing the resources and all of their resolved relationships.ParametersNo parametersresolvePromise resolve( string id )Inherited from:  RegistryGet a specific resource in the registry, and resolve all of its relationships to other assets, participants, and transactions. The result is a JavaScript object, and should only be used for visualization purposes. You cannot use the  add or update functions with a resolved resource.ReturnsPromise - A promise that will be resolved with a JavaScript object representing the resource and all of its resolved relationships.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the asset.",
        "url": "/composer/latest/api/client-historian"
      }
      ,
    
      "api-client-identityregistry": {
        "title": "IdentityRegistry (Client API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIIdentityRegistryThe IdentityRegistry is used to store a set of identities on the blockchain.DetailsExtends RegistryModule clientSee alsoSee RegistryMethod SummaryNameReturnsDescriptionaddvoidUnsupported operation; you cannot add an identity to an identity registryaddAllvoidUnsupported operation; you cannot add an identity to an identity registrygetIdentityRegistryPromiseGet an existing identity registryremovevoidUnsupported operation; you cannot remove an identity from an identity registryremoveAllvoidUnsupported operation; you cannot remove an identity from an identity registryupdatevoidUnsupported operation; you cannot update an identity in an identity registryupdateAllvoidUnsupported operation; you cannot update an identity in an identity registryInherited Method SummarySupertypeNameReturnsDescriptionRegistrygetAllPromiseGet all of the resources in the registryRegistrygetPromiseGet a specific resource in the registryRegistryexistsPromiseDetermines whether a specific resource exists in the registryRegistryresolveAllPromiseGet all of the resources in the registry, and resolve all of their relationships to other assets, participants, and transactionsRegistryresolvePromiseGet a specific resource in the registry, and resolve all of its relationships to other assets, participants, and transactionsMethod DetailsgetIdentityRegistryPromise getIdentityRegistry( SecurityContext securitycontext, ModelManager modelmanager, Factory factory, Serializer serializer )Get an existing identity registry.ReturnsPromise - A promise that will be resolved with a IdentityRegistry instance representing the identity registry.ParametersNameTypeMandatoryDescriptionsecurityContextSecurityContextYesThe user&#39;s security context.modelManagerModelManagerYesThe ModelManager to use for this identity registry.factoryFactoryYesThe factory to use for this identity registry.serializerSerializerYesThe Serializer to use for this identity registry.addadd( Resource resource, string data )Unsupported operation; you cannot add an identity to an identity registry.ParametersNameTypeMandatoryDescriptionresourceResourceYesThe resource to be added to the registry.datastringYesThe data for the resource.addAlladdAll(  resources )Unsupported operation; you cannot add an identity to an identity registry.ParametersNameTypeMandatoryDescriptionresourcesYesThe resources to be added to the registry.updateupdate( Resource resource )Unsupported operation; you cannot update an identity in an identity registry. This method will always throw an exception when called.ParametersNameTypeMandatoryDescriptionresourceResourceYesThe resource to be updated in the registry.updateAllupdateAll(  resources )Unsupported operation; you cannot update an identity in an identity registry.ParametersNameTypeMandatoryDescriptionresourcesYesThe resources to be updated in the asset registry.removeremove( Resource; string resource )Unsupported operation; you cannot remove an identity from an identity registry. This method will always throw an exception when called.ParametersNameTypeMandatoryDescriptionresourceResource; stringYesThe resource, or the unique identifier of the resource.removeAllremoveAll( Resource[]; string[] resources )Unsupported operation; you cannot remove an identity from an identity registry. This method will always throw an exception when called.ParametersNameTypeMandatoryDescriptionresourcesResource[]; string[]YesThe resources, or the unique identifiers of the resources.Inherited methodsgetAllPromise getAll(  )Inherited from:  RegistryGet all of the resources in the registry.ReturnsPromise - A promise that will be resolved with an array of JSON objects representing the resources.ParametersNo parametersgetPromise get( string id )Inherited from:  RegistryGet a specific resource in the registry.ReturnsPromise - A promise that will be resolved with a JSON object representing the resource.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the resource.existsPromise exists( string id )Inherited from:  RegistryDetermines whether a specific resource exists in the registry.ReturnsPromise - A promise that will be resolved with true/false depending on whether the resource exists.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the resource.resolveAllPromise resolveAll(  )Inherited from:  RegistryGet all of the resources in the registry, and resolve all of their relationships to other assets, participants, and transactions. The result is a JavaScript object, and should only be used for visualization purposes. You cannot use the add or update functions with a resolved resource.ReturnsPromise - A promise that will be resolved with an array of JavaScript objects representing the resources and all of their resolved relationships.ParametersNo parametersresolvePromise resolve( string id )Inherited from:  RegistryGet a specific resource in the registry, and resolve all of its relationships to other assets, participants, and transactions. The result is a JavaScript object, and should only be used for visualization purposes. You cannot use the  add or update functions with a resolved resource.ReturnsPromise - A promise that will be resolved with a JavaScript object representing the resource and all of its resolved relationships.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the asset.",
        "url": "/composer/latest/api/client-identityregistry"
      }
      ,
    
      "api-client-participantregistry": {
        "title": "ParticipantRegistry (Client API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIParticipantRegistryThe ParticipantRegistry is used to manage a set of participants stored on the blockchain.DetailsExtends RegistryModule clientSee alsoSee RegistryInherited Method SummarySupertypeNameReturnsDescriptionRegistryremovePromiseRemove an asset with a given type and id from the registryRegistryaddAllPromiseAdds a list of new resources to the registryRegistryupdateAllPromiseUpdates a list of resources in the registryRegistryupdatePromiseUpdates a resource in the registryRegistryremoveAllPromiseRemoves a list of resources from the registryRegistryaddPromiseAdds a new resource to the registryRegistrygetAllPromiseGet all of the resources in the registryRegistrygetPromiseGet a specific resource in the registryRegistryexistsPromiseDetermines whether a specific resource exists in the registryRegistryresolveAllPromiseGet all of the resources in the registry, and resolve all of their relationships to other assets, participants, and transactionsRegistryresolvePromiseGet a specific resource in the registry, and resolve all of its relationships to other assets, participants, and transactionsMethod DetailsInherited methodsaddAllPromise addAll(  resources )Inherited from:  RegistryAdds a list of new resources to the registry.ReturnsPromise - A promise that will be resolved when the resource is added to the registry.ParametersNameTypeMandatoryDescriptionresourcesYesThe resources to be added to the registry.addPromise add( Resource resource )Inherited from:  RegistryAdds a new resource to the registry.ReturnsPromise - A promise that will be resolved when the resource is added to the registry.ParametersNameTypeMandatoryDescriptionresourceResourceYesThe resource to be added to the registry.updateAllPromise updateAll(  resources )Inherited from:  RegistryUpdates a list of resources in the registry.ReturnsPromise - A promise that will be resolved when the resource is added to the registry.ParametersNameTypeMandatoryDescriptionresourcesYesThe resources to be updated in the asset registry.updatePromise update( Resource resource )Inherited from:  RegistryUpdates a resource in the registry.ReturnsPromise - A promise that will be resolved when the resource is updated in the registry.ParametersNameTypeMandatoryDescriptionresourceResourceYesThe resource to be updated in the registry.removeAllPromise removeAll( Resource[]; string[] resources )Inherited from:  RegistryRemoves a list of resources from the registry.ReturnsPromise - A promise that will be resolved when the resource is added to the registry.ParametersNameTypeMandatoryDescriptionresourcesResource[]; string[]YesThe resources, or the unique identifiers of the resources.removePromise remove( Resource; string resource )Inherited from:  RegistryRemove an asset with a given type and id from the registry.ReturnsPromise - A promise that will be resolved when the resource is removed from the registry.ParametersNameTypeMandatoryDescriptionresourceResource; stringYesThe resource, or the unique identifier of the resource.getAllPromise getAll(  )Inherited from:  RegistryGet all of the resources in the registry.ReturnsPromise - A promise that will be resolved with an array of JSON objects representing the resources.ParametersNo parametersgetPromise get( string id )Inherited from:  RegistryGet a specific resource in the registry.ReturnsPromise - A promise that will be resolved with a JSON object representing the resource.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the resource.existsPromise exists( string id )Inherited from:  RegistryDetermines whether a specific resource exists in the registry.ReturnsPromise - A promise that will be resolved with true/false depending on whether the resource exists.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the resource.resolveAllPromise resolveAll(  )Inherited from:  RegistryGet all of the resources in the registry, and resolve all of their relationships to other assets, participants, and transactions. The result is a JavaScript object, and should only be used for visualization purposes. You cannot use the add or update functions with a resolved resource.ReturnsPromise - A promise that will be resolved with an array of JavaScript objects representing the resources and all of their resolved relationships.ParametersNo parametersresolvePromise resolve( string id )Inherited from:  RegistryGet a specific resource in the registry, and resolve all of its relationships to other assets, participants, and transactions. The result is a JavaScript object, and should only be used for visualization purposes. You cannot use the  add or update functions with a resolved resource.ReturnsPromise - A promise that will be resolved with a JavaScript object representing the resource and all of its resolved relationships.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the asset.",
        "url": "/composer/latest/api/client-participantregistry"
      }
      ,
    
      "api-client-query": {
        "title": "Query (Client API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIQueryThe Query class represents a built query. A built query has been parsed and validated.Do not attempt to create an instance of this class.You must use the buildQuerymethod instead.DetailsModule clientMethod DetailsInherited methods",
        "url": "/composer/latest/api/client-query"
      }
      ,
    
      "api-client-registry": {
        "title": "Registry (Client API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIRegistryClass representing an Abstract Registry.** Applications should retrieve instances from BusinessNetworkConnection**DetailsModule clientMethod SummaryNameReturnsDescriptionaddPromiseAdds a new resource to the registryaddAllPromiseAdds a list of new resources to the registryexistsPromiseDetermines whether a specific resource exists in the registrygetPromiseGet a specific resource in the registrygetAllPromiseGet all of the resources in the registryremovePromiseRemove an asset with a given type and id from the registryremoveAllPromiseRemoves a list of resources from the registryresolvePromiseGet a specific resource in the registry, and resolve all of its relationships to other assets, participants, and transactionsresolveAllPromiseGet all of the resources in the registry, and resolve all of their relationships to other assets, participants, and transactionsupdatePromiseUpdates a resource in the registryupdateAllPromiseUpdates a list of resources in the registryMethod DetailsaddAllPromise addAll(  resources )Adds a list of new resources to the registry.ReturnsPromise - A promise that will be resolved when the resource is added to the registry.ParametersNameTypeMandatoryDescriptionresourcesYesThe resources to be added to the registry.addPromise add( Resource resource )Adds a new resource to the registry.ReturnsPromise - A promise that will be resolved when the resource is added to the registry.ParametersNameTypeMandatoryDescriptionresourceResourceYesThe resource to be added to the registry.updateAllPromise updateAll(  resources )Updates a list of resources in the registry.ReturnsPromise - A promise that will be resolved when the resource is added to the registry.ParametersNameTypeMandatoryDescriptionresourcesYesThe resources to be updated in the asset registry.updatePromise update( Resource resource )Updates a resource in the registry.ReturnsPromise - A promise that will be resolved when the resource is updated in the registry.ParametersNameTypeMandatoryDescriptionresourceResourceYesThe resource to be updated in the registry.removeAllPromise removeAll( Resource[]; string[] resources )Removes a list of resources from the registry.ReturnsPromise - A promise that will be resolved when the resource is added to the registry.ParametersNameTypeMandatoryDescriptionresourcesResource[]; string[]YesThe resources, or the unique identifiers of the resources.removePromise remove( Resource; string resource )Remove an asset with a given type and id from the registry.ReturnsPromise - A promise that will be resolved when the resource is removed from the registry.ParametersNameTypeMandatoryDescriptionresourceResource; stringYesThe resource, or the unique identifier of the resource.getAllPromise getAll(  )Get all of the resources in the registry.ReturnsPromise - A promise that will be resolved with an array of JSON objects representing the resources.ParametersNo parametersgetPromise get( string id )Get a specific resource in the registry.ReturnsPromise - A promise that will be resolved with a JSON object representing the resource.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the resource.existsPromise exists( string id )Determines whether a specific resource exists in the registry.ReturnsPromise - A promise that will be resolved with true/false depending on whether the resource exists.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the resource.resolveAllPromise resolveAll(  )Get all of the resources in the registry, and resolve all of their relationships to other assets, participants, and transactions. The result is a JavaScript object, and should only be used for visualization purposes. You cannot use the add or update functions with a resolved resource.ReturnsPromise - A promise that will be resolved with an array of JavaScript objects representing the resources and all of their resolved relationships.ParametersNo parametersresolvePromise resolve( string id )Get a specific resource in the registry, and resolve all of its relationships to other assets, participants, and transactions. The result is a JavaScript object, and should only be used for visualization purposes. You cannot use the  add or update functions with a resolved resource.ReturnsPromise - A promise that will be resolved with a JavaScript object representing the resource and all of its resolved relationships.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the asset.Inherited methods",
        "url": "/composer/latest/api/client-registry"
      }
      ,
    
      "api-client-transactionregistry": {
        "title": "TransactionRegistry (Client API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APITransactionRegistryThe TransactionRegistry is used to store a set of transactions on the blockchain.Applications should retrieve instances from BusinessNetworkConnectionDetailsExtends RegistryModule clientSee alsoSee RegistryMethod SummaryNameReturnsDescriptionaddTransactionRegistryPromiseAdd a new transaction registrygetAllTransactionRegistriesPromiseGet a list of all existing transaction registriesgetTransactionRegistryPromiseGet an existing transaction registryInherited Method SummarySupertypeNameReturnsDescriptionRegistryremovePromiseRemove an asset with a given type and id from the registryRegistryaddAllPromiseAdds a list of new resources to the registryRegistryupdateAllPromiseUpdates a list of resources in the registryRegistryupdatePromiseUpdates a resource in the registryRegistryremoveAllPromiseRemoves a list of resources from the registryRegistryaddPromiseAdds a new resource to the registryRegistrygetAllPromiseGet all of the resources in the registryRegistrygetPromiseGet a specific resource in the registryRegistryexistsPromiseDetermines whether a specific resource exists in the registryRegistryresolveAllPromiseGet all of the resources in the registry, and resolve all of their relationships to other assets, participants, and transactionsRegistryresolvePromiseGet a specific resource in the registry, and resolve all of its relationships to other assets, participants, and transactionsMethod DetailsgetAllTransactionRegistriesPromise getAllTransactionRegistries( SecurityContext securitycontext, ModelManager modelmanager, Factory factory, Serializer serializer, BusinessNetworkConnection bnc, Boolean systemregistry )Get a list of all existing transaction registries.ReturnsPromise - A promise that will be resolved with a list of TransactionRegistry instances representing the transaction registries.ParametersNameTypeMandatoryDescriptionsecurityContextSecurityContextYesThe user&#39;s security context.modelManagerModelManagerYesThe ModelManager to use for this transaction registry.factoryFactoryYesThe factory to use for this transaction registry.serializerSerializerYesThe Serializer to use for this transaction registry.bncBusinessNetworkConnectionYesBusinessNetworkConnection to usesystemRegistryBooleanYesTrue if system transaction registries should be included in the list.getTransactionRegistryPromise getTransactionRegistry( SecurityContext securitycontext, string id, ModelManager modelmanager, Factory factory, Serializer serializer )Get an existing transaction registry.ReturnsPromise - A promise that will be resolved with a TransactionRegistry instance representing the transaction registry.ParametersNameTypeMandatoryDescriptionsecurityContextSecurityContextYesThe user&#39;s security context.idstringYesThe unique identifier of the transaction registry.modelManagerModelManagerYesThe ModelManager to use for this transaction registry.factoryFactoryYesThe factory to use for this transaction registry.serializerSerializerYesThe Serializer to use for this transaction registry.addTransactionRegistryPromise addTransactionRegistry( SecurityContext securitycontext, string id, string name, ModelManager modelmanager, Factory factory, Serializer serializer )Add a new transaction registry.ReturnsPromise - A promise that will be resolved with a TransactionRegistry instance representing the new transaction registry.ParametersNameTypeMandatoryDescriptionsecurityContextSecurityContextYesThe user&#39;s security context.idstringYesThe unique identifier of the transaction registry.namestringYesThe name of the transaction registry.modelManagerModelManagerYesThe ModelManager to use for this transaction registry.factoryFactoryYesThe factory to use for this transaction registry.serializerSerializerYesThe Serializer to use for this transaction registry.Inherited methodsaddAllPromise addAll(  resources )Inherited from:  RegistryAdds a list of new resources to the registry.ReturnsPromise - A promise that will be resolved when the resource is added to the registry.ParametersNameTypeMandatoryDescriptionresourcesYesThe resources to be added to the registry.addPromise add( Resource resource )Inherited from:  RegistryAdds a new resource to the registry.ReturnsPromise - A promise that will be resolved when the resource is added to the registry.ParametersNameTypeMandatoryDescriptionresourceResourceYesThe resource to be added to the registry.updateAllPromise updateAll(  resources )Inherited from:  RegistryUpdates a list of resources in the registry.ReturnsPromise - A promise that will be resolved when the resource is added to the registry.ParametersNameTypeMandatoryDescriptionresourcesYesThe resources to be updated in the asset registry.updatePromise update( Resource resource )Inherited from:  RegistryUpdates a resource in the registry.ReturnsPromise - A promise that will be resolved when the resource is updated in the registry.ParametersNameTypeMandatoryDescriptionresourceResourceYesThe resource to be updated in the registry.removeAllPromise removeAll( Resource[]; string[] resources )Inherited from:  RegistryRemoves a list of resources from the registry.ReturnsPromise - A promise that will be resolved when the resource is added to the registry.ParametersNameTypeMandatoryDescriptionresourcesResource[]; string[]YesThe resources, or the unique identifiers of the resources.removePromise remove( Resource; string resource )Inherited from:  RegistryRemove an asset with a given type and id from the registry.ReturnsPromise - A promise that will be resolved when the resource is removed from the registry.ParametersNameTypeMandatoryDescriptionresourceResource; stringYesThe resource, or the unique identifier of the resource.getAllPromise getAll(  )Inherited from:  RegistryGet all of the resources in the registry.ReturnsPromise - A promise that will be resolved with an array of JSON objects representing the resources.ParametersNo parametersgetPromise get( string id )Inherited from:  RegistryGet a specific resource in the registry.ReturnsPromise - A promise that will be resolved with a JSON object representing the resource.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the resource.existsPromise exists( string id )Inherited from:  RegistryDetermines whether a specific resource exists in the registry.ReturnsPromise - A promise that will be resolved with true/false depending on whether the resource exists.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the resource.resolveAllPromise resolveAll(  )Inherited from:  RegistryGet all of the resources in the registry, and resolve all of their relationships to other assets, participants, and transactions. The result is a JavaScript object, and should only be used for visualization purposes. You cannot use the add or update functions with a resolved resource.ReturnsPromise - A promise that will be resolved with an array of JavaScript objects representing the resources and all of their resolved relationships.ParametersNo parametersresolvePromise resolve( string id )Inherited from:  RegistryGet a specific resource in the registry, and resolve all of its relationships to other assets, participants, and transactions. The result is a JavaScript object, and should only be used for visualization purposes. You cannot use the  add or update functions with a resolved resource.ReturnsPromise - A promise that will be resolved with a JavaScript object representing the resource and all of its resolved relationships.ParametersNameTypeMandatoryDescriptionidstringYesThe unique identifier of the asset.",
        "url": "/composer/latest/api/client-transactionregistry"
      }
      ,
    
      "business-network-cloud-wallets": {
        "title": "Customising card stores",
        "author": "",
        "category": "concepts",
        "content": "Customising the card storeThe default card store is the /home/username/.composer directory on the host machine. Local wallets can be problematic for applications running in cloud environments, and it may be desired to have the card store at different directory location. By using custom wallets, users can control where business network cards and the certificates and private keys used for Hyperledger Fabric authentication are stored.ArchitectureWhenever a BusinessNetworkConnection or AdminConnection is made, it has an associated CardStore. Each connection can be configured to use a specific CardStore. In the Hyperledger Composer repository, there are two pre-configured options for stores:composer-wallet-filesystemcomposer-wallet-inmemoryCustom implementations can be written for any given backend database or object store, enabling the specification of a CardStore that is in a non-default file location, a separate docker container, or hosted in a cloud based data store. The store configuration can be completed using either a configuration file, or by using environment variables.composer-tools/composer-wallet-redis   - provides a backing store using a Redis server@ampretia/composer-wallet-ibmcos  - provides a backing store using the IBM Cloud Object Store. This has an S3 compatible APIMultiple cloud wallet implementations can be installed using global npm installs.For more details of the writing a new cloud wallet implementation, see the following README.Configuring a custom walletThere are two ways to define the configuration for a custom wallet: by using a .json configuration file, or by defining environment variables.Please note: any custom wallet implementation must include the composer-wallet prefix in the module name.Using a configuration fileFor production deployments, it is more useful to be able to configure the card store outside of the application,Hyperledger Composer uses the standard configuration module config. The configuration file is loaded from a sub-directory of the current working directory called config.  The default configuration file is called default.json, the configuration file name can be changed using the NODE_ENV environment variable.The following configuration file uses the Redis format as an example:{  \"composer\": {    \"wallet\": {      \"type\": \"composer-wallet-redis\",      \"desc\": \"Uses a local redis instance,      \"options\": {      }    }  }}type is the name of this moduledesc is some text for the humansPlease note: Each connection will have a new instance of the card store specified. If these resolve to the same backend store, cards can be shared.Using an environment variableSpecifying the details of a custom wallet on the command line via environment variables may be achieved by setting an environment variable containing the same information as the configuration file.The following environment variable example uses the same format and data as the preceding configuration file.export NODE_CONFIG={\"composer\":{\"wallet\":{\"type\":\"composer-wallet-redis\",\"desc\":\"Uses  a local redis instance,\"options\":{}}}}Any application that is in this shell will use the cloud wallets.Configuring file system custom card storesThe location of the file system card store can be changed using a configuration file, through specification of a storePath as one of the wallet options.{  \"composer\": {    \"wallet\" : {        \"type\": \"composer-wallet-filesystem\",        \"options\" : {            \"storePath\" : \"/my/network/location\"        }    }}The same .json snippet may be exported as an environment variable.Configuring cloud based custom card storesThe following GitHub repositories contain implementations of cloud custom wallets using Redis and the IBM Cloud Object Store, respectively.composer-tools/composer-wallet-redis - provides a backing store using a Redis server@ampretia/composer-wallet-ibmcos - provides a backing store using the IBM Cloud Object Store. This has an S3 compatible API.Multiple cloud custom wallet implementations can be installed using global npm installs.For more details of the writing a new cloud based custom wallet implementation, see the following README.To migrate to either the Redis or IBM Cloud Object Store cloud custom wallet solutions, refer to the README files of the relevant GitHub repository.In a general sense, migrating to a cloud wallet implementation has three steps.Export the business network cards you wish to use in the cloud custom wallet.Change configuration to specify the cloud custom wallet.Import the business network cards into the cloud custom wallet.The composer-wallet-filesystem is the default card store and follows the same layout on disc, and by default is in the same location.Some samples and test cases show the card stores being created programmatically. This is still possible and but is slightly different in terms of initial creation of the card store.Using custom wallets with APIsAPI CardStore configurationUsing the default location file system card store remains the default option within API calls. For instance:        adminConnection = new AdminConnection();        clientConnection = new BusinessNetworkConnection();will use the file system card store at the location /home/username/.composer, or pick up on the exported custom wallet specified within NODE_CONFIG if and only if executing within the same shell instance.To specify a custom wallet within the API, without the use of a globally exported value, it must be included as an option passed to the connection:        const connectionOptions = {            wallet : {                type: 'composer-wallet-filesystem',                options : {                    storePath :'/my/network/location'                }            }        };        adminConnection = new AdminConnection(connectionOptions);        clientConnection = new BusinessNetworkConnection(connectionOptions);In the above, the wallet type may be that of a new file location, or a cloud based location.API MemoryCardStore configurationPreviously to use the in MemoryCardStore, the code would have been written        cardStore = new MemoryCardStore();        const adminConnectionOptions = {            cardStore : cardStore        };        adminConnection = new AdminConnection(adminConnectionOptions);        // or more concisely        clientConnection = new BusinessNetworkConnection({cardStore});This has now changed and Card stores must now be specified differently:        const connectionOptions = {            wallet : {                type: 'composer-wallet-inmemory'            }        };        adminConnection = new AdminConnection(connectionOptions);        clientConnection = new BusinessNetworkConnection(connectionOptions);",
        "url": "/composer/latest/business-network/cloud-wallets"
      }
      ,
    
      "reference-commands": {
        "title": "Hyperledger Composer CLI Commands",
        "author": "",
        "category": "",
        "content": "Hyperledger Composer Command LineThe Hyperledger Composer command line application, composer, can be used to perform multipleadministrative, operational, and development tasks.The Hyperledger Composer command line application can be installed using npm:npm install -g composer-cli@0.20Please note: When using Ubuntu this command will fail when running in a root user shell.A Javascript API is also available with the same behavior than the Hyperledger Composer command line application.Business Network Archivescomposer archive createCreate a Business Network Archive from a directory on disk: composer archive createcomposer archive listVerify the contents of a Business Network Archive on disk: composer archive listBusiness Network Card Managementcomposer card createCreates a business network card from a connection profile, business network name, and certificates: composer card createcomposer card deleteDeletes a business network card which you have imported locally: composer card deletecomposer card importImports a created card into your local wallet: composer card importcomposer card exportExports and packages a card from your wallet: composer card exportcomposer card listLists all cards currently in your wallet: composer card listBusiness Network managementcomposer network installInstall a business network archive to an organization&#39;s Hyperledger Fabric peer(s): composer network installcomposer network startStart an already installed business network: composer network startcomposer network listList the contents of a deployed Business Network: composer network listcomposer network loglevelReturn or update the log level for the composer runtime: composer network loglevelcomposer network pingTest the connection to a deployed a Business Network: composer network pingcomposer network upgradeUpgrade the Hyperledger Composer runtime of a specific deployed business network: composer network upgradecomposer network downloadDownload the business network definition that is currently deployed to an instance of Hyperledger Fabric: composer network downloadcomposer network resetReset the business network that is currently deployed to an instance of Hyperledger Fabric: composer network resetParticipant and Identity managementcomposer participant addAdds a participant to a participant registry: composer participant addcomposer identity issueIssue a new identity to a participant: composer identity issuecomposer identity bindBind an existing identity to a participant: composer identity bindcomposer identity listList all identities in a business network: composer identity listcomposer identity revokeRevoke an identity from a participant: composer identity revokeSupport diagnosticscomposer reportCreate a diagnostic report: composer reportTransaction executioncomposer transaction submitSubmit a transaction for execution: composer transaction submitComposer Generatorcomposer generator createCreate files useful for application development: composer generator createcomposer generator docsCreate documentation for a business network definition: composer generator docs",
        "url": "/composer/latest/reference/commands"
      }
      ,
    
      "api-common-assetdeclaration": {
        "title": "AssetDeclaration (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIAssetDeclarationAssetDeclaration defines the schema (aka model or class) foran Asset. It extends ClassDeclaration which manages a set offields, a super-type and the specification of anidentifying field.DetailsExtends ClassDeclarationModule commonSee alsoSee ClassDeclarationMethod SummaryNameReturnsDescriptionconstructorvoidCreate an AssetDeclarationgetSystemTypestringReturns the base system type for Assets from the system namespaceisRelationshipTargetbooleanReturns true if this class can be pointed to by a relationshipInherited Method SummarySupertypeNameReturnsDescriptionClassDeclarationgetIdentifierFieldNamestringReturns the name of the identifying field for this classClassDeclaration_resolveSuperTypeClassDeclarationResolve the super type on this class and store it as an internal propertyClassDeclarationisEnumbooleanReturns true if this class is an enumerationClassDeclarationisConceptbooleanReturns true if this class is the definition of a conceptClassDeclarationisEventbooleanReturns true if this class is the definition of an eventClassDeclarationisSystemRelationshipTargetbooleanReturns true if this class can be pointed to by a relationship in a system modelClassDeclarationisSystemTypebooleanReturns true is this type is in the system namespaceClassDeclarationisSystemCoreTypebooleanReturns true if this class is a system core type - both in the system namespace, and also one of the system core types (Asset, Participant, etc)ClassDeclarationgetNamestringReturns the short name of a classClassDeclarationgetNamespaceStringReturn the namespace of this classClassDeclarationgetFullyQualifiedNamestringReturns the fully qualified name of this classClassDeclarationisAbstractbooleanReturns true if this class is declared as abstract in the model fileClassDeclarationgetOwnPropertyPropertyReturns the field with a given name or null if it does not existClassDeclarationgetOwnPropertiesProperty[]Returns the fields directly defined by this classClassDeclarationgetSuperTypestringReturns the FQN of the super type for this class or null if this class does not have a super typeClassDeclarationgetSuperTypeDeclarationClassDeclarationGet the super type class declaration for this classClassDeclarationgetAssignableClassDeclarationsClassDeclaration[]Get the class declarations for all subclasses of this class, including this classClassDeclarationgetAllSuperTypeDeclarationsClassDeclaration[]Get all the super-type declarations for this typeClassDeclarationgetPropertyPropertyReturns the property with a given name or null if it does not existClassDeclarationgetPropertiesProperty[]Returns the properties defined in this class and all super classesClassDeclarationgetNestedPropertyPropertyGet a nested property using a dotted property pathClassDeclarationtoStringStringReturns the string representation of this classMethod Detailsnew AssetDeclaration()Create an AssetDeclaration.ParametersNameTypeMandatoryDescriptionmodelFileModelFileYesthe ModelFile for this classastObjectYesThe AST created by the parserisRelationshipTargetboolean isRelationshipTarget(  )Returns true if this class can be pointed to by a relationshipReturnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersgetSystemTypestring getSystemType(  )Returns the base system type for Assets from the system namespaceReturnsstring - the short name of the base system typeParametersNo parametersInherited methods_resolveSuperTypeClassDeclaration _resolveSuperType(  )Inherited from:  ClassDeclarationResolve the super type on this class and store it as an internal property.ReturnsClassDeclaration - The super type, or null if non specified.ParametersNo parametersisAbstractboolean isAbstract(  )Inherited from:  ClassDeclarationReturns true if this class is declared as abstract in the model fileReturnsboolean - true if the class is abstractParametersNo parametersisEnumboolean isEnum(  )Inherited from:  ClassDeclarationReturns true if this class is an enumeration.Returnsboolean - true if the class is an enumerated typeParametersNo parametersisConceptboolean isConcept(  )Inherited from:  ClassDeclarationReturns true if this class is the definition of a concept.Returnsboolean - true if the class is a conceptParametersNo parametersisEventboolean isEvent(  )Inherited from:  ClassDeclarationReturns true if this class is the definition of an event.Returnsboolean - true if the class is an eventParametersNo parametersisSystemRelationshipTargetboolean isSystemRelationshipTarget(  )Inherited from:  ClassDeclarationReturns true if this class can be pointed to by a relationship in a system modelReturnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersisSystemTypeboolean isSystemType(  )Inherited from:  ClassDeclarationReturns true is this type is in the system namespaceReturnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersisSystemCoreTypeboolean isSystemCoreType(  )Inherited from:  ClassDeclarationReturns true if this class is a system core type - both in the system namespace, and also one of the system core types (Asset, Participant, etc).Returnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersgetNamestring getName(  )Inherited from:  ClassDeclarationReturns the short name of a class. This name does not include the namespace from the owning ModelFile.Returnsstring - the short name of this classParametersNo parametersgetNamespaceString getNamespace(  )Inherited from:  ClassDeclarationReturn the namespace of this class.ReturnsString - namespace - a namespace.ParametersNo parametersgetFullyQualifiedNamestring getFullyQualifiedName(  )Inherited from:  ClassDeclarationReturns the fully qualified name of this class. The name will include the namespace if present.Returnsstring - the fully-qualified name of this classParametersNo parametersgetIdentifierFieldNamestring getIdentifierFieldName(  )Inherited from:  ClassDeclarationReturns the name of the identifying field for this class. Note that the identifying field may come from a super type.Returnsstring - the name of the id field for this classParametersNo parametersgetOwnPropertyProperty getOwnProperty( string name )Inherited from:  ClassDeclarationReturns the field with a given name or null if it does not exist. The field must be directly owned by this class -- the super-type is not introspected.ReturnsProperty - the field definition or null if it does not exist.ParametersNameTypeMandatoryDescriptionnamestringYesthe name of the fieldgetOwnPropertiesProperty[] getOwnProperties(  )Inherited from:  ClassDeclarationReturns the fields directly defined by this class.ReturnsProperty - the array of fieldsParametersNo parametersgetSuperTypestring getSuperType(  )Inherited from:  ClassDeclarationReturns the FQN of the super type for this class or null if this class does not have a super type.Returnsstring - the FQN name of the super type or nullParametersNo parametersgetSuperTypeDeclarationClassDeclaration getSuperTypeDeclaration(  )Inherited from:  ClassDeclarationGet the super type class declaration for this class.ReturnsClassDeclaration - the super type declaration, or null if there is no super type.ParametersNo parametersgetAssignableClassDeclarationsClassDeclaration[] getAssignableClassDeclarations(  )Inherited from:  ClassDeclarationGet the class declarations for all subclasses of this class, including this class.ReturnsClassDeclaration - subclass declarations.ParametersNo parametersgetAllSuperTypeDeclarationsClassDeclaration[] getAllSuperTypeDeclarations(  )Inherited from:  ClassDeclarationGet all the super-type declarations for this type.ReturnsClassDeclaration - super-type declarations.ParametersNo parametersgetPropertyProperty getProperty( string name )Inherited from:  ClassDeclarationReturns the property with a given name or null if it does not exist. Fields defined in super-types are also introspected.ReturnsProperty - the field, or null if it does not existParametersNameTypeMandatoryDescriptionnamestringYesthe name of the fieldgetPropertiesProperty[] getProperties(  )Inherited from:  ClassDeclarationReturns the properties defined in this class and all super classes.ReturnsProperty - the array of fieldsParametersNo parametersgetNestedPropertyProperty getNestedProperty( string propertypath )Inherited from:  ClassDeclarationGet a nested property using a dotted property pathReturnsProperty - the propertyParametersNameTypeMandatoryDescriptionpropertyPathstringYesThe property name or name with nested structure e.g a.b.ctoStringString toString(  )Inherited from:  ClassDeclarationReturns the string representation of this classReturnsString - the string representation of the classParametersNo parameters",
        "url": "/composer/latest/api/common-assetdeclaration"
      }
      ,
    
      "api-common-businessnetworkcardstore": {
        "title": "BusinessNetworkCardStore (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIBusinessNetworkCardStoreManages persistence of business network cards.Applications would not work with this abstract class directlyThe File system card store is the default for both Admin and Business Network ConnectionsDetailsModule commonMethod SummaryNameReturnsDescriptiondeletePromiseDelete a specific card from the storegetPromiseGets a card from the storegetAllPromiseGets all cards from the storegetDefaultCardNameStringGet a default name for a given business network cardhasPromiseHas returns a boolean indicating whether a card with the specified name exists or notputPromisePuts a card in the storeMethod DetailsgetDefaultCardNameString getDefaultCardName( IdCard card )Get a default name for a given business network card.ReturnsString - A card nameParametersNameTypeMandatoryDescriptioncardIdCardYesA business network cardgetPromise get( String cardname )Gets a card from the store.ReturnsPromise - A promise that is resolved with an IdCard, or rejected if the card does not exist.ParametersNameTypeMandatoryDescriptioncardNameStringYesThe name of the card to getputPromise put( String cardname, IdCard card )Puts a card in the store. If the named card already exists in the store, it will be replaced.ReturnsPromise - A promise that resolves once the data is writtenParametersNameTypeMandatoryDescriptioncardNameStringYesThe name of the card to savecardIdCardYesThe cardhasPromise has( String cardname )Has returns a boolean indicating whether a card with the specified name exists or not.ReturnsPromise - A promise resolved with true or false.ParametersNameTypeMandatoryDescriptioncardNameStringYesThe name of the card to checkgetAllPromise getAll(  )Gets all cards from the store.ReturnsPromise - A promise that is resolved with a Map where the keys are identity card names and the values are IdCard objects.ParametersNo parametersdeletePromise delete( String cardname )Delete a specific card from the store.ReturnsPromise - A promise that resolves to true if the card existed; otherwise false.ParametersNameTypeMandatoryDescriptioncardNameStringYesThe name of the card to delete.Inherited methods",
        "url": "/composer/latest/api/common-businessnetworkcardstore"
      }
      ,
    
      "api-common-businessnetworkdefinition": {
        "title": "BusinessNetworkDefinition (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIBusinessNetworkDefinitionA BusinessNetworkDefinition defines a set of Participants that exchange Assets bysending Transactions. This class manages the metadata and domain-specific types forthe network as well as a set of executable scripts.Applications shouldretrieve instances from BusinessNetworkDefinition#fromArchiveDetailsModule commonMethod SummaryNameReturnsDescriptionfromArchivePromiseCreate a BusinessNetworkDefinition from an archivefromDirectoryPromiseBuilds a BusinessNetworkDefintion from the contents of a directory.getDescriptionStringReturns the description for this business networkgetFactoryFactoryProvides access to the Factory for this business networkgetIdentifierStringReturns the identifier for this business network The identifier is formed from a business network name + &#39;@&#39; + versiongetIntrospectorIntrospectorProvides access to the Introspector for this business networkgetMetadataBusinessNetworkMetadataReturns the metadata for this business networkgetNameStringReturns the name for this business networkgetSerializerSerializerProvides access to the Serializer for this business networkgetVersionStringReturns the version for this business networktoArchivePromiseStore a BusinessNetworkDefinition as an archivetoDirectoryPromiseStore a BusinessNetworkDefinition to a directoryMethod DetailsgetIdentifierString getIdentifier(  )Returns the identifier for this business network The identifier is formed from a business network name + &#39;@&#39; + version. The version is a semver valid version string. It is not used by Hyperledger Composer and is not needed in any other API. It is for application developer information purposes onlyuReturnsString - the identifier of this business networkParametersNo parametersgetMetadataBusinessNetworkMetadata getMetadata(  )Returns the metadata for this business networkReturnsBusinessNetworkMetadata - the metadata for this business networkParametersNo parametersgetNameString getName(  )Returns the name for this business networkReturnsString - the name of this business networkParametersNo parametersgetVersionString getVersion(  )Returns the version for this business networkReturnsString - the version of this business network. Use semver module to parse.ParametersNo parametersgetDescriptionString getDescription(  )Returns the description for this business networkReturnsString - the description of this business networkParametersNo parametersfromArchivePromise fromArchive( Buffer zipbuffer )Create a BusinessNetworkDefinition from an archive.ReturnsPromise - a Promise to the instantiated business networkParametersNameTypeMandatoryDescriptionzipBufferBufferYesthe Buffer to a zip archivetoArchivePromise toArchive( [Object options] )Store a BusinessNetworkDefinition as an archive.ReturnsPromise - Resolves to a Buffer of the zip file content.ParametersNameTypeMandatoryDescriptionoptionsObjectYesJSZip optionsfromDirectoryPromise fromDirectory( String path, [Object options] )Builds a BusinessNetworkDefintion from the contents of a directory. The directory must include a package.json in the root (used to specify the name, version and description of the business network). This method is designed to work with business networks that refer to external models using npm dependencies as well as business networks that statically package their model files.  If package.json contains a dependencies property then this method will search for model (CTO) files under the node_modules directory for each dependency that passes the options.dependencyGlob pattern.   If the network depends on an npm module its dependencies (transitive closure) will also be scanned for model (CTO) files.   The directory may optionally contain a README.md file which is accessible from the BusinessNetworkMetadata.getREADME method.   In addition all model files will be added that are not under node_modules and that pass the options.modelFileGlob pattern. By default you should put model files under a directory called &#39;models&#39;.   All script (js) files will be added that are not under node_modules and that pass the options.scriptGlob pattern. By default you should put Javascript files under the &#39;lib&#39; directory. ReturnsPromise - a Promise to the instantiated business networkParametersNameTypeMandatoryDescriptionpathStringYesto a local directoryoptionsObjectYesan optional set of options to configure the instance.Sub-optionsNameTypeMandatoryDescriptionoptions.dependencyGlobObjectYesspecify the glob pattern used to match the npm dependencies to process. Defaults to **options.modelFileGlobbooleanYesspecify the glob pattern used to match the model files to include. Defaults to \\/models/\\/*.ctooptions.scriptGlobbooleanYesspecify the glob pattern used to match the script files to include. Defaults to \\/lib/\\/*.jsoptions.updateExternalModelsbooleanYesif true then external models for the network are downloaded and updated.options.updateExternalModelsOptionsobjectYesoptions passed to ModelManager.updateExternalModelsoptions.processDependenciesbooleanYesif false, do not process package dependencies; otherwise package dependencies are processed.toDirectoryPromise toDirectory( String directorypath )Store a BusinessNetworkDefinition to a directoryReturnsPromise - Resolves when the directory is written.ParametersNameTypeMandatoryDescriptiondirectoryPathStringYesThe directory to write the content of the business networkgetIntrospectorIntrospector getIntrospector(  )Provides access to the Introspector for this business network. The Introspector is used to reflect on the types defined within this business network.ReturnsIntrospector - the Introspector for this business networkParametersNo parametersgetFactoryFactory getFactory(  )Provides access to the Factory for this business network. The Factory is used to create the types defined in this business network.ReturnsFactory - the Factory for this business networkParametersNo parametersgetSerializerSerializer getSerializer(  )Provides access to the Serializer for this business network. The Serializer is used to serialize instances of the types defined within this business network.ReturnsSerializer - the Serializer for this business networkParametersNo parametersInherited methods",
        "url": "/composer/latest/api/common-businessnetworkdefinition"
      }
      ,
    
      "api-common-businessnetworkmetadata": {
        "title": "BusinessNetworkMetadata (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIBusinessNetworkMetadataDefines the metadata for a BusinessNeworkDefinition. This includes:package.jsonREADME.md (optional)Applications should retrieve instances from BusinessNetworkDefinitionDetailsModule commonMethod SummaryNameReturnsDescriptiongetDescriptionStringReturns the description for this business networkgetIdentifierStringReturns the identifier for this business networkgetNameStringReturns the name for this business networkgetPackageJsonobjectReturns the packagegetREADMEStringReturns the READMEgetVersionStringReturns the version for this business networkMethod DetailsgetREADMEString getREADME(  )Returns the README.md for this business network. This may be null if the business network does not have a README.mdReturnsString - the README.md file for the business network or nullParametersNo parametersgetPackageJsonobject getPackageJson(  )Returns the package.json for this business network.Returnsobject - the Javascript object for package.jsonParametersNo parametersgetNameString getName(  )Returns the name for this business network.ReturnsString - the name of the business networkParametersNo parametersgetDescriptionString getDescription(  )Returns the description for this business network.ReturnsString - the description of the business networkParametersNo parametersgetVersionString getVersion(  )Returns the version for this business network.ReturnsString - the description of the business networkParametersNo parametersgetIdentifierString getIdentifier(  )Returns the identifier for this business network. Formed from name@version.ReturnsString - the identifier of the business networkParametersNo parametersInherited methods",
        "url": "/composer/latest/api/common-businessnetworkmetadata"
      }
      ,
    
      "api-common-classdeclaration": {
        "title": "ClassDeclaration (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIClassDeclarationClassDeclaration defines the structure (model/schema) of composite data.It is composed of a set of Properties, may have an identifying field, and mayhave a super-type.A ClassDeclaration is conceptually owned by a ModelFile whichdefines all the classes that are part of a namespace.DetailsModule commonMethod SummaryNameReturnsDescription_resolveSuperTypeClassDeclarationResolve the super type on this class and store it as an internal propertyconstructorvoidCreate a ClassDeclaration from an Abstract Syntax TreegetAllSuperTypeDeclarationsClassDeclaration[]Get all the super-type declarations for this typegetAssignableClassDeclarationsClassDeclaration[]Get the class declarations for all subclasses of this class, including this classgetFullyQualifiedNamestringReturns the fully qualified name of this classgetIdentifierFieldNamestringReturns the name of the identifying field for this classgetNamestringReturns the short name of a classgetNamespaceStringReturn the namespace of this classgetNestedPropertyPropertyGet a nested property using a dotted property pathgetOwnPropertiesProperty[]Returns the fields directly defined by this classgetOwnPropertyPropertyReturns the field with a given name or null if it does not existgetPropertiesProperty[]Returns the properties defined in this class and all super classesgetPropertyPropertyReturns the property with a given name or null if it does not existgetSuperTypestringReturns the FQN of the super type for this class or null if this class does not have a super typegetSuperTypeDeclarationClassDeclarationGet the super type class declaration for this classgetSystemTypestringReturns the base system type for this type of class declarationisAbstractbooleanReturns true if this class is declared as abstract in the model fileisConceptbooleanReturns true if this class is the definition of a conceptisEnumbooleanReturns true if this class is an enumerationisEventbooleanReturns true if this class is the definition of an eventisRelationshipTargetbooleanReturns true if this class can be pointed to by a relationshipisSystemCoreTypebooleanReturns true if this class is a system core type - both in the system namespace, and also one of the system core types (Asset, Participant, etc)isSystemRelationshipTargetbooleanReturns true if this class can be pointed to by a relationship in a system modelisSystemTypebooleanReturns true is this type is in the system namespacetoStringStringReturns the string representation of this classMethod Detailsnew ClassDeclaration()Create a ClassDeclaration from an Abstract Syntax Tree. The AST is the result of parsing.ParametersNameTypeMandatoryDescriptionmodelFileModelFileYesthe ModelFile for this classaststringYesthe AST created by the parser_resolveSuperTypeClassDeclaration _resolveSuperType(  )Resolve the super type on this class and store it as an internal property.ReturnsClassDeclaration - The super type, or null if non specified.ParametersNo parametersgetSystemTypestring getSystemType(  )Returns the base system type for this type of class declaration. Override this method in derived classes to specify a base system type.Returnsstring - the short name of the base system type or nullParametersNo parametersisAbstractboolean isAbstract(  )Returns true if this class is declared as abstract in the model fileReturnsboolean - true if the class is abstractParametersNo parametersisEnumboolean isEnum(  )Returns true if this class is an enumeration.Returnsboolean - true if the class is an enumerated typeParametersNo parametersisConceptboolean isConcept(  )Returns true if this class is the definition of a concept.Returnsboolean - true if the class is a conceptParametersNo parametersisEventboolean isEvent(  )Returns true if this class is the definition of an event.Returnsboolean - true if the class is an eventParametersNo parametersisRelationshipTargetboolean isRelationshipTarget(  )Returns true if this class can be pointed to by a relationshipReturnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersisSystemRelationshipTargetboolean isSystemRelationshipTarget(  )Returns true if this class can be pointed to by a relationship in a system modelReturnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersisSystemTypeboolean isSystemType(  )Returns true is this type is in the system namespaceReturnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersisSystemCoreTypeboolean isSystemCoreType(  )Returns true if this class is a system core type - both in the system namespace, and also one of the system core types (Asset, Participant, etc).Returnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersgetNamestring getName(  )Returns the short name of a class. This name does not include the namespace from the owning ModelFile.Returnsstring - the short name of this classParametersNo parametersgetNamespaceString getNamespace(  )Return the namespace of this class.ReturnsString - namespace - a namespace.ParametersNo parametersgetFullyQualifiedNamestring getFullyQualifiedName(  )Returns the fully qualified name of this class. The name will include the namespace if present.Returnsstring - the fully-qualified name of this classParametersNo parametersgetIdentifierFieldNamestring getIdentifierFieldName(  )Returns the name of the identifying field for this class. Note that the identifying field may come from a super type.Returnsstring - the name of the id field for this classParametersNo parametersgetOwnPropertyProperty getOwnProperty( string name )Returns the field with a given name or null if it does not exist. The field must be directly owned by this class -- the super-type is not introspected.ReturnsProperty - the field definition or null if it does not exist.ParametersNameTypeMandatoryDescriptionnamestringYesthe name of the fieldgetOwnPropertiesProperty[] getOwnProperties(  )Returns the fields directly defined by this class.ReturnsProperty - the array of fieldsParametersNo parametersgetSuperTypestring getSuperType(  )Returns the FQN of the super type for this class or null if this class does not have a super type.Returnsstring - the FQN name of the super type or nullParametersNo parametersgetSuperTypeDeclarationClassDeclaration getSuperTypeDeclaration(  )Get the super type class declaration for this class.ReturnsClassDeclaration - the super type declaration, or null if there is no super type.ParametersNo parametersgetAssignableClassDeclarationsClassDeclaration[] getAssignableClassDeclarations(  )Get the class declarations for all subclasses of this class, including this class.ReturnsClassDeclaration - subclass declarations.ParametersNo parametersgetAllSuperTypeDeclarationsClassDeclaration[] getAllSuperTypeDeclarations(  )Get all the super-type declarations for this type.ReturnsClassDeclaration - super-type declarations.ParametersNo parametersgetPropertyProperty getProperty( string name )Returns the property with a given name or null if it does not exist. Fields defined in super-types are also introspected.ReturnsProperty - the field, or null if it does not existParametersNameTypeMandatoryDescriptionnamestringYesthe name of the fieldgetPropertiesProperty[] getProperties(  )Returns the properties defined in this class and all super classes.ReturnsProperty - the array of fieldsParametersNo parametersgetNestedPropertyProperty getNestedProperty( string propertypath )Get a nested property using a dotted property pathReturnsProperty - the propertyParametersNameTypeMandatoryDescriptionpropertyPathstringYesThe property name or name with nested structure e.g a.b.ctoStringString toString(  )Returns the string representation of this classReturnsString - the string representation of the classParametersNo parametersInherited methods",
        "url": "/composer/latest/api/common-classdeclaration"
      }
      ,
    
      "api-common-concept": {
        "title": "Concept (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIConceptResource is an instance that has a type. The type of the resourcespecifies a set of properites (which themselves have types).Type information in Composer is used to validate the structure ofResource instances and for serialization.Resources are used in Composer to represent Assets, Participants, Transactions andother domain classes that can be serialized for long-term persistent storage.DetailsExtends TypedModule commonSee alsoSee  ResourceMethod SummaryNameReturnsDescriptionisConceptbooleanDetermine if this typed is a conceptInherited Method SummarySupertypeNameReturnsDescriptionTypedgetTypestringGet the type of the instance (a short name, not including namespace)TypedgetFullyQualifiedTypestringGet the fully-qualified type name of the instance (including namespace)TypedgetNamespacestringGet the namespace of the instanceTypedsetPropertyValuevoidSets a property on this ResourceTypedaddArrayValuevoidAdds a value to an array property on this ResourceTypedinstanceOfbooleanCheck to see if this instance is an instance of the specified fully qualified type nameMethod DetailsisConceptboolean isConcept(  )Determine if this typed is a concept.Returnsboolean - True if this typed is a concept, false if not.ParametersNo parametersInherited methodsgetTypestring getType(  )Inherited from:  TypedGet the type of the instance (a short name, not including namespace).Returnsstring - The type of this objectParametersNo parametersgetFullyQualifiedTypestring getFullyQualifiedType(  )Inherited from:  TypedGet the fully-qualified type name of the instance (including namespace).Returnsstring - The fully-qualified type name of this objectParametersNo parametersgetNamespacestring getNamespace(  )Inherited from:  TypedGet the namespace of the instance.Returnsstring - The namespace of this objectParametersNo parameterssetPropertyValuevoid setPropertyValue( string propname, string value )Inherited from:  TypedSets a property on this ResourceParametersNameTypeMandatoryDescriptionpropNamestringYesthe name of the fieldvaluestringYesthe value of the propertyaddArrayValuevoid addArrayValue( string propname, string value )Inherited from:  TypedAdds a value to an array property on this ResourceParametersNameTypeMandatoryDescriptionpropNamestringYesthe name of the fieldvaluestringYesthe value of the propertyinstanceOfboolean instanceOf( String fqt )Inherited from:  TypedCheck to see if this instance is an instance of the specified fully qualified type name.Returnsboolean - True if this instance is an instance of the specified fully qualified type name, false otherwise.ParametersNameTypeMandatoryDescriptionfqtStringYesThe fully qualified type name.",
        "url": "/composer/latest/api/common-concept"
      }
      ,
    
      "api-common-conceptdeclaration": {
        "title": "ConceptDeclaration (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIConceptDeclarationConceptDeclaration defines the schema (aka model or class) foran Concept. It extends ClassDeclaration which manages a set offields, a super-type and the specification of anidentifying field.DetailsExtends ClassDeclarationModule commonSee alsoClassDeclarationMethod SummaryNameReturnsDescriptionconstructorvoidCreate an AssetDeclarationisConceptbooleanReturns true if this class is the definition of a conceptInherited Method SummarySupertypeNameReturnsDescriptionClassDeclarationgetFullyQualifiedNamestringReturns the fully qualified name of this classClassDeclaration_resolveSuperTypeClassDeclarationResolve the super type on this class and store it as an internal propertyClassDeclarationisAbstractbooleanReturns true if this class is declared as abstract in the model fileClassDeclarationisEnumbooleanReturns true if this class is an enumerationClassDeclarationisEventbooleanReturns true if this class is the definition of an eventClassDeclarationisRelationshipTargetbooleanReturns true if this class can be pointed to by a relationshipClassDeclarationisSystemRelationshipTargetbooleanReturns true if this class can be pointed to by a relationship in a system modelClassDeclarationisSystemTypebooleanReturns true is this type is in the system namespaceClassDeclarationisSystemCoreTypebooleanReturns true if this class is a system core type - both in the system namespace, and also one of the system core types (Asset, Participant, etc)ClassDeclarationgetNamestringReturns the short name of a classClassDeclarationgetNamespaceStringReturn the namespace of this classClassDeclarationgetSystemTypestringReturns the base system type for this type of class declarationClassDeclarationgetIdentifierFieldNamestringReturns the name of the identifying field for this classClassDeclarationgetOwnPropertyPropertyReturns the field with a given name or null if it does not existClassDeclarationgetOwnPropertiesProperty[]Returns the fields directly defined by this classClassDeclarationgetSuperTypestringReturns the FQN of the super type for this class or null if this class does not have a super typeClassDeclarationgetSuperTypeDeclarationClassDeclarationGet the super type class declaration for this classClassDeclarationgetAssignableClassDeclarationsClassDeclaration[]Get the class declarations for all subclasses of this class, including this classClassDeclarationgetAllSuperTypeDeclarationsClassDeclaration[]Get all the super-type declarations for this typeClassDeclarationgetPropertyPropertyReturns the property with a given name or null if it does not existClassDeclarationgetPropertiesProperty[]Returns the properties defined in this class and all super classesClassDeclarationgetNestedPropertyPropertyGet a nested property using a dotted property pathClassDeclarationtoStringStringReturns the string representation of this classMethod Detailsnew ConceptDeclaration()Create an AssetDeclaration.ParametersNameTypeMandatoryDescriptionmodelFileModelFileYesthe ModelFile for this classastObjectYesThe AST created by the parserisConceptboolean isConcept(  )Returns true if this class is the definition of a concept.Returnsboolean - true if the class is a conceptParametersNo parametersInherited methods_resolveSuperTypeClassDeclaration _resolveSuperType(  )Inherited from:  ClassDeclarationResolve the super type on this class and store it as an internal property.ReturnsClassDeclaration - The super type, or null if non specified.ParametersNo parametersgetSystemTypestring getSystemType(  )Inherited from:  ClassDeclarationReturns the base system type for this type of class declaration. Override this method in derived classes to specify a base system type.Returnsstring - the short name of the base system type or nullParametersNo parametersisAbstractboolean isAbstract(  )Inherited from:  ClassDeclarationReturns true if this class is declared as abstract in the model fileReturnsboolean - true if the class is abstractParametersNo parametersisEnumboolean isEnum(  )Inherited from:  ClassDeclarationReturns true if this class is an enumeration.Returnsboolean - true if the class is an enumerated typeParametersNo parametersisEventboolean isEvent(  )Inherited from:  ClassDeclarationReturns true if this class is the definition of an event.Returnsboolean - true if the class is an eventParametersNo parametersisRelationshipTargetboolean isRelationshipTarget(  )Inherited from:  ClassDeclarationReturns true if this class can be pointed to by a relationshipReturnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersisSystemRelationshipTargetboolean isSystemRelationshipTarget(  )Inherited from:  ClassDeclarationReturns true if this class can be pointed to by a relationship in a system modelReturnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersisSystemTypeboolean isSystemType(  )Inherited from:  ClassDeclarationReturns true is this type is in the system namespaceReturnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersisSystemCoreTypeboolean isSystemCoreType(  )Inherited from:  ClassDeclarationReturns true if this class is a system core type - both in the system namespace, and also one of the system core types (Asset, Participant, etc).Returnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersgetNamestring getName(  )Inherited from:  ClassDeclarationReturns the short name of a class. This name does not include the namespace from the owning ModelFile.Returnsstring - the short name of this classParametersNo parametersgetNamespaceString getNamespace(  )Inherited from:  ClassDeclarationReturn the namespace of this class.ReturnsString - namespace - a namespace.ParametersNo parametersgetFullyQualifiedNamestring getFullyQualifiedName(  )Inherited from:  ClassDeclarationReturns the fully qualified name of this class. The name will include the namespace if present.Returnsstring - the fully-qualified name of this classParametersNo parametersgetIdentifierFieldNamestring getIdentifierFieldName(  )Inherited from:  ClassDeclarationReturns the name of the identifying field for this class. Note that the identifying field may come from a super type.Returnsstring - the name of the id field for this classParametersNo parametersgetOwnPropertyProperty getOwnProperty( string name )Inherited from:  ClassDeclarationReturns the field with a given name or null if it does not exist. The field must be directly owned by this class -- the super-type is not introspected.ReturnsProperty - the field definition or null if it does not exist.ParametersNameTypeMandatoryDescriptionnamestringYesthe name of the fieldgetOwnPropertiesProperty[] getOwnProperties(  )Inherited from:  ClassDeclarationReturns the fields directly defined by this class.ReturnsProperty - the array of fieldsParametersNo parametersgetSuperTypestring getSuperType(  )Inherited from:  ClassDeclarationReturns the FQN of the super type for this class or null if this class does not have a super type.Returnsstring - the FQN name of the super type or nullParametersNo parametersgetSuperTypeDeclarationClassDeclaration getSuperTypeDeclaration(  )Inherited from:  ClassDeclarationGet the super type class declaration for this class.ReturnsClassDeclaration - the super type declaration, or null if there is no super type.ParametersNo parametersgetAssignableClassDeclarationsClassDeclaration[] getAssignableClassDeclarations(  )Inherited from:  ClassDeclarationGet the class declarations for all subclasses of this class, including this class.ReturnsClassDeclaration - subclass declarations.ParametersNo parametersgetAllSuperTypeDeclarationsClassDeclaration[] getAllSuperTypeDeclarations(  )Inherited from:  ClassDeclarationGet all the super-type declarations for this type.ReturnsClassDeclaration - super-type declarations.ParametersNo parametersgetPropertyProperty getProperty( string name )Inherited from:  ClassDeclarationReturns the property with a given name or null if it does not exist. Fields defined in super-types are also introspected.ReturnsProperty - the field, or null if it does not existParametersNameTypeMandatoryDescriptionnamestringYesthe name of the fieldgetPropertiesProperty[] getProperties(  )Inherited from:  ClassDeclarationReturns the properties defined in this class and all super classes.ReturnsProperty - the array of fieldsParametersNo parametersgetNestedPropertyProperty getNestedProperty( string propertypath )Inherited from:  ClassDeclarationGet a nested property using a dotted property pathReturnsProperty - the propertyParametersNameTypeMandatoryDescriptionpropertyPathstringYesThe property name or name with nested structure e.g a.b.ctoStringString toString(  )Inherited from:  ClassDeclarationReturns the string representation of this classReturnsString - the string representation of the classParametersNo parameters",
        "url": "/composer/latest/api/common-conceptdeclaration"
      }
      ,
    
      "api-common-decorator": {
        "title": "Decorator (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIDecoratorDecorator encapsulates a decorator (annotation) on a class or property.DetailsModule commonMethod SummaryNameReturnsDescriptionconstructorvoidCreate a DecoratorgetArgumentsobject[]Returns the arguments for this decoratorgetNamestringReturns the name of a decoratorgetParentvoidReturns the owner of this propertyMethod Detailsnew Decorator()Create a Decorator.ParametersNameTypeMandatoryDescriptionparentClassDeclaration; PropertyYesthe owner of this propertyastObjectYesThe AST created by the parsergetParentgetParent(  )Returns the owner of this propertyParametersNo parametersgetNamestring getName(  )Returns the name of a decoratorReturnsstring - the name of this decoratorParametersNo parametersgetArgumentsobject[] getArguments(  )Returns the arguments for this decoratorReturnsobject - the arguments for this decorator or null if it does not have any argumentsParametersNo parametersInherited methods",
        "url": "/composer/latest/api/common-decorator"
      }
      ,
    
      "api-common-decoratorfactory": {
        "title": "DecoratorFactory (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIDecoratorFactoryAn interface for a class that processes a decorator and returns a specificimplementation class for that decorator.DetailsModule commonMethod SummaryNameReturnsDescriptionnewDecoratorDecoratorProcess the decorator, and return a specific implementation class for that decorator, or return null if this decorator is not handled by this processorMethod DetailsnewDecoratorDecorator newDecorator( ClassDeclaration; Property parent, Object ast )Process the decorator, and return a specific implementation class for that decorator, or return null if this decorator is not handled by this processor.ReturnsDecorator - The decorator.ParametersNameTypeMandatoryDescriptionparentClassDeclaration; PropertyYesthe owner of this propertyastObjectYesThe AST created by the parserInherited methods",
        "url": "/composer/latest/api/common-decoratorfactory"
      }
      ,
    
      "api-common-enumdeclaration": {
        "title": "EnumDeclaration (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIEnumDeclarationEnumDeclaration defines an enumeration of static values.DetailsExtends ClassDeclarationModule commonSee alsoSee ClassDeclarationMethod SummaryNameReturnsDescriptionconstructorvoidCreate an AssetDeclarationisEnumbooleanReturns true if this class is an enumerationtoStringStringReturns the string representation of this classInherited Method SummarySupertypeNameReturnsDescriptionClassDeclarationgetFullyQualifiedNamestringReturns the fully qualified name of this classClassDeclaration_resolveSuperTypeClassDeclarationResolve the super type on this class and store it as an internal propertyClassDeclarationisAbstractbooleanReturns true if this class is declared as abstract in the model fileClassDeclarationisConceptbooleanReturns true if this class is the definition of a conceptClassDeclarationisEventbooleanReturns true if this class is the definition of an eventClassDeclarationisRelationshipTargetbooleanReturns true if this class can be pointed to by a relationshipClassDeclarationisSystemRelationshipTargetbooleanReturns true if this class can be pointed to by a relationship in a system modelClassDeclarationisSystemTypebooleanReturns true is this type is in the system namespaceClassDeclarationisSystemCoreTypebooleanReturns true if this class is a system core type - both in the system namespace, and also one of the system core types (Asset, Participant, etc)ClassDeclarationgetNamestringReturns the short name of a classClassDeclarationgetNamespaceStringReturn the namespace of this classClassDeclarationgetSystemTypestringReturns the base system type for this type of class declarationClassDeclarationgetIdentifierFieldNamestringReturns the name of the identifying field for this classClassDeclarationgetOwnPropertyPropertyReturns the field with a given name or null if it does not existClassDeclarationgetOwnPropertiesProperty[]Returns the fields directly defined by this classClassDeclarationgetSuperTypestringReturns the FQN of the super type for this class or null if this class does not have a super typeClassDeclarationgetSuperTypeDeclarationClassDeclarationGet the super type class declaration for this classClassDeclarationgetAssignableClassDeclarationsClassDeclaration[]Get the class declarations for all subclasses of this class, including this classClassDeclarationgetAllSuperTypeDeclarationsClassDeclaration[]Get all the super-type declarations for this typeClassDeclarationgetPropertyPropertyReturns the property with a given name or null if it does not existClassDeclarationgetPropertiesProperty[]Returns the properties defined in this class and all super classesClassDeclarationgetNestedPropertyPropertyGet a nested property using a dotted property pathMethod Detailsnew EnumDeclaration()Create an AssetDeclaration.ParametersNameTypeMandatoryDescriptionmodelFileModelFileYesthe ModelFile for this classastObjectYesThe AST created by the parserisEnumboolean isEnum(  )Returns true if this class is an enumeration.Returnsboolean - true if the class is an enumerated typeParametersNo parameterstoStringString toString(  )Returns the string representation of this classReturnsString - the string representation of the classParametersNo parametersInherited methods_resolveSuperTypeClassDeclaration _resolveSuperType(  )Inherited from:  ClassDeclarationResolve the super type on this class and store it as an internal property.ReturnsClassDeclaration - The super type, or null if non specified.ParametersNo parametersgetSystemTypestring getSystemType(  )Inherited from:  ClassDeclarationReturns the base system type for this type of class declaration. Override this method in derived classes to specify a base system type.Returnsstring - the short name of the base system type or nullParametersNo parametersisAbstractboolean isAbstract(  )Inherited from:  ClassDeclarationReturns true if this class is declared as abstract in the model fileReturnsboolean - true if the class is abstractParametersNo parametersisConceptboolean isConcept(  )Inherited from:  ClassDeclarationReturns true if this class is the definition of a concept.Returnsboolean - true if the class is a conceptParametersNo parametersisEventboolean isEvent(  )Inherited from:  ClassDeclarationReturns true if this class is the definition of an event.Returnsboolean - true if the class is an eventParametersNo parametersisRelationshipTargetboolean isRelationshipTarget(  )Inherited from:  ClassDeclarationReturns true if this class can be pointed to by a relationshipReturnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersisSystemRelationshipTargetboolean isSystemRelationshipTarget(  )Inherited from:  ClassDeclarationReturns true if this class can be pointed to by a relationship in a system modelReturnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersisSystemTypeboolean isSystemType(  )Inherited from:  ClassDeclarationReturns true is this type is in the system namespaceReturnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersisSystemCoreTypeboolean isSystemCoreType(  )Inherited from:  ClassDeclarationReturns true if this class is a system core type - both in the system namespace, and also one of the system core types (Asset, Participant, etc).Returnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersgetNamestring getName(  )Inherited from:  ClassDeclarationReturns the short name of a class. This name does not include the namespace from the owning ModelFile.Returnsstring - the short name of this classParametersNo parametersgetNamespaceString getNamespace(  )Inherited from:  ClassDeclarationReturn the namespace of this class.ReturnsString - namespace - a namespace.ParametersNo parametersgetFullyQualifiedNamestring getFullyQualifiedName(  )Inherited from:  ClassDeclarationReturns the fully qualified name of this class. The name will include the namespace if present.Returnsstring - the fully-qualified name of this classParametersNo parametersgetIdentifierFieldNamestring getIdentifierFieldName(  )Inherited from:  ClassDeclarationReturns the name of the identifying field for this class. Note that the identifying field may come from a super type.Returnsstring - the name of the id field for this classParametersNo parametersgetOwnPropertyProperty getOwnProperty( string name )Inherited from:  ClassDeclarationReturns the field with a given name or null if it does not exist. The field must be directly owned by this class -- the super-type is not introspected.ReturnsProperty - the field definition or null if it does not exist.ParametersNameTypeMandatoryDescriptionnamestringYesthe name of the fieldgetOwnPropertiesProperty[] getOwnProperties(  )Inherited from:  ClassDeclarationReturns the fields directly defined by this class.ReturnsProperty - the array of fieldsParametersNo parametersgetSuperTypestring getSuperType(  )Inherited from:  ClassDeclarationReturns the FQN of the super type for this class or null if this class does not have a super type.Returnsstring - the FQN name of the super type or nullParametersNo parametersgetSuperTypeDeclarationClassDeclaration getSuperTypeDeclaration(  )Inherited from:  ClassDeclarationGet the super type class declaration for this class.ReturnsClassDeclaration - the super type declaration, or null if there is no super type.ParametersNo parametersgetAssignableClassDeclarationsClassDeclaration[] getAssignableClassDeclarations(  )Inherited from:  ClassDeclarationGet the class declarations for all subclasses of this class, including this class.ReturnsClassDeclaration - subclass declarations.ParametersNo parametersgetAllSuperTypeDeclarationsClassDeclaration[] getAllSuperTypeDeclarations(  )Inherited from:  ClassDeclarationGet all the super-type declarations for this type.ReturnsClassDeclaration - super-type declarations.ParametersNo parametersgetPropertyProperty getProperty( string name )Inherited from:  ClassDeclarationReturns the property with a given name or null if it does not exist. Fields defined in super-types are also introspected.ReturnsProperty - the field, or null if it does not existParametersNameTypeMandatoryDescriptionnamestringYesthe name of the fieldgetPropertiesProperty[] getProperties(  )Inherited from:  ClassDeclarationReturns the properties defined in this class and all super classes.ReturnsProperty - the array of fieldsParametersNo parametersgetNestedPropertyProperty getNestedProperty( string propertypath )Inherited from:  ClassDeclarationGet a nested property using a dotted property pathReturnsProperty - the propertyParametersNameTypeMandatoryDescriptionpropertyPathstringYesThe property name or name with nested structure e.g a.b.c",
        "url": "/composer/latest/api/common-enumdeclaration"
      }
      ,
    
      "api-common-enumvaluedeclaration": {
        "title": "EnumValueDeclaration (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIEnumValueDeclarationClass representing a value from a set of enumerated valuesDetailsExtends PropertyModule commonSee alsoSee PropertyMethod SummaryNameReturnsDescriptionconstructorvoidCreate a EnumValueDeclarationInherited Method SummarySupertypeNameReturnsDescriptionPropertygetParentClassDeclarationReturns the owner of this propertyPropertygetNamestringReturns the name of a propertyPropertygetTypestringReturns the type of a propertyPropertyisOptionalbooleanReturns true if the field is optionalPropertygetFullyQualifiedTypeNamestringReturns the fully qualified type name of a propertyPropertygetFullyQualifiedNamestringReturns the fully name of a property (ns + class name + property name)PropertygetNamespacestringReturns the namespace of the parent of this propertyPropertyisArraybooleanReturns true if the field is declared as an array typePropertyisTypeEnumbooleanReturns true if the field is declared as an enumerated valuePropertyisPrimitivebooleanReturns true if this property is a primitive typeMethod Detailsnew EnumValueDeclaration()Create a EnumValueDeclaration.ParametersNameTypeMandatoryDescriptionparentClassDeclarationYesThe owner of this propertyastObjectYesThe AST created by the parserInherited methodsgetParentClassDeclaration getParent(  )Inherited from:  PropertyReturns the owner of this propertyReturnsClassDeclaration - the parent class declarationParametersNo parametersgetNamestring getName(  )Inherited from:  PropertyReturns the name of a propertyReturnsstring - the name of this fieldParametersNo parametersgetTypestring getType(  )Inherited from:  PropertyReturns the type of a propertyReturnsstring - the type of this fieldParametersNo parametersisOptionalboolean isOptional(  )Inherited from:  PropertyReturns true if the field is optionalReturnsboolean - true if the field is optionalParametersNo parametersgetFullyQualifiedTypeNamestring getFullyQualifiedTypeName(  )Inherited from:  PropertyReturns the fully qualified type name of a propertyReturnsstring - the fully qualified type of this propertyParametersNo parametersgetFullyQualifiedNamestring getFullyQualifiedName(  )Inherited from:  PropertyReturns the fully name of a property (ns + class name + property name)Returnsstring - the fully qualified name of this propertyParametersNo parametersgetNamespacestring getNamespace(  )Inherited from:  PropertyReturns the namespace of the parent of this propertyReturnsstring - the namespace of the parent of this propertyParametersNo parametersisArrayboolean isArray(  )Inherited from:  PropertyReturns true if the field is declared as an array typeReturnsboolean - true if the property is an array typeParametersNo parametersisTypeEnumboolean isTypeEnum(  )Inherited from:  PropertyReturns true if the field is declared as an enumerated valueReturnsboolean - true if the property is an enumerated valueParametersNo parametersisPrimitiveboolean isPrimitive(  )Inherited from:  PropertyReturns true if this property is a primitive type.Returnsboolean - true if the property is a primitive type.ParametersNo parameters",
        "url": "/composer/latest/api/common-enumvaluedeclaration"
      }
      ,
    
      "api-common-eventdeclaration": {
        "title": "EventDeclaration (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIEventDeclarationClass representing the definition of an Event.DetailsExtends ClassDeclarationModule commonSee alsoSee  ClassDeclarationMethod SummaryNameReturnsDescriptionconstructorvoidCreate an EventDeclarationgetSystemTypestringReturns the base system type for Events from the system namespaceisEventbooleanReturns true if this class is the definition of an eventInherited Method SummarySupertypeNameReturnsDescriptionClassDeclarationgetIdentifierFieldNamestringReturns the name of the identifying field for this classClassDeclaration_resolveSuperTypeClassDeclarationResolve the super type on this class and store it as an internal propertyClassDeclarationisEnumbooleanReturns true if this class is an enumerationClassDeclarationisConceptbooleanReturns true if this class is the definition of a conceptClassDeclarationisRelationshipTargetbooleanReturns true if this class can be pointed to by a relationshipClassDeclarationisSystemRelationshipTargetbooleanReturns true if this class can be pointed to by a relationship in a system modelClassDeclarationisSystemTypebooleanReturns true is this type is in the system namespaceClassDeclarationisSystemCoreTypebooleanReturns true if this class is a system core type - both in the system namespace, and also one of the system core types (Asset, Participant, etc)ClassDeclarationgetNamestringReturns the short name of a classClassDeclarationgetNamespaceStringReturn the namespace of this classClassDeclarationgetFullyQualifiedNamestringReturns the fully qualified name of this classClassDeclarationisAbstractbooleanReturns true if this class is declared as abstract in the model fileClassDeclarationgetOwnPropertyPropertyReturns the field with a given name or null if it does not existClassDeclarationgetOwnPropertiesProperty[]Returns the fields directly defined by this classClassDeclarationgetSuperTypestringReturns the FQN of the super type for this class or null if this class does not have a super typeClassDeclarationgetSuperTypeDeclarationClassDeclarationGet the super type class declaration for this classClassDeclarationgetAssignableClassDeclarationsClassDeclaration[]Get the class declarations for all subclasses of this class, including this classClassDeclarationgetAllSuperTypeDeclarationsClassDeclaration[]Get all the super-type declarations for this typeClassDeclarationgetPropertyPropertyReturns the property with a given name or null if it does not existClassDeclarationgetPropertiesProperty[]Returns the properties defined in this class and all super classesClassDeclarationgetNestedPropertyPropertyGet a nested property using a dotted property pathClassDeclarationtoStringStringReturns the string representation of this classMethod Detailsnew EventDeclaration()Create an EventDeclaration.ParametersNameTypeMandatoryDescriptionmodelFileModelFileYesthe ModelFile for this classastObjectYesThe AST created by the parsergetSystemTypestring getSystemType(  )Returns the base system type for Events from the system namespaceReturnsstring - the short name of the base system typeParametersNo parametersisEventboolean isEvent(  )Returns true if this class is the definition of an eventReturnsboolean - true if the class is an eventParametersNo parametersInherited methods_resolveSuperTypeClassDeclaration _resolveSuperType(  )Inherited from:  ClassDeclarationResolve the super type on this class and store it as an internal property.ReturnsClassDeclaration - The super type, or null if non specified.ParametersNo parametersisAbstractboolean isAbstract(  )Inherited from:  ClassDeclarationReturns true if this class is declared as abstract in the model fileReturnsboolean - true if the class is abstractParametersNo parametersisEnumboolean isEnum(  )Inherited from:  ClassDeclarationReturns true if this class is an enumeration.Returnsboolean - true if the class is an enumerated typeParametersNo parametersisConceptboolean isConcept(  )Inherited from:  ClassDeclarationReturns true if this class is the definition of a concept.Returnsboolean - true if the class is a conceptParametersNo parametersisRelationshipTargetboolean isRelationshipTarget(  )Inherited from:  ClassDeclarationReturns true if this class can be pointed to by a relationshipReturnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersisSystemRelationshipTargetboolean isSystemRelationshipTarget(  )Inherited from:  ClassDeclarationReturns true if this class can be pointed to by a relationship in a system modelReturnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersisSystemTypeboolean isSystemType(  )Inherited from:  ClassDeclarationReturns true is this type is in the system namespaceReturnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersisSystemCoreTypeboolean isSystemCoreType(  )Inherited from:  ClassDeclarationReturns true if this class is a system core type - both in the system namespace, and also one of the system core types (Asset, Participant, etc).Returnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersgetNamestring getName(  )Inherited from:  ClassDeclarationReturns the short name of a class. This name does not include the namespace from the owning ModelFile.Returnsstring - the short name of this classParametersNo parametersgetNamespaceString getNamespace(  )Inherited from:  ClassDeclarationReturn the namespace of this class.ReturnsString - namespace - a namespace.ParametersNo parametersgetFullyQualifiedNamestring getFullyQualifiedName(  )Inherited from:  ClassDeclarationReturns the fully qualified name of this class. The name will include the namespace if present.Returnsstring - the fully-qualified name of this classParametersNo parametersgetIdentifierFieldNamestring getIdentifierFieldName(  )Inherited from:  ClassDeclarationReturns the name of the identifying field for this class. Note that the identifying field may come from a super type.Returnsstring - the name of the id field for this classParametersNo parametersgetOwnPropertyProperty getOwnProperty( string name )Inherited from:  ClassDeclarationReturns the field with a given name or null if it does not exist. The field must be directly owned by this class -- the super-type is not introspected.ReturnsProperty - the field definition or null if it does not exist.ParametersNameTypeMandatoryDescriptionnamestringYesthe name of the fieldgetOwnPropertiesProperty[] getOwnProperties(  )Inherited from:  ClassDeclarationReturns the fields directly defined by this class.ReturnsProperty - the array of fieldsParametersNo parametersgetSuperTypestring getSuperType(  )Inherited from:  ClassDeclarationReturns the FQN of the super type for this class or null if this class does not have a super type.Returnsstring - the FQN name of the super type or nullParametersNo parametersgetSuperTypeDeclarationClassDeclaration getSuperTypeDeclaration(  )Inherited from:  ClassDeclarationGet the super type class declaration for this class.ReturnsClassDeclaration - the super type declaration, or null if there is no super type.ParametersNo parametersgetAssignableClassDeclarationsClassDeclaration[] getAssignableClassDeclarations(  )Inherited from:  ClassDeclarationGet the class declarations for all subclasses of this class, including this class.ReturnsClassDeclaration - subclass declarations.ParametersNo parametersgetAllSuperTypeDeclarationsClassDeclaration[] getAllSuperTypeDeclarations(  )Inherited from:  ClassDeclarationGet all the super-type declarations for this type.ReturnsClassDeclaration - super-type declarations.ParametersNo parametersgetPropertyProperty getProperty( string name )Inherited from:  ClassDeclarationReturns the property with a given name or null if it does not exist. Fields defined in super-types are also introspected.ReturnsProperty - the field, or null if it does not existParametersNameTypeMandatoryDescriptionnamestringYesthe name of the fieldgetPropertiesProperty[] getProperties(  )Inherited from:  ClassDeclarationReturns the properties defined in this class and all super classes.ReturnsProperty - the array of fieldsParametersNo parametersgetNestedPropertyProperty getNestedProperty( string propertypath )Inherited from:  ClassDeclarationGet a nested property using a dotted property pathReturnsProperty - the propertyParametersNameTypeMandatoryDescriptionpropertyPathstringYesThe property name or name with nested structure e.g a.b.ctoStringString toString(  )Inherited from:  ClassDeclarationReturns the string representation of this classReturnsString - the string representation of the classParametersNo parameters",
        "url": "/composer/latest/api/common-eventdeclaration"
      }
      ,
    
      "api-common-factory": {
        "title": "Factory (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIFactoryUse the Factory to create instances of Resource: transactions, participantsand assets.Applications should retrieve instances of the Factory from BusinessNetworkDefinition#getFactoryDetailsModule commonMethod SummaryNameReturnsDescriptionnewConceptResourceCreate a new Concept with a given namespace and type namenewEventResourceCreate a new event objectnewRelationshipRelationshipCreate a new Relationship with a given namespace, type and identifiernewResourceResourceCreate a new Resource with a given namespace, type name and idnewTransactionResourceCreate a new transaction objectMethod DetailsnewResourceResource newResource( String ns, String type, String id, [Object options] )Create a new Resource with a given namespace, type name and idReturnsResource - the new instanceParametersNameTypeMandatoryDescriptionnsStringYesthe namespace of the ResourcetypeStringYesthe type of the ResourceidStringYesthe identifieroptionsObjectYesan optional set of optionsSub-optionsNameTypeMandatoryDescriptionoptions.disableValidationbooleanYespass true if you want the factory to return a Resource instead of a ValidatedResource. Defaults to false.options.generateStringYesPass one of:  samplereturn a resource instance with generated sample data. emptyreturn a resource instance with empty property values.options.includeOptionalFieldsbooleanYesif options.generate is specified, whether optional fields should be generated.options.allowEmptyIdbooleanYesif options.allowEmptyId is specified as true, a zero length string for id is allowed (allows it to be filled in later).newConceptResource newConcept( String ns, String type, [Object options] )Create a new Concept with a given namespace and type nameReturnsResource - the new instanceParametersNameTypeMandatoryDescriptionnsStringYesthe namespace of the ConcepttypeStringYesthe type of the ConceptoptionsObjectYesan optional set of optionsSub-optionsNameTypeMandatoryDescriptionoptions.disableValidationbooleanYespass true if you want the factory to return a Concept instead of a ValidatedConcept. Defaults to false.options.generateStringYesPass one of:  samplereturn a resource instance with generated sample data. emptyreturn a resource instance with empty property values.options.includeOptionalFieldsbooleanYesif options.generate is specified, whether optional fields should be generated.newRelationshipRelationship newRelationship( String ns, String type, String id )Create a new Relationship with a given namespace, type and identifier. A relationship is a typed pointer to an instance. I.e the relationship with namespace = &#39;org.example&#39;, type = &#39;Vehicle&#39; and id = &#39;ABC&#39; creates a pointer that points at an instance of org.example.Vehicle with the id ABC.ReturnsRelationship - the new relationship instanceParametersNameTypeMandatoryDescriptionnsStringYesthe namespace of the ResourcetypeStringYesthe type of the ResourceidStringYesthe identifiernewTransactionResource newTransaction( String ns, String type, [String id], [Object options] )Create a new transaction object. The identifier of the transaction is set to a UUID.ReturnsResource - A resource for the new transaction.ParametersNameTypeMandatoryDescriptionnsStringYesthe namespace of the transaction.typeStringYesthe type of the transaction.idStringYesan optional identifier for the transaction; if you do not specify one then an identifier will be automatically generated.optionsObjectYesan optional set of optionsSub-optionsNameTypeMandatoryDescriptionoptions.generateStringYesPass one of:  samplereturn a resource instance with generated sample data. emptyreturn a resource instance with empty property values.options.includeOptionalFieldsbooleanYesif options.generate is specified, whether optional fields should be generated.options.allowEmptyIdbooleanYesif options.allowEmptyId is specified as true, a zero length string for id is allowed (allows it to be filled in later).newEventResource newEvent( String ns, String type, [String id], [Object options] )Create a new event object. The identifier of the event is set to a UUID.ReturnsResource - A resource for the new event.ParametersNameTypeMandatoryDescriptionnsStringYesthe namespace of the event.typeStringYesthe type of the event.idStringYesan optional identifier for the event; if you do not specify one then an identifier will be automatically generated.optionsObjectYesan optional set of optionsSub-optionsNameTypeMandatoryDescriptionoptions.generateStringYesPass one of:  samplereturn a resource instance with generated sample data. emptyreturn a resource instance with empty property values.options.includeOptionalFieldsbooleanYesif options.generate is specified, whether optional fields should be generated.options.allowEmptyIdbooleanYesif options.allowEmptyId is specified as true, a zero length string for id is allowed (allows it to be filled in later).Inherited methods",
        "url": "/composer/latest/api/common-factory"
      }
      ,
    
      "api-common-functiondeclaration": {
        "title": "FunctionDeclaration (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIFunctionDeclarationFunctionDeclaration defines a function that has been definedin a model file. If the name of the function starts with &#39;on&#39;then the name of the function denotes the name of a transactiondeclaration that the function processes.DetailsModule commonMethod SummaryNameReturnsDescriptionconstructorvoidCreate a FunctionDeclarationgetDecoratorsstring[]Returns the decorators that the function was tagged withgetFunctionTextstringReturns the text of this functiongetLanguagestringReturns the programming language that the function is written ingetNamestringReturns the name of the functiongetParameterNamesstring[]Returns the names of the parameters processed by the functiongetParameterTypesstring[]Returns the types of the parameters processed by the functiongetReturnTypestringReturns the return type for this functiongetThrowsstringReturns the type thrown by this functiongetTransactionDeclarationNamestringReturns the short name of the transaction declaration that is being processedgetVisibilitystringReturns the visibility of this functionMethod Detailsnew FunctionDeclaration()Create a FunctionDeclarationParametersNameTypeMandatoryDescriptionmodelManagerModelManagerYesthe ModelManager used to validate this functionlanguagestringYesthe language that the function is written in. E.g. JS.namestringYesthe name of the functionvisibilitystringYesthe visibility of the functionreturnTypestringYesthe return type of the functionthrowsstringYesthe type that is thrown by the functionparameterNamesYesthe names of parameters of the functionparameterTypesYesthe type names of parameters of the functiondecoratorsYesthe function decoratorsfunctionTextstringYesthe function as textgetFunctionTextstring getFunctionText(  )Returns the text of this function.Returnsstring - the text that defines the functionParametersNo parametersgetThrowsstring getThrows(  )Returns the type thrown by this functionReturnsstring - the type thrown by the functionParametersNo parametersgetLanguagestring getLanguage(  )Returns the programming language that the function is written inReturnsstring - the language of the functionParametersNo parametersgetDecoratorsstring[] getDecorators(  )Returns the decorators that the function was tagged withReturnsstring - the @ prefixed decorators for the functionParametersNo parametersgetVisibilitystring getVisibility(  )Returns the visibility of this functionReturnsstring - the visibility of the function (+ is public), (- is private)ParametersNo parametersgetReturnTypestring getReturnType(  )Returns the return type for this functionReturnsstring - the return type for the functionParametersNo parametersgetNamestring getName(  )Returns the name of the functionReturnsstring - the name of the function.ParametersNo parametersgetTransactionDeclarationNamestring getTransactionDeclarationName(  )Returns the short name of the transaction declaration that is being processed. This is calculated by removing the &#39;on&#39; prefix from the function name. If the function name does not start with &#39;on&#39; then nullReturnsstring - the name of the transaction declaration.ParametersNo parametersgetParameterNamesstring[] getParameterNames(  )Returns the names of the parameters processed by the function.Returnsstring - the names of the parameters.ParametersNo parametersgetParameterTypesstring[] getParameterTypes(  )Returns the types of the parameters processed by the function.Returnsstring - the types of the parameters.ParametersNo parametersInherited methods",
        "url": "/composer/latest/api/common-functiondeclaration"
      }
      ,
    
      "api-common-idcard": {
        "title": "IdCard (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIIdCardBusiness Network Card. Encapsulates credentials and other information required to connect to a specific business networkas a specific user.Instances of this class can be created using IdCard.fromArchive or IdCard.fromDirectory, as well as the constructor.DetailsModule commonMethod SummaryNameReturnsDescriptionconstructorvoidCreate the IdCardfromArchivePromiseCreate an IdCard from a card archivefromDirectoryPromiseCreate an IdCard from a directory consisting of the content of an ID cardgetBusinessNetworkNameStringName of the business network to which the ID card appliesgetConnectionProfileObjectConnection profile for this cardgetCredentialsObjectCredentials associated with this card, and which are used to connect to the associated business networkgetDescriptionStringFree text description of the cardgetEnrollmentCredentialsObjectEnrollment credentialsgetRolesString[]Special roles for which this ID can be used, which can include:    PeerAdmin   ChannelAdmin   Issuer getUserNameStringName of the user identity associated with the cardsetCredentialsvoidCredentials to associate with this cardtoArchivePromiseGenerate a card archive representing this ID cardtoDirectoryPromiseSave the content of an IdCard a directoryMethod Detailsnew IdCard()Create the IdCard.ParametersNameTypeMandatoryDescriptionmetadataObjectYesmetadata associated with the card.connectionProfileObjectYesconnection profile associated with the card.getUserNameString getUserName(  )Name of the user identity associated with the card. This should be unique within the scope of a given business network and connection profile.This is a mandatory field.ReturnsString - Name of the user identity.ParametersNo parametersgetDescriptionString getDescription(  )Free text description of the card.ReturnsString - card description.ParametersNo parametersgetBusinessNetworkNameString getBusinessNetworkName(  )Name of the business network to which the ID card applies. Generally this will be present but may be omitted for system cards.ReturnsString - business network name.ParametersNo parametersgetConnectionProfileObject getConnectionProfile(  )Connection profile for this card.This is a mandatory field.ReturnsObject - connection profile.ParametersNo parametersgetCredentialsObject getCredentials(  )Credentials associated with this card, and which are used to connect to the associated business network.  For PKI-based authentication, the credentials are expected to be of the form: { certificate: String, privateKey: String }.ReturnsObject - credentials.ParametersNo parameterssetCredentialssetCredentials( Object credentials )Credentials to associate with this card.  For PKI-based authentication, the credentials are expected to be of the form: { certificate: String, privateKey: String }.ParametersNameTypeMandatoryDescriptioncredentialsObjectYescredentials.getEnrollmentCredentialsObject getEnrollmentCredentials(  )Enrollment credentials. If there are no credentials associated with this card, these credentials  are used to enroll with a business network and obtain certificates.  For an ID/secret enrollment scheme, the credentials are expected to be of the form: { secret: String }.ReturnsObject - enrollment credentials, or null if none exist.ParametersNo parametersgetRolesString[] getRoles(  )Special roles for which this ID can be used, which can include:    PeerAdmin   ChannelAdmin   Issuer ReturnsString - roles.ParametersNo parametersfromArchivePromise fromArchive( String; ArrayBuffer; Uint8Array; Buffer; Blob; Promise zipdata )Create an IdCard from a card archive.  Valid types for zipData are any of the types supported by JSZip.ReturnsPromise - Promise to the instantiated IdCard.ParametersNameTypeMandatoryDescriptionzipDataString; ArrayBuffer; Uint8Array; Buffer; Blob; PromiseYescard archive data.toArchivePromise toArchive( [Object options] )Generate a card archive representing this ID card.  The default value for the options.type parameter is arraybuffer. See JSZip documentation for other valid values.ReturnsPromise - Promise of the generated ZIP file; by default an ArrayBuffer.ParametersNameTypeMandatoryDescriptionoptionsObjectYesJSZip generation options.Sub-optionsNameTypeMandatoryDescriptionoptions.typeStringYestype of the resulting ZIP file data.fromDirectoryPromise fromDirectory( String carddirectory, [ fs] )Create an IdCard from a directory consisting of the content of an ID card.ReturnsPromise - Promise that resolves to an IdCard.ParametersNameTypeMandatoryDescriptioncardDirectoryStringYesdirectory containing card data.fsYesNode file system API implementation to use for reading card data. Defaults to the Node implementation.toDirectoryPromise toDirectory( String carddirectory, [ fs] )Save the content of an IdCard a directory.ReturnsPromise - Promise that resolves then the save is complete.ParametersNameTypeMandatoryDescriptioncardDirectoryStringYesdirectory to save card data.fsYesNode file system API implementation to use for writing card data. Defaults to the Node implementation.Inherited methods",
        "url": "/composer/latest/api/common-idcard"
      }
      ,
    
      "api-common-identifiable": {
        "title": "Identifiable (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIIdentifiableIdentifiable is an entity with a namespace, type and an identifier.Applications should retrieve instances from FactoryThis class is abstract.DetailsExtends TypedModule commonMethod SummaryNameReturnsDescriptiongetFullyQualifiedIdentifierstringGet the fully qualified identifier of this instancegetIdentifierstringGet the identifier of this instanceisRelationshipbooleanDetermine if this identifiable is a relationshipisResourcebooleanDetermine if this identifiable is a resourcesetIdentifiervoidSet the identifier of this instancetoStringStringReturns the string representation of this classtoURIStringReturns a URI representation of a reference to this identifiableInherited Method SummarySupertypeNameReturnsDescriptionTypedgetTypestringGet the type of the instance (a short name, not including namespace)TypedgetFullyQualifiedTypestringGet the fully-qualified type name of the instance (including namespace)TypedgetNamespacestringGet the namespace of the instanceTypedsetPropertyValuevoidSets a property on this ResourceTypedaddArrayValuevoidAdds a value to an array property on this ResourceTypedinstanceOfbooleanCheck to see if this instance is an instance of the specified fully qualified type nameMethod DetailsgetIdentifierstring getIdentifier(  )Get the identifier of this instanceReturnsstring - The identifier for this objectParametersNo parameterssetIdentifiersetIdentifier( string id )Set the identifier of this instanceParametersNameTypeMandatoryDescriptionidstringYesthe new identifier for this objectgetFullyQualifiedIdentifierstring getFullyQualifiedIdentifier(  )Get the fully qualified identifier of this instance. (namespace &#39;.&#39; type &#39;#&#39; identifier).Returnsstring - the fully qualified identifier of this instanceParametersNo parameterstoStringString toString(  )Returns the string representation of this classReturnsString - the string representation of the classParametersNo parametersisRelationshipboolean isRelationship(  )Determine if this identifiable is a relationship.Returnsboolean - True if this identifiable is a relationship, false if not.ParametersNo parametersisResourceboolean isResource(  )Determine if this identifiable is a resource.Returnsboolean - True if this identifiable is a resource, false if not.ParametersNo parameterstoURIString toURI(  )Returns a URI representation of a reference to this identifiableReturnsString - the URI for the identifiableParametersNo parametersInherited methodsgetTypestring getType(  )Inherited from:  TypedGet the type of the instance (a short name, not including namespace).Returnsstring - The type of this objectParametersNo parametersgetFullyQualifiedTypestring getFullyQualifiedType(  )Inherited from:  TypedGet the fully-qualified type name of the instance (including namespace).Returnsstring - The fully-qualified type name of this objectParametersNo parametersgetNamespacestring getNamespace(  )Inherited from:  TypedGet the namespace of the instance.Returnsstring - The namespace of this objectParametersNo parameterssetPropertyValuevoid setPropertyValue( string propname, string value )Inherited from:  TypedSets a property on this ResourceParametersNameTypeMandatoryDescriptionpropNamestringYesthe name of the fieldvaluestringYesthe value of the propertyaddArrayValuevoid addArrayValue( string propname, string value )Inherited from:  TypedAdds a value to an array property on this ResourceParametersNameTypeMandatoryDescriptionpropNamestringYesthe name of the fieldvaluestringYesthe value of the propertyinstanceOfboolean instanceOf( String fqt )Inherited from:  TypedCheck to see if this instance is an instance of the specified fully qualified type name.Returnsboolean - True if this instance is an instance of the specified fully qualified type name, false otherwise.ParametersNameTypeMandatoryDescriptionfqtStringYesThe fully qualified type name.",
        "url": "/composer/latest/api/common-identifiable"
      }
      ,
    
      "api-common-introspector": {
        "title": "Introspector (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIIntrospectorProvides access to the structure of transactions, assets and participants.DetailsModule commonMethod SummaryNameReturnsDescriptionconstructorvoidCreate the IntrospectorgetClassDeclarationClassDeclarationReturns the class declaration with the given fully qualified namegetClassDeclarationsClassDeclaration[]Returns all the class declarations for the business networkMethod Detailsnew Introspector()Create the Introspector.  Note: Only to be called by framework code. Applications should retrieve instances from BusinessNetworkDefinition ParametersNameTypeMandatoryDescriptionmodelManagerModelManagerYesthe ModelManager that backs this IntrospectorgetClassDeclarationsClassDeclaration[] getClassDeclarations(  )Returns all the class declarations for the business network.ReturnsClassDeclaration - the array of class declarationsParametersNo parametersgetClassDeclarationClassDeclaration getClassDeclaration( String fullyqualifiedtypename )Returns the class declaration with the given fully qualified name. Throws an error if the class declaration does not exist.ReturnsClassDeclaration - the class declarationParametersNameTypeMandatoryDescriptionfullyQualifiedTypeNameStringYesthe fully qualified name of the typeInherited methods",
        "url": "/composer/latest/api/common-introspector"
      }
      ,
    
      "api-common-modelfile": {
        "title": "ModelFile (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIModelFileClass representing a Model File. A Model File contains a single namespaceand a set of model elements: assets, transactions etc.DetailsModule commonMethod SummaryNameReturnsDescriptiongetAllDeclarationsClassDeclaration[]Get all declarations in this ModelFilegetAssetDeclarationAssetDeclarationGet the AssetDeclarations defined in this ModelFile or nullgetAssetDeclarationsAssetDeclaration[]Get the AssetDeclarations defined in this ModelFilegetConceptDeclarationsConceptDeclaration[]Get the ConceptDeclarations defined in this ModelFilegetDeclarationsClassDeclaration[]Get the instances of a given type in this ModelFilegetDefinitionsstringGet the definitions for this modelgetEnumDeclarationsEnumDeclaration[]Get the EnumDeclarations defined in this ModelFilegetEventDeclarationEventDeclarationGet the EventDeclaration defined in this ModelFile or nullgetEventDeclarationsEventDeclaration[]Get the EventDeclarations defined in this ModelFilegetImportsstring[]Returns the types that have been imported into this ModelFilegetLocalTypeClassDeclarationReturns the type with the specified name or nullgetModelManagerModelManagerReturns the ModelManager associated with this ModelFilegetNamestringGet the filename for this model filegetNamespacestringGet the Namespace for this model filegetParticipantDeclarationParticipantDeclarationGet the ParticipantDeclaration defined in this ModelFile or nullgetParticipantDeclarationsParticipantDeclaration[]Get the ParticipantDeclarations defined in this ModelFilegetTransactionDeclarationTransactionDeclarationGet the TransactionDeclaration defined in this ModelFile or nullgetTransactionDeclarationsTransactionDeclaration[]Get the TransactionDeclarations defined in this ModelFileisDefinedbooleanReturns true if the type is defined in the model fileisExternalbooleanReturns true if this ModelFile was downloaded from an external URIisSystemModelFilebooleanReturns true if this ModelFile is a system modelMethod DetailsisExternalboolean isExternal(  )Returns true if this ModelFile was downloaded from an external URI.Returnsboolean - true iff this ModelFile was downloaded from an external URIParametersNo parametersgetModelManagerModelManager getModelManager(  )Returns the ModelManager associated with this ModelFileReturnsModelManager - The ModelManager for this ModelFileParametersNo parametersgetImportsstring[] getImports(  )Returns the types that have been imported into this ModelFile.Returnsstring - The array of imports for this ModelFileParametersNo parametersisDefinedboolean isDefined( string type )Returns true if the type is defined in the model fileReturnsboolean - true if the type (asset or transaction) is definedParametersNameTypeMandatoryDescriptiontypestringYesthe name of the typegetLocalTypeClassDeclaration getLocalType( string type )Returns the type with the specified name or nullReturnsClassDeclaration - the ClassDeclaration, or null if the type does not existParametersNameTypeMandatoryDescriptiontypestringYesthe short OR FQN name of the typegetAssetDeclarationAssetDeclaration getAssetDeclaration( string name )Get the AssetDeclarations defined in this ModelFile or nullReturnsAssetDeclaration - the AssetDeclaration with the given short nameParametersNameTypeMandatoryDescriptionnamestringYesthe name of the typegetTransactionDeclarationTransactionDeclaration getTransactionDeclaration( string name )Get the TransactionDeclaration defined in this ModelFile or nullReturnsTransactionDeclaration - the TransactionDeclaration with the given short nameParametersNameTypeMandatoryDescriptionnamestringYesthe name of the typegetEventDeclarationEventDeclaration getEventDeclaration( string name )Get the EventDeclaration defined in this ModelFile or nullReturnsEventDeclaration - the EventDeclaration with the given short nameParametersNameTypeMandatoryDescriptionnamestringYesthe name of the typegetParticipantDeclarationParticipantDeclaration getParticipantDeclaration( string name )Get the ParticipantDeclaration defined in this ModelFile or nullReturnsParticipantDeclaration - the ParticipantDeclaration with the given short nameParametersNameTypeMandatoryDescriptionnamestringYesthe name of the typegetNamespacestring getNamespace(  )Get the Namespace for this model file.Returnsstring - The Namespace for this model fileParametersNo parametersgetNamestring getName(  )Get the filename for this model file. Note that this may be null.Returnsstring - The filename for this model fileParametersNo parametersgetAssetDeclarationsAssetDeclaration[] getAssetDeclarations( Boolean includesystemtype )Get the AssetDeclarations defined in this ModelFileReturnsAssetDeclaration - the AssetDeclarations defined in the model fileParametersNameTypeMandatoryDescriptionincludeSystemTypeBooleanYesInclude the decalarations of system type in returned datagetTransactionDeclarationsTransactionDeclaration[] getTransactionDeclarations( Boolean includesystemtype )Get the TransactionDeclarations defined in this ModelFileReturnsTransactionDeclaration - the TransactionDeclarations defined in the model fileParametersNameTypeMandatoryDescriptionincludeSystemTypeBooleanYesInclude the decalarations of system type in returned datagetEventDeclarationsEventDeclaration[] getEventDeclarations( Boolean includesystemtype )Get the EventDeclarations defined in this ModelFileReturnsEventDeclaration - the EventDeclarations defined in the model fileParametersNameTypeMandatoryDescriptionincludeSystemTypeBooleanYesInclude the decalarations of system type in returned datagetParticipantDeclarationsParticipantDeclaration[] getParticipantDeclarations( Boolean includesystemtype )Get the ParticipantDeclarations defined in this ModelFileReturnsParticipantDeclaration - the ParticipantDeclaration defined in the model fileParametersNameTypeMandatoryDescriptionincludeSystemTypeBooleanYesInclude the decalarations of system type in returned datagetConceptDeclarationsConceptDeclaration[] getConceptDeclarations( Boolean includesystemtype )Get the ConceptDeclarations defined in this ModelFileReturnsConceptDeclaration - the ParticipantDeclaration defined in the model fileParametersNameTypeMandatoryDescriptionincludeSystemTypeBooleanYesInclude the decalarations of system type in returned datagetEnumDeclarationsEnumDeclaration[] getEnumDeclarations( Boolean includesystemtype )Get the EnumDeclarations defined in this ModelFileReturnsEnumDeclaration - the EnumDeclaration defined in the model fileParametersNameTypeMandatoryDescriptionincludeSystemTypeBooleanYesInclude the decalarations of system type in returned datagetDeclarationsClassDeclaration[] getDeclarations( Function type, Boolean includesystemtype )Get the instances of a given type in this ModelFileReturnsClassDeclaration - the ClassDeclaration defined in the model fileParametersNameTypeMandatoryDescriptiontypeFunctionYesthe type of the declarationincludeSystemTypeBooleanYesInclude the decalarations of system type in returned datagetAllDeclarationsClassDeclaration[] getAllDeclarations(  )Get all declarations in this ModelFileReturnsClassDeclaration - the ClassDeclarations defined in the model fileParametersNo parametersgetDefinitionsstring getDefinitions(  )Get the definitions for this model.Returnsstring - The definitions for this model.ParametersNo parametersisSystemModelFileboolean isSystemModelFile(  )Returns true if this ModelFile is a system modelReturnsboolean - true of this ModelFile is a system modelParametersNo parametersInherited methods",
        "url": "/composer/latest/api/common-modelfile"
      }
      ,
    
      "api-common-modelmanager": {
        "title": "ModelManager (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIModelManagerManages the Composer model files.The structure of Resources (Assets, Transactions, Participants) is modelledin a set of Composer files. The contents of these files are managedby the ModelManager. Each Composer file has a single namespace and containsa set of asset, transaction and participant type definitions.Composer applications load their Composer files and then call the addModelFilemethod to register the Composer file(s) with the ModelManager. The ModelManagerparses the text of the Composer file and will make all defined types availableto other Composer services, such as the Serializer (to convert instances to/from JSON)and Factory (to create instances).DetailsModule commonMethod SummaryNameReturnsDescriptionaddDecoratorFactoryvoidAdd a decorator factory to this model manageraddModelFileObjectAdds a Composer file (as a string) to the ModelManageraddModelFilesObject[]Add a set of Composer files to the model managerclearModelFilesvoidRemove all registered Composer filesdeleteModelFilevoidRemove the Composer file for a given namespacegetAssetDeclarationsAssetDeclaration[]Get the AssetDeclarations defined in this model managergetConceptDeclarationsConceptDeclaration[]Get the Concepts defined in this model managergetDecoratorFactoriesDecoratorFactory[]Get the decorator factories for this model managergetEnumDeclarationsEnumDeclaration[]Get the EnumDeclarations defined in this model managergetEventDeclarationsEventDeclaration[]Get the EventDeclarations defined in this model managergetFactoryFactoryGet a factory for creating new instances of types defined in this model managergetNamespacesstring[]Get the namespaces registered with the ModelManagergetParticipantDeclarationsParticipantDeclaration[]Get the ParticipantDeclarations defined in this model managergetSerializerSerializerGet a serializer for serializing instances of types defined in this model managergetSystemTypesClassDeclaration[]Get all class declarations from system namespacesgetTransactionDeclarationsTransactionDeclaration[]Get the TransactionDeclarations defined in this model managerupdateExternalModelsPromiseDownloads all ModelFiles that are external dependencies and adds or updates them in this ModelManagerupdateModelFileObjectUpdates a Composer file (as a string) on the ModelManagervalidateModelFilevoidValidates a Composer file (as a string) to the ModelManagervalidateModelFilesvoidValidates all models files in this model managerMethod DetailsvalidateModelFilevalidateModelFile( string modelfile, string filename )Validates a Composer file (as a string) to the ModelManager. Composer files have a single namespace.Note that if there are dependencies between multiple files the files must be added in dependency order, or the addModelFiles method can be used to add a set of files irrespective of dependencies.ParametersNameTypeMandatoryDescriptionmodelFilestringYesThe Composer file as a stringfileNamestringYesan optional file name to associate with the model fileaddModelFileObject addModelFile( string modelfile, string filename, [boolean disablevalidation] )Adds a Composer file (as a string) to the ModelManager. Composer files have a single namespace. If a Composer file with the same namespace has already been added to the ModelManager then it will be replaced. Note that if there are dependencies between multiple files the files must be added in dependency order, or the addModelFiles method can be used to add a set of files irrespective of dependencies.ReturnsObject - The newly added model file (internal).ParametersNameTypeMandatoryDescriptionmodelFilestringYesThe Composer file as a stringfileNamestringYesan optional file name to associate with the model filedisableValidationbooleanYesIf true then the model files are not validatedupdateModelFileObject updateModelFile( string modelfile, string filename, [boolean disablevalidation] )Updates a Composer file (as a string) on the ModelManager. Composer files have a single namespace. If a Composer file with the same namespace has already been added to the ModelManager then it will be replaced.ReturnsObject - The newly added model file (internal).ParametersNameTypeMandatoryDescriptionmodelFilestringYesThe Composer file as a stringfileNamestringYesan optional file name to associate with the model filedisableValidationbooleanYesIf true then the model files are not validateddeleteModelFiledeleteModelFile( string namespace )Remove the Composer file for a given namespaceParametersNameTypeMandatoryDescriptionnamespacestringYesThe namespace of the model file to delete.addModelFilesObject[] addModelFiles(  modelfiles, [ filenames], [boolean disablevalidation] )Add a set of Composer files to the model manager.ReturnsObject - The newly added model files (internal).ParametersNameTypeMandatoryDescriptionmodelFilesYesAn array of Composer files as strings.fileNamesYesAn optional array of file names to associate with the model filesdisableValidationbooleanYesIf true then the model files are not validatedvalidateModelFilesvalidateModelFiles(  )Validates all models files in this model managerParametersNo parametersupdateExternalModelsPromise updateExternalModels( [Object options], [ModelFileDownloader modelfiledownloader] )Downloads all ModelFiles that are external dependencies and adds or updates them in this ModelManager.ReturnsPromise - a promise when the download and update operation is completed.ParametersNameTypeMandatoryDescriptionoptionsObjectYesOptions object passed to ModelFileLoadersmodelFileDownloaderModelFileDownloaderYesan optional ModelFileDownloaderclearModelFilesclearModelFiles(  )Remove all registered Composer filesParametersNo parametersgetNamespacesstring[] getNamespaces(  )Get the namespaces registered with the ModelManager.Returnsstring - namespaces - the namespaces that have been registered.ParametersNo parametersgetSystemTypesClassDeclaration[] getSystemTypes(  )Get all class declarations from system namespacesReturnsClassDeclaration - the ClassDeclarations from system namespacesParametersNo parametersgetAssetDeclarationsAssetDeclaration[] getAssetDeclarations( Boolean includesystemtype )Get the AssetDeclarations defined in this model managerReturnsAssetDeclaration - the AssetDeclarations defined in the model managerParametersNameTypeMandatoryDescriptionincludeSystemTypeBooleanYesInclude the decalarations of system type in returned datagetTransactionDeclarationsTransactionDeclaration[] getTransactionDeclarations( Boolean includesystemtype )Get the TransactionDeclarations defined in this model managerReturnsTransactionDeclaration - the TransactionDeclarations defined in the model managerParametersNameTypeMandatoryDescriptionincludeSystemTypeBooleanYesInclude the decalarations of system type in returned datagetEventDeclarationsEventDeclaration[] getEventDeclarations( Boolean includesystemtype )Get the EventDeclarations defined in this model managerReturnsEventDeclaration - the EventDeclaration defined in the model managerParametersNameTypeMandatoryDescriptionincludeSystemTypeBooleanYesInclude the decalarations of system type in returned datagetParticipantDeclarationsParticipantDeclaration[] getParticipantDeclarations( Boolean includesystemtype )Get the ParticipantDeclarations defined in this model managerReturnsParticipantDeclaration - the ParticipantDeclaration defined in the model managerParametersNameTypeMandatoryDescriptionincludeSystemTypeBooleanYesInclude the decalarations of system type in returned datagetEnumDeclarationsEnumDeclaration[] getEnumDeclarations( Boolean includesystemtype )Get the EnumDeclarations defined in this model managerReturnsEnumDeclaration - the EnumDeclaration defined in the model managerParametersNameTypeMandatoryDescriptionincludeSystemTypeBooleanYesInclude the decalarations of system type in returned datagetConceptDeclarationsConceptDeclaration[] getConceptDeclarations( Boolean includesystemtype )Get the Concepts defined in this model managerReturnsConceptDeclaration - the ConceptDeclaration defined in the model managerParametersNameTypeMandatoryDescriptionincludeSystemTypeBooleanYesInclude the decalarations of system type in returned datagetFactoryFactory getFactory(  )Get a factory for creating new instances of types defined in this model manager.ReturnsFactory - A factory for creating new instances of types defined in this model manager.ParametersNo parametersgetSerializerSerializer getSerializer(  )Get a serializer for serializing instances of types defined in this model manager.ReturnsSerializer - A serializer for serializing instances of types defined in this model manager.ParametersNo parametersgetDecoratorFactoriesDecoratorFactory[] getDecoratorFactories(  )Get the decorator factories for this model manager.ReturnsDecoratorFactory - The decorator factories for this model manager.ParametersNo parametersaddDecoratorFactoryaddDecoratorFactory( DecoratorFactory factory )Add a decorator factory to this model manager.ParametersNameTypeMandatoryDescriptionfactoryDecoratorFactoryYesThe decorator factory to add to this model manager.Inherited methods",
        "url": "/composer/latest/api/common-modelmanager"
      }
      ,
    
      "api-common-participantdeclaration": {
        "title": "ParticipantDeclaration (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIParticipantDeclarationClass representing the definition of a Participant.DetailsExtends ClassDeclarationModule commonSee alsoSee  ClassDeclarationMethod SummaryNameReturnsDescriptionconstructorvoidCreate an ParticipantDeclarationgetSystemTypestringReturns the base system type for Participants from the system namespaceisRelationshipTargetbooleanReturns true if this class can be pointed to by a relationshipInherited Method SummarySupertypeNameReturnsDescriptionClassDeclarationgetIdentifierFieldNamestringReturns the name of the identifying field for this classClassDeclaration_resolveSuperTypeClassDeclarationResolve the super type on this class and store it as an internal propertyClassDeclarationisEnumbooleanReturns true if this class is an enumerationClassDeclarationisConceptbooleanReturns true if this class is the definition of a conceptClassDeclarationisEventbooleanReturns true if this class is the definition of an eventClassDeclarationisSystemRelationshipTargetbooleanReturns true if this class can be pointed to by a relationship in a system modelClassDeclarationisSystemTypebooleanReturns true is this type is in the system namespaceClassDeclarationisSystemCoreTypebooleanReturns true if this class is a system core type - both in the system namespace, and also one of the system core types (Asset, Participant, etc)ClassDeclarationgetNamestringReturns the short name of a classClassDeclarationgetNamespaceStringReturn the namespace of this classClassDeclarationgetFullyQualifiedNamestringReturns the fully qualified name of this classClassDeclarationisAbstractbooleanReturns true if this class is declared as abstract in the model fileClassDeclarationgetOwnPropertyPropertyReturns the field with a given name or null if it does not existClassDeclarationgetOwnPropertiesProperty[]Returns the fields directly defined by this classClassDeclarationgetSuperTypestringReturns the FQN of the super type for this class or null if this class does not have a super typeClassDeclarationgetSuperTypeDeclarationClassDeclarationGet the super type class declaration for this classClassDeclarationgetAssignableClassDeclarationsClassDeclaration[]Get the class declarations for all subclasses of this class, including this classClassDeclarationgetAllSuperTypeDeclarationsClassDeclaration[]Get all the super-type declarations for this typeClassDeclarationgetPropertyPropertyReturns the property with a given name or null if it does not existClassDeclarationgetPropertiesProperty[]Returns the properties defined in this class and all super classesClassDeclarationgetNestedPropertyPropertyGet a nested property using a dotted property pathClassDeclarationtoStringStringReturns the string representation of this classMethod Detailsnew ParticipantDeclaration()Create an ParticipantDeclaration.ParametersNameTypeMandatoryDescriptionmodelFileModelFileYesthe ModelFile for this classastObjectYesThe AST created by the parserisRelationshipTargetboolean isRelationshipTarget(  )Returns true if this class can be pointed to by a relationshipReturnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersgetSystemTypestring getSystemType(  )Returns the base system type for Participants from the system namespaceReturnsstring - the short name of the base system typeParametersNo parametersInherited methods_resolveSuperTypeClassDeclaration _resolveSuperType(  )Inherited from:  ClassDeclarationResolve the super type on this class and store it as an internal property.ReturnsClassDeclaration - The super type, or null if non specified.ParametersNo parametersisAbstractboolean isAbstract(  )Inherited from:  ClassDeclarationReturns true if this class is declared as abstract in the model fileReturnsboolean - true if the class is abstractParametersNo parametersisEnumboolean isEnum(  )Inherited from:  ClassDeclarationReturns true if this class is an enumeration.Returnsboolean - true if the class is an enumerated typeParametersNo parametersisConceptboolean isConcept(  )Inherited from:  ClassDeclarationReturns true if this class is the definition of a concept.Returnsboolean - true if the class is a conceptParametersNo parametersisEventboolean isEvent(  )Inherited from:  ClassDeclarationReturns true if this class is the definition of an event.Returnsboolean - true if the class is an eventParametersNo parametersisSystemRelationshipTargetboolean isSystemRelationshipTarget(  )Inherited from:  ClassDeclarationReturns true if this class can be pointed to by a relationship in a system modelReturnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersisSystemTypeboolean isSystemType(  )Inherited from:  ClassDeclarationReturns true is this type is in the system namespaceReturnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersisSystemCoreTypeboolean isSystemCoreType(  )Inherited from:  ClassDeclarationReturns true if this class is a system core type - both in the system namespace, and also one of the system core types (Asset, Participant, etc).Returnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersgetNamestring getName(  )Inherited from:  ClassDeclarationReturns the short name of a class. This name does not include the namespace from the owning ModelFile.Returnsstring - the short name of this classParametersNo parametersgetNamespaceString getNamespace(  )Inherited from:  ClassDeclarationReturn the namespace of this class.ReturnsString - namespace - a namespace.ParametersNo parametersgetFullyQualifiedNamestring getFullyQualifiedName(  )Inherited from:  ClassDeclarationReturns the fully qualified name of this class. The name will include the namespace if present.Returnsstring - the fully-qualified name of this classParametersNo parametersgetIdentifierFieldNamestring getIdentifierFieldName(  )Inherited from:  ClassDeclarationReturns the name of the identifying field for this class. Note that the identifying field may come from a super type.Returnsstring - the name of the id field for this classParametersNo parametersgetOwnPropertyProperty getOwnProperty( string name )Inherited from:  ClassDeclarationReturns the field with a given name or null if it does not exist. The field must be directly owned by this class -- the super-type is not introspected.ReturnsProperty - the field definition or null if it does not exist.ParametersNameTypeMandatoryDescriptionnamestringYesthe name of the fieldgetOwnPropertiesProperty[] getOwnProperties(  )Inherited from:  ClassDeclarationReturns the fields directly defined by this class.ReturnsProperty - the array of fieldsParametersNo parametersgetSuperTypestring getSuperType(  )Inherited from:  ClassDeclarationReturns the FQN of the super type for this class or null if this class does not have a super type.Returnsstring - the FQN name of the super type or nullParametersNo parametersgetSuperTypeDeclarationClassDeclaration getSuperTypeDeclaration(  )Inherited from:  ClassDeclarationGet the super type class declaration for this class.ReturnsClassDeclaration - the super type declaration, or null if there is no super type.ParametersNo parametersgetAssignableClassDeclarationsClassDeclaration[] getAssignableClassDeclarations(  )Inherited from:  ClassDeclarationGet the class declarations for all subclasses of this class, including this class.ReturnsClassDeclaration - subclass declarations.ParametersNo parametersgetAllSuperTypeDeclarationsClassDeclaration[] getAllSuperTypeDeclarations(  )Inherited from:  ClassDeclarationGet all the super-type declarations for this type.ReturnsClassDeclaration - super-type declarations.ParametersNo parametersgetPropertyProperty getProperty( string name )Inherited from:  ClassDeclarationReturns the property with a given name or null if it does not exist. Fields defined in super-types are also introspected.ReturnsProperty - the field, or null if it does not existParametersNameTypeMandatoryDescriptionnamestringYesthe name of the fieldgetPropertiesProperty[] getProperties(  )Inherited from:  ClassDeclarationReturns the properties defined in this class and all super classes.ReturnsProperty - the array of fieldsParametersNo parametersgetNestedPropertyProperty getNestedProperty( string propertypath )Inherited from:  ClassDeclarationGet a nested property using a dotted property pathReturnsProperty - the propertyParametersNameTypeMandatoryDescriptionpropertyPathstringYesThe property name or name with nested structure e.g a.b.ctoStringString toString(  )Inherited from:  ClassDeclarationReturns the string representation of this classReturnsString - the string representation of the classParametersNo parameters",
        "url": "/composer/latest/api/common-participantdeclaration"
      }
      ,
    
      "api-common-property": {
        "title": "Property (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIPropertyProperty representing an attribute of a class declaration,either a Field or a Relationship.DetailsModule commonMethod SummaryNameReturnsDescriptionconstructorvoidCreate a PropertygetFullyQualifiedNamestringReturns the fully name of a property (ns + class name + property name)getFullyQualifiedTypeNamestringReturns the fully qualified type name of a propertygetNamestringReturns the name of a propertygetNamespacestringReturns the namespace of the parent of this propertygetParentClassDeclarationReturns the owner of this propertygetTypestringReturns the type of a propertyisArraybooleanReturns true if the field is declared as an array typeisOptionalbooleanReturns true if the field is optionalisPrimitivebooleanReturns true if this property is a primitive typeisTypeEnumbooleanReturns true if the field is declared as an enumerated valueMethod Detailsnew Property()Create a Property.ParametersNameTypeMandatoryDescriptionparentClassDeclarationYesthe owner of this propertyastObjectYesThe AST created by the parsergetParentClassDeclaration getParent(  )Returns the owner of this propertyReturnsClassDeclaration - the parent class declarationParametersNo parametersgetNamestring getName(  )Returns the name of a propertyReturnsstring - the name of this fieldParametersNo parametersgetTypestring getType(  )Returns the type of a propertyReturnsstring - the type of this fieldParametersNo parametersisOptionalboolean isOptional(  )Returns true if the field is optionalReturnsboolean - true if the field is optionalParametersNo parametersgetFullyQualifiedTypeNamestring getFullyQualifiedTypeName(  )Returns the fully qualified type name of a propertyReturnsstring - the fully qualified type of this propertyParametersNo parametersgetFullyQualifiedNamestring getFullyQualifiedName(  )Returns the fully name of a property (ns + class name + property name)Returnsstring - the fully qualified name of this propertyParametersNo parametersgetNamespacestring getNamespace(  )Returns the namespace of the parent of this propertyReturnsstring - the namespace of the parent of this propertyParametersNo parametersisArrayboolean isArray(  )Returns true if the field is declared as an array typeReturnsboolean - true if the property is an array typeParametersNo parametersisTypeEnumboolean isTypeEnum(  )Returns true if the field is declared as an enumerated valueReturnsboolean - true if the property is an enumerated valueParametersNo parametersisPrimitiveboolean isPrimitive(  )Returns true if this property is a primitive type.Returnsboolean - true if the property is a primitive type.ParametersNo parametersInherited methods",
        "url": "/composer/latest/api/common-property"
      }
      ,
    
      "api-common-relationship": {
        "title": "Relationship (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIRelationshipA Relationship is a typed pointer to an instance. I.e the relationshipwith namespace = &#39;org.example&#39;, type = &#39;Vehicle&#39; and id = &#39;ABC&#39; createsa pointer that points at an instance of org.example.Vehicle with the idABC.Applications should retrieve instances from FactoryDetailsExtends IdentifiableModule commonSee alsoSee IdentifiableMethod SummaryNameReturnsDescriptionfromURIRelationshipContructs a Relationship instance from a URI representation (created using toURI)isRelationshipbooleanDetermine if this identifiable is a relationshiptoStringStringReturns the string representation of this classInherited Method SummarySupertypeNameReturnsDescriptionTypedgetTypestringGet the type of the instance (a short name, not including namespace)IdentifiablegetIdentifierstringGet the identifier of this instanceIdentifiablegetFullyQualifiedIdentifierstringGet the fully qualified identifier of this instanceIdentifiableisResourcebooleanDetermine if this identifiable is a resourceIdentifiabletoURIStringReturns a URI representation of a reference to this identifiableIdentifiablesetIdentifiervoidSet the identifier of this instanceTypedgetFullyQualifiedTypestringGet the fully-qualified type name of the instance (including namespace)TypedgetNamespacestringGet the namespace of the instanceTypedsetPropertyValuevoidSets a property on this ResourceTypedaddArrayValuevoidAdds a value to an array property on this ResourceTypedinstanceOfbooleanCheck to see if this instance is an instance of the specified fully qualified type nameMethod DetailstoStringString toString(  )Returns the string representation of this classReturnsString - the string representation of the classParametersNo parametersisRelationshipboolean isRelationship(  )Determine if this identifiable is a relationship.Returnsboolean - True if this identifiable is a relationship, false if not.ParametersNo parametersfromURIRelationship fromURI( ModelManager modelmanager, String uriasstring, [String defaultnamespace], [String defaulttype] )Contructs a Relationship instance from a URI representation (created using toURI).ReturnsRelationship - the relationshipParametersNameTypeMandatoryDescriptionmodelManagerModelManagerYesthe model manager to bind the relationship touriAsStringStringYesthe URI as a string, generated using Identifiable.toURI()defaultNamespaceStringYesdefault namespace to use for backwards compatability (optional)defaultTypeStringYesdefault type to use for backwards compatability (optional)Inherited methodsgetIdentifierstring getIdentifier(  )Inherited from:  IdentifiableGet the identifier of this instanceReturnsstring - The identifier for this objectParametersNo parameterssetIdentifiervoid setIdentifier( string id )Inherited from:  IdentifiableSet the identifier of this instanceParametersNameTypeMandatoryDescriptionidstringYesthe new identifier for this objectgetFullyQualifiedIdentifierstring getFullyQualifiedIdentifier(  )Inherited from:  IdentifiableGet the fully qualified identifier of this instance. (namespace &#39;.&#39; type &#39;#&#39; identifier).Returnsstring - the fully qualified identifier of this instanceParametersNo parametersisResourceboolean isResource(  )Inherited from:  IdentifiableDetermine if this identifiable is a resource.Returnsboolean - True if this identifiable is a resource, false if not.ParametersNo parameterstoURIString toURI(  )Inherited from:  IdentifiableReturns a URI representation of a reference to this identifiableReturnsString - the URI for the identifiableParametersNo parametersgetTypestring getType(  )Inherited from:  TypedGet the type of the instance (a short name, not including namespace).Returnsstring - The type of this objectParametersNo parametersgetFullyQualifiedTypestring getFullyQualifiedType(  )Inherited from:  TypedGet the fully-qualified type name of the instance (including namespace).Returnsstring - The fully-qualified type name of this objectParametersNo parametersgetNamespacestring getNamespace(  )Inherited from:  TypedGet the namespace of the instance.Returnsstring - The namespace of this objectParametersNo parameterssetPropertyValuevoid setPropertyValue( string propname, string value )Inherited from:  TypedSets a property on this ResourceParametersNameTypeMandatoryDescriptionpropNamestringYesthe name of the fieldvaluestringYesthe value of the propertyaddArrayValuevoid addArrayValue( string propname, string value )Inherited from:  TypedAdds a value to an array property on this ResourceParametersNameTypeMandatoryDescriptionpropNamestringYesthe name of the fieldvaluestringYesthe value of the propertyinstanceOfboolean instanceOf( String fqt )Inherited from:  TypedCheck to see if this instance is an instance of the specified fully qualified type name.Returnsboolean - True if this instance is an instance of the specified fully qualified type name, false otherwise.ParametersNameTypeMandatoryDescriptionfqtStringYesThe fully qualified type name.",
        "url": "/composer/latest/api/common-relationship"
      }
      ,
    
      "api-common-relationshipdeclaration": {
        "title": "RelationshipDeclaration (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIRelationshipDeclarationClass representing a relationship between model elementsDetailsExtends PropertyModule commonSee alsoSee  PropertyMethod SummaryNameReturnsDescriptionconstructorvoidCreate a RelationshiptoStringStringReturns a string representation of this propertyInherited Method SummarySupertypeNameReturnsDescriptionPropertygetParentClassDeclarationReturns the owner of this propertyPropertygetNamestringReturns the name of a propertyPropertygetTypestringReturns the type of a propertyPropertyisOptionalbooleanReturns true if the field is optionalPropertygetFullyQualifiedTypeNamestringReturns the fully qualified type name of a propertyPropertygetFullyQualifiedNamestringReturns the fully name of a property (ns + class name + property name)PropertygetNamespacestringReturns the namespace of the parent of this propertyPropertyisArraybooleanReturns true if the field is declared as an array typePropertyisTypeEnumbooleanReturns true if the field is declared as an enumerated valuePropertyisPrimitivebooleanReturns true if this property is a primitive typeMethod Detailsnew RelationshipDeclaration()Create a Relationship.ParametersNameTypeMandatoryDescriptionparentClassDeclarationYesThe owner of this propertyastObjectYesThe AST created by the parsertoStringString toString(  )Returns a string representation of this propertyReturnsString - the string version of the property.ParametersNo parametersInherited methodsgetParentClassDeclaration getParent(  )Inherited from:  PropertyReturns the owner of this propertyReturnsClassDeclaration - the parent class declarationParametersNo parametersgetNamestring getName(  )Inherited from:  PropertyReturns the name of a propertyReturnsstring - the name of this fieldParametersNo parametersgetTypestring getType(  )Inherited from:  PropertyReturns the type of a propertyReturnsstring - the type of this fieldParametersNo parametersisOptionalboolean isOptional(  )Inherited from:  PropertyReturns true if the field is optionalReturnsboolean - true if the field is optionalParametersNo parametersgetFullyQualifiedTypeNamestring getFullyQualifiedTypeName(  )Inherited from:  PropertyReturns the fully qualified type name of a propertyReturnsstring - the fully qualified type of this propertyParametersNo parametersgetFullyQualifiedNamestring getFullyQualifiedName(  )Inherited from:  PropertyReturns the fully name of a property (ns + class name + property name)Returnsstring - the fully qualified name of this propertyParametersNo parametersgetNamespacestring getNamespace(  )Inherited from:  PropertyReturns the namespace of the parent of this propertyReturnsstring - the namespace of the parent of this propertyParametersNo parametersisArrayboolean isArray(  )Inherited from:  PropertyReturns true if the field is declared as an array typeReturnsboolean - true if the property is an array typeParametersNo parametersisTypeEnumboolean isTypeEnum(  )Inherited from:  PropertyReturns true if the field is declared as an enumerated valueReturnsboolean - true if the property is an enumerated valueParametersNo parametersisPrimitiveboolean isPrimitive(  )Inherited from:  PropertyReturns true if this property is a primitive type.Returnsboolean - true if the property is a primitive type.ParametersNo parameters",
        "url": "/composer/latest/api/common-relationshipdeclaration"
      }
      ,
    
      "api-common-resource": {
        "title": "Resource (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIResourceResource is an instance that has a type. The type of the resourcespecifies a set of properites (which themselves have types).Type information in Composer is used to validate the structure ofResource instances and for serialization.Resources are used in Composer to represent Assets, Participants, Transactions andother domain classes that can be serialized for long-term persistent storage.DetailsExtends IdentifiableModule commonSee alsoSee ResourceMethod SummaryNameReturnsDescriptionisResourcebooleanDetermine if this identifiable is a resourcetoJSONObjectSerialize this resource into a JavaScript object suitable for serialization to JSON, using the default options for the serializertoStringStringReturns the string representation of this classInherited Method SummarySupertypeNameReturnsDescriptionTypedgetTypestringGet the type of the instance (a short name, not including namespace)IdentifiablegetIdentifierstringGet the identifier of this instanceIdentifiablegetFullyQualifiedIdentifierstringGet the fully qualified identifier of this instanceIdentifiableisRelationshipbooleanDetermine if this identifiable is a relationshipIdentifiabletoURIStringReturns a URI representation of a reference to this identifiableIdentifiablesetIdentifiervoidSet the identifier of this instanceTypedgetFullyQualifiedTypestringGet the fully-qualified type name of the instance (including namespace)TypedgetNamespacestringGet the namespace of the instanceTypedsetPropertyValuevoidSets a property on this ResourceTypedaddArrayValuevoidAdds a value to an array property on this ResourceTypedinstanceOfbooleanCheck to see if this instance is an instance of the specified fully qualified type nameMethod DetailstoStringString toString(  )Returns the string representation of this classReturnsString - the string representation of the classParametersNo parametersisResourceboolean isResource(  )Determine if this identifiable is a resource.Returnsboolean - True if this identifiable is a resource, false if not.ParametersNo parameterstoJSONObject toJSON(  )Serialize this resource into a JavaScript object suitable for serialization to JSON, using the default options for the serializer. If you need to set additional options for the serializer, use the Serializer#toJSON method instead.ReturnsObject - A JavaScript object suitable for serialization to JSON.ParametersNo parametersInherited methodsgetIdentifierstring getIdentifier(  )Inherited from:  IdentifiableGet the identifier of this instanceReturnsstring - The identifier for this objectParametersNo parameterssetIdentifiervoid setIdentifier( string id )Inherited from:  IdentifiableSet the identifier of this instanceParametersNameTypeMandatoryDescriptionidstringYesthe new identifier for this objectgetFullyQualifiedIdentifierstring getFullyQualifiedIdentifier(  )Inherited from:  IdentifiableGet the fully qualified identifier of this instance. (namespace &#39;.&#39; type &#39;#&#39; identifier).Returnsstring - the fully qualified identifier of this instanceParametersNo parametersisRelationshipboolean isRelationship(  )Inherited from:  IdentifiableDetermine if this identifiable is a relationship.Returnsboolean - True if this identifiable is a relationship, false if not.ParametersNo parameterstoURIString toURI(  )Inherited from:  IdentifiableReturns a URI representation of a reference to this identifiableReturnsString - the URI for the identifiableParametersNo parametersgetTypestring getType(  )Inherited from:  TypedGet the type of the instance (a short name, not including namespace).Returnsstring - The type of this objectParametersNo parametersgetFullyQualifiedTypestring getFullyQualifiedType(  )Inherited from:  TypedGet the fully-qualified type name of the instance (including namespace).Returnsstring - The fully-qualified type name of this objectParametersNo parametersgetNamespacestring getNamespace(  )Inherited from:  TypedGet the namespace of the instance.Returnsstring - The namespace of this objectParametersNo parameterssetPropertyValuevoid setPropertyValue( string propname, string value )Inherited from:  TypedSets a property on this ResourceParametersNameTypeMandatoryDescriptionpropNamestringYesthe name of the fieldvaluestringYesthe value of the propertyaddArrayValuevoid addArrayValue( string propname, string value )Inherited from:  TypedAdds a value to an array property on this ResourceParametersNameTypeMandatoryDescriptionpropNamestringYesthe name of the fieldvaluestringYesthe value of the propertyinstanceOfboolean instanceOf( String fqt )Inherited from:  TypedCheck to see if this instance is an instance of the specified fully qualified type name.Returnsboolean - True if this instance is an instance of the specified fully qualified type name, false otherwise.ParametersNameTypeMandatoryDescriptionfqtStringYesThe fully qualified type name.",
        "url": "/composer/latest/api/common-resource"
      }
      ,
    
      "api-common-serializer": {
        "title": "Serializer (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APISerializerSerialize Resources instances to/from various formats for long-term storage(e.g. on the blockchain).DetailsModule commonMethod SummaryNameReturnsDescriptionconstructorvoidCreate a SerializerfromJSONResourceCreate a Resource from a JavaScript Object representationsetDefaultOptionsvoidSet the default options for the serializertoJSONObject Convert a Resource to a JavaScript object suitable for long-term peristent storageMethod Detailsnew Serializer()Create a Serializer. Note: Only to be called by framework code. Applications should retrieve instances from BusinessNetworkDefinition ParametersNameTypeMandatoryDescriptionfactoryFactoryYesThe Factory to use to create instancesmodelManagerModelManagerYesThe ModelManager to use for validation etc.setDefaultOptionssetDefaultOptions( Object newdefaultoptions )Set the default options for the serializer.ParametersNameTypeMandatoryDescriptionnewDefaultOptionsObjectYesThe new default options for the serializer.toJSONObject toJSON( Resource resource, [Object options] ) Convert a [Resource](common-resource) to a JavaScript object suitable for long-term peristent storage. ReturnsObject - The Javascript Object that represents the resourceParametersNameTypeMandatoryDescriptionresourceResourceYesThe instance to convert to JSONoptionsObjectYesthe optional serialization options.Sub-optionsNameTypeMandatoryDescriptionoptions.validatebooleanYesvalidate the structure of the Resource with its model prior to serialization (default to true)options.convertResourcesToRelationshipsbooleanYesConvert resources that are specified for relationship fields into relationships, false by default.options.permitResourcesForRelationshipsbooleanYesPermit resources in the place of relationships (serializing them as resources), false by default.options.deduplicateResourcesbooleanYesGenerate $id for resources and if a resources appears multiple times in the object graph only the first instance is serialized in full, subsequent instances are replaced with a reference to the $idfromJSONResource fromJSON( Object jsonobject, Object options )Create a Resource from a JavaScript Object representation. The JavaScript Object should have been created by calling the toJSON API.The Resource is populated based on the JavaScript object.ReturnsResource - The new populated resourceParametersNameTypeMandatoryDescriptionjsonObjectObjectYesThe JavaScript Object for a ResourceoptionsObjectYesthe optional serialization optionsSub-optionsNameTypeMandatoryDescriptionoptions.acceptResourcesForRelationshipsbooleanYeshandle JSON objects in the place of strings for relationships, defaults to false.options.validatebooleanYesvalidate the structure of the Resource with its model prior to serialization (default to true)Inherited methods",
        "url": "/composer/latest/api/common-serializer"
      }
      ,
    
      "api-common-transactiondeclaration": {
        "title": "TransactionDeclaration (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APITransactionDeclarationClass representing the definition of an Transaction.DetailsExtends ClassDeclarationModule commonSee alsoSee  ClassDeclarationMethod SummaryNameReturnsDescriptionconstructorvoidCreate an TransactionDeclarationgetSystemTypestringReturns the base system type for Transactions from the system namespaceInherited Method SummarySupertypeNameReturnsDescriptionClassDeclarationgetFullyQualifiedNamestringReturns the fully qualified name of this classClassDeclaration_resolveSuperTypeClassDeclarationResolve the super type on this class and store it as an internal propertyClassDeclarationisEnumbooleanReturns true if this class is an enumerationClassDeclarationisConceptbooleanReturns true if this class is the definition of a conceptClassDeclarationisEventbooleanReturns true if this class is the definition of an eventClassDeclarationisRelationshipTargetbooleanReturns true if this class can be pointed to by a relationshipClassDeclarationisSystemRelationshipTargetbooleanReturns true if this class can be pointed to by a relationship in a system modelClassDeclarationisSystemTypebooleanReturns true is this type is in the system namespaceClassDeclarationisSystemCoreTypebooleanReturns true if this class is a system core type - both in the system namespace, and also one of the system core types (Asset, Participant, etc)ClassDeclarationgetNamestringReturns the short name of a classClassDeclarationgetNamespaceStringReturn the namespace of this classClassDeclarationisAbstractbooleanReturns true if this class is declared as abstract in the model fileClassDeclarationgetIdentifierFieldNamestringReturns the name of the identifying field for this classClassDeclarationgetOwnPropertyPropertyReturns the field with a given name or null if it does not existClassDeclarationgetOwnPropertiesProperty[]Returns the fields directly defined by this classClassDeclarationgetSuperTypestringReturns the FQN of the super type for this class or null if this class does not have a super typeClassDeclarationgetSuperTypeDeclarationClassDeclarationGet the super type class declaration for this classClassDeclarationgetAssignableClassDeclarationsClassDeclaration[]Get the class declarations for all subclasses of this class, including this classClassDeclarationgetAllSuperTypeDeclarationsClassDeclaration[]Get all the super-type declarations for this typeClassDeclarationgetPropertyPropertyReturns the property with a given name or null if it does not existClassDeclarationgetPropertiesProperty[]Returns the properties defined in this class and all super classesClassDeclarationgetNestedPropertyPropertyGet a nested property using a dotted property pathClassDeclarationtoStringStringReturns the string representation of this classMethod Detailsnew TransactionDeclaration()Create an TransactionDeclaration.ParametersNameTypeMandatoryDescriptionmodelFileModelFileYesthe ModelFile for this classastObjectYesThe AST created by the parsergetSystemTypestring getSystemType(  )Returns the base system type for Transactions from the system namespaceReturnsstring - the short name of the base system typeParametersNo parametersInherited methods_resolveSuperTypeClassDeclaration _resolveSuperType(  )Inherited from:  ClassDeclarationResolve the super type on this class and store it as an internal property.ReturnsClassDeclaration - The super type, or null if non specified.ParametersNo parametersisAbstractboolean isAbstract(  )Inherited from:  ClassDeclarationReturns true if this class is declared as abstract in the model fileReturnsboolean - true if the class is abstractParametersNo parametersisEnumboolean isEnum(  )Inherited from:  ClassDeclarationReturns true if this class is an enumeration.Returnsboolean - true if the class is an enumerated typeParametersNo parametersisConceptboolean isConcept(  )Inherited from:  ClassDeclarationReturns true if this class is the definition of a concept.Returnsboolean - true if the class is a conceptParametersNo parametersisEventboolean isEvent(  )Inherited from:  ClassDeclarationReturns true if this class is the definition of an event.Returnsboolean - true if the class is an eventParametersNo parametersisRelationshipTargetboolean isRelationshipTarget(  )Inherited from:  ClassDeclarationReturns true if this class can be pointed to by a relationshipReturnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersisSystemRelationshipTargetboolean isSystemRelationshipTarget(  )Inherited from:  ClassDeclarationReturns true if this class can be pointed to by a relationship in a system modelReturnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersisSystemTypeboolean isSystemType(  )Inherited from:  ClassDeclarationReturns true is this type is in the system namespaceReturnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersisSystemCoreTypeboolean isSystemCoreType(  )Inherited from:  ClassDeclarationReturns true if this class is a system core type - both in the system namespace, and also one of the system core types (Asset, Participant, etc).Returnsboolean - true if the class may be pointed to by a relationshipParametersNo parametersgetNamestring getName(  )Inherited from:  ClassDeclarationReturns the short name of a class. This name does not include the namespace from the owning ModelFile.Returnsstring - the short name of this classParametersNo parametersgetNamespaceString getNamespace(  )Inherited from:  ClassDeclarationReturn the namespace of this class.ReturnsString - namespace - a namespace.ParametersNo parametersgetFullyQualifiedNamestring getFullyQualifiedName(  )Inherited from:  ClassDeclarationReturns the fully qualified name of this class. The name will include the namespace if present.Returnsstring - the fully-qualified name of this classParametersNo parametersgetIdentifierFieldNamestring getIdentifierFieldName(  )Inherited from:  ClassDeclarationReturns the name of the identifying field for this class. Note that the identifying field may come from a super type.Returnsstring - the name of the id field for this classParametersNo parametersgetOwnPropertyProperty getOwnProperty( string name )Inherited from:  ClassDeclarationReturns the field with a given name or null if it does not exist. The field must be directly owned by this class -- the super-type is not introspected.ReturnsProperty - the field definition or null if it does not exist.ParametersNameTypeMandatoryDescriptionnamestringYesthe name of the fieldgetOwnPropertiesProperty[] getOwnProperties(  )Inherited from:  ClassDeclarationReturns the fields directly defined by this class.ReturnsProperty - the array of fieldsParametersNo parametersgetSuperTypestring getSuperType(  )Inherited from:  ClassDeclarationReturns the FQN of the super type for this class or null if this class does not have a super type.Returnsstring - the FQN name of the super type or nullParametersNo parametersgetSuperTypeDeclarationClassDeclaration getSuperTypeDeclaration(  )Inherited from:  ClassDeclarationGet the super type class declaration for this class.ReturnsClassDeclaration - the super type declaration, or null if there is no super type.ParametersNo parametersgetAssignableClassDeclarationsClassDeclaration[] getAssignableClassDeclarations(  )Inherited from:  ClassDeclarationGet the class declarations for all subclasses of this class, including this class.ReturnsClassDeclaration - subclass declarations.ParametersNo parametersgetAllSuperTypeDeclarationsClassDeclaration[] getAllSuperTypeDeclarations(  )Inherited from:  ClassDeclarationGet all the super-type declarations for this type.ReturnsClassDeclaration - super-type declarations.ParametersNo parametersgetPropertyProperty getProperty( string name )Inherited from:  ClassDeclarationReturns the property with a given name or null if it does not exist. Fields defined in super-types are also introspected.ReturnsProperty - the field, or null if it does not existParametersNameTypeMandatoryDescriptionnamestringYesthe name of the fieldgetPropertiesProperty[] getProperties(  )Inherited from:  ClassDeclarationReturns the properties defined in this class and all super classes.ReturnsProperty - the array of fieldsParametersNo parametersgetNestedPropertyProperty getNestedProperty( string propertypath )Inherited from:  ClassDeclarationGet a nested property using a dotted property pathReturnsProperty - the propertyParametersNameTypeMandatoryDescriptionpropertyPathstringYesThe property name or name with nested structure e.g a.b.ctoStringString toString(  )Inherited from:  ClassDeclarationReturns the string representation of this classReturnsString - the string representation of the classParametersNo parameters",
        "url": "/composer/latest/api/common-transactiondeclaration"
      }
      ,
    
      "api-common-typed": {
        "title": "Typed (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APITypedObject is an instance with a namespace and a type.This class is abstract.DetailsModule commonMethod SummaryNameReturnsDescriptionaddArrayValuevoidAdds a value to an array property on this ResourcegetFullyQualifiedTypestringGet the fully-qualified type name of the instance (including namespace)getNamespacestringGet the namespace of the instancegetTypestringGet the type of the instance (a short name, not including namespace)instanceOfbooleanCheck to see if this instance is an instance of the specified fully qualified type namesetPropertyValuevoidSets a property on this ResourceMethod DetailsgetTypestring getType(  )Get the type of the instance (a short name, not including namespace).Returnsstring - The type of this objectParametersNo parametersgetFullyQualifiedTypestring getFullyQualifiedType(  )Get the fully-qualified type name of the instance (including namespace).Returnsstring - The fully-qualified type name of this objectParametersNo parametersgetNamespacestring getNamespace(  )Get the namespace of the instance.Returnsstring - The namespace of this objectParametersNo parameterssetPropertyValuesetPropertyValue( string propname, string value )Sets a property on this ResourceParametersNameTypeMandatoryDescriptionpropNamestringYesthe name of the fieldvaluestringYesthe value of the propertyaddArrayValueaddArrayValue( string propname, string value )Adds a value to an array property on this ResourceParametersNameTypeMandatoryDescriptionpropNamestringYesthe name of the fieldvaluestringYesthe value of the propertyinstanceOfboolean instanceOf( String fqt )Check to see if this instance is an instance of the specified fully qualified type name.Returnsboolean - True if this instance is an instance of the specified fully qualified type name, false otherwise.ParametersNameTypeMandatoryDescriptionfqtStringYesThe fully qualified type name.Inherited methods",
        "url": "/composer/latest/api/common-typed"
      }
      ,
    
      "api-common-validatedconcept": {
        "title": "ValidatedConcept (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIValidatedConceptResource is an instance that has a type. The type of the resourcespecifies a set of properites (which themselves have types).Type information in Composer is used to validate the structure ofResource instances and for serialization.Resources are used in Composer to represent Assets, Participants, Transactions andother domain classes that can be serialized for long-term persistent storage.DetailsExtends ConceptModule commonSee alsoSee ResourceMethod SummaryNameReturnsDescriptionaddArrayValuevoidAdds an array property value, validating that it does not violate the modelsetPropertyValuevoidSets a property, validating that it does not violate the modelvalidatevoidValidates the instance against its modelInherited Method SummarySupertypeNameReturnsDescriptionConceptisConceptbooleanDetermine if this typed is a conceptTypedgetTypestringGet the type of the instance (a short name, not including namespace)TypedgetFullyQualifiedTypestringGet the fully-qualified type name of the instance (including namespace)TypedgetNamespacestringGet the namespace of the instanceTypedinstanceOfbooleanCheck to see if this instance is an instance of the specified fully qualified type nameMethod DetailssetPropertyValuesetPropertyValue( string propname, string value )Sets a property, validating that it does not violate the modelParametersNameTypeMandatoryDescriptionpropNamestringYesthe name of the fieldvaluestringYesthe value of the propertyaddArrayValueaddArrayValue( string propname, string value )Adds an array property value, validating that it does not violate the modelParametersNameTypeMandatoryDescriptionpropNamestringYesthe name of the fieldvaluestringYesthe value of the propertyvalidatevalidate(  )Validates the instance against its model.ParametersNo parametersInherited methodsisConceptboolean isConcept(  )Inherited from:  ConceptDetermine if this typed is a concept.Returnsboolean - True if this typed is a concept, false if not.ParametersNo parametersgetTypestring getType(  )Inherited from:  TypedGet the type of the instance (a short name, not including namespace).Returnsstring - The type of this objectParametersNo parametersgetFullyQualifiedTypestring getFullyQualifiedType(  )Inherited from:  TypedGet the fully-qualified type name of the instance (including namespace).Returnsstring - The fully-qualified type name of this objectParametersNo parametersgetNamespacestring getNamespace(  )Inherited from:  TypedGet the namespace of the instance.Returnsstring - The namespace of this objectParametersNo parametersinstanceOfboolean instanceOf( String fqt )Inherited from:  TypedCheck to see if this instance is an instance of the specified fully qualified type name.Returnsboolean - True if this instance is an instance of the specified fully qualified type name, false otherwise.ParametersNameTypeMandatoryDescriptionfqtStringYesThe fully qualified type name.",
        "url": "/composer/latest/api/common-validatedconcept"
      }
      ,
    
      "api-common-validatedresource": {
        "title": "ValidatedResource (Common API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIValidatedResourceValidatedResource is a Resource that can validate that propertychanges (or the whole instance) do not violate the structure ofthe type information associated with the instance.DetailsExtends ResourceModule commonSee alsoSee ResourceMethod SummaryNameReturnsDescriptionaddArrayValuevoidAdds an array property value, validating that it does not violate the modelsetPropertyValuevoidSets a property, validating that it does not violate the modelvalidatevoidValidates the instance against its modelInherited Method SummarySupertypeNameReturnsDescriptionIdentifiableisRelationshipbooleanDetermine if this identifiable is a relationshipResourcetoStringStringReturns the string representation of this classResourcetoJSONObjectSerialize this resource into a JavaScript object suitable for serialization to JSON, using the default options for the serializerIdentifiablegetIdentifierstringGet the identifier of this instanceIdentifiablesetIdentifiervoidSet the identifier of this instanceIdentifiablegetFullyQualifiedIdentifierstringGet the fully qualified identifier of this instanceIdentifiabletoStringStringReturns the string representation of this classResourceisResourcebooleanDetermine if this identifiable is a resourceIdentifiableisResourcebooleanDetermine if this identifiable is a resourceIdentifiabletoURIStringReturns a URI representation of a reference to this identifiableTypedgetTypestringGet the type of the instance (a short name, not including namespace)TypedgetFullyQualifiedTypestringGet the fully-qualified type name of the instance (including namespace)TypedgetNamespacestringGet the namespace of the instanceTypedinstanceOfbooleanCheck to see if this instance is an instance of the specified fully qualified type nameMethod DetailssetPropertyValuesetPropertyValue( string propname, string value )Sets a property, validating that it does not violate the modelParametersNameTypeMandatoryDescriptionpropNamestringYesthe name of the fieldvaluestringYesthe value of the propertyaddArrayValueaddArrayValue( string propname, string value )Adds an array property value, validating that it does not violate the modelParametersNameTypeMandatoryDescriptionpropNamestringYesthe name of the fieldvaluestringYesthe value of the propertyvalidatevalidate(  )Validates the instance against its model.ParametersNo parametersInherited methodstoStringString toString(  )Inherited from:  ResourceReturns the string representation of this classReturnsString - the string representation of the classParametersNo parametersisResourceboolean isResource(  )Inherited from:  ResourceDetermine if this identifiable is a resource.Returnsboolean - True if this identifiable is a resource, false if not.ParametersNo parameterstoJSONObject toJSON(  )Inherited from:  ResourceSerialize this resource into a JavaScript object suitable for serialization to JSON, using the default options for the serializer. If you need to set additional options for the serializer, use the Serializer#toJSON method instead.ReturnsObject - A JavaScript object suitable for serialization to JSON.ParametersNo parametersgetIdentifierstring getIdentifier(  )Inherited from:  IdentifiableGet the identifier of this instanceReturnsstring - The identifier for this objectParametersNo parameterssetIdentifiervoid setIdentifier( string id )Inherited from:  IdentifiableSet the identifier of this instanceParametersNameTypeMandatoryDescriptionidstringYesthe new identifier for this objectgetFullyQualifiedIdentifierstring getFullyQualifiedIdentifier(  )Inherited from:  IdentifiableGet the fully qualified identifier of this instance. (namespace &#39;.&#39; type &#39;#&#39; identifier).Returnsstring - the fully qualified identifier of this instanceParametersNo parameterstoStringString toString(  )Inherited from:  IdentifiableReturns the string representation of this classReturnsString - the string representation of the classParametersNo parametersisRelationshipboolean isRelationship(  )Inherited from:  IdentifiableDetermine if this identifiable is a relationship.Returnsboolean - True if this identifiable is a relationship, false if not.ParametersNo parametersisResourceboolean isResource(  )Inherited from:  IdentifiableDetermine if this identifiable is a resource.Returnsboolean - True if this identifiable is a resource, false if not.ParametersNo parameterstoURIString toURI(  )Inherited from:  IdentifiableReturns a URI representation of a reference to this identifiableReturnsString - the URI for the identifiableParametersNo parametersgetTypestring getType(  )Inherited from:  TypedGet the type of the instance (a short name, not including namespace).Returnsstring - The type of this objectParametersNo parametersgetFullyQualifiedTypestring getFullyQualifiedType(  )Inherited from:  TypedGet the fully-qualified type name of the instance (including namespace).Returnsstring - The fully-qualified type name of this objectParametersNo parametersgetNamespacestring getNamespace(  )Inherited from:  TypedGet the namespace of the instance.Returnsstring - The namespace of this objectParametersNo parametersinstanceOfboolean instanceOf( String fqt )Inherited from:  TypedCheck to see if this instance is an instance of the specified fully qualified type name.Returnsboolean - True if this instance is an instance of the specified fully qualified type name, false otherwise.ParametersNameTypeMandatoryDescriptionfqtStringYesThe fully qualified type name.",
        "url": "/composer/latest/api/common-validatedresource"
      }
      ,
    
      "reference-composer-archive-create": {
        "title": "Hyperledger Composer Archive Create CLI",
        "author": "",
        "category": "",
        "content": "Hyperledger Composer Archive CreateThe composer archive create utility is used to create a business network archive from the contents of a directory.To create an archive from source files (ie business network definition project files) present in the current &#39;working&#39; directory:composer archive create -a &lt;business-network-archive&gt;orto specify paths (to a source business network definition,  and a destination directory for the archive file (.bna file)):composer archive create --sourceType dir --sourceName &lt;dirpath&gt; -a digitalproperty-network.bnaOptionscomposer archive create --archiveFile digitalPropertyNetwork.bna --sourceType module --sourceName digitalproperty-networkOptions:  --help             Show help  [boolean]  -v, --version      Show version number  [boolean]  --archiveFile, -a  Business network archive file name. Default is based on the Identifier of the BusinessNetwork  [string]  --sourceType, -t   The type of the input containg the files used to create the archive [ module | dir ]  [required]  --sourceName, -n   The Location to create the archive from e.g. NPM module directory or Name of the npm module to use  [required]Only one of either inputDir or moduleName must be specified.Example Command and Output$ pwd/Users/dselman/dev/tempcomposer archive create --sourceType dir --sourceName . -a dist/digitalproperty-network.bnaCreating Business Network ArchiveLooking for package.json of Business Network Definition in /Users/dselman/dev/temp/distDescription:Digital Property NetworkName:digitalproperty-networkIdentifier:digitalproperty-network@0.0.1Written Business Network Definition Archive file to digitalproperty-network@0.0.1.bnaCommand completed successfully.Javascript API Exampleconst ArchiveCreate = require('composer-cli').Archive.Create;let options = {  sourceType: 'dir',  sourceName: '.',  archiveFile: 'dist/digitalproperty-network.bna'};ArchiveCreate.handler(options);",
        "url": "/composer/latest/reference/composer.archive.create"
      }
      ,
    
      "reference-composer-archive-list": {
        "title": "Hyperledger Composer Archive List CLI",
        "author": "",
        "category": "",
        "content": "Hyperledger Composer Archive ListThe composer archive list utility is used to verify the structure of a business network archive on disk and print metdata.composer archive list -a &lt;business-network-archive file&gt;Options--help             Show help  [boolean]  -v, --version      Show version number  [boolean]  --archiveFile, -a  Business network archive file name.  [string]Example Outputcomposer archive list -a digitalPropertyNetwork.bnaListing Business Network Archive from digitalPropertyNetwork.bnaIdentifier:digitalproperty-network@0.0.1Name:digitalproperty-networkVersion:0.0.1Command succeededJavascript API Exampleconst ArchiveList = require('composer-cli').Archive.List;let options = {  archiveFile: 'digitalPropertyNetwork.bna'};ArchiveList.handler(options);",
        "url": "/composer/latest/reference/composer.archive.list"
      }
      ,
    
      "reference-composer-card-create": {
        "title": "Hyperledger Composer Card Create",
        "author": "",
        "category": "",
        "content": "Composer Card CreateCreates a business network card from individual components. When creating a business network card, you will need either an enrollSecret, both a certificate and privateKey or just a certificate if your private keys are managed by a HSM (Hardware Security Module).composer card create --file conga.card --businessNetworkName penguin-network --connectionProfileFile connection.json --user conga --enrollSecret supersecretSyntaxCard options  --file, -f                   File name of the card archive to be created  [string]  --businessNetworkName, -n    The business network name  [string]  --connectionProfileFile, -p  Filename of the connection profile json file  [string] [required]  --user, -u                   The name of the identity for the card  [string] [required]  --enrollSecret, -s           The enrollment secret of the user  [string]  --certificate, -c            File containing the user's certificate.  [string]  --privateKey, -k             File containing the user's private key  [string]  --role, -r                   The role for this card can, specify as many as needed  [choices: \"PeerAdmin\", \"ChannelAdmin\"]Options:  --help         Show help  [boolean]  -v, --version  Show version number  [boolean]RolesRoles are only used by playground when interacting with Hyperledger Fabric to determine which card to use when performing the 2 step action of installing new business networks and then either starting or upgrading that business network. Whenever a business network is first deployed or new changes are deployed, the new business network is first installed onto the peer(s) and then a start or upgrade is requested.In order to perform an installation of a business network, a card with the PeerAdmin role is used. To perform a start or upgrade of the business network a card with the ChannelAdmin role is used.Javascript API Exampleconst CardCreate = require('composer-cli').Card.Create;let options = {  file: 'conga.card',  businessNetworkName: 'penguin-network',  connectionProfileFile: 'connection.json',  user: 'conga',  enrollSecret: 'supersecret'};CardCreate.handler(options);",
        "url": "/composer/latest/reference/composer.card.create"
      }
      ,
    
      "reference-composer-card-delete": {
        "title": "Hyperledger Composer Card Delete",
        "author": "",
        "category": "",
        "content": "Composer Card DeleteDeletes a business network card.composer card delete --card admin@tutorial-networkSyntaxOptions:  --help         Show help  [boolean]  -v, --version  Show version number  [boolean]  --card, -c     The name of the card to delete  [string] [required]Javascript API Exampleconst CardDelete = require('composer-cli').Card.Delete;let options = {  card: 'admin@tutorial-network'};CardDelete.handler(options);",
        "url": "/composer/latest/reference/composer.card.delete"
      }
      ,
    
      "reference-composer-card-export": {
        "title": "Hyperledger Composer Card Export",
        "author": "",
        "category": "",
        "content": "Composer Card ExportExports a card from your local wallet and packages it so it can be transferred or used elsewhere.composer card export --file dan.card --card dan@penguin-networkSyntaxOptions:  --help         Show help  [boolean]  -v, --version  Show version number  [boolean]  --file, -f     The packaged card file name  [string]  --card, -c     The name of the card to export  [string] [required]Javascript API Exampleconst CardExport = require('composer-cli').Card.Export;let options = {  file: 'dan.card',  card: 'dan@penguin-network'};CardExport.handler(options);",
        "url": "/composer/latest/reference/composer.card.export"
      }
      ,
    
      "reference-composer-card-import": {
        "title": "Hyperledger Composer Card Import",
        "author": "",
        "category": "",
        "content": "Composer Card ImportImports a card which has already been created into your local wallet.composer card import --file admin.card --card admin@tutorial-networkSyntaxOptions:  --help         Show help  [boolean]  -v, --version  Show version number  [boolean]  --file, -f     The card file name  [string] [required]  --card, -c     The name to identify the imported card  [string]Javascript API Exampleconst CardImport = require('composer-cli').Card.Import;let options = {  file: 'admin.card',  card: 'admin@tutorial-network'};CardImport.handler(options);",
        "url": "/composer/latest/reference/composer.card.import"
      }
      ,
    
      "reference-composer-card-list": {
        "title": "Hyperledger Composer Card List",
        "author": "",
        "category": "",
        "content": "Composer Card ListList all business network cards stored in the local wallet, or if a card is specified, display details of that business network card.composer card list --card admin@tutorial-networkSyntaxOptions:  --help         Show help  [boolean]  -v, --version  Show version number  [boolean]  --card, -c     The name of the card to list  [string]  --quiet, -q    Only display the card name  [boolean]Javascript API Exampleconst CardList = require('composer-cli').Card.List;let options = {  card: 'admin@tutorial-network'};CardList.handler(options);",
        "url": "/composer/latest/reference/composer.card.list"
      }
      ,
    
      "reference-composer-generator-create": {
        "title": "Hyperledger Composer Generator CLI",
        "author": "",
        "category": "",
        "content": "Namecomposer generator create - create code artifacts based on a business network definitionSynopsiscomposer generator create &lt;options&gt;Options:  --help             Show help  [boolean]  -v, --version      Show version number  [boolean]  --archiveFile, -a  Business network archive file name. Default is based on the Identifier of the BusinessNetwork  [string] [required]  --format, -f       Format of code to generate: Go (beta), PlantUML, Typescript (beta), JSONSchema.  [required]  --outputDir, -o    Output Location  [required]DescriptionThis will take the Hyperledger Composer business network definition as input and create artifacts related to writing new applications.Options-a --archiveFileThe path to the business network archive file. This will be the source that is used to create the artifacts-f --formatThe format of the artifacts that will be created.go Generates class definitions in the go language for the assets and participantsTypescript Generates class definitions in the Typescript language for the assets and participantsJSONSchema Generates the equivalent to the model in JSONSchemaPlantUML Generates a description of the model suitable for use with PlantUML to generate diagramsXmlSchema Generates a set of XML Schema (XSD) files--helpShows the help text-v --versionShows the version number-o, --outputDirThe output directory for the generated files.Example Usagecomposer generator create --archiveFile digitalPropertyNetwork.bna --format Go --outputDir ./dev/go-appJavascript API Exampleconst GeneratorCreate = require('composer-cli').Generator.Create;let options = {  archiveFile: 'digitalPropertyNetwork.bna',  format: 'Go',  outputDir: './dev/go-app'};GeneratorCreate.handler(options);",
        "url": "/composer/latest/reference/composer.generator.create"
      }
      ,
    
      "reference-composer-generator-docs": {
        "title": "Hyperledger Composer Generator CLI",
        "author": "",
        "category": "",
        "content": "Namecomposer generator docs - create documentation for a Business NetworkSynopsiscomposer generator docs &lt;options&gt;Options:  --help             Show help  [boolean]  -v, --version      Show version number  [boolean]  --archive, -a  Business network archive file name. Default is based on the Identifier of the BusinessNetwork  [string] [required]  --config, -c   Path to the configuration file to use, default is one specificaly for BNA files  [default: \"\"]  --outdir, -o   Output Location  [default: \"./out\"]DescriptionThis will take the Composer business network definition as input and create html based documentation for all aspects.Options-a --archiveFileThe path to the business network archive file. This will be the source that is used to create the artifacts-c --configThe configuration that controls how the documentation is produced. An existing template is in-built and this does not need to specified.Reserved for future expansion-o --outputThe output directory with the html. index.html is the starting point.--helpShows the help text-v --versionShows the version numberExample Usagecomposer generator docs --archiveFile digitalPropertyNetwork.bna",
        "url": "/composer/latest/reference/composer.generator.docs"
      }
      ,
    
      "reference-composer-identity-bind": {
        "title": "Hyperledger Composer Identity Bind Command",
        "author": "",
        "category": "",
        "content": "Composer Identity BindThe composer identity bind command binds an existing identity to a participant in aparticipant registry. See the task Binding an existing identity to a participantfor a walkthrough of using this command or the API.Syntax$ composer identity bindcomposer identity bind [options]Options:  --help                 Show help  [boolean]  -v, --version          Show version number  [boolean]  --card, -c             Name of the network card to use  [string] [required]  --participantId, -a    The particpant to issue the new identity to  [string] [required]  --certificateFile, -e  File containing the certificate  [string] [required]Options--card, -cName of the business network card to use.Example: admin@sample-network--certificateFile, -eThe path a file containing the public certificate for the existing identity in PEM format.Example: /tmp/cert.pem--participantId, -aThe fully qualified identifier of the participant that the identity should be bound to.Example: resource:net.biz.digitalPropertyNetwork.Person#lenny@biznet.orgJavascript API Exampleconst IdentityBind = require('composer-cli').Identity.Bind;let options = {  card: 'admin@sample-network',  certificateFile: '/tmp/cert.pem',  participantId: 'resource:net.biz.digitalPropertyNetwork.Person#lenny@biznet.org'};IdentityBind.handler(options);",
        "url": "/composer/latest/reference/composer.identity.bind"
      }
      ,
    
      "reference-composer-identity-issue": {
        "title": "Hyperledger Composer Identity Issue Command",
        "author": "",
        "category": "",
        "content": "Composer Identity IssueThe composer identity issue command issues a new identity to a participant in a participant registry relating to a business network. See the task Issuing a new identity to a participant for a walkthrough of using this command or the API.ConsiderationsThis command creates a new card file. The connection profile in this card file comes from the card defined in the -c|--card option used to perform the request and the connection profile defines whether an identity in a card should be HSM managed or not. If the card used for the request is not HSM managed (as defined in the connection profle) then the card file created will not be HSM managed. Conversely if the card used for the request is HSM managed then the card file created will also be HSM managed.Syntax$ composer identity issueBusiness Network Cards  --card, -c  Name of the network card to use for issuing  [string]  --file, -f  The card file name for the new identity  [string]Identity Options  --newUserId, -u      The user ID for the new identity  [string]  --participantId, -a  The participant to issue the new identity to  [string] [required]  --issuer, -x         If the new identity should be able to issue other new identities  [boolean]Options:  --help             Show help  [boolean]  -v, --version      Show version number  [boolean]  --option, -o       Options that are specific to connection. Multiple options are specified by repeating this option  [string]  --optionsFile, -O  A file containing options that are specific to connection  [string]Options--card, -cThe name of the business network card to use to issue the identity.Example: admin@tutorial-network--file, -fThe file name of the card file to be created, note this is not the name of the identity to be created.Example: DanSelman--newUserId, -uThe user ID for the new identity, this is the name of the new identity.Example: Dan--participantId, -aThe fully qualified identifier (in URI form) of the participant that the identity should be issued to.Example: resource:net.biz.tutorial-network.Person#DanSelman@biznet.org--issuer, -xWhether the new identity will be able to issue other new identities.Please refer to Connector specific information for more information about connecting to Hyperledger Fabric v1.2.Javascript API Exampleconst IdentityIssue = require('composer-cli').Identity.Issue;let options = {  card: 'admin@tutorial-network',  file: 'DanSelman',  newUserId: 'Dan',  participantId: 'resource:net.biz.tutorial-network.Person#DanSelman@biznet.org'};IdentityIssue.handler(options);",
        "url": "/composer/latest/reference/composer.identity.issue"
      }
      ,
    
      "reference-composer-identity-list": {
        "title": "Hyperledger Composer Identity List Command",
        "author": "",
        "category": "",
        "content": "Composer Identity ListThe composer identity list command lists all of the identities in a business network.See the task Listing all identities in a business networkfor a walkthrough of using this command or the API.Syntax$ composer identity listcomposer identity list [options]Options:  --help                       Show help  [boolean]  -v, --version                Show version number  [boolean]  -c, --card                   The business network card to use [string] [required]Options--card, -cThe business network card to use when listing identities.Example: admin@tutorial-networkJavascript API Exampleconst IdentityList = require('composer-cli').Identity.List;let options = {  card: 'admin@tutorial-network'};IdentityList.handler(options);",
        "url": "/composer/latest/reference/composer.identity.list"
      }
      ,
    
      "reference-composer-identity-revoke": {
        "title": "Hyperledger Composer Identity Revoke Command",
        "author": "",
        "category": "",
        "content": "composer identity revokeThe composer identity revoke command revokes an existing identity from a participant in aparticipant registry. See the task Revoke an Identity from a Participantfor a walkthrough of using this command or the API.Syntax$ composer identity revokecomposer identity revoke [options]Options:  --help                      Show help  [boolean]  -v, --version               Show version number  [boolean]  --card, -c                  Name of the network card to use  [string] [required]  --identityId, -u, --userId  The unique identifier of the identity to revoke  [string] [required]Options--card, -cThe business network card to use to revoke the specified identity.Example: admin@tutorial-network--identityId, -uThe unique identifier of the existing identity that should be revoked.Example: f1c5b9fe136d7f2d31b927e0dcb745499aa039b201f83fe34e243f36e1984862Javascript API Exampleconst IdentityRevoke = require('composer-cli').Identity.Revoke;let options = {  card: 'admin@tutorial-network',  identityId: 'f1c5b9fe136d7f2d31b927e0dcb745499aa039b201f83fe34e243f36e1984862'};IdentityRevoke.handler(options);",
        "url": "/composer/latest/reference/composer.identity.revoke"
      }
      ,
    
      "reference-composer-network-download": {
        "title": "Hyperledger Composer Network Download Command",
        "author": "",
        "category": "",
        "content": "Composer Network DownloadThe composer network download command downloads a business network from a Hyperledger Fabric, without undeploying it.composer network download -a businessnetworkv1.1.4 -c admin@examplenetworkSyntaxOptions:  --help             Show help  [boolean]  -v, --version      Show version number  [boolean]  --archiveFile, -a  The business network archive file name to write  [string] [required]  --card, -c         The cardname to use to download the network  [string] [required]Options--archiveFile, -aThe business network archive file name to create.Example: businessnetworkv1.1.4--card, -cThe business network card to use to download the network.Javascript API Exampleconst NetworkDownload = require('composer-cli').Network.Download;let options = {  archiveFile: 'businessnetworkv1.1.4',  card: 'admin@examplenetwork'};NetworkDownload.handler(options);",
        "url": "/composer/latest/reference/composer.network.download"
      }
      ,
    
      "reference-composer-network-install": {
        "title": "Hyperledger Composer Network Install CLI",
        "author": "",
        "category": "",
        "content": "Hyperledger Composer Network InstallThe composer network install command is used to install a business network archive on the Hyperledger Fabric peers of the blockchain network you are connecting to. This command must be run before the composer network start command.composer network install --archiveFile &lt;business-network-archive&gt; --card &lt;peer-admin-card&gt;Optionscomposer network install [options]Options:  --help                     Show help  [boolean]  -v, --version              Show version number  [boolean]  --archiveFile, -a  The business network archive file name  [string] [required]  --card, -c         The cardname to use to install the network  [string] [required]  --option, -o       Options that are specific to connection. Multiple options are specified by repeating this option  [string]  --optionsFile, -O  A file containing options that are specific to connection  [string]  Please refer to Connector specific information for more information about connecting to Hyperledger Fabric v1.2.Javascript API Exampleconst NetworkInstall = require('composer-cli').Network.Install;let options = {  archiveFile: 'digitalPropertyNetwork.bna',  card: 'admin@tutorial-network'};NetworkInstall.handler(options);",
        "url": "/composer/latest/reference/composer.network.install"
      }
      ,
    
      "reference-composer-network-list": {
        "title": "Hyperledger Composer Network List CLI",
        "author": "",
        "category": "",
        "content": "Hyperledger Composer Network ListThe composer network list utility is used to connect to a business network and retrieve metadata and asset information.composer network list -c admin@tutorial-networkOptionsOptions:  --help          Show help  [boolean]  -v, --version   Show version number  [boolean]  --registry, -r  List specific registry  [string]  --asset, -a     List specific asset  [string]  --card, -c      The card name used to list the network  [string]Example Outputcomposer network list -c admin@tutorial-network✔ List business network digitalproperty-networkname:       digitalproperty-networkmodels:  - org.hyperledger.composer.system  - net.biz.digitalPropertyNetworkscripts:  - lib/DigitalLandTitle.jsregistries:  net.biz.digitalPropertyNetwork.LandTitle:    id:           net.biz.digitalPropertyNetwork.LandTitle    name:         Asset registry for net.biz.digitalPropertyNetwork.LandTitle    registryType: Asset    assets:      LID:1148:        $class:      net.biz.digitalPropertyNetwork.LandTitle        titleId:     LID:1148        owner:       resource:net.biz.digitalPropertyNetwork.Person#PID:1234567890        information: A nice house in the country        forSale:     true      LID:6789:        $class:      net.biz.digitalPropertyNetwork.LandTitle        titleId:     LID:6789        owner:       resource:net.biz.digitalPropertyNetwork.Person#PID:1234567890        information: A small flat in the city  net.biz.digitalPropertyNetwork.SalesAgreement:    id:           net.biz.digitalPropertyNetwork.SalesAgreement    name:         Asset registry for net.biz.digitalPropertyNetwork.SalesAgreement    registryType: Asset  net.biz.digitalPropertyNetwork.Person:    id:           net.biz.digitalPropertyNetwork.Person    name:         Participant registry for net.biz.digitalPropertyNetwork.Person    registryType: Participant    assets:      PID:1234567890:        $class:    net.biz.digitalPropertyNetwork.Person        personId:  PID:1234567890        firstName: Fred        lastName:  BloggsCommand succeededJavascript API Exampleconst NetworkList = require('composer-cli').Network.List;let options = {  card: 'admin@tutorial-network'};NetworkList.handler(options);",
        "url": "/composer/latest/reference/composer.network.list"
      }
      ,
    
      "reference-composer-network-loglevel": {
        "title": "Hyperledger Composer Network loglevel",
        "author": "",
        "category": "",
        "content": "Hyperledger Composer Network loglevelThe composer network loglevel command is used to return or define the log level of the composer runtime. If the newlevel option is specified it will change the current level to the specified value. If newlevel is not specified, this command will return the current logging level.composer network loglevel -c admin@tutorial-networkOptionsOptions:  --help          Show help  [boolean]  -v, --version   Show version number  [boolean]  --newlevel, -l  the new logging level  [choices: \"INFO\", \"WARNING\", \"ERROR\", \"DEBUG\"]  --card, -c      The cardname to use to change the log level the network  [string]Javascript API Exampleconst NetworkLogLevel = require('composer-cli').Network.LogLevel;let options = {  card: 'admin@tutorial-network'};NetworkLogLevel.handler(options);",
        "url": "/composer/latest/reference/composer.network.logLevel"
      }
      ,
    
      "reference-composer-network-ping": {
        "title": "Hyperledger Composer Network Ping CLI",
        "author": "",
        "category": "",
        "content": "Hyperledger Composer Network PingThe composer network ping utility is used to verify the connection to a business network deployed to a Hyperledger Fabric.Note that ping also returns the participant information for the identity that was used to connect to the network, ifan identity has been issued for the participant.composer network ping --card admin@tutorial-networkOptionsOptions:  --help         Show help  [boolean]  -v, --version  Show version number  [boolean]  --card, -c     The cardname to use to ping the network  [string]Example Outputcomposer network ping --card admin@tutorial-networkThe connection to the network was successfully tested: tutorial-network    version: 0.15.0-20171108090428    participant: org.hyperledger.composer.system.NetworkAdmin#adminCommand succeededJavascript API Exampleconst NetworkPing = require('composer-cli').Network.Ping;let options = {  card: 'admin@tutorial-network'};NetworkPing.handler(options);",
        "url": "/composer/latest/reference/composer.network.ping"
      }
      ,
    
      "reference-composer-network-reset": {
        "title": "Hyperledger Composer Network Reset Command",
        "author": "",
        "category": "",
        "content": "Composer Network ResetThe composer network reset command deletes the contents of all the registries in the State Database.  It is fast way for developers to reset the Business Network and remove test data. composer network reset -c admin@example-networkSyntaxOptions:  --help             Show help  [boolean]  -v, --version      Show version number  [boolean]  --card, -c         The cardname to use to reset the network  [string] [required]Options--card, -cThe business network card to use to reset the network.",
        "url": "/composer/latest/reference/composer.network.reset"
      }
      ,
    
      "reference-composer-network-start": {
        "title": "Hyperledger Composer Network Start CLI",
        "author": "",
        "category": "",
        "content": "Hyperledger Composer Network StartThe composer network start utility is used to start a specific version of a business network that has been previously installed to a Hyperledger Fabric v1.2 network.Before using this command, read the topic Deploying and Updating Business Networks.Please Note: You must first install the business network to the Hyperledger Fabric peers by using the composer network install command.composer network start --networkName &lt;business-network-name&gt; --networkVersion &lt;business-network-version&gt; --networkAdmin &lt;admin-name&gt; --networkAdminEnrollSecret &lt;enroll-secret&gt; --card &lt;peer-admin-card&gt; --file &lt;admin-card-file-name&gt;ConsiderationsThis command creates a new card file. The connection profile in this card file comes from the card defined in the -c|--card option used to perform the request and the connection profile defines whether an identity in a card should be HSM managed or not. If the card used for the request is not HSM managed (as defined in the connection profle) then the card file created will not be HSM managed. Conversely if the card used for the request is HSM managed then the card file created will also be HSM managed.Optionscomposer network start [options]Options:  --help                             Show help  [boolean]  -v, --version                      Show version number  [boolean]  --networkName, -n                  Name of the business network to start  [required]  --networkVersion, -V               Version of the business network to start  [required]  --loglevel, -l                     The initial loglevel to set  [choices: \"INFO\", \"WARNING\", \"ERROR\", \"DEBUG\"]  --option, -o                       Options that are specific to connection. Multiple options are specified by repeating this option  [string]  --optionsFile, -O                  A file containing options that are specific to connection  [string]  --networkAdmin, -A                 The identity name of the business network administrator  [string] [required]  --networkAdminCertificateFile, -C  The certificate of the business network administrator  [string]  --networkAdminPrivateKeyFile, -K   The private key of the business network administrator  [string]  --networkAdminEnrollSecret, -S     The enrollment secret for the business network administrator  [string]  --card, -c                         The cardname to use to start the network  [string] [required]  --file, -f                         File name of the card to be created  [string]Please refer to Connector specific information for more information about connecting to Hyperledger Fabric v1.2.Javascript API Exampleconst NetworkStart = require('composer-cli').Network.Start;let options = {  networkName: 'tutorial-network',  networkVersion: '0.0.1',  networkAdmin: 'admin',  networkAdminEnrollSecret: 'adminpw',  card: 'PeerAdmin@fabric-network'};NetworkStart.handler(options);",
        "url": "/composer/latest/reference/composer.network.start"
      }
      ,
    
      "reference-composer-network-upgrade": {
        "title": "Hyperledger Composer Network Upgrade CLI",
        "author": "",
        "category": "",
        "content": "Hyperledger Composer Network UpgradeThe composer network upgrade utility is used to upgrade the Hyperledger Composer business network to a new version.composer network upgrade -n &lt;business-network-name&gt; -V &lt;business-network-version&gt; -c &lt;business-network-card&gt;composer network upgrade upgrades the named Hyperledger Composer business network. Before running the composer network upgrade command, a new version of the Hyperledger Composer business network must have been installed to a blockchain node by using the composer network install command.Optionscomposer network upgrade [options]Options:  --help                     Show help  [boolean]  -v, --version              Show version number  [boolean]  --card, -c                 The cardname to use to upgrade the network  [string] [required]  --networkName, -n          Name of the business network to upgrade  [required]  --networkVersion, -V       Version of the business network to upgrade to  [required]  --option, -o               Options that are specific to connection. Multiple options are specified by repeating this option  [string]  --optionsFile, -O          A file containing options that are specific to connection  [string]Please refer to Connector specific information for more information about connecting to Hyperledger Fabric v1.2.Javascript API Exampleconst NetworkUpgrade = require('composer-cli').Network.Upgrade;let options = {  networkName: 'tutorial-network',  networkVersion: '0.0.1',  card: 'PeerAdmin@fabric-network'};NetworkUpgrade.handler(options);",
        "url": "/composer/latest/reference/composer.network.upgrade"
      }
      ,
    
      "reference-composer-participant-add": {
        "title": "Hyperledger Composer Participant Add Command",
        "author": "",
        "category": "",
        "content": "Composer participant addThe composer participant add command adds a new instance of a participant to a participant registry. See the task Add a Participant for a walkthrough of using this command or the API.The data option must contain a serialized JSON representation of the participant to add, and must be wrapped in single quotes.Syntax$ composer participant addcomposer participant add [options]Participant options  --card, -c  The cardname to use to add the participant  [string] [required]  --data, -d  Serialized participant JSON object as a string  [string] [required]Options:  --help         Show help  [boolean]  -v, --version  Show version number  [boolean]Options--card, -cThe business network card, defining the business network and identity to use.Example: admin@tutorial-network--data, -dThe serialized JSON representation of the participant to add to the participant registry. The data must be valid according to the model of the participant.  Example: &#39;{&quot;$class&quot;:&quot;net.biz.digitalPropertyNetwork.Person&quot;,&quot;personId&quot;:&quot;mae@biznet.org&quot;,&quot;firstName&quot;:&quot;Mae&quot;,&quot;lastName&quot;:&quot;Smith&quot;}&#39;Javascript API Exampleconst ParticipantAdd = require('composer-cli').Participant.Add;let options = {  card: 'admin@tutorial-network',  data: '{\"$class\":\"net.biz.digitalPropertyNetwork.Person\",\"personId\":\"mae@biznet.org\",\"firstName\":\"Mae\",\"lastName\":\"Smith\"}'};ParticipantAdd.handler(options);",
        "url": "/composer/latest/reference/composer.participant.add"
      }
      ,
    
      "reference-composer-report": {
        "title": "Hyperledger Composer Report",
        "author": "",
        "category": "",
        "content": "Composer ReportThe composer report command creates a compressed archive file in the directory where the command was issued. The archive file contains details of the current composer environment.SyntaxOptions:  --help         Show help  [boolean]  -v, --version  Show version number  [boolean]Stand-alone commandAn alternative stand-alone command is available for situations where the composer command is not working, or the composer-cli module could not be installed for any reason.This would normally be installed as a global modulenpm install -g composer-report@0.20Once installed, running composer-report will create a report archive in the current directory in the same way as the full composer report command.Javascript API Exampleconst Report = require('composer-cli').Report.Report;Report.handler();",
        "url": "/composer/latest/reference/composer.report"
      }
      ,
    
      "reference-composer-transaction-submit": {
        "title": "Hyperledger Composer Transaction Submit Command",
        "author": "",
        "category": "",
        "content": "composer transaction submitThe composer transaction submit command submits a transaction to a business network.Syntax$ composer transaction submitcomposer transaction submit [options]Options:  --help                       Show help  [boolean]  -v, --version                Show version number  [boolean]  -c, --card                   The name of the business network card to use [string] [required]  --data, -d                   Transactions JSON object as a string  [string] [required]Options--card, -cThe name of the business network card to use. The business network card is used to determine connection and business network details.Example: admin@tutorial-network--data, -dThe serialized JSON representation of the transaction to send to the business network. The data must be valid according to the model of the transaction.Example: {&quot;$class&quot;:&quot;net.biz.digitalPropertyNetwork.RegisterPropertyForSale&quot;,&quot;transactionId&quot;:&quot;TRANSACTION_001&quot;,&quot;seller&quot;:&quot;mae@biznet.org&quot;,&quot;title&quot;:&quot;TITLE_001&quot;}Example commandThis command submits a transaction to the business network digitalproperty-network using the business network card maeid1@digitalproperty-network. The transaction submitted is &#39;{&quot;$class&quot;:&quot;net.biz.digitalPropertyNetwork.RegisterPropertyForSale&quot;,&quot;transactionId&quot;:&quot;TRANSACTION_001&quot;,&quot;seller&quot;:&quot;mae@biznet.org&quot;,&quot;title&quot;:&quot;TITLE_001&quot;}&#39;.Here is the entire command:composer transaction submit -c maeid1@digitalproperty-network -d '{\"$class\":\"net.biz.digitalPropertyNetwork.RegisterPropertyForSale\",\"transactionId\":\"TRANSACTION_001\",\"seller\":\"mae@biznet.org\",\"title\":\"TITLE_001\"}'Javascript API Exampleconst TransactionSubmit = require('composer-cli').Transaction.Submit;let options = {  card: 'admin@tutorial-network',  data: '{\"$class\":\"net.biz.digitalPropertyNetwork.RegisterPropertyForSale\",\"transactionId\":\"TRANSACTION_001\",\"seller\":\"mae@biznet.org\",\"title\":\"TITLE_001\"}'};TransactionSubmit.handler(options);",
        "url": "/composer/latest/reference/composer.transaction.submit"
      }
      ,
    
      "reference-connectionprofile": {
        "title": "Connection Profiles",
        "author": "",
        "category": "",
        "content": "Connection ProfilesA Connection Profile is used by Hyperledger Composer to connect to a runtime.Creating a Connection Profile for Hyperledger Fabric v1.2Hyperledger Fabric defines the format of the connection profile. The following is an example of a single organization fabric network{    \"name\": \"hlfv1\",    \"x-type\": \"hlfv1\",    \"x-commitTimeout\": 300,    \"version\": \"1.0.0\",    \"client\": {        \"organization\": \"Org1\",        \"connection\": {            \"timeout\": {                \"peer\": {                    \"endorser\": \"300\",                    \"eventHub\": \"300\",                    \"eventReg\": \"300\"                },                \"orderer\": \"300\"            }        }    },    \"channels\": {        \"composerchannel\": {            \"orderers\": [                \"orderer.example.com\"            ],            \"peers\": {                \"peer0.org1.example.com\": {                    \"endorsingPeer\": true,                    \"chaincodeQuery\": true,                    \"ledgerQuery\": true,                    \"eventSource\": true                }            }        }    },    \"organizations\": {        \"Org1\": {            \"mspid\": \"Org1MSP\",            \"peers\": [                \"peer0.org1.example.com\"            ],            \"certificateAuthorities\": [                \"ca.org1.example.com\"            ]        }    },    \"orderers\": {        \"orderer.example.com\": {            \"url\": \"grpc://orderer.example.com:7050\"        }    },    \"peers\": {        \"peer0.org1.example.com\": {            \"url\": \"grpc://peer0.org1.example.com:7051\"        }    },    \"certificateAuthorities\": {        \"ca.org1.example.com\": {            \"url\": \"http://ca.org1.example.com:7054\",            \"caName\": \"ca.org1.example.com\"        }    }}Official documentation for this structure can be found here:  https://fabric-sdk-node.github.io/tutorial-network-config.html.The Hyperledger Fabric v1.2 connection profile is significantly different to the connection profiles used by previous versions of Hyperledger Composer. The Hyperledger Fabric v1.2 connection profile defines all the servers that exist, not only in your organization but all organizations as well as all defined channels.The full capability of the connection profile is not given here and not all of it is supported but this will be discussed in the sections.The following sections define the server details:OrderersPeersCertificate AuthoritiesOrganizational details are defined in:OrganizationsChannelsClient sectionGeneral information\"name\": \"hlfv1\",\"x-type\": \"hlfv1\",\"x-commitTimeout\": 300,\"version\": \"1.0.0\",name is a name used to refer to the connection profile, and is required.x-type defines the version of Hyperledger Fabric that you will connect to. To connect to Hyperledger Fabric v1.2, x-type must be hlfv1.x-commitTimeout defines the number of seconds to wait for a commit response to be received for a transaction.version defines the version of a connection profile and currently only a version of 1.0.0 is supported.OrderersHere we define all the orderers that are part of the network. The name &quot;orderer.example.com&quot; is a label allowing us to reference this definition later.\"orderers\": {    \"orderer.example.com\": {        \"url\": \"grpc://orderer.example.com:7050\"    }},This section defines all the available orderers, the example here provides a basic configuration for a non-tls orderer. To configure an orderer to use TLS, use the following format:\"orderers\": {    \"orderer.example.com\": {        \"url\": \"grpcs://orderer.example.com:7050\",        \"grpcOptions\": {            \"ssl-target-name-override\": \"orderer.example.com\"        },        \"tlsCACerts\": {            \"pem\": \"-----BEGIN CERTIFICATE----- &lt;etc&gt; \"        }    }},In order to guarantee portability it is highly recommended to embed required certificate(s) into the connection profile using the pem option.Certificates can also be defined using a file path, but this is not recommended.PeersHere we define all the peers in all organizations in the network. Each has a unique label so it can be referenced later. In the example the label is peer0.org1.example.com.\"peers\": {    \"peer0.org1.example.com\": {        \"url\": \"grpc://peer0.org1.example.com:7051\"    }},Peer definitions are similar to orderer definitions in structure.\"peers\": {    \"peer0.org1.example.com\": {        \"url\": \"grpc://peer0.org1.example.com:7051\",        \"grpcOptions\": {            \"ssl-target-name-override\": \"peer.org1.example.com\"        },        \"tlsCACerts\": {            \"pem\": \"-----BEGIN CERTIFICATE----- &lt;etc&gt; \"        }    }},To define multiple peers, use the following format:\"peers\": {    \"peer0.org1.example.com\": {        \"url\": \"grpc://peer0.org1.example.com:7051\"    },    \"peer1.org1.example.com\": {        \"url\": \"grpc://peer1.org1.example.com:7051\"    },    \"peer0.org2.example.com\": {        \"url\": \"grpc://peer0.org2.example.com:7051\"    },},Certificate AuthoritiesHere you define all the certificate authorities\"certificateAuthorities\": {    \"ca.org1.example.com\": {        \"url\": \"http://ca.org1.example.com:7054\",        \"caName\": \"ca.org1.example.com\"    }}url defines the url of a Hyperledger Fabric certificate authority to connect to. If your certificate authority requires a name, it must be defined in caName.trustedRoots and verify options for the Certificate Authority are described here https://fabric-sdk-node.github.io/global.html#TLSOptionsOrganizationsHere you define the servers that are part of your organization as well as your MSPid and provide it with a name which can be referenced.In the example our MSPid is Org1MSP and we have a single peer and a single certificate authority and label our organization Org1. Note the referencing of the peer and certificate authority.    \"organizations\": {        \"Org1\": {            \"mspid\": \"Org1MSP\",            \"peers\": [                \"peer0.org1.example.com\"            ],            \"certificateAuthorities\": [                \"ca.org1.example.com\"            ]        }    },mspid is the Membership Service Provider ID of your organization. It is associated with the enrolment id that you will use to interact with the business network.ChannelsThis defines the various Hyperledger Fabric peers and orderers that are participating on a specific channel as well as the role of the peers.IMPORTANT Hyperledger Composer can only work with 1 channel, so you need to ensure that only a single channel is defined in this section even though the document can support multiple channel definitions.\"channels\": {    \"composerchannel\": {        \"orderers\": [            \"orderer.example.com\"        ],        \"peers\": {            \"peer0.org1.example.com\": {                \"endorsingPeer\": true,                \"chaincodeQuery\": true,                \"ledgerQuery\": true,                \"eventSource\": true            }        }    }},A peer has 4 possible roles. If a role is not specified then it is assumed to be true.endorsingPeer means that peer is there to endorse transactions and must have chaincode instantiated.chaincodeQuery means that peer is able to handle chaincode query requests and must have chaincode instantiated.ledgerQuery means that peer is able to perform a ledger query. This does not require chaincode to be instantiated on that peer.eventSource means that this peer will generate events.ClientThis section will be unique for each organization and defines configuration information specific to your client application.\"client\": {    \"organization\": \"Org1\",    \"connection\": {        \"timeout\": {            \"peer\": {                \"endorser\": \"300\",                \"eventHub\": \"300\",                \"eventReg\": \"300\"            },            \"orderer\": \"300\"        }    }},In this section you define the organization you belong to, in the example this is Org1 which references the Org1 organization in the profile. You also define timeouts in seconds for each of the possible interactions.Common propertiesWhen defining a peer or orderer there are some common options you can use. These are:grpcOptionstlsCACertsFor example a peer definition might look like:\"peer0.org1.example.com\": {    \"url\": \"grpcs://peer0.org1.example.com:7051\",    \"grpcOptions\": {        \"ssl-target-name-override\": \"peer.org1.example.com\",        \"grpc.keepalive_time_ms\": 600000,        \"grpc.max_send_message_length\": 15728640,        \"grpc.max_receive_message_length\": 15728640    },    \"tlsCACerts\": {        \"pem\": \"-----BEGIN CERTIFICATE----- &lt;etc&gt; \"    }}The grpc message lengths are in bytes and the timeout is in milliseconds. the grpc options are not specific to the connection profile and are the same properties defined by grpc itself.A similar thing could be done for an orderer definition:\"orderer.example.com\": {    \"url\": \"grpcs://orderer.example.com:7050\",    \"grpcOptions\": {        \"ssl-target-name-override\": \"orderer.example.com\",        \"grpc.keepalive_time_ms\": 600000,        \"grpc.max_send_message_length\": 15728640,        \"grpc.max_receive_message_length\": 15728640    },    \"tlsCACerts\": {        \"pem\": \"-----BEGIN CERTIFICATE----- &lt;etc&gt; \"    }}There are other grpcOptions available, please refer to the https://fabric-sdk-node.github.io/tutorial-network-config.html for more informationHSM SupportSupport for HSM (Hardware Security Module)is now possible so long as you have PKCS#11 support for your HSM and the PKCS#11 module is configured as per the vendor documentation. To drive management of identities through a HSM you need to provide the connection profile with information about your HSM setup. This information needs to go into the client section, for example\"client\": {    \"organization\": \"Org1\",    \"connection\": {        \"timeout\": {            \"peer\": {                \"endorser\": \"300\",                \"eventHub\": \"300\",                \"eventReg\": \"300\"            },            \"orderer\": \"300\"        }    },    \"x-hsm\": {        \"library\": \"/usr/local/lib/myhsm.so\",        \"slot\": 0,        \"pin\": 98765432    }},library is the absolute path to the pkcs#11 library required for communication with your specific HSMslot is the configured slot number for the HSMpin is the pin defined for access to that slot.To be able to ensure connection profiles remain portable as well as not hard coding the slot and pin in the connection profile, each of the hsm properties can be referenced from an environment variable. For example if you define environment variables on your system called PKCS_LIBRARY, PKCS_SLOT and PKCS_PIN to hold the hsm information, for exampleexport PKCS_LIBRARY=/usr/local/lib/myhsm.soexport PKCS_SLOT=0export PKCS_PIN=98765432then you can reference these in the connection profile as follows\"x-hsm\": {    \"library\": \"{PKCS_LIBRARY}\",    \"slot\": \"{PKCS_SLOT}\",    \"pin\": \"{PKCS_PIN}\"}",
        "url": "/composer/latest/reference/connectionprofile"
      }
      ,
    
      "managing-connector-information": {
        "title": "Interacting with Hyperledger Fabric",
        "author": "",
        "category": "tasks",
        "content": "Hyperledger FabricThere are several cases where information specific to Hyperledger Fabric must be included in Hyperledger Composer commands, including composer network install, composer network start and composer identity issue. The --option, -o option and the --optionsFile, -O option allow connector specific information to be sent.Multiple options can be specified using the --option, -o by repeating the tag, for example:composer somecmd -o thisOpt=value2 -o thatOpt=value2Alternatively you can create a single file to contain multiple options, for example a file called someCmdOpts.txt could contain:thisOpt=value1thatOpt=value2To reference an options file, use the following format:composer somecmd --optionsFile=someCmdOpts.txtSome API&#39;s will also include the option to pass a generic options object including AdminConnection.start() and AdminConnection.install()Providing npm config settings for installCLIThe npmrcFile option is available on the composer network install command.The npmrcFile option allows you to specify npm configuration information when Hyperledger Fabric builds the chaincode image for the Hyperledger Composer runtime.For example rather than using the default npm registry, you can specify an internal registry within your organization by including the registry option in an options file:registry=http://mycompanynpmregistry.com:4873Supply the fully qualified filename as part of an install command, for example if the file was called npmConfigin your /home/user1/config directory:composer network install --c PeerAdmin@hlfv1 --a tutorial-network@0.0.1.bna -o npmrcFile=/home/user1/config/npmConfigThe file contents can be anything that permitted in the .npmrc configuration files of npm.Admin APIYou can supply the name of the file as part of the AdminConnection api on the install method by specifying the npmrcFile property on the installOptions object. For example to pass the name of the npm configuration options file to be provided on install:await AdminConnection.install(businessNetworkDefinition, {npmrcFile: '/tmp/npmrc'});Hyperledger Fabric Endorsement PoliciesYou can provide Hyperledger Fabric endorsement policies to both network start and network upgrade requests. The examples that follow show start but the approach is identical to upgrade as well.composer network start/upgrade CLIHyperledger Fabric endorsement policies can be sent using the -o and -O options in several ways.Using the -o option, the endorsement policy can be sent either as a single-line JSON string or as a fully qualified file path:composer network start ... -o endorsementPolicy='{\"identities\": [.... }'composer network start ... -o endorsementPolicyFile=/path/to/file/endorsementPolicy.jsonWhen a file path is specified, the endorsement policy file should follow this format:    {\"identities\":[...],        \"policy\": {...}}Using the -O option, the endorsement policy must be sent as a file path as follows:composer network start ... -O /path/to/file/options.jsonIn this case, the options file should follow this format:        {\"endorsementPolicy\": {\"Identities\": [...].            \"policy: {...}\"          },          \"someOtherOption\": \"A Value\"        }For more information on writing Hyperledger Fabric endorsement policies, see the Hyperledger Fabric Node.js SDK documentation which provides examples of endorsement policies.Admin APITo send an endorsement policy via the Admin API, the endorsement policy file must be included as part of the startOptions or deployOptions objects when calling start or deploy respectively. To pass an endorsement policy file it must be specified in the object property endorsementPolicyFile. To supply the policy as a JSON object, the endorsementPolicy object property must be specified.await adminConnection.start('tutorial-network', '0.0.1', { networkAdmins: networkAdmins,  endorsementPolicyFile: 'endorsement-policy.json'} );Identity IssueWhen a new identity is issued, you may want to specify whether the issued identity has the authority to register new identities with a Hyperledger Fabric certificate authority server. CLITo grant an identity the authority to register new identities with a certificate authority from the command line, the -x option is available (which is a shortcut replacement for -o issuer=true).composer identity issue -c admin@digitalproperty-network -u MyUser -a net.biz.digitalPropertyNetwork.Person#P1 -xAPITo specify the issuer property you set it in an object and pass this object as part of the issueOptions on issueIdentity.For example to issue an identity that has issuer authorityawait businessNetworkConnection.issueIdentity(participantId, newUserId, {issuer: true});Next stepsLearn more about connection profiles.",
        "url": "/composer/latest/managing/connector-information"
      }
      ,
    
      "reference-cto-language": {
        "title": "Modeling Language",
        "author": "",
        "category": "",
        "content": "Hyperledger Composer Modeling LanguageHyperledger Composer includes an object-oriented modeling language that is used to define the domain model for a business network definition.A Hyperledger Composer CTO file is composed of the following elements:A single namespace. All resource declarations within the file are implicitly in this namespace.A set of resource definitions, encompassing assets, transactions, participants, and events.Optional import declarations that import resources from other namespaces.Organization and Hyperledger Composer System NamespacesYour organization namespace is defined in the namespace line of your model (.cto) file, and all resources created are implicitly part of this namespace.As well as defining new classes of asset, participant, event, and transaction, there is a system namespace which contains the base definitions of asset, event, participant, and transaction. These base definitions are abstract types which are implicitly extended by all assets, events, participants, and transactions.In the system namespace definitions, asset and participant have no required values. Events and transactions are defined by an eventId or transactionId and a timestamp. The system namespace also includes definitions of registries, historian records, identities, and a number of system transactions.If you have defined an event or transaction including an eventId, transactionId, or timestamp, you must delete the eventId, transactionId, or timestamp properties.Declarations of resourcesResources in Hyperledger Composer include:Assets, Participants, Transactions, and Events.Enumerated Types.Concepts.Assets, Participants and Transactions are class definitions. The concepts of Asset, Participant and Transaction may be considered to be different stereotypes of the class type.A class in Hyperledger Composer is referred to as a Resource Definition, therefore an asset instance has an Asset Definition.A resource definition has the following properties:A namespace defined by the namespace of its parent file. The namespace of a .cto file implicitly applies to all resources created in it.A name, for example Vehicle, and an identifying field, for example, vin. If the resource is an asset or participant, the name is followed by the identifying field, if the resource is an event or transaction, the identifying field is set automatically. In this example, the asset is named Vehicle and the identifying field is vin./** * A vehicle asset. */asset Vehicle identified by vin {  o String vin}An optional super-type, which the resource definition extends. The resource will take all properties and fields required by the super-type and add any additional properties or fields from its own definition./** * A car asset. A car is related to a list of parts */asset Car extends Vehicle {  o String model  --&gt; Part[] Parts}An optional &#39;abstract&#39; declaration, to indicate that this type cannot be created. Abstract resources can be used as a basis for other classes to extend. Extensions of abstract classes do not inherit the abstract status. For example, the asset Vehicle defined above should never be created, as there should be more specific asset classes defined to extend it./** * An abstract Vehicle asset. */abstract asset Vehicle identified by vin {  o String vin}A set of named properties. The properties must be named, and the primitive data type defined.The properties and their data are owned by each resource, for example, a Car asset has a vin, and a model property, both of which are strings.A set of relationships to other Composer types that are not owned by the resource but that may be referenced from the resource. Relationships are unidirectional./** * A Field asset. A Field is related to a list of animals */asset Field identified by fieldId {  o String fieldId  o String name  --&gt; Animal[] animals}Declarations of enumerated typesEnumerated types are used to specify a type that may have 1 or N possible values. The example below defines the ProductType enumeration, which may have the value DAIRY or BEEF or VEGETABLES./** * An enumerated type */enum ProductType {  o DAIRY  o BEEF  o VEGETABLES}When another resource is created, for example, a participant, a property of that resource can be defined in terms of an enumerated type.participant Farmer identified by farmerId {    o String farmerId    o ProductType primaryProduct}ConceptsConcepts are abstract classes that are not assets, participants or transactions. They are typically contained by an asset, participant or transaction.For example, below an abstract concept Address is defined, and then specialized into a UnitedStatesAddress. Note that concepts do not have an identified by field as they cannot be directly stored in registries or referenced in relationships.abstract concept Address {  o String street  o String city default =\"Winchester\"  o String country default = \"UK\"  o Integer[] counts optional}concept UnitedStatesAddress extends Address {  o String zipcode}You can then use this concept, for exampleparticipant Farmer identified by farmerId {    o String farmerId    o UnitedStatesAddress address    o ProductType primaryProduct}Primitive typesComposer resources are defined in terms of the following primitive types:String: a UTF8 encoded String.Double: a double precision 64 bit numeric value.Integer: a 32 bit signed whole number.Long: a 64 bit signed whole number.DateTime: an ISO-8601 compatible time instance, with optional time zone and UTZ offset.Boolean: a Boolean value, either true or false.ArraysAll types in Composer may be declared as arrays using the [] notation.Integer[] integerArrayIs an array of Integers stored in a field called &#39;integerArray&#39;. While--&gt; Animal[] incomingIs an array of relationships to the Animal type, stored in a field called&#39;incoming&#39;.RelationshipsA relationship in the Composer language is a tuple composed of:The namespace of the type being referencedThe type name of the type being referencedThe identifier of the instance being referencedHence a relationship could be to:    org.example.Vehicle#123456This would be a relationship to the Vehicle type declared in the org.examplenamespace with the identifier 123456.Relationships are unidirectional and deletes do not cascade, ie. removing the relationship has no impact on the thing that is being pointed to. Removing the thing being pointed to does not invalidate the relationship.Relationships must be resolved to retrieve an instance of the object beingreferenced. The act of resolution may result in null, if the object no longerexists or the information in the relationship is invalid.Field ValidatorsString fields may include an optional regular expression, which is used to validate the contents of the field. Careful use of field validators allows Composer to perform rich data validation, leading to fewer errors and less boilerplate code.The example below declares that the Farmer participant contains a field postcode that must conform to the regular expression for valid UK postcodes.participant Farmer extends Participant {    o String firstName default=\"Old\"    o String lastName default=\"McDonald\"    o String address1    o String address2    o String county    o String postcode regex=/(GIR 0AA)|((([A-Z-[QVf]][0-9][0-9]?)|(([A-Z-[QVf]][A-Z-[IJZ]][0-9][0-9]?)|(([A-Z-[QVf]][0-9][A-HJKPSTUW])|([A-Z-[QVf]][A-Z-[IJZ]][0-9][ABEHMNPRVWfY])))) [0-9][A-Z-[CIKMOV]]{2})/}Double, Long or Integer fields may include an optional range expression, which is used to validate the contents of the field.The example below declared that the Vehicle asset has an Integer field year which defaults to 2016 and must be 1990, or higher. Range expressions may omit the lower or upper bound if checking is not required.asset Vehicle extends Base {  // An asset contains Fields, each of which can have an optional default value  o String model default=\"F150\"  o String make default=\"FORD\"  o String reg default=\"ABC123\"  // A numeric field can have a range validation expression  o Integer year default=2016 range=[1990,] optional // model year must be 1990 or higher  o Integer[] integerArray  o State state  o Double value  o String colour  o String V5cID regex=/^[A-z][A-z][0-9]{7}/  o String LeaseContractID  o Boolean scrapped default=false  o DateTime lastUpdate optional  --&gt; Participant owner //relationship to a Participant, with the field named 'owner'.  --&gt; Participant[] previousOwners optional // Nary relationship  o Customer customer}ImportsUse the import keyword with a fully-qualified type name to import a type from another namespace. Alternatively use the .* notation to import all the types from another namespace.import org.example.MyAssetimport org.example2.*DecoratorsResources and properties of resources may have decorators attached. Decorators are used to annotate a model with metadata. The example below adds the foo decorator to the Buyer participant, with &quot;arg1&#39; and 2 passed as arguments to the decorator.Similarly decorators can be attached to properties, relationships and enumerated values.@foo(\"arg1\", 2)participant Buyer extends Person {}Resource definitions and properties may be decorated with 0 or more decorations. Note that only a single instance of a decorator is allowed on each element type. I.e. it is invalid to have the @bar decorator listed twice on the same element.Decorator ArgumentsDecorators may have an arbitrary list of arguments (0 or more items). Argument values must be strings, numbers or booleans.Decorator APIsDecorators are accessible at runtime via the ModelManager introspect APIs. This allows external tools and utilities to use the Composer Modelling Language (CTO) file format to describe a core model, while decorating it with sufficient metadata for their own purposes.The example below retrieves the 3rd argument to the foo decorator attached to the myField property of a class declaration:const val = myField.getDecorator('foo').getArguments()[2];",
        "url": "/composer/latest/reference/cto_language"
      }
      ,
    
      "integrating-customizing-the-rest-server": {
        "title": "Customizing the REST server for a business network",
        "author": "",
        "category": "start",
        "content": "Customizing the REST server for a business networkBy default, the Hyperledger Composer REST server includes functionality that generates a set of RESTful APIs for all of the assets, participants, and transactions within a deployed business network.The Hyperledger Composer REST server also includes functionality for the following features:Publishing events using WebSockets.Enabling authentication using the open source Passport authentication middleware.Enabling multiple user mode so authenticated users can supply their own blockchain credentials.Enabling HTTPS and TLS for secure client-server communications.These features are all designed to be general purpose and easy to use out of the box. The Hyperledger Composer REST server is distributed as an application called composer-rest-server, which can be installed using either npm or Docker, and includes all of these features.However, these features may not meet all of the requirements of all users. For example, a user of the Hyperledger Composer REST server may wish to use a different form of authentication middleware, instead of using Passport.As an alternative to using the Hyperledger Composer REST server application composer-rest-server, you can generate a LoopBack application on disk that is equivalent in functionality. By editing the code in this generated LoopBack application, you can customize the REST server to meet all of your requirements.Generating a LoopBack applicationYou can use the Yeoman generator to generate a LoopBack application. Before running the Yeoman generator, you must have deployed a business network, and you must have a business network card that can be used to access that business network.In the example below, we have deployed the tutorial-network business network, and we can use the business network card admin@tutorial-network to connect to that business network.Run the Yeoman generator by issuing the following command in a terminal:yo hyperledger-composerThe Yeoman generator will ask a series of questions before generating the LoopBack application. Ensure that you pick LoopBack as the project type, and specify the correct name for the business network card instead of that shown in the example below:Welcome to the Hyperledger Composer project generator? Please select the type of project: LoopBackYou can run this generator using: 'yo hyperledger-composer:loopback'Welcome to the Hyperledger Composer LoopBack project generator? Do you want to connect to a running Business Network? Yes? Project name: my-loopback-app? Description: Hyperledger Composer LoopBack project? Author name: Simon Stone? Author email: simon@congaverse.com? License: Apache-2.0? Name of the Business Network card: admin@tutorial-networkIf successful, the Yeoman generator will create an application in a sub directory of the current working directory named after the specified Project name. In the example above, the sub directory would be called my-loopback-app.You can start the generated application by entering the sub directory, and running the following command:npm startThe generated application will give you a URL that you can use to interact with the RESTful APIs:&gt; my-loopback-app@1.0.0 start /private/tmp/my-loopback-app&gt; node .Web server listening at: http://localhost:3000Browse your REST API at http://localhost:3000/explorerCustomizing the LoopBack applicationThe generated LoopBack application is a standard LoopBack application. It contains a set of LoopBack model files, one for each modelled type in the business network, under the subdirectory common/models. Each model file is comprised of a JSON file (e.g. Commodity.json) and a JavaScript file (e.g. Commodity.js).  There are also LoopBack model files for generic business network RESTful APIs, such as the /system/ping API.The generated LoopBack application includes a single data source named composer that uses the LoopBack connector for Hyperledger Composer, loopback-connector-composer. The data source configuration, in the file server/datasources.json, includes the name of the business network card; if you change the name of the business network card, you must also change the data source configuration:{    \"composer\": {        \"name\": \"composer\",        \"connector\": \"loopback-connector-composer\",        \"card\": \"admin@tutorial-network\",        \"namespaces\": false    }}The generated LoopBack application includes model configuration that binds all of the LoopBack model files to the data source named composer, and exposes them over RESTful APIs by setting the flag public to true. The model configuration, in the file server/model-config.json, can be edited to hide or disable the RESTful APIs for a particular modelled type:{    ...    \"Commodity\": {        \"dataSource\": \"composer\",        \"public\": true    }    ...}For further information about the structure of a LoopBack application, including how to customize and add additional functionality to the application, read the LoopBack documentation. The generated LoopBack application uses Loopback v3.0, and the documentation for LoopBack v3.0 can be found here: https://loopback.io/doc/en/lb3/",
        "url": "/composer/latest/integrating/customizing-the-rest-server"
      }
      ,
    
      "tutorials-deploy-to-fabric-multi-org": {
        "title": "Deploying to a multi-organization Hyperledger Fabric",
        "author": "",
        "category": "tutorials",
        "content": "Deploying a Hyperledger Composer blockchain business network to Hyperledger Fabric (multiple organizations)This tutorial provides an insight into the process for configuring a blockchain network, spanning multiple organizations.It outlines the steps you need configure a Hyperledger Fabric based multi-organisation blockchain network. The two-organisation blockchain network is based on a sample network provided by Hyperledger Fabric. Furthermore, it describes the steps to generate the necessary security artifacts and secure the network in either organization.Once the blockchain network is configured, we show how to deploy a business network (eg. a Commodity trading business network from our sample networks), which runs in its own chaincode container and which is instantiated on the ledger shared across both organizations. We then show interactions with the shared ledger as different participants / identities, as generated by an Identity provider in each organization.It is recommended that you first follow the accompanying singie organization tutorial first ; this tutorial demonstrates how to deploy a blockchain network to an instance of Hyperledger Fabric for a single organization, and will explain some of the concepts in more detail.The Hyperledger Fabric blockchain network (for two organizations) in this tutorial is configured using docker containers,  with both organizations&#39; fabric networks, on the same machine - obviously, in the real world, they&#39;ll be in separate IP networks or domains, or secure Cloud environments.The tutorial has colour-coded steps for convenience, to indicate &#39;which organization&#39; should follow a particular step or sequence - or indeed, if steps are needed for both Orgs.The first kind of step is for both organizations to follow:Example Step: A step for Org1 and Org2 to followThe organization Org1 is represented by Alice, the Green Conga Block:Example Step: A step for Org1 to followThe organization Org2 is represented by Bob, the Violet Conga Block:Example Step: A step for Org2 to followYou can follow these steps by yourself, or pair with a friend or colleague and follow the steps together.Let&#39;s get started!PrerequisitesIf you have previously installed the Composer development environment, you will need to first tear down the Hyperledger Fabric containers provided by the development environment:cd ~/fabric-dev-serversexport FABRIC_VERSION=hlfv12./stopFabric.sh./teardownFabric.shNext, clone the following GitHub Fabric Samples repository using the command line (IMPORTANT: DO NOT USE the samples from the Fabric site: as it is missing some changes that are required for this tutorial)git clone https://github.com/mahoney1/fabric-samples.gitWe are using the  Building Your First Network Fabric sample network for this multi-org tutorial. We will refer to this Hyperledger Fabric network as the &#39;BYFN&#39; (Building Your First Network) network henceforth. If you choose to split your organisations across separate physical machines or separate virtual machines running on different IP networks, it is outside the scope of this particular tutorial.Step One: Starting a Hyperledger Fabric networkIn order to follow this tutorial, you must start up a fresh Hyperledger Fabric network. This tutorial will assume that you use the Hyperledger Fabric network provided in the Hyperledger Fabric Building Your First Network tutorial.change directory to fabric-samplescd fabric-samplesDownload the platform binaries, including cryptogen using this command (three parameters needed for the bash command):curl -sSL http://bit.ly/2ysbOFE | bash -s 1.2.0 1.2.0 0.4.10Verify the list of docker images downloaded without issues.(Please note that you can ignore the initial &quot;error: pathspec v1.x.x did not match&quot; message in the output - you may not even see this message)We need to use the &#39;multi-org&#39; branch from the Git repo we cloned earlier (to work with current Fabric level):git checkout multi-orgchange directory into first-network samplecd first-networkNext, start the BYFN network - additional flags (to the byfn.sh script below) must be specified, as we&#39;re using CouchDB as the world state database (different to that specified on the Fabric BYFN page) - we also want to start a Certificate Authority (CA) for each organization.Execute the following commands in sequence from the first-network directory:./byfn.sh -m generate./byfn.sh -m up -s couchdb -aIf the command works successfully, the first command will generate Fabric network / security artifacts(see this link. Following the second command (above), the BYFN network is started, and verify that you see the following output before proceeding:========= All GOOD, BYFN execution completed ===========_____   _   _   ____| ____| | \\ | | |  _ \\|  _|   |  \\| | | | | || |___  | |\\  | | |_| ||_____| |_| \\_| |____/Next, delete any &#39;old&#39; business network cards that may exist in your wallet from previous Fabric environments. It is safe to ignore any errors that state that the business network cards cannot be found:composer card delete -c PeerAdmin@byfn-network-org1composer card delete -c PeerAdmin@byfn-network-org2composer card delete -c alice@trade-networkcomposer card delete -c bob@trade-networkcomposer card delete -c admin@trade-networkcomposer card delete -c PeerAdmin@fabric-networkHowever any other types of failure could indicate you have cards in the card store which are from an older version of Hyperledger Composer and you will then have to delete your file system card store in your HOME directory as follows:rm -fr $HOME/.composerStep Two: Exploring the Hyperledger Fabric networkThis step will explore the BFYN network configuration and components. The configuration details are required to complete the subsequent steps.OrganizationsThe BYFN network is made up of two organizations: Org1 and Org2. The organization Org1 uses the domain name org1.example.com. The Membership Services Provider (MSP) for Org1 is called Org1MSP. The organization Org2 uses the domain name org2.example.com. The MSP for Org2 is called Org2MSP. In this tutorial, you will deploy a blockchain business network that both of the organizations Org1 and Org2 can interact with.Network componentsThe Hyperledger Fabric network is made up of several components:Two peer nodes for Org1, named peer0.org1.example.com and peer1.org1.example.com.The request port for peer0 is 7051.The event hub port for peer0 is 7053.The request port for peer1 is 8051.The event hub port for peer1 is 8053.A single CA (Certificate Authority) for Org1, named ca.org1.example.com.The CA port is 7054.Two peer nodes for Org2, named peer0.org2.example.com and peer1.org2.example.com.The request port for peer0 is 9051.The event hub port for peer0 is 9053.The request port for peer1 is 10051.The event hub port for peer1 is 10053.A single CA (Certificate Authority) for Org2, named ca.org2.example.com.The CA port is 8054.A single orderer node, named orderer.example.com.The orderer port is 7050.These components are running inside Docker containers. When running Hyperledger Composer within a Docker container, the names above (for example, peer0.org1.example.com) can be used to interact with the Hyperledger Fabric network.This tutorial will run Hyperledger Composer commands on the Docker host machine, rather than from inside the Docker network. This means that the Hyperledger Composer commands must interact with the Hyperledger Fabric network using localhost as the host name and the exposed container ports.All of the network components are secured using TLS to encrypt communications. You will need the Certificate Authority (CA) certificates for all of the network components in order to connect to those network components. The CA certificates can be found in the directory containing the byfn.sh script.CA certificate for the orderer node:crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tls/ca.crtCA certificate for Org1:crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crtCA certificate for Org2:crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crtYou will use these files later on to interact with the Hyperledger Fabric network.UsersThe organization Org1 is configured with a user named Admin@org1.example.com. This user is an administrator.The user Admin@org1.example.com has a set of certificates and private key files stored in the directory:crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspThe organization Org2 is configured with a user named Admin@org2.example.com. This user is an administrator.The user Admin@org2.example.com has a set of certificates and private key files stored in the directory:crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspYou will use some of these files later on to interact with the Hyperledger Fabric network.In addition to the administrator, the CAs (Certificate Authorities) for Org1 and Org2 have been configured with a default user. This default user has an enrolment ID of admin and an enrolment secret of adminpw. However, this user does not have permission to deploy a blockchain business network.It is recommended to create a temporary working directory (and subdirectories) to manage the Composer connection profiles and key/certificate files that we will work with later on in the tutorial.mkdir -p /tmp/composer/org1mkdir -p /tmp/composer/org2ChannelA channel named mychannel has been created. All four peer nodes - peer0.org1.example.com, peer1.org1.example.com, peer0.org2.example.com, and peer1.org2.example.com have been joined to this channel.Connection ProfilesWe need a base connection profile that describes this fabric network which can then be given to alice and bob to customize for their organization.{    \"name\": \"byfn-network\",    \"x-type\": \"hlfv1\",    \"version\": \"1.0.0\",    \"channels\": {        \"mychannel\": {            \"orderers\": [                \"orderer.example.com\"            ],            \"peers\": {                \"peer0.org1.example.com\": {                    \"endorsingPeer\": true,                    \"chaincodeQuery\": true,                    \"eventSource\": true                },                \"peer1.org1.example.com\": {                    \"endorsingPeer\": true,                    \"chaincodeQuery\": true,                    \"eventSource\": true                },                \"peer0.org2.example.com\": {                    \"endorsingPeer\": true,                    \"chaincodeQuery\": true,                    \"eventSource\": true                },                \"peer1.org2.example.com\": {                    \"endorsingPeer\": true,                    \"chaincodeQuery\": true,                    \"eventSource\": true                }            }        }    },    \"organizations\": {        \"Org1\": {            \"mspid\": \"Org1MSP\",            \"peers\": [                \"peer0.org1.example.com\",                \"peer1.org1.example.com\"            ],            \"certificateAuthorities\": [                \"ca.org1.example.com\"            ]        },        \"Org2\": {            \"mspid\": \"Org2MSP\",            \"peers\": [                \"peer0.org2.example.com\",                \"peer1.org2.example.com\"            ],            \"certificateAuthorities\": [                \"ca.org2.example.com\"            ]        }    },    \"orderers\": {        \"orderer.example.com\": {            \"url\": \"grpcs://localhost:7050\",            \"grpcOptions\": {                \"ssl-target-name-override\": \"orderer.example.com\"            },            \"tlsCACerts\": {                \"pem\": \"INSERT_ORDERER_CA_CERT\"            }        }    },    \"peers\": {        \"peer0.org1.example.com\": {            \"url\": \"grpcs://localhost:7051\",            \"grpcOptions\": {                \"ssl-target-name-override\": \"peer0.org1.example.com\"            },            \"tlsCACerts\": {                \"pem\": \"INSERT_ORG1_CA_CERT\"            }        },        \"peer1.org1.example.com\": {            \"url\": \"grpcs://localhost:8051\",            \"grpcOptions\": {                \"ssl-target-name-override\": \"peer1.org1.example.com\"            },            \"tlsCACerts\": {                \"pem\": \"INSERT_ORG1_CA_CERT\"            }        },        \"peer0.org2.example.com\": {            \"url\": \"grpcs://localhost:9051\",            \"grpcOptions\": {                \"ssl-target-name-override\": \"peer0.org2.example.com\"            },            \"tlsCACerts\": {                \"pem\": \"INSERT_ORG2_CA_CERT\"            }        },        \"peer1.org2.example.com\": {            \"url\": \"grpcs://localhost:10051\",            \"grpcOptions\": {                \"ssl-target-name-override\": \"peer1.org2.example.com\"            },            \"tlsCACerts\": {                \"pem\": \"INSERT_ORG2_CA_CERT\"            }        }    },    \"certificateAuthorities\": {        \"ca.org1.example.com\": {            \"url\": \"https://localhost:7054\",            \"caName\": \"ca-org1\",            \"httpOptions\": {                \"verify\": false            }        },        \"ca.org2.example.com\": {            \"url\": \"https://localhost:8054\",            \"caName\": \"ca-org2\",            \"httpOptions\": {                \"verify\": false            }        }    }}Copy this base file (above) into a new file  byfn-network.json under the new directory /tmp/composer and save it.Open byfn-network.json and replace all instances of the text INSERT_ORG1_CA_CERT with the CA certificate for the peer nodes for Org1: - use the following command to get the certificate from the .pem file so that it can be embedded into the above connection profile.awk 'NF {sub(/\\r/, \"\"); printf \"%s\\\\n\",$0;}' crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt &gt; /tmp/composer/org1/ca-org1.txtCopy the contents of the file /tmp/composer/org1/ca-org1.txt and replace the text INSERT_ORG1_CA_CERT in the .json file. It should now look something like this (must be a single line in the profile file as shown)\"pem\": \"-----BEGIN CERTIFICATE-----\\nMIICNTCCAdygAwIBAgIRAMNvmQpnXi7uM19BLdha3MwwCgYIKoZIzj0EAwIwbDEL\\nMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNhbiBG\\ncmFuY2lzY28xFDASBgNVBAoTC2V4YW1wbGUuY29tMRowGAYDVQQDExF0bHNjYS5l\\neGFtcGxlLmNvbTAeFw0xNzA2MjYxMjQ5MjZaFw0yNzA2MjQxMjQ5MjZaMGwxCzAJ\\nBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1TYW4gRnJh\\nbmNpc2NvMRQwEgYDVQQKEwtleGFtcGxlLmNvbTEaMBgGA1UEAxMRdGxzY2EuZXhh\\nbXBsZS5jb20wWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASJn3QUVcKCp+s6lSPE\\nP5KlWmE9rEG0kpECsAfW28vZQSIg2Ez+Tp1alA9SYN/5BtL1N6lUUoVhG3lz8uvi\\n8zhro18wXTAOBgNVHQ8BAf8EBAMCAaYwDwYDVR0lBAgwBgYEVR0lADAPBgNVHRMB\\nAf8EBTADAQH/MCkGA1UdDgQiBCB7ULYTq3+BQqnzwae1RsnwQgJv/HQ5+je2xcDr\\nka4MHTAKBggqhkjOPQQDAgNHADBEAiB2hLiS8B1g4J5Qbxu15dVWAZTAXX9xPAvm\\n4l25e1oS+gIgBiU/aBwSxY0uambwMB6xtQz0ZE/D4lyTZZcW9SODlOE=\\n-----END CERTIFICATE-----\\n\"In the same .json file - you need to replace all instances of the text INSERT_ORG2_CA_CERT with the CA certificate for the peer nodes for Org2:  - use the following command to convert the .pem file to something that can be embedded into the above connection profile.awk 'NF {sub(/\\r/, \"\"); printf \"%s\\\\n\",$0;}' crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt &gt; /tmp/composer/org2/ca-org2.txtCopy the contents of the file /tmp/composer/org2/ca-org2.txt and replace the text called INSERT_ORG2_CA_CERT. Once again, all on the same line.Replace all instances of the text INSERT_ORDERER_CA_CERT with the CA certificate for the orderer node:  use the following command to convert the .pem file to something that can be embedded into the above connection profile json file.awk 'NF {sub(/\\r/, \"\"); printf \"%s\\\\n\",$0;}' crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tls/ca.crt &gt; /tmp/composer/ca-orderer.txtCopy the contents of the file /tmp/composer/ca-orderer.txt  and replace the text INSERT_ORDERER_CA_CERT. Once again, all on the same line.Once done, save this file as  /tmp/composer/byfn-network.json.This connection profile now describes the fabric network setup, all the peers, orderers and certificate authorities that are part of the network, it defines all the organizations that are participating in the network and also defines the channel&#39;s on this network. Hyperledger Composer can only interact with a single channel so only one channel should be defined.Step Three: Customizing the connection profile for Org1This is just a case of specifying the organization that alice belongs to, in a client section with optional timeouts,  add the following block into the above connection profile /tmp/composer/byfn-network.json, between the version property and just before the channel property - once done, save it as a NEW file called  /tmp/composer/org1/byfn-network-org1.json.    \"client\": {        \"organization\": \"Org1\",        \"connection\": {            \"timeout\": {                \"peer\": {                    \"endorser\": \"300\",                    \"eventHub\": \"300\",                    \"eventReg\": \"300\"                },                \"orderer\": \"300\"            }        }    },So the section of the profile should look like    ...    \"version\": \"1.0.0\",    \"client\": {        \"organization\": \"Org1\",        \"connection\": {            \"timeout\": {                \"peer\": {                    \"endorser\": \"300\",                    \"eventHub\": \"300\",                    \"eventReg\": \"300\"                },                \"orderer\": \"300\"            }        }    },    \"channel\": {    ...Step Four: Building a connection profile for Org2Repeat the same process for bob - but this time specify the organization as Org2 and then save the file as /tmp/composer/byfn-network-org2.json - so the section of the profile should look like:    ...    \"version\": \"1.0.0\",    \"client\": {        \"organization\": \"Org2\",        \"connection\": {            \"timeout\": {                \"peer\": {                    \"endorser\": \"300\",                    \"eventHub\": \"300\",                    \"eventReg\": \"300\"                },                \"orderer\": \"300\"            }        }    },    \"channel\": {    ...Step Five: Locating the certificate and private key for the Hyperledger Fabric administrator for Org1The administrator for our Hyperledger Fabric Org1 network is a user called Admin@org1.example.com. The certificates and private key files for this user are stored in the directory:crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspYou must first locate the certificate file for this user. The certificate is the public part of the identity. The certificate file can be found in the signcerts subdirectory and is named Admin@org1.example.com-cert.pem.Next, you must locate the private key file for this user. The private key is used to sign transactions as this identity. The private key file can be found in the keystore subdirectory. The name of the private key file is a long hexadecimal string, with a suffix of _sk, for example: 78f2139bfcfc0edc7ada0801650ed785a11cfcdef3f9c36f3c8ca2ebfa00a59c_sk. The name will change every time the configuration is generated, hence the wildcard below.Remember the path to both of these files - or copy them into the same directory as the connection profile file /tmp/composer/org1/byfn-network-org1.json that you created in &#39;Step Three&#39;. You will need these files in the next steps.Use the following commands to do this:export ORG1=crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspcp -p $ORG1/signcerts/A*.pem /tmp/composer/org1cp -p $ORG1/keystore/*_sk /tmp/composer/org1Step Six: Locating the certificate and private key for the Hyperledger Fabric administrator for Org2The administrator for our Hyperledger Fabric network is a user called Admin@org2.example.com. The certificates and private key files for this user are stored in the directory:crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspYou must first locate the certificate file for this user. The certificate is the public part of the identity. The certificate file can be found in the signcerts subdirectory and is named Admin@org2.example.com-cert.pem.Next, you must locate the private key file for this user. The private key is used to sign transactions as this identity. The private key file can be found in the keystore subdirectory. The name of the private key file is a long hexadecimal string, with a suffix of _sk, for example d4889cb2a32e167bf7aeced872a214673ee5976b63a94a6a4e61c135ca2f2dbb_sk. The name will change every time the configuration is generated.Remember the path to both of these files, or copy them into the same directory as the connection profile file /tmp/composer/byfn-network-org2.json that you created in step four. You will need these files in the next steps.Use the following commands to do this:export ORG2=crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspcp -p $ORG2/signcerts/A*.pem /tmp/composer/org2cp -p $ORG2/keystore/*_sk /tmp/composer/org2Step Seven: Creating business network cards for the Hyperledger Fabric administrator for Org1In this step you will create business network cards for the administrator to use to deploy the blockchain business network to the Hyperledger Fabric network.Run the composer card create command to create a business network card using the connection profile for Org1. You must specify the path to all three files that you either created or located in the previous steps: (note: the sk file will differ.)composer card create -p /tmp/composer/org1/byfn-network-org1.json -u PeerAdmin -c /tmp/composer/org1/Admin@org1.example.com-cert.pem -k /tmp/composer/org1/*_sk -r PeerAdmin -r ChannelAdmin -f PeerAdmin@byfn-network-org1.cardIf the command works successfully, a business network card file called PeerAdmin@byfn-network-org1.card will have been written to the current directory.Step Eight: Creating business network cards for the Hyperledger Fabric administrator for Org2In this step you will create business network cards for the administrator to use to deploy the blockchain business network to the Hyperledger Fabric network.Run the composer card create command to create a business network card using the connection profile for Org2. You must specify the path to all three files that you either created or located in the previous steps:composer card create -p /tmp/composer/org2/byfn-network-org2.json -u PeerAdmin -c /tmp/composer/org2/Admin@org2.example.com-cert.pem -k /tmp/composer/org2/*_sk -r PeerAdmin -r ChannelAdmin -f PeerAdmin@byfn-network-org2.cardIf the command works successfully, a business network card file called PeerAdmin@byfn-network-org2.card will have been written to the current directory.Step Nine: Importing the business network cards for the Hyperledger Fabric administrator for Org1Run the composer card import command to import the business network card for Org1 into the wallet:composer card import -f PeerAdmin@byfn-network-org1.card --card PeerAdmin@byfn-network-org1If the command works successfully, a business network card called PeerAdmin@byfn-network-org1 will have been imported into the wallet.Step Ten: Importing the business network cards for the Hyperledger Fabric administrator for Org2Run the composer card import command to import the business network card for Org2 into the wallet:composer card import -f PeerAdmin@byfn-network-org2.card --card PeerAdmin@byfn-network-org2If the command works successfully, a business network card called PeerAdmin@byfn-network-org2 will have been imported into the wallet.Step Eleven: Installing the business network onto the Hyperledger Fabric peer nodes for Org1Run the composer network install command to install the business network onto all of the Hyperledger Fabric peer nodes for Org1 that you specified in the connection profile file you created in &#39;Step Three&#39;:composer network install --card PeerAdmin@byfn-network-org1 --archiveFile trade-network.bnaAs you can see from the above, we are using a Hyperledger Composer business network called trade-network to test our multi-org environment. You will need a file trade-network.bna (business network archive, from our sample networks) to do the test. If you don&#39;t have this, just go to https://composer-playground.mybluemix.net/ and deploy the trade-network sample in the online Playground, then &#39;connect&#39; to the business network as &#39;admin&#39;, change the version number to 0.1.14 in the lower left, and export it to the current directory as trade-network.bna. The business network has a version property specified in a package.json file. That version must be specified when the business network is started using the composer start command in Step Seventeen. If you are using the trade-network sample network, the version is 0.1.14. (Note: If you are planning on using a different network, such as the Composer tutorial network tutorial-network as your business network,  you would need to specify that file in the network install command above and thereafter, as the business network archive in this tutorial, as well as the correct version number for this business network).A useful feature of the network install command is that it will output the name of the business network and the version number that has just been installed and you can note these down for use in &#39;Step Seventeen&#39; later.Step Twelve: Installing the business network onto the Hyperledger Fabric peer nodes for Org2Run the composer network install command to install the business network onto all of the Hyperledger Fabric peer nodes for Org2 that you specified in the connection profile file you created in step four:composer network install --card PeerAdmin@byfn-network-org2 --archiveFile trade-network.bnaStep Thirteen: Defining the endorsement policy for the business networkA running business network has an endorsement policy, which defines the rules around which organizations must endorse transactions before they can be committed to the blockchain. By default, a business network is deployed with an endorsement policy that states that only one organization has to endorse a transaction before it can be committed to the blockchain.In real world blockchain business networks, multiple organizations will want to ensure that they endorse transactions before they can be committed to the blockchain, and so the default endorsement policy is not suitable. Instead, you can specify a custom endorsement policy when you start a business network.You can find more information on endorsement policies in the Hyperledger Fabric documentation, in Endorsement policies.Please note that the endorsement policies used for a business network must be in the JSON format used by the Hyperledger Fabric Node.js SDK. This is a different format to the simple endorsement policy format used by the Hyperledger Fabric CLI, which you will see in the Hyperledger Fabric documentation.Create an endorsement policy file called /tmp/composer/endorsement-policy.json with the following contents and save it to disk. You will use this file in later steps, so remember where you place it!{    \"identities\": [        {            \"role\": {                \"name\": \"member\",                \"mspId\": \"Org1MSP\"            }        },        {            \"role\": {                \"name\": \"member\",                \"mspId\": \"Org2MSP\"            }        }    ],    \"policy\": {        \"2-of\": [            {                \"signed-by\": 0            },            {                \"signed-by\": 1            }        ]    }}The endorsement policy you have just created states that both Org1 and Org2 must endorse transactions in the business network before they can be committed to the blockchain. If Org1 or Org2 do not endorse transactions, or disagree on the result of a transaction, then the transaction will be rejected by the business network.Step Fourteen: Understanding and selecting the business network administratorsWhen a business network is started, the business network must be configured with a set of initial participants. These participants will be responsible for bootstrapping the business network and onboarding other participants into the business network. In Hyperledger Composer, we call these initial participants the business network administrators.In our business network, the organizations Org1 and Org2 have equal rights. Each organization will provide a business network administrator for the business network, and those business network administrators will onboard the other participants in their organizations. The business network administrator for Org1 will be Alice, and the business network administrator for Org2 will be Bob.When the business network is started, the certificates (the public part of the identity) for all of the business network administrators must be passed to the organization performing the commands to start the business network. After the business network has been started, all of the business network administrators can use their identities to interact with the business network.You can find more information on business network administrators in Deploying Business Networks.Step Fifteen: Retrieving business network administrator certificates for Org1Run the composer identity request command to retrieve certificates for Alice to use as the business network administrator for Org1:composer identity request -c PeerAdmin@byfn-network-org1 -u admin -s adminpw -d aliceThe -u admin and the -s adminpw options to this command correspond to the default user registered with the Hyperledger Fabric CA (Certificate Authority).The certficates will be placed into a directory called alice in the current working directory. There are three certificate files created, but only two are important. These are admin-pub.pem, the certificate (including the public key), and admin-priv.pem, the private key. Only the admin-pub.pem file is suitable for sharing with other organizations. The admin-priv.pem file must be kept secret as it can be used to sign transactions on behalf of the issuing organization.Step Sixteen: Retrieving business network administrator certificates for Org2Run the composer identity request command to retrieve certificates for Bob to use as the business network administrator for Org2:composer identity request -c PeerAdmin@byfn-network-org2 -u admin -s adminpw -d bobThe -u admin and the -s adminpw options to this command correspond to the default user registered with the Hyperledger Fabric CA (Certificate Authority).The certficates will be placed into a directory called bob in the current working directory. There are three certificate files created, but only two are important. These are admin-pub.pem, the certificate (including the public key), and admin-priv.pem, the private key. Only the admin-pub.pem file is suitable for sharing with other organizations. The admin-priv.pem file must be kept secret as it can be used to sign transactions on behalf of the issuing organization.Step Seventeen: Starting the business networkRun the composer network start command to start the business network. Only Org1 needs to perform this operation. This command uses the /tmp/composer/endorsement-policy.json file created in step thirteen, and the admin-pub.pem files created by both Alice and Bob in step fifteen and step sixteen, so you must ensure that all of these files are accessible to this command:composer network start -c PeerAdmin@byfn-network-org1 -n trade-network -V 0.1.14 -o endorsementPolicyFile=/tmp/composer/endorsement-policy.json -A alice -C alice/admin-pub.pem -A bob -C bob/admin-pub.pemOnce this command completes, the business network will have been started. Both Alice and Bob will be able to access the business network, start to set up the business network, and onboard other participants from their respective organizations. However, both Alice and Bob must create new business network cards with the certificates that they created in the previous steps so that they can access the business network.Step Eighteen: Creating a business network card to access the business network as Org1Run the composer card create command to create a business network card that Alice, the business network administrator for Org1, can use to access the business network:composer card create -p /tmp/composer/org1/byfn-network-org1.json -u alice -n trade-network -c alice/admin-pub.pem -k alice/admin-priv.pemRun the composer card import command to import the business network card that you just created:composer card import -f alice@trade-network.cardRun the composer network ping command to test the connection to the blockchain business network:composer network ping -c alice@trade-networkIf the command completes successfully, then you should see the fully qualified participant identifier org.hyperledger.composer.system.NetworkAdmin#alice in the output from the command. You can now use this business network card to interact with the blockchain business network and onboard other participants in your organization.Lets create a participant, issue an identity (mapped to that participant) and create an asset on the blockchain network as that identity.Run the composer participant add command below, copying it to the command line to execute:composer participant add -c alice@trade-network -d '{\"$class\":\"org.example.trading.Trader\",\"tradeId\":\"trader1-org1\", \"firstName\":\"Jo\",\"lastName\":\"Doe\"}'Next create the identity for trader1-org1 with the composer issue identity command below:composer identity issue -c alice@trade-network -f jo.card -u jdoe -a \"resource:org.example.trading.Trader#trader1-org1\"Import the card and test itcomposer card import -f jo.cardcomposer network ping -c jdoe@trade-networkNext we will create an asset - From the command line, submit a transaction to create a Commodity asset, as participant jdoe (or alternatively, if you already have Composer Playground installed, connect as jdoe@trade-network to trade-network to create the asset &#39;EMA&#39; - the JSON snippet is shown below ).To create the asset using the CLI - copy the transaction submit sequence below - it creates a Commodity asset for you:composer transaction submit --card jdoe@trade-network -d '{\"$class\": \"org.hyperledger.composer.system.AddAsset\", \"targetRegistry\" : \"resource:org.hyperledger.composer.system.AssetRegistry#org.example.trading.Commodity\", \"resources\": [{\"$class\": \"org.example.trading.Commodity\",\"tradingSymbol\":\"EMA\", \"description\":\"Corn commodity\",\"mainExchange\":\"EURONEXT\", \"quantity\":\"10\",\"owner\":\"resource:org.example.trading.Trader#trader1-org1\"}]}'Or alternatively, to create in Playground - copy the following:{  \"$class\": \"org.example.trading.Commodity\",  \"tradingSymbol\": \"EMA\",  \"description\": \"Corn commodity\",  \"mainExchange\": \"EURONEXT\",  \"quantity\": 10,  \"owner\": \"resource:org.example.trading.Trader#trader1-org1\"}Finally, do a composer network list to confirm the generated artifacts in the business network:composer network list -c jdoe@trade-networkStep Nineteen: Creating a business network card to access the business network as Org2Run the composer card create command to create a business network card that Bob, the business network administrator for Org2, can use to access the business network:composer card create -p /tmp/composer/org2/byfn-network-org2.json -u bob -n trade-network -c bob/admin-pub.pem -k bob/admin-priv.pemRun the composer card import command to import the business network card that you just created:composer card import -f bob@trade-network.cardRun the composer network ping command to test the connection to the blockchain business network:composer network ping -c bob@trade-networkIf the command completes successfully, then you should see the fully qualified participant identifier org.hyperledger.composer.system.NetworkAdmin#bob in the output from the command. Let&#39;s onboard another Trader, this time for Org 2:Once again, create a participant, issue an identity (mapped to that participant) - as we already have an asset on the blockchain network, we will use a transaction to change the ownership (from Org1 trader to an Org2 trader):Run the composer participant add command below, copying it to the command line to execute:composer participant add -c bob@trade-network -d '{\"$class\":\"org.example.trading.Trader\",\"tradeId\":\"trader2-org2\", \"firstName\":\"Dave\",\"lastName\":\"Lowe\"}'Next create the identity for trader2-org2 with the composer issue identity command below:composer identity issue -c bob@trade-network -f dave.card -u dlowe -a \"resource:org.example.trading.Trader#trader2-org2\"Import the card and test itcomposer card import -f dave.cardcomposer network ping -c dlowe@trade-networkLastly, submit a transaction to change ownership of the Commodity asset created earlier. We will submit the transaction as the asset owner Jon Doe and transfer it to trader &#39;Dave Lowe&#39;. We will then verify the ownership change has occurred as the Org 2 trader participant mapped to the dlowe identity: Perform the step below.composer transaction submit --card jdoe@trade-network -d '{\"$class\":\"org.example.trading.Trade\",\"commodity\":\"resource:org.example.trading.Commodity#EMA\",\"newOwner\":\"resource:org.example.trading.Trader#trader2-org2\"}'Finally, do a composer network list as the Org 2 trader participant to confirm the change of ownership on the asset:composer network list -c dlowe@trade-networkConclusionIn this tutorial you have seen how to configure a blockchain network based on Hyperledger Composer in a multi-organizational setup.  You&#39;ve also learned how to deploy a business network (such as our Commodities trading network) to that blockchain network and perform some simple transactions as participants in each organization, using identities that were issued by the Certificate of Authorities in either organization.",
        "url": "/composer/latest/tutorials/deploy-to-fabric-multi-org"
      }
      ,
    
      "tutorials-deploy-to-fabric-single-org": {
        "title": "Deploying to a single organization Hyperledger Fabric",
        "author": "",
        "category": "tutorials",
        "content": "Deploying a Hyperledger Composer blockchain business network to Hyperledger Fabric for a single organizationIn the development environment, a simple development only Hyperledger Fabric single organization, single peer network is created for you (fabric-dev-servers), along with all of the Hyperledger Composer configuration that you need in order to deploy a blockchain business network.This tutorial will demonstrate the steps that an administrator needs to take in order to deploy a blockchain business network to an instance of Hyperledger Fabric for a single organization, including how to generate the necessary Hyperledger Composer configuration. A subsequent tutorial will demonstrate how to deploy a blockchain business network to an instance of Hyperledger Fabric for multiple organizations.During this tutorial, you may wish to refer to the Hyperledger Fabric documentation.PrerequisitesBefore you continue, ensure that you have followed the steps in installing a development environment.Step One: Starting a Hyperledger Fabric networkIn order to follow this tutorial, you must start a Hyperledger Fabric network. You can use the simple Hyperledger Fabric network provided in the development environment, or you can use your own Hyperledger Fabric network that you have built by following the Hyperledger Fabric documentation.The tutorial will assume that you use the simple Hyperledger Fabric network provided in the development environment. If you use your own Hyperledger Fabric network, then you must map between the configuration detailed below and your own configuration and it should be a single organization network.Start a clean Hyperledger Fabric by running the following commands:cd ~/fabric-dev-serversexport FABRIC_VERSION=hlfv12./stopFabric.sh./teardownFabric.sh./downloadFabric.sh./startFabric.shDelete any business network cards that may exist in your wallet. It is safe to ignore any errors that state that the business network cards cannot be found:composer card delete -c PeerAdmin@fabric-networkcomposer card delete -c admin@tutorial-networkIf these commands fail, then you have network cards from a previous version and you will have to delete the file system card store.    rm -fr ~/.composerStep Two: Exploring the Hyperledger Fabric networkThis step will explore the Hyperledger Fabric network that you have just started, so that you can understand how it has been configured, and what components it consists of. You will use all of the information in this section to configure Hyperledger Composer in subsequent steps.Configuration filesThe simple Hyperledger Fabric network provided in the development environment has been configured using the Hyperledger Fabric configuration tools cryptogen and configtxgen.The configuration for cryptogen is stored in the file:~/fabric-dev-servers/fabric-scripts/hlfv11/composer/crypto-config.yamlThe configuration for configtxgen is stored in the file:~/fabric-dev-servers/fabric-scripts/hlfv11/composer/configtx.yamlYou can find more information about these configuration tools, what they do, and how to use them by reading the Hyperledger Fabric documentation.OrganizationsThe simple Hyperledger Fabric network is made up of a single organization called Org1. The organization uses the domain name org1.example.com. Additionally, the Membership Services Provider (MSP) for this organization is called Org1MSP. In this tutorial, you will deploy a blockchain business network that only the organization Org1 can interact with.Network componentsThe Hyperledger Fabric network is made up of several components:A single peer node for Org1, named peer0.org1.example.com.The request port is 7051.The event hub port is 7053.A single Certificate Authority (CA) for Org1, named ca.org1.example.com.The CA port is 7054.A single orderer node, named orderer.example.com.The orderer port is 7050.The Hyperledger Fabric network components are running inside Docker containers. When running Hyperledger Composer within a Docker container, the names above (for example, peer0.org1.example.com) can be used to interact with the Hyperledger Fabric network.This tutorial will run Hyperledger Composer commands on the Docker host machine, rather than from inside the Docker network. This means that the Hyperledger Composer commands must interact with the Hyperledger Fabric network using localhost as the host name and the exposed container ports.UsersThe organization Org1 is configured with a user named Admin@org1.example.com. This user is an administrator. Administrators for an organization have the permission to install the code for a blockchain business network onto their organization&#39;s peers, and can also have the permission to start the blockchain business network, depending on configuration. In this tutorial, you will deploy a blockchain business network by acting as the user Admin@org1.example.com.The user Admin@org1.example.com has a set of certificates and private key files stored in the directory:~/fabric-dev-servers/fabric-scripts/hlfv11/composer/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspYou will use some of these files later on to interact with the Hyperledger Fabric network.In addition to the administrator, the CA (Certificate Authority) for Org1 has been configured with a default user. This default user has an enrollment ID of admin and an enrollment secret of adminpw. However, this user does not have permission to deploy a blockchain business network.ChannelFinally, a channel named composerchannel has been created. The peer node peer0.org1.example.com has been joined to this channel. You can only deploy Hyperledger Composer blockchain business networks into existing channels, but you can create additional channels by following the Hyperledger Fabric documentation.Step Three: Building a connection profileA connection profile specifies all of the information required to locate and connect to the Hyperledger Fabric network, for example the host names and ports of all of the Hyperledger Fabric network components. In this step, you will create a connection profile for Hyperledger Composer to use to connect to the Hyperledger Fabric network.Create a connection profile file called connection.json.Give the connection profile name, version and x-type properties by adding the following three lines to the top of connection.json:{    \"name\": \"fabric-network\",    \"x-type\": \"hlfv1\",    \"version\": \"1.0.0\",The name property in a connection profile gives a name to the Hyperledger Fabric network, so we can reference it later on. In the connection profile you have just created, the name is fabric-network. You can use any name you like for the Hyperledger Fabric network.Hyperledger Composer is designed to be compatible with different types blockchain networks. Currently, only Hyperledger Fabric v1.x is supported, but you must specify the type of blockchain network to use. The x-type for Hyperledger Fabric v1.2 is hlfv1.The version number is the version of this connection profile format. Currently there is only 1 version of 1.0.0.There is also an optional property x-commitTimeout which can also be specified with defines how long Hyperledger Composer should wait for a submitted transaction to be committed to your organization&#39;s peer before  giving up waiting. The default if not specified is 300 seconds.We must specify the host names and ports of all of the peer nodes in the Hyperledger Fabric network. There is only 1 peer and we give it a label of peer0.org1.example.com.    \"peers\": {        \"peer0.org1.example.com\": {            \"url\": \"grpc://localhost:7051\"        }    },Here, we have specified our single peer node peer0.org1.example.com (using the host name localhost), the request port 7051, and the event hub port 7053.The peers array can contain multiple peer nodes. If you have multiple peer nodes, you should add them all to the peers object.We must specify the host name and port of the certificate authority (CA) in the Hyperledger Fabric network that we want to use for enrolling existing users and registering new users.    \"certificateAuthorities\": {        \"ca.org1.example.com\": {            \"url\": \"http://localhost:7054\",            \"caName\": \"ca.org1.example.com\"        }    },Here we have specified our single CA ca.org1.example.com (using the hostname localhost) and the CA port 7054, and we also label this entry as ca-org1.example.comWe must specify the host names and ports of all of the ordering nodes in the Hyperledger Fabric that we want to connect to.    \"orderers\": {        \"orderer.example.com\": {            \"url\": \"grpc://localhost:7050\"        }    },Here, we have specified our single orderer node orderer.example.com (using the hostname localhost) and the orderer port 7050 and we also label this as orderer.example.com.The orderers object can contain multiple orderer nodes. If you have multiple orderer nodes, you should add them all to the orderers object.We now must specify all the organizations in the network. In this tutorial there is only 1 organization, Org1.    \"organizations\": {        \"Org1\": {            \"mspid\": \"Org1MSP\",            \"peers\": [                \"peer0.org1.example.com\"            ],            \"certificateAuthorities\": [                \"ca.org1.example.com\"            ]        }    },Here we are describing the owners of the peers and who their certificate authority is plus we also declare the MSP id that has been defined for this organisation. In this tutorial it has been defined as Org1MSP.We must specify the name of an existing channel. We will deploy our blockchain business network into the channel composerchannel. This is defined in the channels object.    \"channels\": {        \"composerchannel\": {            \"orderers\": [                \"orderer.example.com\"            ],            \"peers\": {                \"peer0.org1.example.com\": {                    \"endorsingPeer\": true,                    \"chaincodeQuery\": true,                    \"eventSource\": true                }            }        }    },Here we are defined the channel composerchannel and also the orderers and peers that are part of that channel. We also specify the roles the peer will perform in this channel. In this tutorial we have added the single orderer and single peer defined earlier referenced using their labels. The peer will have the business network installed so will be a transaction endorser, able to handle chaincode queries and also generate events.The blockchain business network will be deployed to all of the specified peer nodes. Once the blockchain business network has been deployed, the specified peer nodes will be used for querying the blockchain business network, endorsing transactions, and subscribing to events.The final section this is required is the client section. This is used by client applications (such as Hyperledger Composer) to know what organization it is representing when interacting and also some extra optional timeouts.    \"client\": {        \"organization\": \"Org1\",        \"connection\": {            \"timeout\": {                \"peer\": {                    \"endorser\": \"300\",                    \"eventHub\": \"300\",                    \"eventReg\": \"300\"                },                \"orderer\": \"300\"            }        }    }}Here we are specifying that we are in Org1. The timeouts are used to determine how long to wait for a response when interacting with a peer or orderer and the values are specified in seconds. If you don&#39;t specify anything then the default is 45 seconds.Save your changes to connection.json. The completed connection profile should look like the following:{    \"name\": \"fabric-network\",    \"x-type\": \"hlfv1\",    \"version\": \"1.0.0\",    \"peers\": {        \"peer0.org1.example.com\": {            \"url\": \"grpc://localhost:7051\"        }    },    \"certificateAuthorities\": {        \"ca.org1.example.com\": {            \"url\": \"http://localhost:7054\",            \"caName\": \"ca.org1.example.com\"        }    },    \"orderers\": {        \"orderer.example.com\": {            \"url\": \"grpc://localhost:7050\"        }    },    \"organizations\": {        \"Org1\": {            \"mspid\": \"Org1MSP\",            \"peers\": [                \"peer0.org1.example.com\"            ],            \"certificateAuthorities\": [                \"ca.org1.example.com\"            ]        }    },    \"channels\": {        \"composerchannel\": {            \"orderers\": [                \"orderer.example.com\"            ],            \"peers\": {                \"peer0.org1.example.com\": {                    \"endorsingPeer\": true,                    \"chaincodeQuery\": true,                    \"eventSource\": true                }            }        }    },    \"client\": {        \"organization\": \"Org1\",        \"connection\": {            \"timeout\": {                \"peer\": {                    \"endorser\": \"300\",                    \"eventHub\": \"300\",                    \"eventReg\": \"300\"                },                \"orderer\": \"300\"            }        }    }}Step Four: Locating the certificate and private key for the Hyperledger Fabric administratorIn order to deploy a blockchain business network to this Hyperledger Fabric network, we must identify ourselves as an administrator with the permissions to perform this operation. In this step, you locate the files required to identify yourself as an administrator.The administrator for our Hyperledger Fabric network is a user called Admin@org1.example.com. The certificates and private key files for this user are stored in the directory:~/fabric-dev-servers/fabric-scripts/hlfv11/composer/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspYou must first locate the certificate file for this user. The certificate is the public part of the identity. The certificate file can be found in the signcerts subdirectory and is named Admin@org1.example.com-cert.pem. If you look at the contents of this file, then you will find a PEM encoded certificate similar to the following:-----BEGIN CERTIFICATE-----MIICGjCCAcCgAwIBAgIRANuOnVN+yd/BGyoX7ioEklQwCgYIKoZIzj0EAwIwczELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNhbiBGcmFuY2lzY28xGTAXBgNVBAoTEG9yZzEuZXhhbXBsZS5jb20xHDAaBgNVBAMTE2NhLm9yZzEuZXhhbXBsZS5jb20wHhcNMTcwNjI2MTI0OTI2WhcNMjcwNjI0MTI0OTI2WjBbMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNU2FuIEZyYW5jaXNjbzEfMB0GA1UEAwwWQWRtaW5Ab3JnMS5leGFtcGxlLmNvbTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABGu8KxBQ1GkxSTMVoLv7NXiYKWj5t6DhWRTJBHnLkWV7lRUfYaKAKFadSii5M7Z7ZpwD8NS7IsMdPR6Z4EyGgwKjTTBLMA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAAMCsGA1UdIwQkMCKAIBmrZau7BIB9rRLkwKmqpmSecIaOOr0CF6Mi2J5H4aauMAoGCCqGSM49BAMCA0gAMEUCIQC4sKQ6CEgqbTYe48az95W9/hnZ+7DI5eSnWUwV9vCd/gIgS5K6omNJydoFoEpaEIwM97uSXVMHPa0iyC497vdNURA=-----END CERTIFICATE-----Next, you must locate the private key file for this user. The private key is used to sign transactions as this identity. The private key file can be found in the keystore subdirectory. The name of the private key file is a long hexadecimal string, with a suffix of _sk, for example 114aab0e76bf0c78308f89efc4b8c9423e31568da0c340ca187a9b17aa9a4457_sk. The name will change every time the configuration is generated. If you look at the contents of this file, then you will find a PEM encoded private key similar to the following:-----BEGIN PRIVATE KEY-----MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQg00IwLLBKoi/9ikb6ZOAV0S1XeNGWllvlFDeczRKQn2uhRANCAARrvCsQUNRpMUkzFaC7+zV4mClo+beg4VkUyQR5y5Fle5UVH2GigChWnUoouTO2e2acA/DUuyLDHT0emeBMhoMC-----END PRIVATE KEY-----Remember the path to both of these files, or copy them into the same directory as the connection profile file connection.json that you created in the previous step. You will need these files in the next step.Step Five: Creating a business network card for the Hyperledger Fabric administratorA business network card contains all of the information required to connect to a blockchain business network and the underlying Hyperledger Fabric network. This information includes the connection profile created in step three, and the certificate and private key for the administrator located in step four.In this step you will create a business network card for the administrator to use to deploy the blockchain business network to the Hyperledger Fabric network.Run the composer card create command to create a business network card. You must specify the path to all three files that you either created or located in the previous steps:composer card create -p connection.json -u PeerAdmin -c Admin@org1.example.com-cert.pem -k 114aab0e76bf0c78308f89efc4b8c9423e31568da0c340ca187a9b17aa9a4457_sk -r PeerAdmin -r ChannelAdminA business network card file called PeerAdmin@fabric-network.card will have been written to the current directory. Let&#39;s explore the options that we passed to the composer card create command.-p connection.jsonThis is the path to the connection profile file that we created in step three.-u PeerAdminThis is a name that we use to refer to the administrator user. Instead of using Admin@org1.example.com everywhere, which is quite lengthy to type, we have given a name of PeerAdmin so we can easily refer to this user.-c Admin@org1.example.com-cert.pemThis is the path to the certificate file for the user Admin@org1.example.com that we located in step four.-k 114aab0e76bf0c78308f89efc4b8c9423e31568da0c340ca187a9b17aa9a4457_skThis is the path to the private key file for the user Admin@org1.example.com that we located in step four.-r PeerAdmin -r ChannelAdminHere, we specify which roles the user has. This information is required so that Hyperledger Composer playground knows which users are able to perform which operations. The user Admin@org1.example.com is an administrator for the Hyperledger Fabric network, and has the roles PeerAdmin (ability to install chaincode) and ChannelAdmin (ability to instantiate chaincode).Step Six: Importing the business network card for the Hyperledger Fabric administratorHyperledger Composer can only use business network cards that are placed into a wallet. The wallet is a directory on the file system that contains business network cards. In this step, you will import the business network card created in step five into the wallet so that you can use the business network card in subsequent steps.Run the composer card import command to import the business network card into the wallet:composer card import -f PeerAdmin@fabric-network.cardLet&#39;s explore the options that we passed to the composer card import command.-f PeerAdmin@fabric-network.cardThis is the path to the business network card file that we created in step five.You can now use this business network card by specifying the name PeerAdmin@fabric-network. You are now all set to deploy the blockchain business network to the Hyperledger Fabric network.We are going to deploy the blockchain business network tutorial-network that is created by following the Developer Tutorial. If you haven&#39;t created a business network archive (.bna) file by following the developer tutorial, follow steps 1, 2, and 3 of the developer tutorial.Step Seven: Installing the Hyperledger Composer business network onto the Hyperledger Fabric peer nodesIn this step, you will install your blockchain business network onto all of your organizations Hyperledger Fabric peer nodes. In Hyperledger Fabric terms, this is a chaincode install operation.Run the composer network install command to install the Hyperledger Composer runtime onto the Hyperledger Fabric peer nodes that you specified in the connection profile file you created in step three:composer network install -c PeerAdmin@fabric-network -a tutorial-network@0.0.1.bnaLet&#39;s explore the options that we passed to the composer network install command.-c PeerAdmin@fabric-networkThis is the name of the business network card that we imported into the wallet in step six.-a tutorial-network@0.0.1.bnaYou must install a copy of the business network. Here we specify the file name of the blockchain business network that we are deploying, tutorial-network@0.0.1.bna.Step Eight: Starting the blockchain business networkIn this step, you will start the blockchain business network. In Hyperledger Fabric terms, this is a chaincode instantiate operation.Run the composer network start command to start the blockchain business network:composer network start --networkName tutorial-network --networkVersion 0.0.1 -A admin -S adminpw -c PeerAdmin@fabric-networkLet&#39;s explore the options that we passed to the composer network start command.-c PeerAdmin@fabric-networkThis is the name of the business network card that we imported into the wallet in step six.--networkName tutorial-networkThis is the name of blockchain business network called tutorial-network.--networkVersion 0.0.1This is the version of blockchain business network called tutorial-network, defined in the version property of the package.json for the business network-A adminWhen a blockchain business network is deployed, you must create at least one participant who will be a blockchain business network administrator. This participant is responsible for onboarding other participants into the blockchain business network. Here, we are specifying that we want to create a single blockchain business network administrator called admin.-S adminpwThis specifies that our blockchain business network administrator admin will use an enrollment secret of adminpw to request a certificate and private key from the CA (Certificate Authority). When you specify this option, the name specified for the business network administrator must be an existing enrollment ID for a user that is already registered with the CA.Now that our blockchain business network has been started, we can interact with it using the business network card file admin@tutorial-network.card that was created.Step Nine: Importing the business network card for the business network administratorRun the composer card import command to import the business network card into the wallet:composer card import -f admin@tutorial-network.cardYou can now use this business network card by specifying the name admin@tutorial-network. You are now all set to interact with the running blockchain business network!Step Ten: Testing the connection to the blockchain business networkRun the composer network ping command to test the connection to the blockchain business network:composer network ping -c admin@tutorial-networkCheck that the test result was successful, and there is a single participant listed for the business network with the name NetworkAdmin.ConclusionIn this tutorial you have seen how to configure Hyperledger Composer with all of the information required to connect to a Hyperledger Fabric network, and how to deploy a blockchain business network to that Hyperledger Fabric network.If you used the simple Hyperledger Fabric network provided in the development environment, why not try building your own Hyperledger Fabric network by following the Hyperledger Fabric documentation and see if you can successfully deploy a blockchain business network to it?",
        "url": "/composer/latest/tutorials/deploy-to-fabric-single-org"
      }
      ,
    
      "integrating-deploying-the-rest-server": {
        "title": "Deploying the REST server for a business network",
        "author": "",
        "category": "start",
        "content": "Deploying the REST server for a business networkWhen deploying the Hyperledger Composer REST server in a production environment, for example using Docker Swarm or Kubernetes, the REST server should be configured to be highly available. This means that you must deploy multiple instances of the REST server, and those instances should be configured to share data. For example, data such as business network cards, Blockchain identities, and REST API authentication settings should be shared so that a REST API client can make a request to any of the instances without having to reauthenticate.Business network cards and the business network card storeThe REST server uses a business network card specified during startup to connect to and discover the assets, participants, and transactions within a deployed business network. This information is required in order to generate the REST API. This business network card is known as the discovery business network card. By default, the discovery business network card is also used to handle all requests to the REST API. However the REST server can also be configured to multiple user mode, which allows authenticated users to supply their own business network cards for handling requests to the REST API.In order to use a discovery business network card, that business network card must first be imported into a business network card store available to the REST server. The default business network card store is a local file system directory with the path ~/.composer (where ~ is the current users home directory). When using the Docker image for the REST server, you must mount a volume into place of the default business network card store that contains an imported discovery business network card. In the Docker image for the REST server, the business network card store used by the REST server is in the directory /home/composer/.composer (because the REST server in the Docker image always runs under the composer user).A business network card contains a connection profile that describes how to connect to the Hyperledger Fabric network where the deployed business network is running. Note that the connection profile must be valid for use within the Docker image for the REST server, and the hostnames must be correct and accessible by this Docker image.Configuring the REST server with a persistent data storeAll information regarding authenticated users and their wallets (containing that users business network cards when multiple user mode is enabled) is persisted in a LoopBack data source by using a LoopBack connector. By default, the REST server uses the LoopBack &quot;memory&quot; connector to persist user information, which is lost when the REST server is terminated. The REST server should be configured with a LoopBack connector that stores data in a highly available data source, for example a database.You should be able to use any LoopBack connector, but we recommend that you use a LoopBack connector for a NoSQL database. For example, MongoDB or Apache CouchDB.The LoopBack connector needs to be installed in order for the REST server to locate and use it. You can install additional LoopBack connectors by using npm, for example:npm install -g loopback-connector-mongodbFinally, you need to supply the REST server with the connection information required by the LoopBack connector. This connection information should be supplied by using the COMPOSER_DATASOURCES environment variable. For more information on the environment variables that can be used to configure the REST server, see the reference documentation: Hyperledger Composer REST ServerExtending the Docker image for the REST server with additional Node.js modulesIn order to deploy the REST server as a Docker container with additional LoopBack connectors and Passport strategies, you must extend the hyperledger/composer-rest-server Docker image.Here is an example Dockerfile that adds the LoopBack connector for MongoDB and the Passport strategy for GitHub to the Docker image:FROM hyperledger/composer-rest-serverRUN npm install --production loopback-connector-mongodb passport-github &amp;&amp; \\    npm cache clean --force &amp;&amp; \\    ln -s node_modules .node_modulesYou can build this Docker image by placing the Dockerfile above into a directory and using the docker build command, for example:docker build -t myorg/my-composer-rest-server .You may need to publish this Docker image to a Docker image repository, for example Docker Hub, in order to use it with cloud based Docker deployment services.Deploying a persistent and secured REST server using DockerThe following example will demonstrate how to deploy the REST server using Docker. The deployed REST server will persist data using MongoDB, and will be secured using GitHub authentication.The examples are based on the business network that is deployed to Hyperledger Fabric v1.2 as part of the Developer Tutorial, and may need adjusting for your configuration, for example if the Docker network name does not match.Ensure that a valid business network card for your business network is in your local business network card store by running the following composer network ping command. This example uses a business network card for the admin user on the my-network business network:composer network ping -c admin@my-networkNote that you must use the composer network ping command to test the connection to the business network before proceeding. If the business network card only contains a user ID and enrollment secret, then the composer network ping command will trigger the enrollment process to occur and certificates to be stored in the business network card. It is not advisable to use a business network card with only a user ID and enrollment secret when using the Docker image for the REST server.Start an instance of the Docker image for MongoDB named mongo. This MongoDB instance will be used to persist all information regarding authenticated users and their wallets (containing that users business network cards when multiple user mode is enabled) for the REST server.docker run -d --name mongo --network composer_default -p 27017:27017 mongoNote that the MongoDB instance is attached to the Docker network named composer_default. This means that the MongoDB instance will be available on the Docker network named composer_default using the hostname mongo. We will use the hostname mongo to configure the REST server in a subsequent step. Depending on your Docker networking configuration, you may need to specify a different Docker network name. The MongoDB port 27017 is also exposed on the host network using port 27017, so you can use other MongoDB client applications to interact with this MongoDB instance if desired.Extend the Docker image for the REST server by adding the LoopBack connector for MongoDB and the Passport strategy for GitHub authentication. Create a new, empty directory on your local file system, and create a new file named Dockerfile in the new directory, with the following contents:FROM hyperledger/composer-rest-serverRUN npm install --production loopback-connector-mongodb passport-github &amp;&amp; \\    npm cache clean --force &amp;&amp; \\    ln -s node_modules .node_modulesBuild the extended Docker image by running the following docker build command in the directory containing the file named Dockerfile that you just created:docker build -t myorg/my-composer-rest-server .If this command completes successfully, a new Docker image called myorg/my-composer-rest-server has been built and stored in the local Docker registry on your system. If you wish to use this Docker image on other systems, you may need to push the Docker image into a Docker registry, such as Docker Hub.The Docker image for the REST server is configured using environment variables rather than command line options. Create a new file named envvars.txt to store the environment variables for our REST server, with the following contents:COMPOSER_CARD=admin@my-networkCOMPOSER_NAMESPACES=neverCOMPOSER_AUTHENTICATION=trueCOMPOSER_MULTIUSER=trueCOMPOSER_PROVIDERS='{    \"github\": {        \"provider\": \"github\",        \"module\": \"passport-github\",        \"clientID\": \"REPLACE_WITH_CLIENT_ID\",        \"clientSecret\": \"REPLACE_WITH_CLIENT_SECRET\",        \"authPath\": \"/auth/github\",        \"callbackURL\": \"/auth/github/callback\",        \"successRedirect\": \"/\",        \"failureRedirect\": \"/\"    }}'COMPOSER_DATASOURCES='{    \"db\": {        \"name\": \"db\",        \"connector\": \"mongodb\",        \"host\": \"mongo\"    }}'Note that the name of the discovery business network card admin@my-network has been set as the value of the COMPOSER_CARD environment variable. We have disabled namespaces in the generated REST API by specifying never as the value of the COMPOSER_NAMESPACES environment variable. We have enabled authentication of REST API clients by setting the COMPOSER_AUTHENTICATION environment variable to true, and also enabled multi-user mode by setting the COMPOSER_MULTIUSER environment variable to true.We have configured our REST server to use GitHub authentication by configuring the Passport strategy for GitHub in the COMPOSER_PROVIDERS environment variable. Note that you must replace both REPLACE_WITH_CLIENT_ID and REPLACE_WITH_CLIENT_SECRET with the appropriate configuration from GitHub in order for this configuration to work successfully.We have configured our REST server to use our MongoDB instance by configuring the LoopBack connector for MongoDB in the COMPOSER_DATASOURCES environment variable. Note that the host name of the MongoDB instance, mongo, has been specified in the host property of the LoopBack data source named db.Load the environment variables into your current shell by running the following command:source envvars.txtIf you open a new shell, for example a new terminal window or tab, then you must run the same source command again to load the environment variables into the new shell.For more information on the environment variables that can be used to configure the REST server, see the reference documentation: Hyperledger Composer REST ServerStart a new instance of the extended Docker image for the REST server that you created in step 3 by running the following docker run command:docker run \\    -d \\    -e COMPOSER_CARD=${COMPOSER_CARD} \\    -e COMPOSER_NAMESPACES=${COMPOSER_NAMESPACES} \\    -e COMPOSER_AUTHENTICATION=${COMPOSER_AUTHENTICATION} \\    -e COMPOSER_MULTIUSER=${COMPOSER_MULTIUSER} \\    -e COMPOSER_PROVIDERS=\"${COMPOSER_PROVIDERS}\" \\    -e COMPOSER_DATASOURCES=\"${COMPOSER_DATASOURCES}\" \\    -v ~/.composer:/home/composer/.composer \\    --name rest \\    --network composer_default \\    -p 3000:3000 \\    myorg/my-composer-rest-serverNote that we have passed through all of the environment variables that we set in previous steps by using multiple -e options. If you need to add or remove any additional environment variables to configure the REST server, then you must add or remove the appropriate -e options as well.We have mounted our local business network card store into the REST server Docker container by specifying -v ~/.composer:/home/composer/.composer. This permits the REST server to access and use our local business network card store when trying to load the discovery business network card specified using the COMPOSER_CARD environment variable.We have also specified the Docker network name composer_default, and name of the Docker container as rest. This means that the REST server instance will be available on the Docker network named composer_default using the hostname rest. The REST server port 3000 is also exposed on the host network using port 3000.You can check that the REST server has started successfully by using the docker logs command, for example:docker logs -f restIf the REST server has started successfully, then you will see it output a log message similar to Browse your REST API at http://localhost:3000/explorer.Now that the REST server has started successfully, you can access the REST server running inside the Docker container by using the following URL: http://localhost:3000/explorer/.Final notesIn this guide, you have seen how to start a single instance of the REST server using Docker, where that single instance is configured to use MongoDB as a persistent data store. For a true highly available, production deployment of the REST server, you will need to:Configure a highly available instance of the persistent data store, for example a MongoDB replica set.Run multiple instances of the REST server Docker image. This is easy to do by changing the name of the Docker container using the --name argument, and updating or removing the host port mapping for subsequent REST server instances using the -p 3000:3000 argument.Deploy a load balancer, for example Nginx, to distribute REST requests from clients across all of the instances of the REST server.Once you have performed these three tasks, you should be able to stop, restart, or remove any of the REST server instances (but not all!) without losing access to the deployed business network over REST.",
        "url": "/composer/latest/integrating/deploying-the-rest-server"
      }
      ,
    
      "problems-deployment-local-playground": {
        "title": "Error using the local Playground",
        "author": "",
        "category": "tasks",
        "content": "Errors deploying a business network to a local fabric using the Hyperledger Composer PlaygroundWhen deploying a business network to an instance of Hyperledger Fabric by using a locally installed Hyperledger Composer Playground, you may encounter the following error:Error: error trying to list instantiated chaincodes. Error: chaincode error (status 500, message: Authorization for GETCHAINCODES on channel getchaincodes has been denied with error Failed verifying that proposal's creator satisfies local MSP principal during channelless check policy with policy [Admins]:[This identity is not an admin])Once this error has occurred, you must delete your local browser storage to restore normal function. Please note: Deleting local browser storage will delete your connection profile and identities in your wallet.What causes the errorThe error occurs if both the identity you are using to deploy the business network does not have network-level access control, and the instance of Hyperledger Fabric does not have a deployed business network with the name org-acme-biznet.Fixes for the errorIf you attempt to deploy a network using an identity which does not have network-level access control, and the instance of Hyperledger Fabric does not have a business network called org-acme-biznet deployed, you must delete your local browser storage. This will delete the connection profile and the identities.How to avoid the errorWhen using the a local instance of the Hyperledger Composer Playground to deploy a business network to a local Hyperledger Fabric instance, you must use an identity which has network-level access control. If an identity without network-level access control is used, there must be a business network with the name org-acme-biznet deployed to the instance of Hyperledger Fabric being used.",
        "url": "/composer/latest/problems/deployment-local-playground"
      }
      ,
    
      "tutorials-developer-tutorial": {
        "title": "Developer Tutorial",
        "author": "",
        "category": "tutorials",
        "content": "Developer tutorial for creating a Hyperledger Composer solutionThis tutorial will walk you through building a Hyperledger Composer blockchain solution from scratch. In the space of a few hours you will be able to go from an idea for a disruptive blockchain innovation, to executing transactions against a real Hyperledger Fabric blockchain network and generating/running a sample Angular 2 application that interacts with a blockchain network.This tutorial gives an overview of the techniques and resources available to apply to your own use case.Note: This tutorial was written against the latest Hyperledger Composer build on Ubuntu Linux running with Hyperledger Fabric v1.2 where referenced below and also tested for a Mac environment.PrerequisitesBefore beginning this tutorial:Set up your development environmentInstall an editor e.g. VSCode or AtomStep One: Creating a business network structureThe key concept for Hyperledger Composer is the business network definition (BND). It defines the data model, transaction logic and access control rules for your blockchain solution. To create a BND,  we need to create a suitable project structure on disk.The easiest way to get started is to use the Yeoman generator to create a skeleton business network. This will create a directory containing all of the components of a business network.Create a skeleton business network using Yeoman. This command will require a business network name, description, author name, author email address, license selection and namespace.yo hyperledger-composer:businessnetworkEnter  tutorial-network  for the network name, and desired information for description, author name, and author email.Select  Apache-2.0  as the license.Select  org.example.mynetwork  as the namespace.Select  No  when asked whether to generate an empty network or not.Step Two: Defining a business networkA business network is made up of assets, participants, transactions, access control rules, and optionally events and queries. In the skeleton business network created in the previous steps, there is a model (.cto) file which will contain the class definitions for all assets, participants, and transactions in the business network. The skeleton business network also contains an access control (permissions.acl) document with basic access control rules, a script (logic.js) file containing transaction processor functions, and a package.json file containing business network metadata.Modelling assets, participants, and transactionsThe first document to update is the model (.cto) file. This file is written using the Hyperledger Composer Modelling Language. The model file contains the definitions of each class of asset, transaction, participant, and event. It implicitly extends the Hyperledger Composer System Model described in the modelling language documentation.Open the  org.example.mynetwork.cto  model file.Replace the contents with the following:/** * My commodity trading network */namespace org.example.mynetworkasset Commodity identified by tradingSymbol {    o String tradingSymbol    o String description    o String mainExchange    o Double quantity    --&gt; Trader owner}participant Trader identified by tradeId {    o String tradeId    o String firstName    o String lastName}transaction Trade {    --&gt; Commodity commodity    --&gt; Trader newOwner}Save your changes to org.example.mynetwork.cto.Adding JavaScript transaction logicIn the model file, a Trade transaction was defined, specifying a relationship to an  asset, and a participant. The transaction processor function file contains the JavaScript logic to execute the transactions defined in the model file.The Trade transaction is intended to simply accept the identifier of the Commodity asset which is being traded, and the identifier of the Trader participant to set as the new owner.Open the  logic.js  script file.Replace the contents with the following:/** * Track the trade of a commodity from one trader to another * @param {org.example.mynetwork.Trade} trade - the trade to be processed * @transaction */async function tradeCommodity(trade) {    trade.commodity.owner = trade.newOwner;    let assetRegistry = await getAssetRegistry('org.example.mynetwork.Commodity');    await assetRegistry.update(trade.commodity);}Save your changes to logic.js.Adding access controlReplace the following access control rules in the file  permissions.acl :/** * Access control rules for tutorial-network */rule Default {    description: \"Allow all participants access to all resources\"    participant: \"ANY\"    operation: ALL    resource: \"org.example.mynetwork.*\"    action: ALLOW}rule SystemACL {  description:  \"System ACL to permit all access\"  participant: \"ANY\"  operation: ALL  resource: \"org.hyperledger.composer.system.**\"  action: ALLOW}Save your changes to permissions.acl.Step Three: Generate a business network archiveNow that the business network has been defined, it must be packaged into a deployable business network archive (.bna) file.Using the command line, navigate to the  tutorial-network  directory.From the tutorial-network directory, run the following command:composer archive create -t dir -n .After the command has run, a business network archive file called tutorial-network@0.0.1.bna has been created in the tutorial-network directory.Step Four: Deploying the business networkAfter creating the .bna file, the business network can be deployed to the instance of Hyperledger Fabric. Normally, information from the Fabric administrator is required to create a PeerAdmin identity, with privileges to install chaincode to the peer as well as start chaincode on the composerchannel channel. However, as part of the development environment installation, a PeerAdmin identity has been created already.After the business network has been installed, the network can be started. For best practice, a new identity should be created to administer the business network after deployment. This identity is referred to as a network admin.Retrieving the correct credentialsA PeerAdmin business network card with the correct credentials is already created as part of development environment installation.Deploying the business networkDeploying a business network to the Hyperledger Fabric requires the Hyperledger Composer business network to be installed on the peer, then the business network can be started, and a new participant, identity, and associated card must be created to be the network administrator. Finally, the network administrator business network card must be imported for use, and the network can then be pinged to check it is responding.To install the business network, from the tutorial-network directory, run the following command:composer network install --card PeerAdmin@hlfv1 --archiveFile tutorial-network@0.0.1.bnaThe composer network install command requires a PeerAdmin business network card (in this case one has been created and imported in advance), and the the file path of the .bna which defines the business network.To start the business network, run the following command:composer network start --networkName tutorial-network --networkVersion 0.0.1 --networkAdmin admin --networkAdminEnrollSecret adminpw --card PeerAdmin@hlfv1 --file networkadmin.cardThe composer network start command requires a business network card, as well as the name of the admin identity for the business network, the name and version of the business network and the name of the file to be created ready to import as a business network card.To import the network administrator identity as a usable business network card, run the following command:composer card import --file networkadmin.cardThe composer card import command requires the filename specified in composer network start to create a card.To check that the business network has been deployed successfully, run the following command to ping the network:composer network ping --card admin@tutorial-networkThe composer network ping command requires a business network card to identify the network to ping.Step Five: Generating a REST serverHyperledger Composer can generate a bespoke REST API based on a business network. For developing a web application, the REST API provides a useful layer of language-neutral abstraction.To create the REST API, navigate to the  tutorial-network  directory and run the following command:composer-rest-serverEnter  admin@tutorial-network  as the card name.Select never use namespaces when asked whether to use namespaces in the generated API.Select No when asked whether to secure the generated API.Select Yes when asked whether to enable event publication.Select No when asked whether to enable TLS security.The generated API is connected to the deployed blockchain and business network.Step Six: Generating an applicationHyperledger Composer can also generate an Angular 4 application running against the REST API.To create your Angular 4 application, navigate to  tutorial-network  directory and run the following command:yo hyperledger-composer:angularSelect Yes when asked to connect to running business network.Enter standard package.json questions (project name, description, author name, author email, license)Enter  admin@tutorial-network  for the business network card.Select Connect to an existing REST APIEnter  http://localhost  for the REST server address.Enter  3000  for server port.Select Namespaces are not usedThe Angular generator will then create the scaffolding for the project and install all dependencies. To run the application, navigate to your angular project directory and run  npm start . This will fire up an Angular 4 application running against your REST API at  http://localhost:4200 .",
        "url": "/composer/latest/tutorials/developer-tutorial"
      }
      ,
    
      "installing-development-tools": {
        "title": "Installing the development environment",
        "author": "",
        "category": "start",
        "content": "Installing the development environmentFollow these instructions to obtain the Hyperledger Composer development tools (primarily used to create Business Networks) and stand up a Hyperledger Fabric (primarily used to run/deploy your Business Networks locally).Note that the Business Networks you create can also be deployed to Hyperledger Fabric runtimes in other environments e.g. on a cloud platform.Before you beginMake sure you have installed the required pre-requisites, following the instructions in Installing pre-requisites.These instructions assume that you&#39;ve not installed the tools and used them before.  If this is not the case, you might want to check that your previous setup is completely destroyed before you start following this guide.  To learn how to do this, skip to the Appendix.To provide flexibility and enable the maximum number of dev, test and deployment scenarios, Composer is delivered as a set of components you can install with npm and control from the CLI.  These instructions will tell you how to install everything first, then how to control your development environment.Installing componentsStep 1: Install the CLI toolsThere are a few useful CLI tools for Composer developers.  The most important one is composer-cli, which contains all the essential operations, so we&#39;ll install that first.  Next, we&#39;ll also pick up generator-hyperledger-composer, composer-rest-server and Yeoman.  Those last 3 are not core parts of the development environment, but they&#39;ll be useful if you&#39;re following the tutorials or developing applications that interact with your Business Network, so we&#39;ll get them installed now.Note that you should not use su or sudo for the following npm commands.Essential CLI tools:npm install -g composer-cli@0.20Utility for running a REST Server on your machine to expose your business networks as RESTful APIs:npm install -g composer-rest-server@0.20Useful utility for generating application assets:npm install -g generator-hyperledger-composer@0.20Yeoman is a tool for generating applications, which utilises generator-hyperledger-composer:npm install -g yoStep 2: Install PlaygroundIf you&#39;ve already tried Composer online, you&#39;ll have seen the browser app &quot;Playground&quot;.  You can run this locally on your development machine too, giving you a UI for viewing and demonstrating your business networks.Browser app for simple editing and testing Business Networks:npm install -g composer-playground@0.20Step 3: Set up your IDEWhilst the browser app can be used to work on your Business Network code, most users will prefer to work in an IDE.  Our favourite is VSCode, because a Composer extension is available.Install VSCode from this URL: https://code.visualstudio.com/downloadOpen VSCode, go to Extensions, then search for and install the Hyperledger Composer extension from the Marketplace.Step 4: Install Hyperledger FabricThis step gives you a local Hyperledger Fabric runtime to deploy your business networks to.In a directory of your choice (we will assume ~/fabric-dev-servers), get the .tar.gz file that contains the tools to install Hyperledger Fabric:mkdir ~/fabric-dev-servers &amp;&amp; cd ~/fabric-dev-serverscurl -O https://raw.githubusercontent.com/hyperledger/composer-tools/master/packages/fabric-dev-servers/fabric-dev-servers.tar.gztar -xvf fabric-dev-servers.tar.gzA zip is also available if you prefer: just replace the .tar.gz file with fabric-dev-servers.zip and the tar -xvf command with a unzip command in the preceding snippet.Use the scripts you just downloaded and extracted to download a local Hyperledger Fabric v1.2 runtime:cd ~/fabric-dev-serversexport FABRIC_VERSION=hlfv12./downloadFabric.shCongratulations, you&#39;ve now installed everything required for the typical Developer Environment.Read on to learn some of the most common things you&#39;ll do with this environment to develop and test your Blockchain Business Networks.Controlling your dev environmentStarting and stopping Hyperledger FabricYou control your runtime using a set of scripts which you&#39;ll find in ~/fabric-dev-servers if you followed the suggested defaults.  The first time you start up a new runtime, you&#39;ll need to run the start script, then generate a PeerAdmin card:    cd ~/fabric-dev-servers    export FABRIC_VERSION=hlfv12    ./startFabric.sh    ./createPeerAdminCard.shYou can start and stop your runtime using ~/fabric-dev-servers/stopFabric.sh, and start it again with ~/fabric-dev-servers/startFabric.sh.At the end of your development session, you run ~/fabric-dev-servers/stopFabric.sh and then ~/fabric-dev-servers/teardownFabric.sh.  Note that if you&#39;ve run the teardown script, the next time you start the runtime, you&#39;ll need to create a new PeerAdmin card just like you did on first time startup.The local runtime is intended to be frequently started, stopped and torn down, for development use.  If you&#39;re looking for a runtime with more persistent state, you&#39;ll want to run one outside of the dev environment, and deploy Business Networks to it.  Examples of this include running it via Kubernetes, or on a managed platform such as IBM Cloud.Start the web app (&quot;Playground&quot;)To start the web app, run:    composer-playgroundIt will typically open your browser automatically, at the following address: http://localhost:8080/loginYou should see the PeerAdmin@hlfv1 Card you created with the createPeerAdminCard script on your &quot;My Business Networks&quot; screen in the web app: if you don&#39;t see this, you may not have correctly started up your runtime!Congratulations, you&#39;ve got all the components running, and you also know how to stop and tear them down when you&#39;re done with your dev session.What Next?Learn how to use the web app UI with the Playground TutorialLearn how to use the CLI and VSCode tools with the Developer TutorialAppendix: destroy a previous setupIf you&#39;ve previously used an older version of Hyperledger Composer and are now setting up a new install, you may want to kill and remove all previous Docker containers, which you can do with these commands:    docker kill $(docker ps -q)    docker rm $(docker ps -aq)    docker rmi $(docker images dev-* -q)",
        "url": "/composer/latest/installing/development-tools"
      }
      ,
    
      "problems-diagnostics": {
        "title": "Diagnosing Problems",
        "author": "",
        "category": "tasks",
        "content": "Diagnosing ProblemsComposer uses the Winston logging module by default - and will use the Config module to look for any configuration information. If none is found, then a set of defaults will be used.The config module does write out a warning, if there are no configuration files set. Eg. WARNING: No configurations found in configuration directory. This can be suppressed with an environment variable if you are happy with the defaults and don&#39;t wish to use config in your application. See more information here.Diagnosing ProblemsIf something should ever go wrong with an application, what should you do about getting diagnostics?Let&#39;s look at the digitalproperty-app sample, and use that to explain how to get diagnostics out of the framework.Please note: This is a framework - so your application will need to have it&#39;s own logging framework. Also, your application could also have configuration information to control Hyperledger Composer&#39;s own logging.There are two containers that are relevant to logging;the one the application is running in, andthe chain code container that executes the transaction functions.ApplicationInternally, Hyperledger Composer uses the Winston node.js logging package by default, with an initial level of log points and destinations set up.Default ConfigurationThe framework will log information at these levels.ErrorWarnInfoVerboseDebugIn the Hyperledger Composer source code, Entry and Exit logs are produced at the beginning and end of a function. These logs are reported at the Debug level for problem diagnosis.In an application environment, logs can be found either in a text file, or in stdout. In the chaincode container, only stdout is used.Control of what is producedTo control both the location and the type of information that is produced a simple JSON based object configuration is used. The [Config] module is used to help assemble this JSON structure - therefore end user control can be done by environment variables and other formats that Config supports.Short cut environment variables are provided to make working with this JSON structure easy!With that structure, control can be broke into two partsWhat level log messages are produced atWhere these messages are sentWhat is produced?Logging content, and when logs are displayed is controlled by the DEBUG control string, in the same way as many other node applications. The DEBUG string is a comma separated list of components, a * indicates that everything from the component will be logged, a - indicates that nothing will be logged. Care should be taken when using - to specify nothing will be logged, as it affects all logging levels, not only the default logging level. The DEBUG string takes the following format:DEBUG=&lt;moduleA&gt;,&lt;moduleB&gt;When including Hyperledger Composer, the string composer is used. For more specific logging control, the DEBUG string can accept further detail in the following format:DEBUG=composer[tracelevel]:fqn/class/nameIn the preceding example, [tracelevel] indicates the logging level to specify, and defaults to error; fqn/class/name is dependant on how the source code and name of the logger that it requests.The following are examples of debug control strings:composer:* Everything at error levelcomposer[error]:* Everything at error levelcomposer[info]:* Everything at info levelcomposer[info]:BusinessNetworkConnection Solely BusinessNetworkConnection at the info level-composer:BusinessNetworkConnection,composer[error]:* Do not trace anything in the BusinessNetworkConnection class, but do trace anywhere else that has errors.Log output locationThe details of where the files are written are controlled as follows.Default settings are:Console has no logging output (the exception being and errors encountered during log setup)File,  a set of three files, of 1Mb limited in size are written toLocation of this is in ~/.composer/logsA separate set of files is written on every calendar day.Each of the console or file can be controlled. These are controlled using the Config npm module used. Typically this is controlled by using a json file in a config directory in the current working directory.The structure should use the following format:{  \"loadAssets\": {    \"cardName\": \"admin@example-network\"  },  \"composer\": {    \"log\": {      \"debug\": \"composer[debug]:*\",      \"console\": {        \"maxLevel\": \"error\"      },      \"file\": {        \"filename\" : \"./log.txt\"      }    }}This example does several things.The debug control string enables debug trace for everything.  Equivalent to the DEBUG=composer[debug]:*It enables logging to the console, at the maximum level of error (so just errors)And the log file should be in an unlimited file called ./log.txt (by default the max log level is set to silly so as to get everything). However as the [debug] is present this pre-filters the log.ShortcutsThe preceding config file can be specified as a single environment variable on the command line.NODE_CONFIG=' { .... JSON HERE  } 'logger is used to refer the module that does actual logging. default is implying that this is the winston frameworkconfig is passed to the logger to control what it does.  So this section is specific to the logger in use.Enabling more informationThe standard way of enabling node.js applications for debug is to use the DEBUG environment variable. So thereforeExamplesnode app.js  Logs at error to the ~/.composer/logs/log_date.txtDEBUG=composer[info]:* node app.js Logs at info to the ~/.composer/logs/log_date.txtDEBUG=composer[debug]:* COMPOSER_LOGFILE=./log.txt node app.js Logs everything at debug level to the cwd file called log.txtCOMPOSER_LOG_CONSOLE=error node app.js Log to file and errors to the consoleChaincode ContainerWithin the container that is running chaincode, and therefore the business network transaction functions the logging system is the same. However, logging control and log output location differ.Output locationAs this is running within a container it is better to output the logs to stdout instead. This is then captured by docker or the container management system.To achieve this there is a runtime LoggingService that provides a configuration specifically for this purpose. The same framework is therefore used but with a specific configuration.  This is for the composer-runtime-hlfv1 defined as being    getDefaultCfg(){        return {            'logger': './winstonInjector.js',            'debug': 'composer[error]:*',            'console': {                'maxLevel': 'silly'            },            'file': {                'maxLevel': 'none'            },            'origin':'default-runtime-hlfv1',        };    }This routes all log to the console, none to the file system. The default control string is all errors.Transaction IdAn important part of the runtime is the transaction id that is currently being used. This is essential to be able to link together all logs from client, runtime and Fabric.To achieve this, a callback mechanism is in place to permit the retrieval of data that only the runtime will know at the point in time the log call is made.This permits the output in the logs to include the transaction id. For example 88bae779 in this line2018-01-16T12:56:58.987Z [88bae779] [INFO    ] @JS : IdentityManager         :&lt;ResourceManager&gt;()      Binding in the tx names and implControlThe same essential control is available and is focused around provision of the &#39;debug control string&#39;. Though within a container there need to be alternative ways to pass this in. Environment variables can be set for example in the docker-compose files.The &#39;setLogLevel&#39; and &#39;getLogLevel&#39; transactions, can be used to set/get the value of this debug string. The syntax of the string is the same,For example issuing the command to get the log level in a fresh setup:composer network loglevel --card admin@bsn-local                                                                                                              This can then be modified to say include all debug level log points from the TransactionHandler but still errors everywhere elsecomposer network loglevel --card admin@bsn-local -l \"composer[debug]:TransactionHandler,composer[error]:*\"  The logging level was successfully changed to: composer[debug]:TransactionHandler,composer[error]:*Command succeededComponent ProfilesUsing the debug string for another other than broad logging, requires a knowledge of what file/class to trace. If you want to take logging from say ACLs, thenthis there is the concept of &#39;profiles&#39;. For example for ACLs, you can enable trace withDEBUG=composer[debug]:aclsThe syntax is the same, but internally &#39;acls&#39; is expanded to a debug string specifically for ACLs.",
        "url": "/composer/latest/problems/diagnostics"
      }
      ,
    
      "integrating-enabling-multiuser": {
        "title": "Enabling multiple user mode for the REST server",
        "author": "",
        "category": "start",
        "content": "Enabling multiple user mode for the REST serverBy default, the Hyperledger Composer REST server services all requests by using the Blockchain identity specified on the command line at startup. For example, when using the following command, all requests made to the REST server will be serviced by using the Blockchain identity alice1 to digitally sign all transactions:composer-rest-server -c alice1@my-networkThis means that the business network cannot distinguish between different clients of the REST server. This may be acceptable in certain use cases, for example if the Blockchain identity only has read-only access and the REST server is secured using an API management gateway.The REST server can be configured to multiple user mode. Multiple user mode permits clients of the REST server to provide their own Blockchain identities for digitally signing transactions. This enables the business network to differentiate between different clients of the REST server.Multiple user mode requires that REST API authentication is enabled, and will automatically enable REST API authentication if it is not explicitly specified. You must select and configure a Passport strategy for authenticating users. REST API authentication is required so that clients can be identified.Once a client has authenticated to the REST API, that client can add Blockchain identities to a wallet. The wallet is private to that client, and is not accessible to other clients. When a client makes a request to the REST server, a Blockchain identity in the clients wallet is used to digitally sign all transactions made by that client.Please note that this feature requires that clients trust the REST server. This trust is required because this feature requires that the REST server stores the clients Blockchain identities, including the private keys. Therefore, it is strongly recommended that clients only use REST servers that are managed by a trusted party, such as an administrator within their organization.Starting the REST server with multiple user mode enabledYou must configure the environment variable COMPOSER_PROVIDERS before continuing. For instructions on how to perform this task, read the following topic before continuing: Enabling authentication for the REST serverYou can use the -m true argument to start the REST server with multiple user mode enabled. Once multiple user mode is enabled, clients will have to authenticate before they can make any requests to the business network.For example, here is the command for the business network that is deployed as part of the Developer Tutorial, however you may need to modify the command for your business network:composer-rest-server -c admin@my-network -m trueThe -m true argument automatically enables REST API authentication. You can alternatively supply both arguments, -a true -m true, if you wish to be explicit. Before continuing, you must authenticate to the REST API using the configured authentication mechanism. The environment variable COMPOSER_MULTIUSER can be set to true or false inplace of using -m on the command line. Now, navigate to the REST API explorer at http://localhost:3000/explorer/. If multiple user mode has been successfully enabled, any attempts to call one of the business network REST API operations using the REST API explorer should be rejected with an A business network card has not been specified error message.If you see a HTTP 401 Authorization Required error message, you have not authenticated correctly to the REST API.Adding a business network card to the walletFirst, you must issue a Blockchain identity to a participant in the business network. This example will assume that you have issued the Blockchain identity alice1 to the participant org.example.mynetwork.Trader#alice@email.com, and that you have created a business network card for this Blockchain identity stored in the file alice1@my-network.card.Follow these steps to add a business network card to the wallet:Navigate to the REST API explorer at http://localhost:3000/explorer/, and then navigate to the wallet APIs by expanding the Wallet category.Check that the wallet does not contain any business network cards by calling the GET /wallet operation. The response from the operation should be:[]Import the business network card into the wallet by calling the POST /wallet/import operation. You must specify the business network card file alice1@my-network.card by clicking the Choose File button. The response from the operation should be:no contentThe business network card alice1@my-network has now been imported into the wallet.Check that the wallet does contain the business network card alice1@my-network by calling the GET /wallet operation. The response from the operation should be:[    {        \"name\": \"alice1@my-network\",        \"default\": true    }]The business network card alice1@my-network is displayed. The value of the default property is true, which means that this business network card will be used by default when interacting with the business network.Now, navigate to the REST API explorer at http://localhost:3000/explorer/. Attempt to call one of the business network REST API operations again using the REST API explorer. This time, the calls should succeed.You can test that the Blockchain identity is being used by calling the GET /system/ping operation. This operation returns the fully qualified identifier for the participant that the Blockchain identity was issued to:{  \"version\": \"0.8.0\",  \"participant\": \"org.example.mynetwork.Trader#alice@email.com\"}Final notesWhen the REST server is started with multiple user mode enabled, all REST API requests made by clients use a Blockchain identity stored in the clients wallet. The Blockchain identity specified on the command line at startup is not used to service any requests; it is only used to initially connect to the business network and download the business network definition, which is required to generate the REST API. Therefore, the Blockchain identity specified on the command line only requires minimal permissions - the ability to connect, and the ability to download the business network definition - it does not need permission for any assets, participants, or transactions.All user information is persisted in a LoopBack data source by using a LoopBack connector. By default, the REST server uses the LoopBack &quot;memory&quot; connector to persist user information, which is lost when the REST server is terminated. The REST server should be configured with a LoopBack connector that stores data in a highly available data source, for example a database. For more information, see Deploying the REST server.",
        "url": "/composer/latest/integrating/enabling-multiuser"
      }
      ,
    
      "integrating-enabling-rest-authentication": {
        "title": "Enabling authentication for the REST server",
        "author": "",
        "category": "start",
        "content": "Enabling authentication for the REST serverThe REST server can be configured to authenticate clients. When this option is enabled, clients must authenticate to the REST server before they are permitted to call the REST API.Selecting an authentication strategyThe REST server uses the open source Passport authentication middleware. Administrators of the REST server must select Passport strategies to authenticate clients. Multiple Passport strategies can be selected, allowing clients of the REST server to select a preferred authentication mechanism. Passport includes a wide range of strategies (300+ at the time of writing), including a mix of social media (Google, Facebook, Twitter) and enterprise (SAML, LDAP) strategies.The rest of this document will demonstrate how to use the passport-github strategy to authenticate users using their GitHub ID. Install the passport-github strategy by executing the following command:npm install -g passport-githubConfiguring the REST server to use an authentication strategyThe REST server must be configured with a list of Passport strategies to use before REST API authentication can be enabled. This configuration includes both the names of the strategies to use and the individual configuration for each strategy.In order to configure the passport-github strategy, we will need to register an OAuth application on GitHub and retrieve the client ID and client secret. Follow these steps to register an OAuth application on GitHub:Navigate to GitHub and log in with your user ID and password.Click on your profile picture on the top right, and click on Settings from the drop down menu.Click on OAuth applications under Developer settings on the left hand bar.Click on Register a new application.Specify the following settings:Application name: ComposerHomepage: http://localhost:3000/Application description: OAuth application for ComposerAuthorization callback URL: http://localhost:3000/auth/github/callbackClick on Register application.Note down the values for Client ID and Client Secret.The configuration for the REST server should be specified using the environment variable COMPOSER_PROVIDERS. Set the configuration for the REST server by replacing the values of REPLACE_WITH_CLIENT_ID and REPLACE_WITH_CLIENT_SECRET with the values retrieved from step 7, and executing the following command:export COMPOSER_PROVIDERS='{  \"github\": {    \"provider\": \"github\",    \"module\": \"passport-github\",    \"clientID\": \"REPLACE_WITH_CLIENT_ID\",    \"clientSecret\": \"REPLACE_WITH_CLIENT_SECRET\",    \"authPath\": \"/auth/github\",    \"callbackURL\": \"/auth/github/callback\",    \"successRedirect\": \"/\",    \"failureRedirect\": \"/\"  }}'Starting the REST server with REST API authentication enabledOnce the environment variable COMPOSER_PROVIDERS has been set, you can use the -a true argument to start the REST server with authentication enabled. Once authentication is enabled, clients will have to authenticate before they can make any requests to the business network.For example, here is the command for the business network that is deployed as part of the Developer Tutorial, however you may need to modify the command for your business network:composer-rest-server -c admin@my-network -a trueNow, navigate to the REST API explorer at http://localhost:3000/explorer/. If authentication has been successfully enabled, any attempts to call one of the business network REST API operations using the REST API explorer should be rejected with an HTTP 401 Authorization Required message.Authenticating to the REST server using a web browserThis step is dependent on the configuration and behaviour of the Passport strategies being used by the REST server.Authenticate to the REST server by navigating to the value of the authPath property specified in the environment variable COMPOSER_PROVIDERS. In the example above, this is http://localhost:3000/auth/github.The REST server will redirect you to GitHub to perform the OAuth web server authentication flow. GitHub will ask you if you want to authorize the Composer application to access your account. Click the Authorize button.If successful, GitHub will redirect you back to the REST server.Now, navigate to the REST API explorer at http://localhost:3000/explorer/. Attempt to call one of the business network REST API operations again using the REST API explorer. This time, the calls should succeed.Authenticating to the REST server using an HTTP or REST clientWhen a user authenticates to the REST server, a unique access token is generated and assigned to the authenticated user. When the user authenticates using a web browser, the access token is stored in a cookie in the local storage of the users web browser. When the authenticated user makes a subsequent request, the access token is retrieved from the cookie, and the access token is validated instead of reauthenticating the user.The access token can be used to authenticate any HTTP or REST client that wishes to call the REST server. This is required when the HTTP or REST client cannot perform the authentication flow required by the configured Passport strategy. For example, all OAuth2 web authentication flows require the use of a web browser to navigate to the authentication providers website.In order to use the access token, the access token must first be retrieved using a web browser. When you authenticate to the REST server, the REST API explorer at http://localhost:3000/explorer/ will show the access token at the top of the page. By default the access token is hidden, but it can be displayed by clicking the Show button. The access token is a long alphanumeric string, for example: e9M3CLDEEj8SDq0Bx1tkYAZucOTWbgdiWQGLnOxCe7K9GhTruqlet1h5jsw10YjJOnce the access token has been retrieved, the access token can be passed into any HTTP or REST request to authenticate the HTTP or REST client. There are two options for passing the access token - using either a query string parameter, or an HTTP header. For both of the following examples, replace the string xxxxx with the value of the access token.Query string - add the access_token query string parameter to all HTTP or REST requests:curl -v http://localhost:3000/api/system/ping?access_token=xxxxxHTTP header - add the X-Access-Token header to all HTTP or REST requests:curl -v -H 'X-Access-Token: xxxxx' http://localhost:3000/api/system/ping",
        "url": "/composer/latest/integrating/enabling-rest-authentication"
      }
      ,
    
      "integrating-getting-started-rest-api": {
        "title": "Generating a REST API",
        "author": "",
        "category": "start",
        "content": "Generating a REST APIInstalling the REST serverThe Hyperledger Composer REST server can be installed either using npm or Docker.To install with npm, run the following command:npm install -g composer-rest-server@0.20To install the REST server using Docker see deploying the REST server.Running the REST serverHyperledger Composer includes a standalone Node.js process that exposes a business network as a REST API. The LoopBack framework is used to generate an Open API, described by a Swagger document.To launch the REST Server simply type:composer-rest-serverYou will then be asked to enter a few simple details about your business network. An example of consuming a deployed business network is shown below.? Enter the name of the business network card to use: admin@basic-sample-network? Specify if you want namespaces in the generated REST API: always use namespaces? Specify if you want to enable authentication for the REST API using Passport: No? Specify if you want to enable event publication over WebSockets: Yes? Specify if you want to enable TLS security for the REST API: NoTo restart the REST server using the same options, issue the following command:   composer-rest-server -c admin@basic-sample-network -n always -w trueDiscovering types from business network definition ...Discovered types from business network definitionGenerating schemas for all types in business network definition ...Generated schemas for all types in business network definitionAdding schemas for all types to Loopback ...Added schemas for all types to LoopbackWeb server listening at: http://localhost:3000Browse your REST API at http://localhost:3000/explorerThe composer-rest-server commandThe composer-rest-server command has a number of options used to define security and authentication:Options:  -c, --card            The name of the business network card to use  [string]  -n, --namespaces      Use namespaces if conflicting types exist  [string] [choices: \"always\", \"required\", \"never\"] [default: \"always\"]  -p, --port            The port to serve the REST API on  [number]  -y, --apikey          The API key to get access to the REST API [string] [default:undefined]  -a, --authentication  Enable authentication for the REST API using Passport  [boolean] [default: false]  -m, --multiuser       Enable multiple user and identity management using wallets (implies -a)  [boolean] [default: false]  -w, --websockets      Enable event publication over WebSockets  [boolean] [default: true]  -t, --tls             Enable TLS security for the REST API  [boolean] [default: false]  -e, --tlscert         File containing the TLS certificate  [string] [default: \"/usr/local/lib/node_modules/composer-rest-server/cert.pem\"]  -k, --tlskey          File containing the TLS private key  [string] [default: \"/usr/local/lib/node_modules/composer-rest-server/key.pem\"]  -u, --explorer        Enable the test explorer web interface  [boolean] [default: true]  -d, --loggingkey      Specify the key to enable dynamic logging for the rest server (just pressing enter will not enable this feature)  [string]  -h, --help            Show help  [boolean]  -v, --version         Show version number  [boolean]Dynamic Rest Server loggingLogging of the rest server can be controlled in the same way as other composer applications. However to do so requires the rest server to be started with environment variables set and at that point it logs continuously. This has disadvantages of creating large logs, reducing performance of the rest server and if logging is required the rest server needs to be restarted which may be a cumbersome task to achieve.You can enable dynamic rest server logging by specifying a key. This key is used as part of the URL path. This means that unless someone knows the key, even if they are authenticated, they cannot change the logging of the rest server. For example if a key of 45645-575835-A58684 has been set for the logging key, you can either use the rest server explorer (under the Admin section) to alter logging or write an application or use curl. For example in a simple case, assuming authentication is disabled you could docurl -X POST 'http://localhost:3000/api/admin/loglevel/45645-575835-A58684/composer%5Bdebug%5D%3A*/true/false'This sets the debug to composer[debug]:*, the first boolean value says whether to send output to the console, the second boolean value says whether to send it to the file system. In the above example it states to send logging to the console and not to the file system. The response looks like this{    \"oldlevel\":\"composer[error]:*\",    \"newlevel\":\"composer[debug]:*\",    \"oldConsoleLevel\":\"none\",    \"newConsoleLevel\":\"silly\",    \"oldFileLevel\":\"silly\",    \"newFileLevel\":\"none\"}indicating what the values were before and what they are now.Looking at the generated APIsLaunch your browser and go to the URL given (http://0.0.0.0:3000/explorer).  You&#39;ll see a screen similar to this.Updating the REST serverAfter updating a business network definition, the REST server can be updated to generate new APIs reflecting the updates to the business network definition.To update the REST server, first the REST server must be stopped using ctrl-C. Then the REST server can be restarted using composer-rest-server.Generating a REST API with an APIKEYAn API key can be used to provide a first layer of security to access the REST API in development environment.composer-rest-server -y YOUR_API_KEYThis will accept only request with an Header x-api-key set with the value of YOUR_API_KEY.SummaryUsing the Loopback framework on top of the Hyperledger Composer runtime has allowed us to generate a business domain specific REST API based on the deployed business network model!",
        "url": "/composer/latest/integrating/getting-started-rest-api"
      }
      ,
    
      "reference-glossary": {
        "title": "Hyperledger Composer Glossary of Terms",
        "author": "",
        "category": "",
        "content": "Glossary and definition of termsFrom WikipediaA blockchain— originally block chain — is a distributed database that maintains a continuously-growing list of records called blocks. Each block contains a timestamp and a link to a previous block. The data in a block cannot be altered retrospectively. Blockchains are an example of a distributed computing system with high byzantine fault tolerance.Access Control File: Access Control Files (.acl) are optional files within a business network definition. They describe assets or groups of assets and define the participants who can perform operations which affect those assets.Asset: An asset can be anything of value. A house is an example of a physical asset, and a mortgage is an example of non-physical asset. Assets within Hyperledger Composer can be defined to encompass any physical or non-physical asset.Blockchain: A blockchain is a shared and replicated ledger that can record asset transfers and changes. An implemented blockchain platform is often referred to as a Blockchain Fabric.Business Network Archive: A business network archive (.bna) is a compressed business network definition which contains at least a business network model and transaction processor functions and may optionally contain an access control file. Business network archives can be deployed to a Hyperledger fabric.Business Network Definition: A business network definition is made up of the business network model, transaction processor functions and optionally an access control file. The business network definition describes all assets, participants, transactions, and operations for a given solution, and can be interacted with by using a command line interface or an API.Business Network Model: The business network model describes the assets, participants, and transactions in the business network. The model is in effect the static object structure of the overall business network.Connection Profile: Connection profiles are .json files used by Hyperledger Composer to connect to an instance of Hyperledger Fabric.Composer Playground: The Hyperledger Composer Playground is an open toolset allowing business networks to be rapidly modelled and tested. Sample business networks can be imported to learn more about Hyperledger Composer and business network archives can be exported for local editing or later use.Events: Events are defined in the business network definition in the same way as assets or participants. Once events have been defined, they can be included in the transaction processor functions to be emitted as part of a transaction. Applications can subscribe to emitted events through the composer-client API.Fabric: A fabric is a blockchain platform that user applications connect to in order to interact with a ledger. Examples of blockchain fabrics include Bitcoin, Ethereum, Open Blockchain and Hyperledger.Hyperledger: Hyperledger is a Linux Foundation project to produce an open blockchain platform that is ready for business. It provides an implementation of the shared ledger, smart contracts, privacy and consensus mechanisms.Hyperledger Composer Admin API is an administrative API to build administrative applications. This API can install, start and upgrade business network definitions on the Hyperledger Composer fabric runtime.Hyperledger Composer Client API The Client API is used by applications to connect to a business network and submit transactions. These applications could be command line, web applications, or end-user applications. The Client API permits CRUD operations on the assets that have been defined in the model. It also permits the submission of the transactions to be executed to update assets.Identity: An identity is a distinct unique identifier associated with a participant. When joining a business network, an identity is issued to a participant which is used by the participant to interact with the business network. Identity documents normally expire after a given length of time, but can be issued or revoked maunally. Hyperledger Composer uses Hyperledger Fabric enrollment certificates as identity documents.Modelling language: The Hyperledger Composer modelling language is used in the business network definition to describe the assets, participants, and transactions in the business network. For a more in-depth explanation of the modelling language, see modelling language documentation.Participant: Participants represent the organizations or people who take part in the digital business network. Participants are defined in the business network model.Registry: Registries are a stores of assets held on the blockchain. The contents of the registry are validated using the blockchain consensus mechanism.Transaction: Transactions are submitted by a participant to affect the assets held in the asset registries on the Hyperledger blockchain. Transactions with a business network are defined in the business network model, and their operations are defined in the transaction processor function file.Transaction Processor Functions: Transaction processor functions act on assets and participants to either create, update or delete properties on assets and participants. Transactions processor functions are written in JavaScript and contained in a script file as part of a business network definition.",
        "url": "/composer/latest/reference/glossary"
      }
      ,
    
      "tutorials-google-oauth2-rest": {
        "title": "Using Google OAUTH2.0 with a Composer REST server",
        "author": "",
        "category": "tutorials",
        "content": "Using Google OAUTH2.0 with a  REST serverThis tutorial provides an insight into configuring the OAUTH2.0 authentication strategy  (eg. for Google, Facebook, Twitter authentication providers etc) to authorize access to resources in a configured REST Server instance - and allow end users of a blockchain network to interact with a deployed smart contract/business network. An overview diagram is shown below, and a more detailed diagram showing the authentication flow is shown further down. You will run the REST server in multi user mode and test interacting with the sample Trade network as different blockchain identities, accessing resources through the REST APIs. You will need to set up your own Google account / authorization scheme to do this (see appendix on the steps to do this - doesn&#39;t take long), or minimally, use the ID/metadata provided in this tutorial. Suffice to say, it uses Hyperledger Composer as the underlying blockchain network.Note: we have set up the standard &#39;Development Fabric&#39; network as instructed in Step 3 &#39;Setting up your IDE&#39; described hereThere are many Passport strategies one can choose from. In a business organisational sense, enterprise strategies such as SAML, JSON Web Tokens (JWT) or LDAP are more appropriate obviously - eg an organisational Active Directory server. We use/enable Google+ APIs as the authentication provider for this tutorial, as its easy for anyone to setup a Google account (see Appendix on how to achieve this) and configure the service / do the tutorial without worrying about middleware prereqs to be installed.OAUTH2.0 is really an &#39;authorization protocol&#39; but can be used as a &#39;delegated authentication scheme&#39; - authentication normally means identifying a user by his or her own credentials, whereas the OAUTH2.0 authentication, as used here, is used as a &#39;delegate&#39; authentication scheme. There are a number of &#39;roles&#39; to expand on here by way of background. The Composer REST server&#39;s role is to provide access to business network resources, which are protected by the Google+ API OAuth2.0 scheme. The resource owner is the Google+ API user account we set up (described in the appendix) its role is to grant consent (or otherwise) to the client application. The Google+ authorization server requests consent of the resource owner and issues access tokens to REST clients (eg web client apps)  to enable them to access the protected resources.  Smaller API providers may use the same application and URL space in Google+ for both the authorization server and resource server. The idea is that, when a web application user (consuming REST APIs to access a business network) comes along,  he/she doesn&#39;t have to pre-register anything ;  the application user is granted consent by virtue of the configured client application (although that does depend on the OAUTH2.0 flow set up). In our tutorial, we are using a browser to consume the REST APIs and see how this authentication flow actually works.An access key is granted following consent ; the token allows a client to access the APIs protected by OAuth2.0. In OAuth 2.0, these access tokens are called “bearer tokens”, and can be used alone, with no signature or cryptography, to access the information. Furthermore, the access token is stored in a cookie in the local storage of the user&#39;s web browser. When the user makes a subsequent request, the access token is retrieved from the cookie, and the access token is validated, instead of reauthenticating the user.The REST Server itself is configured to persist the business network cards (required to connect to the network) using the MongoDB store. Typically an organisation would run multiple instances of the REST server Docker image described below and configure a highly available instance of the persistent data store, for example a MongoDB replica set. Configuring the components for high availability allows an administrator to stop, restart, or remove REST server instances without the application users losing access to the deployed business network over REST.You should carry out this tutorial as a non-privileged user (sudo or elevated privileges are not required). Step 1: Set up the Persistent DB Credentials Data Store using MongoDB As mentioned, we will store credentials in a persistent data store once the appropriate business network cards are imported to the REST Wallet.Start the MongoDB InstanceOpen a terminal window and enter the following command:docker run -d --name mongo --network composer_default -p 27017:27017 mongoIt should output that a docker image has been downloaded and provide a SHA256 message. An instance of the MongoDB docker container has been started. It is important to use the --network composer_default here, to enable simple network connectivity with the REST server. Step 2: Build the REST Server Docker Image with OAUTH2.0 module In your $HOME directory, create a temporary directory called dockertmp and cd into it:cd $HOME ; mkdir dockertmpcd dockertmpIn the temporary directory, create a docker file called Dockerfile in an editor and paste into the following sequence (including special backslash \\ characters below needed after the RUN and npm lines below  - ie the continuation character ):FROM hyperledger/composer-rest-serverRUN npm install --production loopback-connector-mongodb passport-google-oauth2 &amp;&amp; \\npm cache clean --force &amp;&amp; \\ln -s node_modules .node_modulesThis Docker file will pull the Docker image located at /hyperledger/composer-rest-server and additionally install two more npm modules:• loopback-connector-mongodb – This module provides a MongoDB connector for the LoopBack framework and allows our REST server to use MongoDB as a data source. For more information: https://www.npmjs.com/package/loopback-connector-mongodb• passport-google-oauth2 – This module lets us authenticate using a Google+ account with our REST server. For more information: https://www.npmjs.com/package/passport-google-oauth-2From the same directory where the Dockerfile resides, build the custom Docker REST Server image:docker build -t myorg/composer-rest-server .The parameter given the –t flag is the name you want to give to this Docker image, this can be up to you to name - but for this guide the image will be called ‘myorg/composer-rest-server’.You should see output similar to the following with the bottom 2 lines indicating it was &#39;Successfully built&#39;:docker build -t myorg/composer-rest-server .Sending build context to Docker daemon  4.203GBStep 1/2 : FROM hyperledger/composer-rest-server ---&gt; e682b4374837Step 2/2 : RUN npm install --production loopback-connector-mongodb passport-google-oauth2 &amp;&amp;     npm cache clean  --force &amp;&amp;     ln -s node_modules .node_modules ---&gt; Running in 7a116240be21npm WARN saveError ENOENT: no such file or directory, open '/home/composer/package.json'npm WARN enoent ENOENT: no such file or directory, open '/home/composer/package.json'npm WARN composer No descriptionnpm WARN composer No repository field.npm WARN composer No README datanpm WARN composer No license field.+ passport-google-oauth2@0.1.6+ loopback-connector-mongodb@3.4.1added 114 packages in 7.574snpm WARN using --force I sure hope you know what you are doing. ---&gt; a16cdea42dacRemoving intermediate container 7a116240be21Successfully built a16cdea42dacSuccessfully tagged myorg/composer-rest-server:latestINFO: Don’t worry about seeing the &#39;npm warn messages&#39; as shown on the console as per above. This can be ignored.Lastly, for this section, go back up one level in your directory structure:cd .. Step 3: Define Environment variables for REST Server instance configuration Create a file called envvars.txt in your $HOME directory and paste in the following configuration settings - note that you will need to replace the client ID and clientSecret shown below, with your own Google API + client information below  (as shown in the Appendix)COMPOSER_CARD=restadmin@trade-networkCOMPOSER_NAMESPACES=neverCOMPOSER_AUTHENTICATION=trueCOMPOSER_MULTIUSER=trueCOMPOSER_PROVIDERS='{    \"google\": {        \"provider\": \"google\",        \"module\": \"passport-google-oauth2\",        \"clientID\": \"312039026929-t6i81ijh35ti35jdinhcodl80e87htni.apps.googleusercontent.com\",        \"clientSecret\": \"Q4i_CqpqChCzbE-u3Wsd_tF0\",        \"authPath\": \"/auth/google\",        \"callbackURL\": \"/auth/google/callback\",        \"scope\": \"https://www.googleapis.com/auth/plus.login\",        \"successRedirect\": \"/\",        \"failureRedirect\": \"/\"    }}'COMPOSER_DATASOURCES='{    \"db\": {        \"name\": \"db\",        \"connector\": \"mongodb\",        \"host\": \"mongo\"    }}'The environment variables defined here will indicate that we want a multi user server with authentication using Google OAuth2 along with MongoDB as the persistent data source.The first line indicates the name of the business network card we will start the network with - a specific REST Administrator against a defined business network. You will also see that in this configuration we also define the data source the REST server will use and the authentication provider we are using. These can be seen with the COMPOSER_DATASOURCES and COMPOSER_PROVIDERS variables respectively. Step 4: Load environment variables in current terminal and launch the persistent REST Server instance From the same directory as the envvars.txt file you created containing the environment variables, run the following command:source envvars.txtINFO    No output from command? - this is expected. If you did have a syntax error in your envvars.txt file then this will be indicated by an error, after running this command.Let’s now confirm that environment variables are indeed set by checking a couple of them using “echo” command as shown belowecho $COMPOSER_CARDecho $COMPOSER_PROVIDERS Step 5: Deploy the sample Commodities Trading Business network to query from REST client If you&#39;ve not already done so - download the trade-network.bna for the Trade-network from https://composer-playground.mybluemix.net/. Ensure you note down the version number displayed above the About page.In Playground, connect to the network as admin and export the trade-network.bna  and copy it to your home directory.To deploy the business network, first you need to install the business network onto the peerscomposer network install --card PeerAdmin@hlfv1 --archiveFile trade-network.bnamake a note of the version that is output after running the above command. This is the version of the business network which you will provide to the next command that you use to start the business network.run the following commands, replacing &lt;business_network_version&gt; with the version number output from the previous install command. composer network start --card PeerAdmin@hlfv1 --networkName trade-network --networkVersion &lt;business_network_version&gt; --networkAdmin admin --networkAdminEnrollSecret adminpw --file networkadmin.cardYou should get confirmation that the Commodities Trading Business Network has been started and an &#39;admin&#39; networkadmin.card file has been created.Next, import the business network card, and connect with the card to download the certs to the wallet:composer card import -f networkadmin.cardcomposer network ping -c admin@trade-networkYou should get confirmation that the connectivity was successfully tested. We&#39;re now ready to work with the deployed business network. Step 6:  Create the REST server Administrator for the Composer REST server instance  Create a REST Administrator identity called restadmin and an associated business network card (used to launch the REST server later).composer participant add -c admin@trade-network -d '{\"$class\":\"org.hyperledger.composer.system.NetworkAdmin\", \"participantId\":\"restadmin\"}'composer identity issue -c admin@trade-network -f restadmin.card -u restadmin -a \"resource:org.hyperledger.composer.system.NetworkAdmin#restadmin\"Import and test the card:composer card import -f  restadmin.cardcomposer network ping -c restadmin@trade-networkBecause we are hosting our REST server in another location with its own specific network IP information, we need to update the connection.json - so that the docker hostnames (from within the persistent REST server instance) can resolve each other&#39;s IP addresses.The one-liner below will substitute the &#39;localhost&#39; addresses with docker hostnames and create a new connection.json - which goes into the card of our REST administrator. We will also use this custom connection.json file for our &#39;test&#39; authenticated user later on in the OAUTH2.0 REST authentication sequence, nearer the end of this tutorial. To quickly change the hostnames - copy-and-paste then run this one-liner (below) in the command line from the $HOME directory.sed -e 's/localhost:7051/peer0.org1.example.com:7051/' -e 's/localhost:7053/peer0.org1.example.com:7053/' -e 's/localhost:7054/ca.org1.example.com:7054/'  -e 's/localhost:7050/orderer.example.com:7050/'  &lt; $HOME/.composer/cards/restadmin@trade-network/connection.json  &gt; /tmp/connection.json &amp;&amp; cp -p /tmp/connection.json $HOME/.composer/cards/restadmin@trade-network/  Step 7:  Launch the persistent REST server instance   Run the following docker command to launch a REST server instance (with the restadmin business network card)docker run \\-d \\-e COMPOSER_CARD=${COMPOSER_CARD} \\-e COMPOSER_NAMESPACES=${COMPOSER_NAMESPACES} \\-e COMPOSER_AUTHENTICATION=${COMPOSER_AUTHENTICATION} \\-e COMPOSER_MULTIUSER=${COMPOSER_MULTIUSER} \\-e COMPOSER_PROVIDERS=\"${COMPOSER_PROVIDERS}\" \\-e COMPOSER_DATASOURCES=\"${COMPOSER_DATASOURCES}\" \\-v ~/.composer:/home/composer/.composer \\--name rest \\--network composer_default \\-p 3000:3000 \\myorg/composer-rest-serverThis will output the ID of the Docker container eg . 690f2a5f10776c15c11d9def917fc64f2a98160855a1697d53bd46985caf7934 and confirm that the REST server has been indeed started.Check that all is ok with our container - you can see that it is running using the following commands:docker ps |grep restdocker logs restLook for &quot; Browse your REST API at http://localhost:3000/explorer &quot; at the end of the log - and retrace steps (above) if not there. Step 8:  Test the REST APIs are protected and require authorization   Open a browser window and launch the REST API explorer by going to http://localhost:3000/explorer to view and use the available APIs.INFO    Admin identity restadmin is used as an initial default - The REST server uses restadmin identity until a specific identity e.g. jdoe is set as a default identity in the REST client wallet.Go to the “System: general business network methods” sectionGo to the “/system/historian” API and click on “Try it out!” button as shown below:You should get an Authorized error and that is because we have configured a Google+ passport OAUTH2.0 authentication strategy to protect access to the REST server. Once authentication via the OAUTH2.0 authentication pa has been achieved, the REST APIs in the browser can interact with the Trade Commodity business network (ie. once a business card has been imported). Step 9: Create some Participants and Identities for testing OAUTH2.0 authentication  You need to create a set participant and identities for testing you can interact with the business network. This is because the REST server can handle multiple REST clients in multi-user mode. We will be using the composer CLI commands to add participants and identities as follows - first name is Jo Doe:composer participant add -c admin@trade-network -d '{\"$class\":\"org.example.trading.Trader\",\"tradeId\":\"trader1\", \"firstName\":\"Jo\",\"lastName\":\"Doe\"}'composer identity issue -c admin@trade-network -f jdoe.card -u jdoe -a \"resource:org.example.trading.Trader#trader1\"composer card import -f jdoe.cardOnce again, because we will use this identity to test inside the persistent REST docker container - we will need to change the hostnames to represent the docker resolvable hostnames - once again run this one-liner to carry out those changes quickly:sed -e 's/localhost:7051/peer0.org1.example.com:7051/' -e 's/localhost:7053/peer0.org1.example.com:7053/' -e 's/localhost:7054/ca.org1.example.com:7054/'  -e 's/localhost:7050/orderer.example.com:7050/'  &lt; $HOME/.composer/cards/jdoe@trade-network/connection.json  &gt; /tmp/connection.json &amp;&amp; cp -p /tmp/connection.json $HOME/.composer/cards/jdoe@trade-network/ We need to export the card to a file - to use for importing elsewhere  - ie the card that we will use to import to the wallet in our browser client - and therefore at this point, we can discard the initial business network card file for jdoe.composer card export -f jdoe_exp.card -c jdoe@trade-network ; rm jdoe.cardRepeat the above steps for participant Ken Coe (kcoe) - creating a trader2 participant and issuing the identity kcoe - the sequence of commands are:composer participant add -c admin@trade-network -d '{\"$class\":\"org.example.trading.Trader\",\"tradeId\":\"trader2\", \"firstName\":\"Ken\",\"lastName\":\"Coe\"}'composer identity issue -c admin@trade-network -f kcoe.card -u kcoe -a \"resource:org.example.trading.Trader#trader2\"composer card import -f kcoe.cardsed -e 's/localhost:7051/peer0.org1.example.com:7051/' -e 's/localhost:7053/peer0.org1.example.com:7053/' -e 's/localhost:7054/ca.org1.example.com:7054/'  -e 's/localhost:7050/orderer.example.com:7050/'  &lt; $HOME/.composer/cards/kcoe@trade-network/connection.json  &gt; /tmp/connection.json &amp;&amp; cp -p /tmp/connection.json $HOME/.composer/cards/kcoe@trade-network/ composer card export -f kcoe_exp.card -c kcoe@trade-network ; rm kcoe.cardThese cards can now be imported, then used into the REST client (ie the browser) in the next section. Step 10:   Authenticating from the REST API Explorer and testing using specific identities   Go to http://localhost:3000/auth/google - this will direct you to the Google Authentication consent screen.Login using the following credentials: (example shown below - as advised, you should set up your own per the instructions in the appendix section of this tutorial):Email: composeruser01@gmail.comPassword: You will be authenticated by Google and be redirected back to the REST server (http://localhost:3000/explorer) which shows the access token message in the top left-hand corner - click on &#39;Show&#39; to view the token.While our REST server has authenticated to Google+ OAUTH2.0 service (defined by its project/client scope, and using the client credentials set up in the Appendix for our OAUTH2.0 service), we have not actually done anything yet, in terms of blockchain identity or using business network cards to interact with our Trade Commodity business network - we will do that next,  using the jdoe identity we created earlier. Step 11:  Check the Default Wallet and Import the card and set a default Identity  Firstly, go to the REST endpoint under Wallets and do a GET operation (and &#39;Try it Out&#39;) to get the contents of the Wallet - check that the wallet does not contain any business network cards - it should show as empty [ ]:GET /walletsYou need to add an identity to the REST client wallet and then set this identity as the default one to use for making API calls. Go to the POST system operation under /Wallets - its called the /Wallets/Import endpointChoose to import the file jdoe_exp.card  - and provide the name of the card as jdoe@trade-network  and click &#39;Try it Out&#39;Scroll down - you should you should get an HTTP Status code 204 (request was successful)Next, go back toGET /walletsYou should see that jdoe@trade-network is imported into the wallet. Note also that the value of the default property is true, which means that this business network card will be used by default when interacting with the Commodity Trading business network (until such time as you change it to use another). Step 12:  Test interaction with the Business Network as the default ID jdoe Go to System REST API  Methods section and expand the /GET System/Historian sectionClick on &#39;Try It Out&#39; - you should now see results from the Historian Registry, as the blockchain identity &#39;jdoe&#39; and a set of transactionsGo to the Trader methods and expand the /GET Trader endpoint then click &#39;Try it Out&#39;It should confirm that we are able to interact with the REST Server as jdoe in our authenticated session.You should now be able to see all Trader participants currently created. If any ACLs have been set then restrictions on what he can see may apply (they haven&#39;t been applied for this current sample network, but examples of ACL rules can be seen in the ACL tutorial FYI). Suffice to say that REST APIs accessing a business network are subject to access control - like any other interaction with the business network (such as Playground, JS APIs, CLI etc). Next, return to the POST /wallet/import operation and import the card file kcoe_exp.card with the card name set to kcoe@trade-network and click on &#39;Try it Outto import it - it should return a successful (204) response.However, to use this card, we need to set it as the default card name in our Wallet - go to the POST /wallet/name/setDefault/ method and choose kcoe@trade-network as the default card name and click on Try it Out. This is now the default card.Return to the Trader methods and expand the /GET Trader endpoint then click &#39;Try it Out&#39; . It should confirm that we are now using a different card name and still be able to interact with the REST Server as we are still authenticated.Conclusion This concludes the tutorial section - you&#39;ve seen how to configure a client-based Google OAUTH2.0 authentication service that can be used to authorize client applications and provide consent to interact with a protected resource server (namely an REST Server instance) without the need to authenticate on every request. Furthermore, the REST Server is running in multi-user mode and so,  allows multiple blockchain identities to interact with the deployed Commodity Trading business network from the same REST client session, subject to token expiration times etc etc.The appendix below describes how the Google Authentication scheme in this tutorial was set up, in advance of this tutorial.Appendix - Google+  Authentication Configuration &amp; SetupThe appendix below describes how to create an OAUTH2.0 authentication service for authenticating client applications. These steps at a high-level overview consist of:Create Google API+ ProjectCreate Credentials Service AccountCreate OAuth2.0 ConsentCreate OAuth2.0 Client ID credentials for the Credentials Service AccountStep A1:  Create Google API+ Project Login to your Google account - if you don&#39;t have one - create one at google.com and sign in to GoogleLink for the page https://console.developers.google.com/apis/You should see the following page on arrival. Search for ‘Google+’ in the search bar and select the Google+ APIs icon when presented.Once selected - click to Enable the Google+ APIs - it is important that you do this.As you don’t have a &#39;project&#39; yet, you will be prompted to create a project as it is needed to enable the APIs. Click ‘Create Project’You will be prompted to give it a name - call it &#39;GoogleAuth&#39; and take a note of the Project ID in our case it is shown as proven-caster-195417 - this will be used later on.After creating the project, you will be redirected to the Google+ API page again. You should now see the project name selected and the option to ‘Enable’ the service. Click ‘Enable’.Step A2:  Create Credentials Service Account  Once you have enabled the service you will be prompted to create Service Account Credentials so that you can use the service.  Click ‘Create Credentials’.You will be asked a series of questions to determine what kind of credentials you will need. Give the answers shown in the screenshot below. Choose &#39;Google+ API&#39;  for the API, Web Server (e.g. Node js, Tomcat) and Application data and &#39;No&#39; for the Engine question at the bottom.Click on What credentials do I need  and hit ContinueNext, setup a Credentials service account - with the name &#39;GoogleAuthService&#39; - select &#39;Project&#39; in the dropdown and select a role of Owner and a type of JSON andClick on &#39;Get your Credentials&#39; - it should download (or prompt to download) the service credentials in JSON format - save these to a safe location.Save a JSON file with the application credentials. After downloading the credentials, the site will take you back to the credentials homepage and you will see a new service account key.Step A3:  Create OAUTH2.0 Consent Go to the ‘OAuth consent screen&#39; tab = you will need to give a &#39;product name&#39;  like &#39;Google Auth REST OAUTH2 service&#39; - a banner that is shown when consent to authorize a request is requested  (ie when we test it on the REST client in the main tutorial) and an email address, click ‘Save’.The OAuth consent screen is what the user (in the tutorial) will see when they are authenticating themselves against the Google Auth REST ServiceStep A4:  Create OAuth2.0 Client ID credentials for the Credentials Service Account Go back to the ‘Credentials’ tab and click the ‘Create Credentials’ dropdown and select ‘OAuth Client ID’.Choose &#39;Web Application&#39; and give it a simple name like &#39;Web Client 1&#39;Under the &#39;Authorised Javascript Origins&#39; section add a line with the following URI - this is the client application (the REST Server):http://localhost:3000We will need to add &#39;Authorized Redirect URIs&#39; at the bottom - this is where the authenticated session is redirected back to after getting consent from the Google+ OAUTH2.0 authentication service. The callback will match what we will configure in our Composer REST Server environment variables (specifically the variable COMPOSER_PROVIDERS, in the envvars.txt when performing this instruction in the main tutorial).Under &#39;Authorized Redirect URIs&#39; add the following URIs as authorised URIs. Note: it is best to copy/paste each URI below, then hit ENTER in the browser after each line entry- as the URI line editor can sometimes truncate your entry whilst typing .e.g. if you happen to pause when typing the URI.http://localhost:3000/auth/googlehttp://localhost:3000/auth/google/callbackThen click on the &#39;Create&#39; button at the bottom.You will be prompted to save the Client ID and Client Secret - copy these two and save these for later.You&#39;re all set - you can now return to the main tutorial to set up your REST Server Authentication using Google&#39;s OAUTH2.0 client authentication service.A word on Google Authentication OAUTH2.0 setup and scope of AuthenticationWhen an application uses OAuth 2.0 for authorization, it acts on a user&#39;s behalf to request an OAuth 2.0 access token for access to a resource, which it identifies by one or more scope strings. Normally, of course - the user itself is asked to approve the access.When a user (eg. an admin) grants access to the app for a particular scope, in Google at least, a project-level consent &#39;branding&#39;is setup in the Google+ API Console to challenge for the initial consent. Thereafter, once consented,  Google considers that user (through the Google account he/she has set up) has granted access to a particular scope to any configured client IDs in a API+ project ; the grant indicates the trust in the whole application - for the scope as defined in the Google+ API configuration.The effect is that the application provider is not be prompted to approve access to any resource more than once for the same logical client application.Fortunately, the Google authorization infrastructure can use information about user approvals for a client ID within a given project set up in Google+ API console,  when evaluating whether to authorize others in the same project. It also requires you to set up the authorized URIs that can be granted consent (such as the application call back URL after successful authentication).The Google Authorization module will observe that the calling application and the web client ID are in the same project, and without user approval, return an ID token to the application, signed by Google. The ID token will contain several data fields, of which the following are particularly relevant:iss: always accounts.google.comaud: the client ID and secret of the web component of the projectemail: the email that identifies the user requesting the tokenThis ID token is designed to be transmitted over HTTPS. Before using it, the web component must do the following:Validate the cryptographic signature. Because the token takes the form of a JSON web token or JWT and there are libraries to validate JWTs available in most popular programming languages, this is straightforward and efficient.Ensure that the value of the aud field is identical to its own client ID.Once this is accomplished, the REST server can have a high degree of certainty that - the token was issued by Google.",
        "url": "/composer/latest/tutorials/google_oauth2_rest"
      }
      ,
    
      "business-network-historian": {
        "title": "Hyperledger Composer Historian",
        "author": "",
        "category": "concepts",
        "content": "Hyperledger Composer HistorianThe Hyperledger Composer Historian is a specialised registry which records successful transactions, including the participants and identities that submitted them. The historian stores transactions as HistorianRecord assets, which are defined in the Hyperledger Composer system namespace.The historian registry is a Hyperledger Composer system-level entity. To refer to the historian registry as a resource for access control the historian must be referenced as: org.hyperledger.composer.system.HistorianRecord.Please note: All participants must have the permission to create HistorianRecord assets. If a transaction is submitted by a participant who does not have the permission to create HistorianRecord assets, the transaction will fail.HistorianRecord assetsThe historian registry stores successful transactions as HistorianRecord assets. Whenever a transaction successfully completes, a HistorianRecord asset is created and added to the historian registry. Record assets are defined in the system namespace, and have the following definition:asset HistorianRecord identified by transactionId {  o String      transactionId  o String      transactionType  --&gt; Transaction transactionInvoked  --&gt; Participant participantInvoking  optional  --&gt; Identity    identityUsed         optional  o Event[]       eventsEmitted        optional  o DateTime      transactionTimestamp}String transactionId The transactionId of the transaction that caused the HistorianRecord asset to be created.String transactionType The class of transaction that caused the HistorianRecord asset to be created.Transaction transactionInvoked A relationship to the transaction which caused the HistorianRecord asset to be created.Participant participantInvoking A relationship to the participant who submitted the transaction.Identity identityUsed A relationship to the identity used to submit the transaction.Event[] eventsEmitted An optional property containing any events which were emitted by the transaction.DateTime transactionTimestamp The timestamp of the transaction which caused the HistorianRecord asset to be created.All HistorianRecord assets have relationships to the transaction that created them, the invoking participant of that transaction, and the identity used when the transaction was submitted. Applications that wish to obtain these attributes must resolve this relationship.System transactionsSeveral operations that the Hyperledger Composer runtime makes are classed as transactions. These &#39;system transactions&#39; are defined in the Hyperledger Composer system model. The following will add HistorianRecord assets:Adding, removing and updating assetsAdding, removing and updating participantsIssuing, binding, activating and revoking identitiesUpdating the business network definitionSecuring historian dataAs a registry, access to the historian data can be controlled with access control rules. However, as a system-level entity the resource name for the historian registry is always org.hyperledger.composer.system.HistorianRecord.The following access control rule allows members to only see historian data if it references transactions they submitted.rule historianAccess{  description: \"Only allow members to read historian records referencing transactions they submitted.\"  participant(p): \"org.example.member\"  operation: READ  resource(r): \"org.hyperledger.composer.system.HistorianRecord\"  condition: (r.participantInvoking.getIdentifier() == p.getIdentifier())  action: ALLOW}Retrieving historian dataData from the historian registry can be retrieved using either an API call, or queries. All examples that follow make use of the async/await feature and assume that the code is encapsulated in a function with the async attribute.Using the client and REST APIs with historianHistorianRecord assets can be returned using the system/historian and system/historian/{id} calls using the REST API.When using the REST API, a GET call of system/historian will return ALL historian data. This call should be used with care, the return is not limited and may result in large volumes of data being returned.A GET call of system/historian/{id} using the REST API will return the HistorianRecord asset specified.Querying the HistorianHistorian can be queried in the same manner as other registries. For example, a typical query to return all HistorianRecord assets would be as follows:    let historian = await businessNetworkConnection.getHistorian();    let historianRecords = await historian.getAll();    console.log(prettyoutput(historianRecords));As this is a &#39;getAll&#39; call it will potentially return high volume of data. Therefore the query capability is vital in being able to select a subset of records. A typical example would be to select records based on a time. This uses the query capability to select records where the transaction timestamp is past a certain point. The returned records can be processed in the same way.  let now = new Date();  now.setMinutes(10);  // set the date to be time you want to query from  let q1 = businessNetworkConnection.buildQuery('SELECT org.hyperledger.composer.system.HistorianRecord ' +                                                'WHERE (transactionTimestamp &gt; _$justnow)');     await businessNetworkConnection.query(q1,{justnow:now});More advanced queries can be used; for example, the following query selects and returns the Add, Update, and Remove asset system transactions.  // build the special query for historian records  let q1 = businessNetworkConnection.buildQuery(      `SELECT org.hyperledger.composer.system.HistorianRecord          WHERE (transactionType == 'AddAsset' OR transactionType == 'UpdateAsset' OR transactionType == 'RemoveAsset')`  );        await businessNetworkConnection.query(q1);What next?Applying queries to a business network.Emitting events from transactions.Hyperledger Composer API documentation.",
        "url": "/composer/latest/business-network/historian"
      }
      ,
    
      "reference-historian": {
        "title": "Historian",
        "author": "",
        "category": "",
        "content": "Hyperledger Composer HistorianWarning: This is the first part of the implementation of functionality to track the transactions and asset updates. There are additional use cases that are not a covered by this implementation. Details are being tracked in GitHub issue 55. There may be changes to the HistorianRecord (documented below) as a result.The Historian is a registry populated with HistorianRecords that contains information about historical transactions.  When a transaction is submitted, the HistorianRecord is updated, and over time, maintains a history of transactions within a business network, and the participants and identities involved in submitting those transactions. HistorianRecord assets can be queried using Composer Queries to extract specific records or data. An example would be tracking the lifecycle of an asset such as a Land Title, from creation (with a Land Title ID) through update, through ownership changes carried out by different identities and/or participants. The transactions associated with this example can be queried in Historian, say, over a given time period.Historian RecordA HistorianRecord is an &#39;asset&#39; defined in the Hyperledger Composer system namespace. HistorianRecords are defined as follows.asset HistorianRecord identified by transactionId {  o String      transactionId  o String      transactionType  --&gt; Transaction transactionInvoked  --&gt; Participant participantInvoking  optional  --&gt; Identity    identityUsed         optional  o Event[]       eventsEmitted        optional  o DateTime      transactionTimestamp}String transactionId Using the transaction id as the uuidString transactionType Type of the transaction that was submittedTransaction transactionInvoked Relationship to transactionParticipant participantInvoking Participant who invoked this transactionIdentity identityUsed The identity that was used by the participantEvent[] eventsEmitted The events that where emitted by this transactionIdDateTime transactionTimestamp Use the transaction&#39;s timestampIt&#39;s important to note that the Transaction, Participant and Identity are relationships. Applications that wish to obtain these attributes must resolve this relationship.Tracking TransactionsThe historian registry is updated for each successful transaction, transactions which fail are not recorded. In addition, several operations that the Hyperledger Composer runtime makes are classed as transactions. These &#39;system transactions&#39; are defined in the Hyperledger Composer system model. The following will add HistorianRecord assets.Add, Remove and Update of AssetsAdd, Remove and Update of ParticipantsIssue, Bind, Activate and Revoke of IdentitiesNote that the retrieval of assets and participants is not tracked.Querying the HistorianThe established APIs for querying and working with resources and relationship are applicable. The historian is a registry containing assets (HistorianRecords) so can be queried.For example to get all the HistorianRecord assets a typical promise chain would be as follows.    let historian = await businessNetworkConnection.getHistorian();    let historianRecords = historian.getAll();    console.log(prettyoutput(historianRecords));As this is a &#39;getAll&#39; call it will potentially return high volume of data. Therefore the query capability is vital in being able to select a subset of records. A typical example would be to select records based on a time. This uses the query capability to select records where the transaction timestamp is past a certain point. The returned records can be processed in exactly the same way.  let now = new Date();  now.setMinutes(10);  // set the date to be time you want to query from  let q1 = businessNetworkConnection.buildQuery('SELECT org.hyperledger.composer.system.HistorianRecord ' +                                                'WHERE (transactionTimestamp &gt; _$justnow)');     await businessNetworkConnection.query(q1,{justnow:now});More advanced queries can be used; for example, the following query selects and returns the Add, Update, and Remove asset system transactions.  // build the special query for historian records  let q1 = businessNetworkConnection.buildQuery(      `SELECT org.hyperledger.composer.system.HistorianRecord          WHERE (transactionType == 'AddAsset' OR transactionType == 'UpdateAsset' OR transactionType == 'RemoveAsset')`  );        await businessNetworkConnection.query(q1);What next?Applying queries to a business network.Emitting events from transactions.Hyperledger Composer API documentation.",
        "url": "/composer/latest/reference/historian"
      }
      ,
    
      "managing-id-cards-playground": {
        "title": "Creating, Exporting, and Importing Business Network Cards",
        "author": "",
        "category": "tasks",
        "content": "Creating, Exporting, and Importing Business Network CardsBusiness network cards are represented by .card files containing a metadata.JSON file, a connection profile, and optional certificates.Business network cards can be used in the Hyperledger Composer Playground to manage identities for different business networks and connection profiles.Creating Business Network CardsBusiness network cards can be created in the wallet screen, created from the component files, or created within a business network.Please note: If cards are created from the wallet screen, or created from the component files, there must be a corresponding identity already created in the business network.Creating a business network card within a business networkFrom the My Wallet screen, select an identity to use to connect to your business network. Click Connect Now. Please note: You must use an identity with the permission to create new identities.Optional: To create a participant to assign to the identity, click the Test tab, and click Create New Participant.Click the name of your identity in the upper right, and click ID Registry.Click Issue New ID.Choose an ID Name, and select a Participant to associate the new identity with.Click Create New.Click Add to My Wallet. Adding the business network card to your wallet allows you to use it to connect to the business network, or export it for someone else to use.The My Wallet screen should now show the new business network card.Creating a business network card from the WalletA business network card can be created from the My Wallet page, however, a corresponding identity must already have been created in the business network. Creating a business network card from the My Wallet page requires that you use the same User ID, User Secret and the correct Business network name credentials as when the identity was created within the business network.To create a business network card from the My Wallet page:After receiving a valid User ID and User Secret, click the Create Business Network Card button in the upper right of the My Wallet page.Select a connection profile and click Next.Enter the User ID and User Secret that were generated when the identity was created.Enter the correct Business Network Name and click Create.The business network card should now be displayed in the My Wallet page.Creating a business network card from component filesbusiness network cards are composite files containing up to three elements:A connection profile. (connection.json)A metadata file containing the data for the identity to use to connect to the business network. (metadata.json)An optional credentials directory containing a certificate and private key for the identity in files named certificate and privateKey respectively.Please note: If there is no credentials directory, the metadata file must contain the enrollment secret required to obtain the credentials with the property name enrollmentSecret. If an enrollmentSecret is specified and the business network card is used to connect to a business network, a credentials directory with certificates will be created and populated if the business network card is exported.The metadata file should take the following format:{    \"version\": 1,    \"userName\": \"alice\",    \"description\": \"Alice's identity for basic-sample-network\",    \"businessNetwork\": \"basic-sample-network\",    \"enrollmentSecret\": \"UserSecret\",    \"roles\": [    ]}The businessNetworkName, description, enrollmentSecret, and roles properties are optional. The available roles are PeerAdmin and ChannelAdmin.To create the business network card file, run the composer card create command.This business network card can now be imported using the Hyperledger Composer Playground.Importing and Exporting business network cardsImporting and exporting business network cards is the simplest way to grant access to other users of the business network in Playground. Valid business network cards must be created using one of the methods above, but can then be exported and sent to other users.Exporting Business Network CardsTo export a business network card create an identity by using a business network and add the business network card to your wallet.On the My Wallet page, click the Export icon on the business network card you wish to export. The business network card should download as a .card file.Please note: If you export a business network card that has never been used, for example to send to a new participant, it will contain the enrollment ID and enrollment secret required to obtain the certificate and private key which are then used to identify participants. Alternatively, if you export a business network card that has been used before, it will already contain the certificate and private key.Important: Exported identity cards should be handled with care since they contain unprotected credentials. For example, you should never send identity cards via email or other unencrypted means of communication.Importing Business Network CardsImporting a business network card allows you to connect to a business network without creating a connection profile, identity, and certificates. Members of a business network can create business network cards and export them to give others access to a business network.On the My Wallet screen, click Import business network card in the upper right.Drag and drop, or browse, to select a business network card (.card) file to import. Click Import.The business network card should now be visible in your wallet.",
        "url": "/composer/latest/managing/id-cards-playground"
      }
      ,
    
      "playground-id-cards-playground": {
        "title": "Business Network Cards",
        "author": "",
        "category": "tasks",
        "content": "Business Network CardsA Business Network Card provides all of the information needed to connect to a blockchain business network. It is only possible to access a blockchain Business Network through a valid Business Network Card. A Business Network Card contains and Identity for a single Participant within a deployed business network. Business Network Cards are used in the Hyperledger Composer Playground to connect to deployed Business Networks. You can have multiple Business Network Cards for a single deployed Business Network, where those Business Network Cards belong to multiple Participants.Business Network Cards are grouped under a Connection Profile, and each card shows the business network that may be accessed using the displayed Identity via the Connect now option. A Business Network Card may be deleted or exported using the icons present on the card.Here is a Business Network Card that may be used to connect to the business network named &#39;my-business-network&#39; using the Identity &#39;New User&#39;A Business Network Card can be created when an Identity is issued within the Playground. This Business Network Card can then be exported and shared with others, allowing them to connect to the business network using the issued identity. If a user is provided with an Enrollment ID and Secret by an administrator, which corresponds to a valid Identity within a business network, then a Business Network Card may be directly created in the Playground. It is also possible to manually create a Business Network Card.Creating a peer admin card using PlaygroundDeploying a business network to a Hyperledger Fabric instance for the first time requires that the Hyperledger Composer chaincode be installed on the relevant Hyperledger Fabric peers, and that the business network then be instantiated on the channel. This process requires special Hyperledger Fabric privileges possessed by a peer or channel administrator.A peer admin business network card must be created in order to deploy a Hyperledger Composer business network to a Hyperledger Fabric instance. To create the peer admin business network card:From the My Business Networks screen, click Create Business Network Card.Select Hyperledger Fabric v1.2 and click Next.Enter the details of your connection profile. For a better understanding of creating a connection profile, see Deploying to Hyperledger Fabric and click Next.Select Certificates and upload the certificate and private key information for the peer admin identity. The Deploying to Hyperledger Fabric tutorial gives an overview of where to find the correct certificates.Enter a name for the business network card.Select Admin Card, and then Peer Admin and Channel Admin.Click NextThe peer admin card should now be present in your My Business Networks screen. You can now deploy a business network to the Hyperledger Fabric instance using Playground.Providing Access To Your Business Network With a Business Network CardAccess to your Business Network is granted to another user through the provision of a Business Network Card. Once created, the Business Network Card may be exported and provided to the user for whom the card was created.There must be a Participant existing in the business network in order to bind an Identity required to create the Business Network Card.When an identity is issued within Playground, there is an option to save the identity for use in your Business Networks page. By selecting this option a Business Network Card is created for the issued identity that is valid for the current business network. The Business Network Card will appear on your Business Networks page once you log out of the current business network, and it is from this location where it may be exported to share with another user.Creating a Business Network CardFrom the Business Networks page, select an identity to use to connect to your business network. Click Connect Now. Please note: You must use an identity that has permission to create new identities.If required, create the participant to which you intend to assign the identity:Click the Test tab, and click Create New Participant.Complete the Participant definition and click Create New.        Click the name of your identity in the upper right, and click ID Registry within the drop down.Click +Issue New ID.Choose an ID Name, and input an existing Participant to associate the new identity with. A look-ahead service is provided to auto-complete on known Participants.Click Create New.Click Add to My Wallet. Adding the Business Network Card to your Business Networks page allows you to use it to connect to the business network, or export it for someone else to use.The Business Networks page should now show the new Business Network Card.Exporting a Business Network CardBusiness Network Cards are exported from the Business Networks page in Playground, through interaction with the Business Network Card that you wish to export and is a one-step process.On the Business Networks page, click the Export icon on the Business Network Card you wish to export. The Business Network Card should download as a .card file.Please note: If you export a Business Network Card that has never been used, for example to send to a new participant, it will contain the enrollment ID and enrollment secret required to obtain the certificate and private key which are then used to identify Participants. Alternatively, if you export a Business Network Card that has been used before, it will already contain the certificate and private key. For more information on Participants and Identities, please see our main documentation.Important: Exported identity cards should be handled with care since they contain unprotected credentials. We recommend that you only send identity cards that have been encrypted.Gaining Access To A Business NetworkImporting a Business Network CardImporting a Business Network Card allows you to connect to a deployed business network.On the Business Networks page, click Import Business Network Card in the upper right.Drag and drop, or browse, to select a Business Network Card (.card) file to import. Click Import.The Business Network Card should now be visible in your Business Networks page; you can now connect to the deployed Business Network.Connecting using CredentialsThere are two ways a Business Network Card can be created from the Business Networks page.A Business Network Card can be created using certificates, which requires the following: a certificate and private key, provided by an admin of a business network; a name for the Business Network Card; the business network name for which the credentials are valid; the Connection Profile details for the runtime on which the target business network is deployed.To create a Business Network Card from the Business Networks page using certificates:After receiving a certificate and private key, click the Connect using credentials button in the upper right of the Business Networks page.If you have previously connected to the deployed runtime, select it from the displayed list, click Next and proceed to step 4; otherwise select the radio option to connect to a new Blockchain and click Next.Specify the Connection Profile details that were provided to you and click Save.Enter the certificate, private key, an Business Network Card name and business network name, and click Create.The Business Network Card should now be displayed in the Business Networks page.Manually Creating a Business Network CardBusiness Network Cards are archive (.zip) files containing up to three elements:A Connection Profile. (.json)A metadata file containing the data for the Identity to use to connect to the Business Network. (metadata.json)An optional credentials directory containing a certificate and private key.Please note: If there is no credentials directory, the metadata file must contain the Enrollment Secret property with the property name enrollmentSecret. If an enrollmentSecret is specified, a credentials directory with certificates will be created and populated if the Business Network Card is exported.The metadata file should take the following format:{    \"name\": \"PeerAdmin\",    \"description\": \"A valid Business Network Card\",    \"businessNetwork\": \"basic-sample-network\",    \"enrollmentId\": \"UserID\",    \"enrollmentSecret\": \"UserSecret\",    \"roles\": [    ]}The businessNetworkName, image, enrollmentSecret, and roles properties are optional. The available roles are PeerAdmin and ChannelAdmin.To create the Business Network Card file, compress the Connection Profile, metadata file, and optionally a credentials directory, then modify the file type to .card.This Business Network Card can now be imported using the Hyperledger Composer Playground.",
        "url": "/composer/latest/playground/id-cards-playground"
      }
      ,
    
      "managing-identity-bind": {
        "title": "Binding an existing identity to a participant",
        "author": "",
        "category": "tasks",
        "content": "Binding an existing identity to a participantAn existing identity can be issued to a participant using either the API or the command line.Once the existing identity has been bound, the identity can then be used by the participantto interact with the business network in the context of that participant.When using Hyperledger Fabric, you can bind existing certificates that have been createdby using the Hyperledger Fabric certificate authority (CA) or by using other tooling suchas cryptogen. The existing certificates must be valid for use for submitting transactionson the Hyperledger Fabric network.Before you startBefore you follow these steps, you must have added a participant to a participantregistry. You must have an existing certificate in the PEM format to bind to theparticipant. The binder of the existing identity (whether using command line orusing the Javascript APIs below) must have ACLs that permit them to bind the identity(to be associated with the participant) in Hyperledger Composer.The procedure below shows an example using the following model of a participantfrom the Digital Property sample Business Network Definition: digitalproperty-networknamespace net.biz.digitalPropertyNetworkparticipant Person identified by personId {  o String personId  o String firstName  o String lastName}The example assumes that an instance, net.biz.digitalPropertyNetwork#mae@biznet.org,of that participant has been created and placed into a participant registry.ProcedureConnect to the business network and bind an existing identity to a participantJavaScript API  const BusinessNetworkConnection = require('composer-client').BusinessNetworkConnection;  async function bind() {      let businessNetworkConnection = new BusinessNetworkConnection();      let certificate = `-----BEGIN CERTIFICATE-----            MIIB8DCCAZegAwIBAgIURanHh55fqrUecvHNHtcMKiHJRkwwCgYIKoZIzj0EAwIw            czELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNh            biBGcmFuY2lzY28xGTAXBgNVBAoTEG9yZzEuZXhhbXBsZS5jb20xHDAaBgNVBAMT            E2NhLm9yZzEuZXhhbXBsZS5jb20wHhcNMTcwNzI3MTc0MzAwWhcNMTgwNzI3MTc0            MzAwWjAQMQ4wDAYDVQQDEwVhZG1pbjBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IA            BAANIGFIrXXr5+h0NfUNJhx5YFQ4w6r182eZYRhc9KvYQhYo5D0ZbecfR9sGX2b6            0aW+C7bUaXc6DU3pJSD4fNijbDBqMA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8E            AjAAMB0GA1UdDgQWBBRwuAyWrGlzVQFqRf0OqoTNuoq7QDArBgNVHSMEJDAigCAZ            q2WruwSAfa0S5MCpqqZknnCGjjq9AhejItieR+GmrjAKBggqhkjOPQQDAgNHADBE            AiBcj/JvxmKHel4zQ3EmjITEFhdYku5ijIZEDuR5v9HK3gIgTUbVEfq3MuasVZKx            rkM5DH3e5ECM7T+T1Ovr+1AK6bs=            -----END CERTIFICATE-----`       try {            await businessNetworkConnection.connect('admin@digitalPropertyNetwork');           await businessNetworkConnection.bindIdentity('net.biz.digitalPropertyNetwork.Person#mae@biznet.org', certificate);           await businessNetworkConnection.disconnect();       } catch(error) {           console.error(error);           process.exit(1);       }  }  bind();Command linecomposer identity bind -c admin@digitalPropertyNetwork -a \"resource:net.biz.digitalPropertyNetwork.Person#mae@biznet.org\" -e mae-pub.pemAs the participant, test the connection to the business networkJavaScript API  const BusinessNetworkConnection = require('composer-client').BusinessNetworkConnection;  async function testConnection() {      let businessNetworkConnection = new BusinessNetworkConnection();      try {          await businessNetworkConnection.connect('admin@digitalPropertyNetwork');          let result = await businessNetworkConnection.ping();          console.log(`participant = ${result.participant ? result.participant : '&lt;no participant found&gt;'}`);          await businessNetworkConnection.disconnect();      } catch(error) {          console.error(error);          process.exit(1);      }  }  testConnection();Command linecomposer network ping -c admin@digitalPropertyNetworkThe participant ID will be printed to the console, and should match the participant  ID that was specified in the composer identity bind command.",
        "url": "/composer/latest/managing/identity-bind"
      }
      ,
    
      "managing-identity-issue": {
        "title": "Issuing a new identity to a participant",
        "author": "",
        "category": "tasks",
        "content": "Issuing a new identity to a participantA new identity can be issued to a participant using either the API, the command line, or by using ID cards in the Hyperledger Composer Playground. Once a new identity has been issued, the identity can then be used by the participant to interact with the business network in the context of that participant.When using Hyperledger Fabric, Hyperledger Composer issues new identities by using the Hyperledger Fabric certificate authority (CA) to register new enrollment certificates. The Hyperledger Fabric certificate authority generates an enrollment secret that can be given to the participant, who can then use the enrollment secret to request their enrollment certificate and private keys from the Hyperledger Fabric certificate authority.Before you startBefore you follow these steps, you must have added a participant to a participant registry. The issuer of a new identity (whether using command line or using the Javascript APIs below) must itself have &#39;issuer&#39; authority and as appropriate, ACLs that permit them to issue the identity (to be associated with the participant) in Hyperledger Composer.The procedure below shows an example using the following model of a participant from the Digital Property sample Business Network Definition: digitalproperty-networknamespace net.biz.digitalPropertyNetworkparticipant Person identified by personId {  o String personId  o String firstName  o String lastName}The example assumes that an instance, net.biz.digitalPropertyNetwork#mae@biznet.org, of that participant has been created and placed into a participant registry.ProcedureConnect to the business network and issue a new identity to a participantJavaScript API  const BusinessNetworkConnection = require('composer-client').BusinessNetworkConnection;  async function identityIssue() {      let businessNetworkConnection = new BusinessNetworkConnection();      try {          await businessNetworkConnection.connect('admin@digitalPropertyNetwork');          let result = await businessNetworkConnection.issueIdentity('net.biz.digitalPropertyNetwork.Person#mae@biznet.org', 'maeid1')          console.log(`userID = ${result.userID}`);          console.log(`userSecret = ${result.userSecret}`);          await businessNetworkConnection.disconnect();      } catch(error) {          console.log(error);          process.exit(1);      }  }  identityIssue();Command line  composer identity issue -c admin@network -f maeid1.card -u maeid1 -a \"resource:net.biz.digitalPropertyNetwork.Person#mae@biznet.org\"This will issue card for the user maeid1 and export a card file in your current directory.As the participant, test the connection to the business networkJavaScript API  const BusinessNetworkConnection = require('composer-client').BusinessNetworkConnection;  async function testConnection() {      let businessNetworkConnection = new BusinessNetworkConnection();      try {          await businessNetworkConnection.connect('admin@digitalPropertyNetwork');          let result = await businessNetworkConnection.ping();          console.log(`participant = ${result.participant ? result.participant : '&lt;no participant found&gt;'}`);          await businessNetworkConnection.disconnect();      } catch((error) {          console.error(error);          process.exit(1);      }  }  testConnection();Command line  composer card import -f maeid1@network.card  composer network ping -c maeid1@networkYou need to make sure to import the card into business network before pinging.",
        "url": "/composer/latest/managing/identity-issue"
      }
      ,
    
      "managing-identity-list": {
        "title": "Listing all identities in a business network",
        "author": "",
        "category": "tasks",
        "content": "Listing all identities in a business networkWhen a new identity is issued to a participant, or an existing identity is bound to aparticipant, a mapping between the identity and the participant is created in the identityregistry in the deployed business network. When that participant uses that identity tosubmit transactions to the deployed business network, the Composer runtime looks for avalid mapping for that identity in the identity registry. This lookup is done usingthe public key signature or fingerprint, essentially a hash of the certificate contentsthat is unique to that certificate and identity.In order to perform identity management operations in a deployed business network, youwill need to list and review the set of identities in the identity registry.Before you startBefore you follow these steps, you should have added a participant to a participantregistry, and issued a new identity or bound an existing identity to that participant.Otherwise the identity registry will be empty and you will not see any results.ProcedureConnect to the business network and list the identities in the identity registryJavaScript API  const BusinessNetworkConnection = require('composer-client').BusinessNetworkConnection;  async function identityList() {      let businessNetworkConnection = new BusinessNetworkConnection();      try {          await businessNetworkConnection.connect('admin@digitalPropertyNetwork');          let identityRegistry = await businessNetworkConnection.getIdentityRegistry();          let identities = await identityRegistry.getAll();          identities.forEach((identity) =&gt; {            console.log(`identityId = ${identity.identityId}, name = ${identity.name}, state = ${identity.state}`);          });          await businessNetworkConnection.disconnect();      } catch(error) {          console.log(error);          process.exit(1);      }  }Command linecomposer identity list -c admin@digitalPropertyNetwork",
        "url": "/composer/latest/managing/identity-list"
      }
      ,
    
      "managing-identity-revoke": {
        "title": "Revoking an identity from a participant",
        "author": "",
        "category": "tasks",
        "content": "Revoking an identity from a participantAn identity can be revoked from a participant using either the API or the command line.Once an identity has been revoked, the identity can no longer be used by the participantto interact with the business network in the context of that participant.When using Hyperledger Fabric, Hyperledger Composer does not currentlyattempt to revoke the identity by using the Hyperledger Fabric certificate authority (CA)APIs. The identity can still be used to submit transactions to the underlying Blockchainnetwork, but the transactions will be rejected by the deployed business network.Before you startBefore you follow these steps, you must have added a participant to a participantregistry, and issued or bound an identity to that participant. You must also findthe unique identifier for that identity in the identity registry. For more informationon finding the unique identifiers for identities, look at Listing all identities in a business network.The procedure below shows an example using the following model of a participantfrom the Digital Property sample Business Network Definition: digitalproperty-networknamespace net.biz.digitalPropertyNetworkparticipant Person identified by personId {  o String personId  o String firstName  o String lastName}The example assumes that an instance, net.biz.digitalPropertyNetwork#mae@biznet.org,of that participant has been created and placed into a participant registry.The example also assumes that an identity maeid1 has been issued to that participant,and the unique identifier for that identity is &#39;f1c5b9fe136d7f2d31b927e0dcb745499aa039b201f83fe34e243f36e1984862&#39;.ProcedureConnect to the business network and revoke an existing identity from a participantJavaScript API    const BusinessNetworkConnection = require('composer-client').BusinessNetworkConnection;    async function revoke() {        let businessNetworkConnection = new BusinessNetworkConnection();        try {            await businessNetworkConnection.connect('admin@digitalPropertyNetwork');            await businessNetworkConnection.revokeIdentity('f1c5b9fe136d7f2d31b927e0dcb745499aa039b201f83fe34e243f36e1984862')            await businessNetworkConnection.disconnect();        } catch(error) {            console.log(error);            process.exit(1);        }     }    revoke();Command linecomposer identity revoke -c admin@digitalPropertyNetwork -u f1c5b9fe136d7f2d31b927e0dcb745499aa039b201f83fe34e243f36e1984862",
        "url": "/composer/latest/managing/identity-revoke"
      }
      ,
    
      "": {
        "title": "Hyperledger Composer - Create business networks and blockchain applications quickly for Hyperledger",
        "author": "",
        "category": "",
        "content": "                                        Build Blockchain applications and business networks your way                                    Install Hyperledger Composer                                        Try it online                                                                        or learn more about a typical Composer                    architecture...                                                                                                                                                                                                                                                                                                                                                                                Really simple models        Define a business network in our purpose-built modelling language, and script transactions in JavaScript: the            most popular language on the planet.                        Quick reusable POCs        Rather than weeks, think hours to develop production-ready applications that go from the web-browser all the            way back to the blockchain.                        Data integration        From enterprise systems of record to best of breed dev ops: Composer uses LoopBack to connect your blockchain            to your existing systems.                                                We’re Open Source: Join in!            Calls happen every Thursday.            Learn how to join                        In our open community meetings, we show new features, review designs for future work, and seek any areas                to improve. Join the discussion or just listen in!                                                                                                                            @hyperledger                                                                                                                                #hyperledger-composer                                                                                                                                                                            /hyperledger                                                                                                                                chat.hyperledger.org                                        Visit the community page for                more information.            ",
        "url": "/composer/latest/"
      }
      ,
    
      "installing-installing-index": {
        "title": "Installing",
        "author": "",
        "category": "tasks",
        "content": "Installing Hyperledger Composer Installing pre-requisitesMake sure you have the required pre-requisites by following Installing pre-requisites.Installing the development environmentTo install the full development environment click Installing the development environment here or in the table of contents on the left.Updating the development environmentTo update the full development environment click Updating the development environment here or in the table of contents on the left.Uninstalling the development environmentTo uninstall the full development environment click Uninstalling the development environment here or in the table of contents on the left.",
        "url": "/composer/latest/installing/installing-index"
      }
      ,
    
      "installing-installing-prereqs": {
        "title": "Installing pre-requisites",
        "author": "",
        "category": "start",
        "content": "Installing pre-requisitesThe Hyperledger Composer pre-requisites can be installed on Ubuntu or MacOS.  Choose your operating system to jump to the appropriate section, or scroll down to find the instructions:Ubuntu Mac OSUbuntuTo run Hyperledger Composer and Hyperledger Fabric, we recommend you have at least 4Gb of memory.The following are prerequisites for installing the required development tools:Operating Systems: Ubuntu Linux 14.04 / 16.04 LTS (both 64-bit), or Mac OS 10.12Docker Engine: Version 17.03 or higherDocker-Compose: Version 1.8 or higherNode: 8.9 or higher (note version 9 is not supported)npm: v5.xgit: 2.9.x or higherPython: 2.7.xA code editor of your choice, we recommend VSCode.**If installing Hyperledger Composer using Linux, be aware of the following advice:Login as a normal user, rather than root.Do not su to root.When installing prerequisites, use curl, then unzip using sudo.Run prereqs-ubuntu.sh as a normal user. It may prompt for root password as some of it&#39;s actions are required to be run as root.Do not use npm with sudo or su to root to use it.Avoid installing node globally as root.**If you&#39;re running on Ubuntu, you can download the prerequisites using the following commands:curl -O https://hyperledger.github.io/composer/latest/prereqs-ubuntu.shchmod u+x prereqs-ubuntu.shNext run the script - as this briefly uses sudo during its execution, you will be prompted for your password../prereqs-ubuntu.shWhat next?Congratulations, the installation of the pre-requisites for Hyperledger Composer is complete! You can now proceed with Installing the development environment.Mac OSFollow these instructions to install the pre-requsities for installing Hyperledger Composer on a local Mac OS X machine. You need to install these tools before you attempt to install Hyperledger Composer.Note Mac OS X version 10.12.6 was used for these instructions.Install nvm and Apple XcodeFirst install nvm (the Node version manager). nvm is a tool that allows you to easily install, update and switch between versions of Node.js.Open the terminal (command line) by clicking on the magnifier in the menu bar at the top right of your screen. Type terminal and press enter.In the terminal window paste the text below and press enter:curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bashMore information on this script and the Node install process is available here.When you hit enter you should see the pop-up below, prompting you to install git. Press the Get Xcode button to install the full Apple Xcode IDE, including a C++ compiler, used to install native Node.js modules.The download and install process for Xcode may take 20 minutes or more. Be patient!After the installation of Xcode has completed launch Xcode. Accept the license agreement. It will prompt you for your username and password and will install additional components.After Xcode finishes installing additional components and launches, simply quit Xcode.Switch back to the terminal and create your bash profile (stores user preferences for bash):touch .bash_profileThen rerun the original curl command:curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bashClose the terminal and reopen it.Check that nvm is installed and is accessible:nvm —-versionInstall NodeInstall the latest (long term support) version of Node:nvm install --ltsSwitch to the LTS version of Node:nvm use --ltsCheck that Node is installed:node --versionInstall DockerFollow the instructions here to install Docker for Mac (stable):https://docs.docker.com/docker-for-mac/install/After running the installed Docker application you should have the whale icon in your menu bar, with a green “Docker is running” status.Install VSCodeInstall VSCode by visiting:https://code.visualstudio.comPress the “Download for Mac” button and copy the downloaded application into your Applications folder.Install the Hyperledger Composer Extension for VSCodeLaunch VSCode and then press the “Extensions” button on the vertical left toolbar.Type composer into the search bar and then press the Install button next to the Hyperleger Composer extension. Once the install completes you need to press the Reload button to activate the extension.What next?Congratulations, the installation of the pre-requisites for Hyperledger Composer is complete! You can now proceed with Installing the development environment.",
        "url": "/composer/latest/installing/installing-prereqs"
      }
      ,
    
      "integrating-integrating-index": {
        "title": "Integrating Existing Systems",
        "author": "",
        "category": "concepts",
        "content": "Integrating existing systemsHyperledger Composer can be integrated with existing systems by using a Loopback API. Integrating existing systems allows you to pull data from existing business systems and convert it to assets or participants in a Composer business network.Generating a REST APIHyperledger Composer includes a standalone Node.js process that exposes a business network as a REST API. The LoopBack framework is used to generate an Open API, described by a Swagger document.Publishing events from the REST serverThe REST server can be configured to subscribe to events emitted from a deployed business network, and publish those events to client applications.Enabling authentication for the REST serverThe REST server can be configured to authenticate clients. When this option is enabled, clients must authenticate to the REST server before they are permitted to call the REST API.Enabling multiple user mode for the REST serverThe REST server can be configured to multiple user mode. Multiple user mode permits clients of the REST server to provide their own Blockchain identities for digitally signing transactions. This enables the business network to differentiate between different clients of the REST server.Securing the REST server using HTTPS and TLSWhen deploying Hyperledger Composer REST server in a production environment, the REST server should be configured to be secured with HTTPS and TLS (Transport Layer Security). Once the REST server has been configured with HTTPS and TLS, all data transferred between the REST server and all of the REST clients is encrypted.Deploying the REST server for a business networkBy deploying a REST server for a business network, you can integrate existing systems and data with your Hyperledger Composer business network, allowing you to create, update, or delete assets and participants, as well as get and submit transactions.Customizing the REST server for a business networkBy customizing a REST server for a business network, you can add your own code to implement new custom REST APIs for your business applications or additional authentication mechanisms that are not supported by the standard REST server,Integrating with Node-REDNode-RED includes a number of Hyperledger Composer nodes allowing you to submit transactions, read, update and delete assets and participants, and subscribe to events.Calling external HTTP or REST servicesTransaction processor functions can be used to call external REST services. This allows you to move complex computation off the blockchain.For instructions on setting up a Loopback API, see Generating a REST API.",
        "url": "/composer/latest/integrating/integrating-index"
      }
      ,
    
      "introduction-introduction": {
        "title": "Introduction",
        "author": "",
        "category": "overview",
        "content": "Welcome to Hyperledger ComposerHyperledger Composer is an extensive, open development toolset and framework to make developing blockchain applications easier. Our primary goal is to accelerate time to value, and make it easier to integrate your blockchain applications with the existing business systems. You can use Composer to rapidly develop use cases and deploy a blockchain solution in weeks rather than months. Composer allows you to model your business network and integrate existing systems and data with your blockchain applications.Hyperledger Composer supports the existing Hyperledger Fabric blockchain infrastructure and runtime, which supports pluggable blockchain consensus protocols to ensure that transactions are validated according to policy by the designated business network participants.Everyday applications can consume the data from business networks, providing end users with simple and controlled access points.You can use Hyperledger Composer to quickly model your current business network, containing your existing assets and the transactions related to them; assets are tangible or intangible goods, services, or property. As part of your business network model, you define the transactions which can interact with assets. Business networks also include the participants who interact with them, each of which can be associated with a unique identity, across multiple business networks.How does Hyperledger Composer work in practice?For an example of a business network in action; a realtor can quickly model their business network as such:Assets: houses and listingsParticipants: buyers and homeownersTransactions: buying or selling houses, and creating and closing listingsParticipants can have their access to transactions restricted based on their role as either a buyer, seller, or realtor. The realtor can then create an application to present buyers and sellers with a simple user interface for viewing open listings and making offers. This business network could also be integrated with existing inventory system, adding new houses as assets and removing sold properties. Relevant other parties can be registered as participants, for example a land registry might interact with a buyer to transfer ownership of the land.Where do I go from here?To try Hyperledger Composer right away, see the Online PlaygroundFor an introduction to Composer components and concepts, see Key ConceptsFor an architectural overview of a typical solution built with Composer, see Typical Solution Architecture",
        "url": "/composer/latest/introduction/introduction"
      }
      ,
    
      "tutorials-invoke-composer-network": {
        "title": "Interacting with other business networks",
        "author": "",
        "category": "tutorials",
        "content": "Interacting with other business networksHyperledger Composer includes functionality that can be used by a business network to access an asset, participant, or transaction that is recorded in another business network.This tutorial will demonstrate the steps that a business network developer needs to take in order to invoke a Hyperledger Composer business network from a different business network. As part of the tutorial you will deploy the same business network twice. The business networks in this tutorial will be on the same channel, but they can be on different channels. The business network used in this example will be the tutorial network that is outlined in the developer tutorial. This tutorial will refer to the business networks as &quot;A&quot; and &quot;B&quot;PrerequisitesBefore you continue, ensure that you have followed the steps in installing a development environment.Step One: Starting a Hyperledger Fabric networkIn order to follow this tutorial, you must start a Hyperledger Fabric network. You can use the simple Hyperledger Fabric network provided in the development environment, or you can use your own Hyperledger Fabric network that you have built by following the Hyperledger Fabric documentation.The tutorial will assume that you use the simple Hyperledger Fabric network provided in the development environment. If you use your own Hyperledger Fabric network, then you must map between the configuration detailed below and your own configuration.Start a clean Hyperledger Fabric by running the following commands:cd ~/fabric-dev-serversexport FABRIC_VERSION=hlfv12./stopFabric.sh./teardownFabric.sh./downloadFabric.sh./startFabric.shDelete any business network cards that may exist in your wallet. It is safe to ignore any errors that state that the business network cards cannot be found:composer card delete -c PeerAdmin@hlfv1If these commands fail, then you have business network cards from a previous version and you will have to delete the file system card store.    rm -fr ~/.composerCreate the Peer Admin Card by running the following command        ./createPeerAdminCard.shStep Two: Define the business networksFollow steps one and two in the developer tutorial. This will be network A.Follow steps one and two again but create a business network called other-tutorial-network. This will be network B.The transaction logic needs to be updated in network A and to query an asset in business network B and then update the quantity property of an asset in business network A.Replace the contents of the logic.js script file to update the transaction processor function to be the following.        /**         * Track the trade of a commodity from one trader to another         * @param {org.example.mynetwork.Trade} trade - the trade to be processed         * @transaction         */        async function tradeCommodity(trade) {            trade.commodity.owner = trade.newOwner;            const otherNetworkData = await getNativeAPI().invokeChaincode('other-tutorial-network', ['getResourceInRegistry', 'Asset', 'org.example.mynetwork.Commodity', trade.commodity.tradingSymbol], 'composerchannel');                                const stringAsset = new Buffer(otherNetworkData.payload.toArrayBuffer()).toString('utf8');            const asset = getSerializer().fromJSON(JSON.parse(stringAsset));            trade.commodity.quantity = asset.quantity;            const assetRegistry = await getAssetRegistry('org.example.mynetwork.Commodity');            await assetRegistry.update(trade.commodity);        }Follow step three in the developer tutorial.Step Three: Deploy the business networksInstall and start business network A using the following commandscomposer network install --card PeerAdmin@hlfv1 --archiveFile tutorial-network@0.0.1.bnacomposer network start --networkName tutorial-network --networkVersion 0.0.1 --networkAdmin admin --networkAdminEnrollSecret adminpw --card PeerAdmin@hlfv1 --file networkA.cardcomposer card import --file networkA.card --card networkAInstall and start business network B using the following commandscomposer network install --card PeerAdmin@hlfv1 --archiveFile other-tutorial-network@0.0.1.bnacomposer network start --networkName other-tutorial-network --networkVersion 0.0.1 --networkAdmin admin --networkAdminEnrollSecret adminpw --card PeerAdmin@hlfv1 --file networkB.cardcomposer card import --file networkB.card --card networkBTo check that the business networks have been deployed successfully run the following commands to ping the business networkscomposer network ping --card networkAcomposer network ping --card networkBStep Four: Create the assetsCreate a participant in business network A. Run the following command.composer participant add --card networkA -d '{\"$class\": \"org.example.mynetwork.Trader\", \"tradeId\": \"bob@example.com\", \"firstName\": \"Bob\", \"lastName\": \"Jones\"}'Create an asset in business network  Acomposer transaction submit --card networkA -d '{\"$class\": \"org.hyperledger.composer.system.AddAsset\", \"targetRegistry\" : \"resource:org.hyperledger.composer.system.AssetRegistry#org.example.mynetwork.Commodity\", \"resources\": [{\"$class\": \"org.example.mynetwork.Commodity\",\"tradingSymbol\": \"Ag\",\"owner\": \"resource:org.example.mynetwork.Trader#bob@example.com\",\"description\": \"a lot of gold\", \"mainExchange\": \"exchange\", \"quantity\" : 250}]}'Create a participant in business network B. Run the following command.composer participant add --card networkB -d '{\"$class\": \"org.example.mynetwork.Trader\", \"tradeId\": \"fred@example.com\", \"firstName\": \"Fred\", \"lastName\": \"Bloggs\"}'Create an asset in business network B. Run the following command. Note the different quantity property.composer transaction submit --card networkB -d '{\"$class\": \"org.hyperledger.composer.system.AddAsset\", \"targetRegistry\" : \"resource:org.hyperledger.composer.system.AssetRegistry#org.example.mynetwork.Commodity\", \"resources\": [{\"$class\": \"org.example.mynetwork.Commodity\",\"tradingSymbol\": \"Ag\",\"owner\": \"resource:org.example.mynetwork.Trader#fred@example.com\",\"description\": \"a lot of gold\", \"mainExchange\": \"exchange\", \"quantity\" : 500}]}'Step Five: Bind the identity on network A to the participant on network BExport the networkA card to get the credentialscomposer card export -c networkAUnzip the card, you may need to rename networkA.card to networkA.zip.Bind the identity to the participant. Run the following command.composer identity bind --card networkB --participantId resource:org.hyperledger.composer.system.NetworkAdmin#admin --certificateFile ./networkA/credentials/certificate           Create a card with the bound identity.composer card create -p ~/.composer/cards/networkB/connection.json --businessNetworkName other-tutorial-network -u admin -c ./networkA/credentials/certificate  -k ./networkA/credentials/privateKey -f newNetworkB.cardImport the cardcomposer card import --file newNetworkB.card --card newNetworkBPing the network to activate the identitycomposer network ping --card newNetworkBStep Six: Review the asset dataView the asset to see that the quantity is 250.    composer network list --card networkA -r org.example.mynetwork.Commodity -a Ag        Step Seven: Submit a transactionSubmit a transaction to see the effect of querying an asset on a different business network. Note that NetworkB is only queried and the quantity is not changed.      composer transaction submit --card networkA -d '{\"$class\": \"org.example.mynetwork.Trade\", \"commodity\": \"resource:org.example.mynetwork.Commodity#Ag\", \"newOwner\": \"resource:org.example.mynetwork.Trader#bobId\"}'Step Eight: Check the updated assetView the updated asset to check that the quantity was correctly updated to 500.    composer network list --card networkA -r org.example.mynetwork.Commodity -a Ag",
        "url": "/composer/latest/tutorials/invoke-composer-network"
      }
      ,
    
      "reference-js-scripts": {
        "title": "Transaction Processor Functions",
        "author": "",
        "category": "",
        "content": "Transaction Processor FunctionsA Hyperledger Composer Business Network Definition is composed of a set of model files and a set of scripts. The scripts may contain transaction processor functions that implement the transactions defined in the Business Network Definition&#39;s model files.Transaction processor functions are automatically invoked by the runtime when transactions are submitted using the BusinessNetworkConnection API.Decorators within documentation comments are used to annotate the functions with metadata required for runtime processing.Each transaction type has an associated registry storing the transactions.Transaction processor structureThe structure of transaction processor functions includes decorators and metadata followed by a JavaScript function, both parts are required for a transaction processor function to work.The first line of comments above a transaction processor function contains a human readable description of what the transaction processor function does. The second line must include the @param tag to indicate the parameter definition. The @param tag is followed by the resource name of the transaction which triggers the transaction processor function, this takes the format of the namespace of the business network, followed by the transaction name. After the resource name, is the parameter name which will reference the resource, this parameter must be supplied to the JavaScript function as an argument. The third line must contain the @transaction tag, this tag identifies the code as a transaction processor function and is required./*** A transaction processor function description* @param {org.example.basic.SampleTransaction} parameter-name A human description of the parameter* @transaction*/After the comments is the JavaScript function which powers the transaction. The function can have any name, but must include the parameter name defined in the comment as an argument.function transactionProcessor(parameter-name) {  //Do some things.}A complete transaction processor function as detailed above would take the following format:/*** A transaction processor function description* @param {org.example.basic.SampleTransaction} parameter-name A human description of the parameter* @transaction*/function transactionProcessor(parameter-name) {  //Do some things.}Writing a transaction processor functionA transaction processor function is the logical operation of a transaction defined in a model file. For example, a transaction processor function of a Trade transaction, might use JavaScript to change the owner property of an asset from one participant to another.Here&#39;s an example from the basic-sample-network, the following SampleAsset definition includes a property called value, which is defined as a string. The SampleTransaction transaction requires a relationship to an asset, the asset to be changed, the new value of the value property must be supplied as part of the transaction as a property called newValue.asset SampleAsset identified by assetId {  o String assetId  --&gt; SampleParticipant owner  o String value}transaction SampleTransaction {  --&gt; SampleAsset asset  o String newValue}The transaction processor function relating to the SampleTransaction transaction is what makes the change both to the asset and to the registry where the asset is stored.The transaction processor function defines the SampleTransaction type as the associated transaction, and defines it as the parameter tx. It then saves the original value of the asset to be changed by the transaction, replaces it with the value passed in during the submission of the transaction (the newValue property in the transaction definition), updates the asset in the registry, and then emits an event./** * Sample transaction processor function. * @param {org.example.basic.SampleTransaction} tx The sample transaction instance. * @transaction */async function sampleTransaction(tx) {    // Save the old value of the asset.    let oldValue = tx.asset.value;    // Update the asset with the new value.    tx.asset.value = tx.newValue;    // Get the asset registry for the asset.    let assetRegistry = await getAssetRegistry('org.example.basic.SampleAsset');    // Update the asset in the asset registry.    await assetRegistry.update(tx.asset);    // Emit an event for the modified asset.    let event = getFactory().newEvent('org.example.basic', 'SampleEvent');    event.asset = tx.asset;    event.oldValue = oldValue;    event.newValue = tx.newValue;    emit(event);}Error handling in transaction processor functionsTransaction processor functions will fail and roll back any changes already made an error is thrown. The whole transaction fails, not just the transaction processing, and anything changed by the transaction processor function before the error occurred will be rolled back./** * Sample transaction processor function. * @param {org.example.basic.SampleTransaction} tx The sample transaction instance. * @transaction */async function sampleTransaction(tx) {    // Do something.    throw new Error('example error');    // Execution stops at this point; the transaction fails and rolls back.    // Any updates made by the transaction processor function are discarded.    // Transaction processor functions are atomic; all changes are committed,    // or no changes are committed.}Changes made by transactions are atomic, either the transaction is successful and all changes are applied, or the transaction fails and no changes are applied.Resolving relationships in transactionsWhen assets, transactions, or participants involved in a transaction have a property which includes a relationship, the relationships are resolved automatically. All relationships, including nested relationships, are resolved before the transaction processor functions runs.The following example includes nested relationships, the transaction has a relationship with an asset, which has a relationship with a participant, because all relationships are resolved, the owner property of the asset is resolved to the specific participant.Model file:namespace org.example.basicparticipant SampleParticipant identified by participantId {  o String participantId}asset SampleAsset identified by assetId {  o String assetId  --&gt; SampleParticipant owner}transaction SampleTransaction {  --&gt; SampleAsset asset}Script file:/** * Sample transaction processor function. * @param {org.example.basic.SampleTransaction} tx The sample transaction instance. * @transaction */async function sampleTransaction(tx) {    // The relationships in the transaction are automatically resolved.    // This means that the asset can be accessed in the transaction instance.    let asset = tx.asset;    // The relationships are fully or recursively resolved, so you can also    // access nested relationships. This means that you can also access the    // owner of the asset.    let owner = tx.asset.owner;}In this example, not only can the specific asset referenced by the relationship in the transaction be referenced using tx.asset, the specific participant referenced by the owner relationship can be referenced using tx.asset.owner. In this case, tx.asset.owner would resolve to reference a specific participant.Handling asynchronous code and promises in transaction processor functionsSimilarly to relationships, transaction processor functions will wait for promises to be resolved before committing the transaction. If a promise is rejected, the transaction will fail.In the example code below there are several promises, the transaction will not be completed until each promise has returned.Model file:namespace org.example.basictransaction SampleTransaction {}Node 8 syntax is now supported which means that you can now use async/await syntax instead which is farmore concise than using promise chains. This is the recommended style.Script file:/** * Sample transaction processor function. * @param {org.example.basic.SampleTransaction} tx The sample transaction instance. * @transaction */async function sampleTransaction(tx) {    let assetRegistry = await getAssetRegistry(...);    await assetRegistry.update(...);}however if you so wish you can still use old style promise chains/** * Sample transaction processor function. * @param {org.example.basic.SampleTransaction} tx The sample transaction instance. * @transaction */function sampleTransaction(tx) {    // Transaction processor functions can return promises; Composer will wait    // for the promise to be resolved before committing the transaction.    // Do something that returns a promise.    return Promise.resolve()        .then(function () {            // Do something else that returns a promise.            return Promise.resolve();        })        .then(function () {            // Do something else that returns a promise.            // This transaction is complete only when this            // promise is resolved.            return Promise.resolve();        });}Using APIs in transaction processor functionsThe Hyperledger Composer and Hyperledger Fabric APIs can be called within transaction processor functions.Calling the Hyperledger Composer APIs in transaction processor functionsThe Hyperledger Composer API can be called simply by calling API functions with the appropriate arguments in the transaction processor function.In the code example below, the getAssetRegistry call returns a promise which is resolved before the transaction is complete.Model file:namespace org.example.basicasset SampleAsset identified by assetId {  o String assetId  o String value}transaction SampleTransaction {  --&gt; SampleAsset asset  o String newValue}Script file:/** * Sample transaction processor function. * @param {org.example.basic.SampleTransaction} tx The sample transaction instance. * @transaction */async function sampleTransaction(tx) {    // Update the value in the asset.    let asset = tx.asset;    asset.value = tx.newValue;    // Get the asset registry that stores the assets. Note that    // getAssetRegistry() returns a promise, so we have to await for it.    let assetRegistry = await getAssetRegistry('org.example.basic.SampleAsset');    // Update the asset in the asset registry. Again, note    // that update() returns a promise, so so we have to return    // the promise so that Composer waits for it to be resolved.    await assetRegistry.update(asset);}Calling Hyperledger Fabric APIs in transaction processor functionsTo call the Hyperledger Fabric API in a transaction processor function, the function getNativeAPI must be called, followed by a function from the Hyperledger Fabric API. Using the Hyperledger Fabric API gives you access to functionality which is not available in the Hyperledger Composer API.IMPORTANT: Using the Hyperledger Fabric API such as getState, putState, deleteState, getStateByPartialCompositeKey, getQueryResult functions will bypass the Hyperledger Composer access control rules (ACLs).In the example below, the Hyperledger Fabric API function getHistoryForKey is called, which returns the history of a specified asset as an iterator. The transaction processor function then stores the returned data in an array.For more information on the Hyperledger Fabric APIs you can call in a transaction processor function, see the Hyperledger Fabric API documentation.async function simpleNativeHistoryTransaction (transaction) {    const id = transaction.assetId;    const nativeSupport = transaction.nativeSupport;    const nativeKey = getNativeAPI().createCompositeKey('Asset:systest.transactions.SimpleStringAsset', [id]);    const iterator = await getNativeAPI().getHistoryForKey(nativeKey);    let results = [];    let res = {done : false};    while (!res.done) {        res = await iterator.next();        if (res &amp;&amp; res.value &amp;&amp; res.value.value) {            let val = res.value.value.toString('utf8');            if (val.length &gt; 0) {                results.push(JSON.parse(val));            }        }        if (res &amp;&amp; res.done) {            try {                iterator.close();            }            catch (err) {            }        }    }}Returning data from transaction processor functionsTransaction processor functions can optionally return data to client applications. This can be useful for returning a receipt to the submitter of the transaction, or returning an asset modified by the transaction to avoid a separate lookup of the asset after the transaction has been committed. Data can also be returned to the client application via a transaction REST API for the business network, eg a POST method to return data (as described below) to the client application.The return data for a transaction processor function must be a valid type, either a primitive type (String, Integer, Long, etc.), or a type modelled using the Composer modelling language - a concept, asset, participant, transaction, event or enumeration.The type of the return data must also be specified on the model for the transaction using the @returns(Type) decorator, and the return data must be the last thing returned by the transaction processor function. If you have multiple transaction processor functions for a single transaction, only one of those transaction processor functions can return data. If the return data is missing, or is of the wrong type, then the transaction will fail and will be rejected.Returning a primitive type from a transaction processor functionHere is an example of a transaction processor function that returns a String to a client application.Model file:namespace org.sample@returns(String)transaction MyTransaction {}Transaction processor function:/** * Handle a transaction that returns a string. * @param {org.sample.MyTransaction} transaction The transaction. * @returns [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string) The string. * @transaction */async function myTransaction(transaction) {    return 'hello world!';}Client application:const bnc = new BusinessNetworkConnection();await bnc.connect('admin@sample-network');const factory = bnc.getBusinessNetwork().getFactory();const transaction = factory.newTransaction('org.sample', 'MyTransaction');const string = await bnc.submitTransaction(transaction);console.log(`transaction returned $[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string)`);Here is an example of a transaction processor function that returns an array of integers to a client application.Model file:namespace org.sample@returns(Integer[])transaction MyTransaction {}Transaction processor function:/** * Handle a transaction that returns an array of integers. * @param {org.sample.MyTransaction} transaction The transaction. * @returns {number[]} The array of integers. * @transaction */async function myTransaction(transaction) {    return [1, 2, 3];}Client application:const bnc = new BusinessNetworkConnection();await bnc.connect('admin@sample-network');const factory = bnc.getBusinessNetwork().getFactory();const transaction = factory.newTransaction('org.sample', 'MyTransaction');const integers = await bnc.submitTransaction(transaction);for (const integer of integers) {    console.log(`transaction returned ${integer}`);}Returning a complex type from a transaction processor functionHere is an example of a transaction processor function that returns a concept to a client application. The same code can be modified to return an asset, participant, transaction or event as well.Model file:namespace org.sampleconcept MyConcept {    o String value}@returns(MyConcept)transaction MyTransaction {}Transaction processor function:/** * Handle a transaction that returns a concept. * @param {org.sample.MyTransaction} transaction The transaction. * @returns {org.sample.MyConcept} The concept. * @transaction */async function myTransaction(transaction) {    const factory = getFactory();    const concept = factory.newConcept('org.sample', 'MyConcept');    concept.value = 'hello world!';    return concept;}Client application:const bnc = new BusinessNetworkConnection();await bnc.connect('admin@sample-network');const factory = bnc.getBusinessNetwork().getFactory();const transaction = factory.newTransaction('org.sample', 'MyTransaction');const concept = await bnc.submitTransaction(transaction);console.log(`transaction returned ${concept.value}`);Here is an example of a transaction processor function that returns an array of concepts to a client application.Model file:namespace org.sampleconcept MyConcept {    o String value}@returns(MyConcept[])transaction MyTransaction {}Transaction processor function:/** * Handle a transaction that returns an array of concepts. * @param {org.sample.MyTransaction} transaction The transaction. * @returns {org.sample.MyConcept[]} The array of concepts. * @transaction */async function myTransaction(transaction) {    const factory = getFactory();    const concept1 = factory.newConcept('org.sample', 'MyConcept');    concept1.value = 'hello alice!';    const concept2 = factory.newConcept('org.sample', 'MyConcept');    concept2.value = 'hello bob!';    const concept3 = factory.newConcept('org.sample', 'MyConcept');    concept3.value = 'hello charlie!';    return [ concept1, concept2, concept3 ];}Client application:const bnc = new BusinessNetworkConnection();await bnc.connect('admin@sample-network');const factory = bnc.getBusinessNetwork().getFactory();const transaction = factory.newTransaction('org.sample', 'MyTransaction');const concepts = await bnc.submitTransaction(transaction);for (const concept of concepts) {    console.log(`transaction returned ${concept.value}`);}Returning an enumeration from a transaction processor functionHere is an example of a transaction processor function that returns an enumeration to a client application.Model file:namespace org.sampleenum MyEnum {    o HELLO    o WORLD}@returns(MyEnum)transaction MyTransaction {}Transaction processor function:/** * Handle a transaction that returns an enumeration. * @param {org.sample.MyTransaction} transaction The transaction. * @returns {org.sample.MyEnum} The enumeration. * @transaction */async function myTransaction(transaction) {    return 'HELLO';}Client application:const bnc = new BusinessNetworkConnection();await bnc.connect('admin@sample-network');const factory = bnc.getBusinessNetwork().getFactory();const transaction = factory.newTransaction('org.sample', 'MyTransaction');const enum = await bnc.submitTransaction(transaction);console.log(`transaction returned ${enum}`);Here is an example of a transaction processor function that returns an array of enumerations to a client application.Model file:namespace org.sampleenum MyEnum {    o HELLO    o WORLD}@returns(MyEnum[])transaction MyTransaction {}Transaction processor function:/** * Handle a transaction that returns an array of enumerations. * @param {org.sample.MyTransaction} transaction The transaction. * @returns {org.sample.MyEnum[]} The array of enumerations. * @transaction */async function myTransaction(transaction) {    return [ 'HELLO', 'WORLD' ];}Client application:const bnc = new BusinessNetworkConnection();await bnc.connect('admin@sample-network');const factory = bnc.getBusinessNetwork().getFactory();const transaction = factory.newTransaction('org.sample', 'MyTransaction');const enums = await bnc.submitTransaction(transaction);for (const enum of enums) {    console.log(`transaction returned ${enum}`);}Read-only transaction processor functions (query processor functions)Transactions can be modelled as being read-only by specifying the @commit(false) decorator. When a transaction is modelled as read-only, the transaction is submitted as normal, and any transaction processor functions for that transaction are executed as normal. However, the transaction is not committed - it will not be endorsed by multiple peers on the blockchain network, nor will it be sent to the ordering service, nor will it publish any events.This feature can be useful when the APIs that client applications can use to read data from the business network are too limited for your use case. These APIs include get(id) (get by ID), getAll() (get all), exists(id) (test existence), and query(q, params) (execute a complex query). For example, a client application may wish to get all of the assets across multiple business networks deployed to multiple channels in a single call to the blockchain network. Another example is reducing the result set of a query on the &quot;server&quot; (chaincode) side, before returning the result set to the client application, to reduce network traffic and the load on the client application.Here is an example of a read-only transaction processor function that retrieves a set of assets from the current business network, as well as other business networks, and returns all of the assets to the client application:Model file:namespace org.sampleasset MyAsset identified by assetId {    o String assetId    o String value}@commit(false)@returns(MyAsset[])transaction MyTransaction {}Transaction processor function:/** * Handle a transaction that returns an array of assets. * @param {org.sample.MyTransaction} transaction The transaction. * @returns {org.sample.MyAsset[]} All the assets. * @transaction */async function myTransaction(transaction) {    const allAssets = [];    const assetRegistry = await getAssetRegistry('org.sample.MyAsset');    const localAssets = await assetRegistry.getAll();    for (const asset of localAssets) {        allAssets.push(asset);    }    const businessNetworkNames = ['other-network-1', 'other-network-2'];    for (const businessNetworkName of businessNetworkNames) {        const response = await getNativeAPI().invokeChaincode(businessNetworkName, ['getAllResourcesInRegistry', 'Asset', 'org.sample.MyAsset'], 'composerchannel');        const json = JSON.parse(response.payload.toString('utf8'));        for (const item of json) {            allAssets.push(getSerializer().fromJSON(item));        }    }    return allAssets;}Client application:const bnc = new BusinessNetworkConnection();await bnc.connect('admin@sample-network');const factory = bnc.getBusinessNetwork().getFactory();const transaction = factory.newTransaction('org.sample', 'MyTransaction');const assets = await bnc.submitTransaction(transaction);for (const asset of assets) {    console.log(`transaction returned ${asset.value}`);}What next?Transaction processor functions can also be used to:Define queries for retrieving information about the blockchain world-state from a couchDB database.Define events for sending event data to applications.",
        "url": "/composer/latest/reference/js_scripts"
      }
      ,
    
      "introduction-key-concepts": {
        "title": "Key Concepts",
        "author": "",
        "category": "",
        "content": "Key Concepts in Hyperledger ComposerHyperledger Composer is a programming model containing a modeling language, and a set of APIs to quickly define and deploy business networks and applications that allow participants to send transactions that exchange assets.Hyperledger Composer ComponentsYou can experience Hyperledger Composer with our browser-based UI called Hyperledger Composer Playground.  Playground is available as a hosted version (no install necessary) or a local install (good for editing and testing sample business networks offline).Developers who want to use Hyperledger Composer&#39;s full application development capabilities should install the Developer Tools.Key Concepts in Hyperledger ComposerBlockchain State StorageAll transactions submitted through a business network are stored on the blockchain ledger, and the current state of assets and participants are stored in the blockchain state database. The blockchain distributes the ledger and the state database across a set of peers and ensures that updates to the ledger and state database are consistent across all peers using a consensus algorithm.Connection ProfilesHyperledger Composer uses Connection Profiles to define the system to connect to. A connection profile is a JSON document the is part of a business network card. These profiles are usually provided by the creator of the system they refer to and should be used to create business network cards in order to be able to connect to that system.AssetsAssets are tangible or intangible goods, services, or property, and are stored in registries. Assets can represent almost anything in a business network, for example, a house for sale, the sale listing, the land registry certificate for that house, and the insurance documents for that house may all be assets in one or more business networks.Assets must have a unique identifier, but other than that, they can contain whatever properties you define. Assets may be related to other assets or participants.ParticipantsParticipants are members of a business network. They may own assets and submit transactions. Participant types are modeled, and like assets, must have an identifier and can have any other properties as required. A participant can be mapped to one or multiple identities.IdentitiesAn identity is a digital certificate and private key. Identities are used to transact on a business network and must be mapped to a participant in the business network. A single identity is stored in a business network card and if that identity has been mapped to a participant, it allows the user of that business network card to transact on a business network as that participant.Business Network cardsBusiness network cards are a combination of an identity, a connection profile, and metadata, the metadata optionally containing the name of the business network to connect to. Business network cards simplify the process of connecting to a business network, and extend the concept of an identity outside the business network to a &#39;wallet&#39; of identities, each associated with a specific business network and connection profile.TransactionsTransactions are the mechanism by which participants interact with assets. This could be as simple as a participant placing a bid on a asset in an auction, or an auctioneer marking an auction closed, automatically transferring ownership of the asset to the highest bidder.QueriesQueries are used to return data about the blockchain world-state. Queries are defined within a business network, and can include variable parameters for simple customization. By using queries, data can be easily extracted from your blockchain network. Queries are sent by using the Hyperledger Composer API.EventsEvents are defined in the business network definition in the same way as assets or participants. Once events have been defined, they can be emitted by transaction processor functions to indicate to external systems that something of importance has happened to the ledger. Applications can subscribe to emitted events through the composer-client API.Access ControlBusiness networks may contain a set of access control rules. Access control rules allow fine-grained control over what participants have access to what assets in the business network and under what conditions. The access control language is rich enough to capture sophisticated conditions declaratively, such as &quot;only the owner of a vehicle can transfer ownership of the vehicle&quot;. Externalizing access control from transaction processor function logic makes it easier to inspect, debug, develop and maintain.Historian registryThe historian is a specialised registry which records successful transactions, including the participants and identities that submitted them. The historian stores transactions as HistorianRecord assets, which are defined in the Hyperledger Composer system namespace.Where do I go from here?To try Hyperledger Composer right away, visit the the Online PlaygroundFor an architectural overview of a typical solution built with Composer, see Typical Solution ArchitectureTo install the Development Tools, see Getting setup with development tools",
        "url": "/composer/latest/introduction/key-concepts"
      }
      ,
    
      "managing-managingindex": {
        "title": "Managing a Deployed Business Network",
        "author": "",
        "category": "concepts",
        "content": "Managing your Hyperledger Composer SolutionParticipants and identitiesParticipants and identities are core concepts of Hyperledger Composer. A participant is a member of business networks and might represent individuals or organizations. Participants have identity documents which can be validated to prove their identity. For more information, see participants and identities.Adding participantsParticipants must be added to a business network before they can make transactions. Participants can create assets, and also exchange assets with other participants. A participant works with assets by submitting transactions.Creating, Exporting, and Importing Business Network CardsBusiness network cards combine a connection profile, identity, and certificates to allow a connection to a business network in Hyperledger Composer Playground. Business network cards can be created, exported and imported from the My Wallet page in Hyperledger Composer Playground.Issuing a new identity to a participantA new identity can be issued to a participant using either the API or the command line. Once a new identity has been issued, the identity can then be used by the participant to interact with the business network in the context of that participant.Binding an existing identity to a participantAn existing identity can be bound to a participant using either the API or the command line. Once an existing identity has been bound, the identity can then be used by the participant to interact with the business network in the context of that participant.Listing all identities in a business networkIdentities issued or bound to a participant create a mapping. In order to perform identity management operations in a deployed business network, you will need to list and review the set of identities in the identity registry.Revoking an identity from a participantAn identity can be revoked from a participant using either the API or the command line. Once an identity has been revoked, the identity can no longer be used by the participant to interact with the business network in the context of that participant.Interacting with Hyperledger FabricHyperledger Composer is designed to be platform-agnostic. This section is about specifics in relation to interacting with Hyperledger Fabric.What next?You might want to integrate your existing systems with Hyperledger Composer using LoopBack.Applications which consume data from your business network can subscribe to events.",
        "url": "/composer/latest/managing/managingindex"
      }
      ,
    
      "reference-model-compatibility": {
        "title": "Model Compatibility",
        "author": "",
        "category": "reference",
        "content": "Model CompatibilityComposer models are expected to change and evolve over time. However some care and discipline must be applied when making model changes to ensure that existing instances are still valid with respect to the new model.A model M&#39; is compatible with model M if instances created with model M are valid with respect to model M&#39;. If the instances are valid, then they may be deserialized using the Serializer.The following terms are used throughout this document:Class : the declaration of the structure of an asset, participant, transaction, concept or eventInstance : an instance of a class, for example if org.example.basic.SampleAsset is an asset (class), then org.example.basic.SampleAsset#ABC123 is an instance of an org.example.basic.SampleAssetProperty : a member (or field) defined by a class, including a relationship. For example the class org.example.basic.SampleAsset may have a property called value of type string.A class (the asset SampleAsset):namespace org.example.basicasset SampleAsset identified by assetId {  o String assetId  --&gt; SampleParticipant owner  o String value}An instance of the class:{  \"$class\": \"org.example.basic.SampleAsset\",  \"assetId\": \"assetId:6463\",  \"owner\": \"resource:org.example.basic.SampleParticipant#participantId:8091\",  \"value\": \"secret plant frequently ruler\"}Evolution of NamespacesA new class may be added to a namespace without breaking compatibility with pre-existing instances.Evolution of ClassesThis section describes the effects of changes to the declaration of a class and its properties on pre-existing instances.RenamingRenaming a class will break compatibility with any pre-existing instances of the class, or relationships to the class.abstract ClassesIf a class that was not declared abstract is changed to be declared abstract, then attempts to create new instances of that class will throw an error at runtime; such a change is therefore not recommended for widely distributed classes.Changing a class that is declared abstract to no longer be declared abstract does not break compatibility with pre-existing instances.SuperclassesAn error is thrown at load time if a class would be a superclass of itself. Changes to the class hierarchy that could result in such a circularity when instances are loaded are not recommended for widely distributed classes.Changing the direct superclass of a class type will not break compatibility with pre-existing instances, provided that the total set of superclasses of the class type loses no properties.If a change to the direct superclass results in any class no longer being a superclass respectively, then errors may result if pre-existing instances have relationships to the modified class. Such changes are not recommended for widely distributed classes.Class PropertiesNo incompatibility with pre-existing instances is caused by adding a property to a class if the property is either declared as optional or is assigned a default value. Adding new properties that are neither optional nor have a default will break compatibility with any pre-existing instances of the class.Changing the cardinality of a property (changing an array [] to a non-array or vice-a-versa) will break compatibility with any pre-existing instances of the class.Deleting a property from a class will break compatibility with any pre-existing instances that reference this field.Changing the type of a property may cause an error if the property is used by a pre-existing instance.Changing the validation expression of a property may cause an error if the property is used by a pre-existing instance.Properties that are relationships follow the same rules as for other types.Evolution of EnumsAdding or reordering constants in an enum type will not break compatibility with pre-existing instances.If a pre-existing instance attempts to access an enum constant that no longer exists, an error will occur. Therefore such a change is not recommended for widely distributed enums.In all other respects, the model evolutions rules for enums are identical to those for classes.",
        "url": "/composer/latest/reference/model-compatibility"
      }
      ,
    
      "integrating-node-red": {
        "title": "Integrating with Node-RED",
        "author": "",
        "category": "integrating",
        "content": "Integrating with Node-REDNode-RED is a lightweight Open Source integration technology, written in JavaScript. It uses a graphical flow to integrate different nodes, where nodes can receive data, transform data and output data.Node-RED is commonly used to rapidly prototype Internet of Things style applications, or to wire existing Internet services together.You can use the Hyperledger Composer Node-RED contribution to:Submit transactionsRead and update assets and participantsSubscribe to eventsDelete assets and participantsThe Hyperledger Composer Node-RED nodes are distributed as a standalone npm package, published here:- https://www.npmjs.com/package/node-red-contrib-composerHyperledger Composer Node-RED NodesHyperledger-Composer-outA node red output node that allows you to create, update or delete assets or participants and submit transactions. For example, combining the hyperledger-composer-out node with an inject node allows you to create participants by submitting JSON definitions of those participants.Hyperledger-Composer-MidA node red mid flow node that allows you to create, retrieve, update, or delete assets and participants from a registry. For example, combining hyperledger-composer-mid with an inject node allows you to retrieve assets or participants by submitting the correct registry and identifying field as a JSON object.Hyperledger-Composer-InA Node-RED input node that subscribes to events from a blockchain.",
        "url": "/composer/latest/integrating/node-red"
      }
      ,
    
      "applications-node": {
        "title": "Writing a Node.js application",
        "author": "",
        "category": "start",
        "content": "Writing Node.js ApplicationsApplication developers use the composer-client npm module to programmatically connect to a deployed business network, create, read, update and delete assets and participants and to submit transactions. If applications need to be able to deploy or administer business networks, then the composer-admin npm module can be used.The sample landregistry.js file contains a class to the represent the land registry and contains methods for listing the land titles, adding default titles, and submitting the transaction. This has been implemented using a JavaScript class; however you are free to structure your code as you wish.It&#39;s worth highlighting that the style of the API is to use promises. Typically Hyperledger Composer APIs will return a promise that is resolved when the operation has been successfully completed or with the result of the operation if applicable.If you&#39;re not familiar with Promise based development it&#39;s worth reviewing some of the tutorials online to get an idea. Further to this, in node 8, async/await is now supported making it easier to develop asynchronous applications. The examples shown here make use of await and assume that the code is contained within a function that has async attributeModules requiredconst BusinessNetworkConnection = require('composer-client').BusinessNetworkConnection;For a Hyperledger Composer client application this is the only npm module required.Connecting to the Hyperledger Composer RuntimeA BusinessNetworkConnection instance is created and then used to connect to a runtime:this.bizNetworkConnection = new BusinessNetworkConnection();The first Hyperledger Composer API call that we are going to make here, is the connect() API, to establish the connection to the Hyperledger Composer runtime on the Hyperledger Fabric.An appropriate cardName needs to be provided for connection, for example admin@digitalproperty-network may be a valid card name depending on how the digitalproperty-network was deployed. This API returns a Promise to the businessNetworkDefinition if successful:let this.businessNetworkDefinition = await this.bizNetworkConnection.connect(cardName);For a client application this is all the essential setup that is required, from this point on it&#39;s up to what the application wants to do as to what APIs are called.Adding assets to a registryThe Hyperledger Composer runtime will create a default registry for each type of modeled asset. So in this example, a LandTitle registry will have been created. What we want to do here is get access to that registry and then add some assets. The getAssetRegistry() method takes the fully qualified asset name as defined in the CTO model file (that is the namespace plus the name of the asset type). It returns a promise that is resolved with the asset registry:this.titlesRegistry = await this.bizNetworkConnection.getAssetRegistry('net.biz.digitalPropertyNetwork.LandTitle');Next step is to create some assets (look for the method _bootstrapTitles in the code )A factory style pattern is used to create assets. A factory is obtained from the businessNetworkDefinition and used to create instances of all the types defined in the business network.  Note the use of the namespace and asset name.  Then we can set the properties of this asset. The identifiers here (firstName lastName) matches with the properties defined in the model.let factory = this.businessNetworkDefinition.getFactory();owner = factory.newResource('net.biz.digitalPropertyNetwork', 'Person', 'PID:1234567890');owner.firstName = 'Fred';owner.lastName = 'Bloggs';We now have a Person! Now we need a land title. Note how the owner is specified as being the person we just created. (In the actual sample code we do this code twice to create landTitle1 and landTitle2).let landTitle2 = factory.newResource('net.biz.digitalPropertyNetwork', 'LandTitle', 'LID:6789');landTitle2.owner = owner;landTitle2.information = 'A small flat in the city';We now have a land title created that needs to be stored in the registry.await this.titlesRegistry.addAll([landTitle1, landTitle2]);This is using an API to add multiple titles, which returns a promise that is resolved when the assets are added. The last thing we need to do is add the Person, Fred Bloggs. As this is a &#39;participant&#39;, the getParticipantRegistry API is used.let personRegistry = await this.bizNetworkConnection.getParticipantRegistry('net.biz.digitalPropertyNetwork.Person');await personRegistry.add(owner);Listing assets in a regsitryIn the sample application this is handled in a different method list().  The same setup as for putting assets is required, so as before we need to get the asset registry but this tile we call the getAll() API. This returns an array of objects.let registry = await this.bizNetworkConnection.getAssetRegistry('net.biz.digitalPropertyNetwork.LandTitle');let aResources = await registry.getAll();let table = new Table({    head: ['TitleID', 'OwnerID', 'First Name', 'Surname', 'Description', 'ForSale']});let arrayLength = aResources.length;for (let i = 0; i &lt; arrayLength; i++) {    let tableLine = [];    tableLine.push(aResources[i].titleId);    tableLine.push(aResources[i].owner.personId);    tableLine.push(aResources[i].owner.firstName);    tableLine.push(aResources[i].owner.lastName);    tableLine.push(aResources[i].information);    tableLine.push(aResources[i].forSale ? 'Yes' : 'No');    table.push(tableLine);}  // Put to stdout - as this is really a command line appreturn table;Most of this isn&#39;t Hyperledger Composer API code - but it shows how to access the details of the objects that have been returned. At this point it&#39;s worth just looking again at the model.asset LandTitle identified by titleId {  o String   titleId  o Person   owner  o String   information  o Boolean  forSale   optional}participant Person identified by personId {  o String personId  o String firstName  o String lastName}You can see how the owner and title information are being accessed in a very simple manner.Submitting a transactionThe last thing that we need to do is submit a transaction. This is the definition of the transaction in the model file:transaction RegisterPropertyForSale identified by transactionId{  o String transactionId  --&gt; LandTitle title}The transaction has two fields here, a trandsactionId, and a reference to the land title that should be submitted for sale. The first step is get access to the registry for the landtitle, and get back the specific land title we want to submit for sale.let registry = await this.bizNetworkConnection.getAssetRegistry('net.biz.digitalPropertyNetwork.LandTitle');await registry.get('LID:1148');The getAssetRegistry call should now be looking a bit familiar, the get API is used to get a specific land title.The next step is to create the transaction we want to submit.let serializer = this.businessNetworkDefinition.getSerializer();let resource = serializer.fromJSON({  '$class': 'net.biz.digitalPropertyNetwork.RegisterPropertyForSale',  'title': 'LID:1148'});await this.bizNetworkConnection.submitTransaction(resource);What we need to do here is create a &#39;serializer&#39;.  This is able to create a resource - this resource is then passed to the submitTransaction API. Note that the transaction JSON matches the structure specified in the model file.ReferencesJavaScript API DocumentationPromises tutorialasync/await tutorial",
        "url": "/composer/latest/applications/node"
      }
      ,
    
      "managing-participant-add": {
        "title": "Adding participants",
        "author": "",
        "category": "tasks",
        "content": "Adding participantsA participant can be added to a participant registry using either the API or the command line.Before you startBefore you follow these steps, you must have modeled a participant in a Business Network Definition and deployed it as a Business Network.The procedure below shows an example using the following model of a participant from the Digital Property sample Business Network Definition: digitalproperty-networkPlease note: If you are adding the participant using the composer participant add command, ensure that the JSON representation of the participant is wrapped in single quotes.namespace net.biz.digitalPropertyNetworkparticipant Person identified by personId {  o String personId  o String firstName  o String lastName}ProcedureAdd the participant to a participant registryJavaScript API    const BusinessNetworkConnection = require('composer-client').BusinessNetworkConnection;    async function addParticipant() {        let businessNetworkConnection = new BusinessNetworkConnection();        try {            await businessNetworkConnection.connect('admin@digitalPropertyNetwork');            let participantRegistry = await businessNetworkConnection.getParticipantRegistry('net.biz.digitalPropertyNetwork');            let factory = businessNetworkConnection.getFactory();            let participant = factory.newResource('net.biz.digitalPropertyNetwork', 'Person', 'mae@biznet.org');            participant.firstName = 'Mae';            participant.lastName = 'Smith';            await participantRegistry.add(participant);            await businessNetworkConnection.disconnect();        } catch(error) {            console.error(error);            process.exit(1);        }    }    addParticipant();Command linecomposer participant add -c admin@network -d '{\"$class\":\"net.biz.digitalPropertyNetwork.Person\",\"personId\":\"mae@biznet.org\",\"firstName\":\"Mae\",\"lastName\":\"Smith\"}'",
        "url": "/composer/latest/managing/participant-add"
      }
      ,
    
      "managing-participantsandidentities": {
        "title": "Participants and identities",
        "author": "",
        "category": "concepts",
        "content": "Participants and identitiesConceptsA Participant is an actor in a business network. A participant might be an individual an organization. A participant can create assets, and also exchange assets with other participants. A participant works with assets by submitting transactions.A participant has a set of Identity documents that can be validated to prove the identity of that participant. For example, an individual may have one or more of the following identity documents that prove who they are:PassportDriving licenseFingerprintsRetina scanSSL certificateIn Hyperledger Composer, participants are separated from the set of identity documents that they can use to interact with a business network.In order for a new participant to join a business network, a new instance of that participant must be created in the business network. The participant instance stores all of the required information about that participant, but it does not give that participant access to interact with the business network.In order to grant the participant access to interact with the business network, an identity document must then be Issued to that participant. The new participant can then use that identity document to interact with the business network.A participant may have an existing identity document that they use to interact with other business networks or other external systems. These identity documents can be reused and Bound to that participant. The new participant can then use their existing identity document to interact with the business network.Identity documents usually expire after a set period of time. Identity documents may also be lost or stolen. If the identity document expires, or if it needs to be replaced, then it must be Revoked so it can no longer be used to interact with the business network.However, revoking an identity document does not remove the information about that participant and any assets that they own. Revoking the identity document simply removes the participants ability to interact with the business network using that identity document. Access to the business network can be restored by issuing the participant with a new identity document.These participant and identity management actions are performed by an existing participant in the business network, for example a regulatory body, or a participant in the same organization who has been trusted to manage participants/identities inthat organization.Participants and identities in Hyperledger ComposerIn Hyperledger Composer, the structure of a participant is modeled in a model file. This structure may include various information about the participant, for example the participants name, address, e-mail address, date of birth, etc. New instances of that modeled participant can then be created and added to a participant registry.Hyperledger Composer requires the use Blockchain identities as the form of identity documents. For example, when deploying a business network to Hyperledger Fabric, enrollment certificates are used as the form of identity document. These enrollment certificates are used to cryptographically sign the transactions that are submitted to the deployed business network.A deployed business network maintains a set of mappings of identities to participants in the Identity Registry. When an identity is Issued or Bound to a participant, a new mapping is added to the identity registry. When that participant uses that identity to submit transactions to the deployed business network, the Composer runtime looks for a valid mapping for that identity in the identity registry. This lookup is done using the public key signature or fingerprint, essentially a hash of the certificate contents that is unique to that certificate and identity.Once a mapping is found in the identity registry, the participant for that identity is retrieved from that mapping. That participant becomes the Current Participant, the participant who submitted the transaction. All access control in Hyperledger Composer is based around the current participant. Access control rules that define which participants can perform which operations on which resources all operate on the current participant.When a participant uses an identity to submit a transaction to the deployed business network for the first time, that identity is Activated. This means that the entry in the identity registry is updated to record the fact that the identity was used for the first time. Additional information about the identity, such as the certificate, may also be recorded in the identity registry during activation if it was not available when the identity was issued or bound to the participant.If and when an identity is revoked, the entry in the identity registry for that identity is updated to change the status to Revoked. After an identity is revoked, if a participant tries to use that identity to submit a transaction to the deployed business network, that transaction will be rejected.Identities and Business network cards in the Hyperledger Composer PlaygroundIn the Hyperledger Composer Playground, there is a wallet containing locally stored Business network cards. A Business network card is an access card to a business network, comprising identity data, a connection profile, and the correct certificates for business network access. ID cards can be exported to allow the assignment of identities to others.Performing identity management tasks in Hyperledger ComposerThe Hyperledger Composer Node.js client APIs, REST APIs, and command line interfaces can all be used to perform identity management operations. For example, the following identity management operations are available through all Hyperledger Composer interfaces:Adding a new participant to a participant registryIssuing a new identity to a participantBinding an existing identity to a participantRevoking an identity from a participantListing all identities in a deployed business networkFor more information, see the related tasks and reference material at the bottom of this document.Related ConceptsBusiness Network  Related TasksCreate a Business Network DefinitionAdding participantsIssuing an new identity to a participantBinding an existing identity to a participantListing all identities in a business networkRevoking an identity from a participant  Related Referencecomposer participant addcomposer identity issuecomposer identity bindcomposer identity revokecomposer identity list  ",
        "url": "/composer/latest/managing/participantsandidentities"
      }
      ,
    
      "playground-playground-index": {
        "title": "Using Playground",
        "author": "",
        "category": "start",
        "content": "Using PlaygroundThe Hyperledger Composer Playground provides a user interface for the configuration, deployment and testing of a business network. Advanced Playground features permit users to manage the security of the business network, invite participants to business networks and connect to multiple blockchain business networks.If you are new to the Playground, we recommend that you follow the Playground Tutorial that will guide you through the process of creating, deploying and testing a new blockchain business network before you start interacting with Business Network Cards.Please note: If two or more users are using Hyperledger Composer Playground to connect to the same instance of Hyperledger Fabric, ensure that each user refreshes their browser after the business network definition is updated by another user. Refreshing the browser accepts the changes to the business network definition made by other users. If the the business network is changed without accepting the changes of other users the changes will be lost.Navigating PlaygroundThe Business Networks pageThe Business Networks  page is the default Playground landing page. Here you can see all the Business Network Cards you have available for use. Each Business Network Card provides all of the information needed to connect to a blockchain business network. It is only possible to access a blockchain business network by using a valid Business Network Card. Once connected to a deployed Business Network, you will be taken to the Define page.From this page you can:Connect to a business network. If you already have a deployed business network and a Business Network Card created for it, you can click Connect now to connect to the business network.Deploy a new business network. If this is your first time using Playground, or you wish to start a new network, deploying your own network is a great place to start. When creating a new business network, you can choose to base your business network definition on a sample network, or create your own network from scratch.Interact with Business Network Cards. Business Network Cards are used to connect to business networks which already exist, and are a combination of connection profile and identity. The card provides options to delete the identity/card, export the card, and to connect to the corresponding business network.Import Business Network Cards. Importing an existing .card file from your computer is the simplest way to add a Business Network Card to your Business Networks page.Connect using a user ID and user secret. If you have been provided with a user ID and user secret by your network administrator, click Connect using credentials to enter them and generate a Business Network Card.Run through the Playground tutorial. If you don&#39;t know where to start, the Playground tutorial runs through creating a business network from scratch, and performing some basic operations.Business network optionsOnce connected to a business network using a Business Network Card, there are a number of options available whether you&#39;re looking at the Define tab, or the Test tab.In the upper-left is the name of the connection profile you&#39;re using and the business network you&#39;re connected to. In the example above, the connection profile is called Web and the business network name is basic-sample-network.Links to the Define and Test tabs. In the Define tab, you can add, modify and delete the content of your business network, and in the Test tab you can create assets and participants that were defined in the Define tab, and test the functionality of your business network.On the upper-right is a dropdown menu displaying the identity which is being used to connect to the business network. The dropdown contains a link to the Identity Registry, and the ability to log out of the business network, returning to the Business Networks page.The Define tabThe Define tab is used to create, edit and upgrade your business network.On the left of the Define tab, you can see a list of all the files in your current business network definition. To examine the contents of a file, click on it, and it will appear in the editor view. New files can be added to your business network with the Add a file button. Model files, script files, access control files, and query files can be added to your business network.Once you&#39;ve added and modified the files for your business network definition, you can deploy the changes to your network with the Deploy changes button. After clicking Deploy changes you can experiment with your changes in the Test tab. The Export button allows you to download your current business network as a .bna file.Please note: If two or more users are using Hyperledger Composer Playground to connect to the same instance of Hyperledger Fabric, ensure that each user refreshes their browser after the business network definition is updated by another user. Refreshing the browser accepts the changes to the business network definition made by other users. If the the business network is changed without accepting the changes of other users the changes will be lost.The Test tabThe Test tab is used to test the deployed business network by using the asset types, participant types, and transactions which you defined in the Define tab.On the left of the Test tab, each participant type and asset type is listed. Clicking on a participant type, asset type, or All transactions will display a registry, showing all active instances of that type. For example, by clicking SampleParticipant, you can see a registry showing all SampleParticipants that have been created. If it&#39;s the first time you&#39;ve looked at the Test tab, your registries will be empty!From within each registry, you can create the corresponding asset, participant, or submit the corresponding transaction.In the All transactions registry, also known as the Historian, you can see a record of each transaction that has taken place in your business network, including some transactions which are caused by system events, such as creating participants or assets. In the transaction registry, you can submit transactions, and then check that their effects have occurred by checking the resources that were changed.Playground TasksBusiness Network CardsProvide Access To Your Business Network With a Business Network CardGain Access To A Business Network with a Business Network Card",
        "url": "/composer/latest/playground/playground-index"
      }
      ,
    
      "tutorials-playground-tutorial": {
        "title": "Playground Tutorial",
        "author": "",
        "category": "playground",
        "content": "Playground TutorialIn this step by step tutorial we&#39;ll walk through setting up a business network, defining our assets, participants and transactions, and testing our network by creating some participants and an asset, and submitting transactions to change the ownership of the asset from one to another. This tutorial is intended to act as an introduction to Hyperledger Composer concepts using the online playground environment.Step One: Open the Hyperledger Composer PlaygroundOpen Composer Playground (note, this link will take you to the web Composer Playground - you can also follow along in a local version if you&#39;ve already installed the development environment).You should see the My Business Networks screen. The My Business Networks page shows you a summary of the business networks you can connect to, and the identities you can use to connect to them. Don&#39;t worry about this too much for the time being, as we&#39;re going to create our own network.Step Two: Creating a new business networkNext, we want to create a new business network from scratch. A business network has a couple of defining properties; a name, and an optional description. You can also choose to base a new business network on an existing template, or import your own template.Click Deploy a new business network under the Web Browser heading to get started.The new business network needs a name, let&#39;s call it tutorial-network.Optionally, you can enter a description for your business network.Next we must select a business network to base ours on, because we want to build the network from scratch, click empty-business-network.Now that our network is defined, click Deploy.NOTE: If you are using playground locally and connecting to a real Fabric please refer to the additional notes at the bottom of the tutorial.Step Three: Connecting to the business networkNow that we&#39;ve created and deployed the business network, you should see a new business network card called admin for our business network tutorial-network in your wallet. The wallet can contain business network cards to connect to multiple deployed business networks.When connecting to an external blockchain, business network cards represent everything necessary to connect to a business network. They include connection details, authentication material, and metadata.To connect to our business network click Connect now under our business network card.Step Four: Adding a model fileAs you can see, we&#39;re in the Define tab right now, this tab is where you create and edit the files that make up a business network definition, before deploying them and testing them using the Test tab.As we selected an empty business network template, we need to modify the template files provided. The first step is to update the model file. Model files define the assets, participants, transactions, and events in our business network.For more information on our modeling language, check our documentation.Click the Model file to view it.Delete the lines of code in the model file and replace it with this:/** * My commodity trading network */namespace org.example.mynetworkasset Commodity identified by tradingSymbol {    o String tradingSymbol    o String description    o String mainExchange    o Double quantity    --&gt; Trader owner}participant Trader identified by tradeId {    o String tradeId    o String firstName    o String lastName}transaction Trade {    --&gt; Commodity commodity    --&gt; Trader newOwner}This domain model defines a single asset type Commodity and single participant type Trader and a single transaction type Trade that is used to modify the owner of a commodity.Step Five: Adding a transaction processor script fileNow that the domain model has been defined, we can define the transaction logic for the business network. Composer expresses the logic for a business network using JavaScript functions. These functions are automatically executed when a transaction is submitted for processing.For more information on writing transaction processor functions, check our documentation.Click the Add a file button.Click the Script file and click Add.Delete the lines of code in the script file and replace it with the following code:/** * Track the trade of a commodity from one trader to another * @param {org.example.mynetwork.Trade} trade - the trade to be processed * @transaction */async function tradeCommodity(trade) {    trade.commodity.owner = trade.newOwner;    let assetRegistry = await getAssetRegistry('org.example.mynetwork.Commodity');    await assetRegistry.update(trade.commodity);}This function simply changes the owner property on a commodity based on the newOwner property on an incoming Trade transaction. It then persists the modified Commodity back into the asset registry, used to store Commodity instances.    Step Six: Access controlAccess control files define the access control rules for business networks. Our network is simple, so the default access control file doesn&#39;t need editing. The basic file gives the current participant networkAdmin full access to business network and system-level operations.While you can have multiple model or script files, you can only have one access control file in any business network.For more information on access control files, check our documentation.Step Seven: Deploying the updated business networkNow that we have model, script, and access control files, we need to deploy and test our business network.Click Deploy changes to upgrade the business network.NOTE: If you are using playground locally and connecting to a real Fabric please refer to the additional notes at the bottom of the tutorial.Step Eight: Testing the business network definitionNext, we need to test our business network by creating some participants (in this case Traders), creating an asset (a Commodity), and then using our Trade transaction to change the ownership of the Commodity.Click the Test tab to get started.Step Nine: Creating participantsThe first thing we should add to our business network is two participants.Ensure that you have the Trader tab selected on the left, and click Create New Participant in the upper right.What you can see is the data structure of a Trader participant. We want some easily recognizable data, so delete the code that&#39;s there and paste the following:{  \"$class\": \"org.example.mynetwork.Trader\",  \"tradeId\": \"TRADER1\",  \"firstName\": \"Jenny\",  \"lastName\": \"Jones\"}Click Create New to create the participant.You should be able to see the new Trader participant you&#39;ve created. We need another Trader to test our Trade transaction though, so create another Trader, but this time, use the following data:{  \"$class\": \"org.example.mynetwork.Trader\",  \"tradeId\": \"TRADER2\",  \"firstName\": \"Amy\",  \"lastName\": \"Williams\"}Make sure that both participants exist in the Trader view before moving on!Step Ten: Creating an assetNow that we have two Trader participants, we need something for them to trade. Creating an asset is very similar to creating a participant. The Commodity we&#39;re creating will have an owner property indicating that it belongs to the Trader with the tradeId of TRADER1.Click the Commodity tab under Assets and click Create New Asset.Delete the asset data and replace it with the following:{  \"$class\": \"org.example.mynetwork.Commodity\",  \"tradingSymbol\": \"ABC\",  \"description\": \"Test commodity\",  \"mainExchange\": \"Euronext\",  \"quantity\": 72.297,  \"owner\": \"resource:org.example.mynetwork.Trader#TRADER1\"}After creating this asset, you should be able to see it in the Commodity tab.Step Eleven: Transferring the commodity between the participantsNow that we have two Traders and a Commodity to trade between them, we can test our Trade transaction.Transactions are the basis of all change in a Hyperledger Composer business network, if you want to experiment with your own after this tutorial, try creating another business network from the My Business Network screen and using a more advanced business network template.To test the Trade transaction:Click the Submit Transaction button on the left.Ensure that the transaction type is Trade.Replace the transaction data with the following, or just change the details:{  \"$class\": \"org.example.mynetwork.Trade\",  \"commodity\": \"resource:org.example.mynetwork.Commodity#ABC\",  \"newOwner\": \"resource:org.example.mynetwork.Trader#TRADER2\"}Click Submit.Check that our asset has changed ownership from TRADER1 to TRADER2, by expanding the data section for the asset. You should see that the owner is listed as resource:org.example.mynetwork.Trader#TRADER2.To view the full transaction history of our business network, click All Transactions on the left. Here is a list of each transaction as they were submitted. You can see that certain actions we performed using the UI, like creating the Trader participants and the Commodity asset, are recorded as transactions, even though they&#39;re not defined as transactions in our business network model. These transactions are known as &#39;System Transactions&#39; and are common to all business networks, and defined in the Hyperledger Composer Runtime.Logging out of the business networkNow that transactions have successfully run, we should log out of the business network, ending up at the My Business Network screen where we started.In the upper-right of the screen is a button labelled admin. This lists your current identity, to log out, click admin to open the dropdown menu, and click My Business Networks.Deploying a Business Network to a real Fabric.Using Playground locally, you can use connections to &quot;Web Browser&quot; which works in the browser local storage, or you can use Connections to a real Fabric usually in a group called &quot;hlfv1&quot;If you are connecting to a real Fabric, then you will likely have already created a Card for an identity with PeerAdmin and ChannelAdmin roles - this is often called PeerAdmin.  This is the card that you use to Deploy and Update your network with Composer.When you are deploying your network to a real Fabric there are additional fields to complete before you can click the Deploy button - you need to supply the details of the Network Administrator.Scroll to the bottom of the Deploy Screen to find CREDENTIALS FOR NETWORK ADMINISTRATOR.  For a simple Development Fabric and many Test networks you can supply an ID and Secret.  Enrollment ID - admin  Enrollment Secret - adminpwWhen the ID and Secret are specified, you can click the Deploy button and resume the tutorial at Step Three.If you are working with a Custom or Production Fabric - contact your Fabric Administrator for details of the Network Administrator.Updating a Business Network when connected to a real FabricWhen you are using a real Fabric and click Deploy Changes you will see an addition popup dialog asking you to specify an Installation Card and an Upgrade card from dropdown lists.  Typically you specify the same PeerAdmin card as used to deploy the initial network.  If you are uncertain, contact your Fabric Administrator.Select the cards, and click the Upgrade button.  Note that on a real Fabric this can take a few minutes to complete.Resume the Tutorial at Step Eight.What next?You might want to try the Developer Tutorial, which uses the full development environment (including development in an IDE, generating a REST API and a skeleton web application). If you haven&#39;t already, you&#39;ll need to install the development environment before following this tutorial.",
        "url": "/composer/latest/tutorials/playground-tutorial"
      }
      ,
    
      "business-network-programmatic-access-control": {
        "title": "Programmatic access control",
        "author": "",
        "category": "tasks",
        "content": "Programmatic access controlIt is recommended that you use declarative access control to implement access control rules in your business network definition.However, you can implement programmatic access control in your transaction processors by retrieving and testing either the current participant or the current identity.You can run tests against the properties of the current participant or the current identity to permit or reject the execution of a transaction processor function.A transaction processor function can call the getCurrentParticipant function to get the current participant:let currentParticipant = getCurrentParticipant();The current participant is an instance of a modelled participant from the business network definition, or an instance of the system type org.hyperledger.composer.system.NetworkAdmin.A transaction processor function can call the getCurrentIdentity function to get the current identity:let currentIdentity = getCurrentIdentity();The current identity is an instance of the system type org.hyperledger.composer.system.Identity, which represents an identity within a deployed business network.Before you startBefore you follow these steps, you must have modeled a participant in a businessnetwork definition and deployed it as a business network. You must have createdsome instances of those participants, and issued those participants with identities.The procedure below shows an example using the following participant models:namespace net.biz.digitalPropertyNetworkparticipant Person identified by personId {  o String personId  o String firstName  o String lastName}participant PrivilegedPerson extends Person {}ProcedureIn your transaction processor function, verify the type of the current participantmeets the requirements by using the getCurrentParticipant function:   async function onPrivilegedTransaction(privilegedTransaction) {       let currentParticipant = getCurrentParticipant();       if (currentParticipant.getFullyQualifiedType() !== 'net.biz.digitalPropertyNetwork.PrivilegedPerson') {           throw new Error('Transaction can only be submitted by a privileged person');       }       // Current participant must be a privileged person to get here.   }In your transaction processor function, verify the participant ID of the currentparticipant by using the getCurrentParticipant function:   async function onPrivilegedTransaction(privilegedTransaction) {       let currentParticipant = getCurrentParticipant();       if (currentParticipant.getFullyQualifiedIdentifier() !== 'net.biz.digitalPropertyNetwork.Person#PERSON_1') {           throw new Error('Transaction can only be submitted by person 1');       }       // Current participant must be person 1 to get here.   }The participant ID of the current participant can be compared to a participant   that is linked to an asset (by a relationship) to verify that the current   participant has the authority to access or modify an asset:   async function onPrivilegedTransaction(privilegedTransaction) {       // Get the owner of the asset in the transaction.       let assetOwner = privilegedTransaction.asset.owner;       let currentParticipant = getCurrentParticipant();       if (currentParticipant.getFullyQualifiedIdentifier() !== asset.owner.getFullyQualifiedIdentifier()) {           throw new Error('Transaction can only be submitted by the owner of the asset');       }       // Current participant must be the owner of the asset to get here.   }In your transaction processor function, verify the certificate of the current identitymeets the requirements by using the getCurrentIdentity function:   async function onPrivilegedTransaction(privilegedTransaction) {       let currentIdentity = getCurrentIdentity();       // Get the PEM encoded certificate from the current identity.       let certificate = currentIdentity.certificate;       // Perform testing on the PEM encoded certificate.       if (!certificate.match(/^----BEGIN CERTIFICATE----/)) {            throw new Error('Transaction can only be submitted by a person with a valid certificate');       }       // Current identity must have a valid certificate to get here.   }",
        "url": "/composer/latest/business-network/programmatic-access-control"
      }
      ,
    
      "business-network-publishing-events": {
        "title": "Emitting Events",
        "author": "",
        "category": "tasks",
        "content": "Emitting EventsEvents can be emitted by Hyperledger Composer and subscribed to by external applications. Events are defined in the model file of a business network definition, and are emitted by transaction JavaScript in the transaction processor functions file.Before you beginBefore you begin adding events to your business network, you should have a good understanding of the modeling language for business networks, and what makes up a full business network definition.ProcedureEvents are defined in the model file (.cto) of your business network definition, in the same way as assets and participants. Events use the following format:event BasicEvent {}In order for the event to be published the transaction which creates the event must call three functions, the first is the getFactory function. The getFactory allows events to be created as part of a transaction. Next, an event must be created by using factory.newEvent(&#39;org.namespace&#39;, &#39;BasicEvent&#39;). This creates a BasicEvent defined in a specified namespace. Then the required properties on the event must be set. Lastly, the event must be emitted by using emit(BasicEvent). A simple transaction which calls this event would look like this:/** * @param {org.namespace.BasicEventTransaction} basicEventTransaction * @transaction */async function basicEventTransaction(basicEventTransaction) {    let factory = getFactory();    let basicEvent = factory.newEvent('org.namespace', 'BasicEvent');    emit(basicEvent);}This transaction creates and emits an event of the BasicEvent type as defined in the business network&#39;s model file. For more information on the getFactory function, see the Composer API documentation.What next?Subscribing to eventsDeveloping applications",
        "url": "/composer/latest/business-network/publishing-events"
      }
      ,
    
      "integrating-publishing-events": {
        "title": "Publishing events from the REST server",
        "author": "",
        "category": "start",
        "content": "Publishing events from the REST serverThe REST server can be configured to subscribe to events emitted from a deployed business network, and publish those business events for consumption by client applications. Currently, the REST server supports publishing events to client applications over WebSockets.Client applications can use a WebSocket client to subscribe to the business events that are published by the REST server. There are WebSocket clients available for all major programming languages and application types - for example, client side web user interfaces, backend server processes, mobile applications, and integration tools.Enabling WebSocketsYou can enable WebSockets using the -w argument on the command line:composer-rest-server -c alice1@my-network -wAlternatively, you can enable WebSockets by using the COMPOSER_WEBSOCKETS environment variable:export COMPOSER_WEBSOCKETS=truecomposer-rest-server -c alice1@my-networkWhen you have successfully enabled WebSockets, you will be able to connect a WebSocket client to the base URL displayed in the output of the REST server:Web server listening at: http://localhost:3000Browse your REST API at http://localhost:3000/explorerIn this example, the base URL to use is http://localhost:3000. You must convert this into a WebSocket URL by changing the protocol from http to ws. In this example, the WebSocket URL to use is ws://localhost:3000.Testing that WebSockets has been enabledYou can test that WebSockets has been enabled by using a WebSocket client to subscribe to events. The open source command line application wscat can be used for this purpose.To install wscat, you can use npm. You may need to run this command with sudo, or as root, if you do not have the correct permissions to globally install npm modules:npm install -g wscatYou can then use wscat to connect to and subscribe to business events published by the REST server. Any business events received will be printed to the console:$ wscat -c ws://localhost:3000connected (press CTRL+C to quit)&lt; {\"$class\":\"org.example.basic.SampleEvent\",\"asset\":\"resource:org.example.basic.SampleAsset#assetId:1\",\"oldValue\":\"\",\"newValue\":\"hello world\",\"eventId\":\"a80d220b-09db-4812-b04b-d5d03b663671#0\",\"timestamp\":\"2017-08-23T12:47:17.685Z\"}&gt;",
        "url": "/composer/latest/integrating/publishing-events"
      }
      ,
    
      "tutorials-queries": {
        "title": "Queries Tutorial",
        "author": "",
        "category": "tutorials",
        "content": "Queries Tutorial using the Composer Query language and REST APIsIn this tutorial, we will build on the developer tutorial, extending it to demonstrate  queries. The native  query language can filter results returned using criteria and can be invoked in transactions to perform operations, such as updating or removing assets on result sets.Queries are defined in a query file (.qry) in the parent directory of the business network definition. Queries contain a WHERE clause, which defines the criteria by which assets or participants are selected.This tutorial uses the tutorial-network business network developed and deployed in the Developer-Tutorial.PrerequisitesBefore beginning this tutorial:Complete the development environment installation.Complete the developer tutorial.Step One: Updating the business networkThe business network created in the developer tutorial must be updated. The updated business network contains two events and an additional transactions.Update the model fileThe model file must be updated to contain events and a new transaction.Open the model (.cto) file for the tutorial-network.Add the following events and transaction to the model:event TradeNotification {    --&gt; Commodity commodity}transaction RemoveHighQuantityCommodities {}event RemoveNotification {    --&gt; Commodity commodity}Save the changes to your model.Update transaction logic to use queries and eventsNow that the domain model has been updated, we can write the additional business logic that gets executed when a transaction is submitted for processing. In this tutorial we have added events and queries to the business logic below.Open the transaction processor function file lib/logic.js.Replace the transaction logic with the following JavaScript:/** * Track the trade of a commodity from one trader to another * @param {org.example.mynetwork.Trade} trade - the trade to be processed * @transaction */async function tradeCommodity(trade) {    // set the new owner of the commodity    trade.commodity.owner = trade.newOwner;    let assetRegistry = await getAssetRegistry('org.example.mynetwork.Commodity');    // emit a notification that a trade has occurred    let tradeNotification = getFactory().newEvent('org.example.mynetwork', 'TradeNotification');    tradeNotification.commodity = trade.commodity;    emit(tradeNotification);    // persist the state of the commodity    await assetRegistry.update(trade.commodity);}/** * Remove all high volume commodities * @param {org.example.mynetwork.RemoveHighQuantityCommodities} remove - the remove to be processed * @transaction */async function removeHighQuantityCommodities(remove) {    let assetRegistry = await getAssetRegistry('org.example.mynetwork.Commodity');    let results = await query('selectCommoditiesWithHighQuantity');    for (let n = 0; n &lt; results.length; n++) {        let trade = results[n];        // emit a notification that a trade was removed        let removeNotification = getFactory().newEvent('org.example.mynetwork','RemoveNotification');        removeNotification.commodity = trade;        emit(removeNotification);        await assetRegistry.remove(trade);    }}Save your changes to logic.js.The first function tradeCommodity will change the owner property on a commodity (with a new owner Participant) on an incoming Trade transaction and emit a Notification event to that effect. It then persists the modified Commodity back into the asset registry which is used to store Commodity instances.The second function calls a named query &#39;selectCommoditiesWithHighQuantity&#39; (defined in queries.qry) which will return all Commodity asset records that have a quantity &gt; 60 ; emit an event ; and remove the Commodity from the AssetRegistry.Step Two: Create a query definition fileThe queries used by the Transaction Processor logic are defined in a file which must be called queries.qry. Each query entry defines the resources and criteria against which the query is executed.In the tutorial-network directory, create a new file called queries.qry.Copy and paste the following code into queries.qry:/** Sample queries for Commodity Trading business network*/query selectCommodities {  description: \"Select all commodities\"  statement:      SELECT org.example.mynetwork.Commodity}query selectCommoditiesByExchange {  description: \"Select all commodities based on their main exchange\"  statement:      SELECT org.example.mynetwork.Commodity          WHERE (mainExchange==_$exchange)}query selectCommoditiesByOwner {  description: \"Select all commodities based on their owner\"  statement:      SELECT org.example.mynetwork.Commodity          WHERE (owner == _$owner)}query selectCommoditiesWithHighQuantity {  description: \"Select commodities based on quantity\"  statement:      SELECT org.example.mynetwork.Commodity          WHERE (quantity &gt; 60)}Save your changes to queries.qry.Step Three: Regenerate your business network archiveAfter changing the files in a business network, the business network must be repackaged as a business network archive (.bna) and redeployed to the Hyperledger Fabric instance. Upgrading a deployed network requires that the new version being deployed have a new version number.In the tutorial-network directory, open the package.json file.Update the version property from 0.0.1 to 0.0.2.Using the command line, navigate to the tutorial-network directory.Run the following command:composer archive create --sourceType dir --sourceName . -a tutorial-network@0.0.2.bnaStep Four: Deploy the updated business network definitionWe need to deploy the modified network to become the latest edition on the blockchain! We are using the newly created archive business network archive file to update the existing deployed business network; this is the same business network name, that we used during the Developer Tutorial.Switch to the terminal, change directory to the folder containing the tutorial-network@0.0.2.bna.Run the following command to install the updated business network:composer network install --card PeerAdmin@hlfv1 --archiveFile tutorial-network@0.0.2.bnaRun the following command to upgrade the network to the new version:composer network upgrade -c PeerAdmin@hlfv1 -n tutorial-network -V 0.0.2Check the current version of the business network before continuing by using the following command:composer network ping -c admin@tutorial-network | grep BusinessStep Five: Regenerate the REST APIs for the updated Business NetworkWe will now integrate the newly updated business network with queries added, and expose the REST APIs for this business network.Using the command line, navigate to the tutorial-network directory.Use the following command to launch the REST server:composer-rest-serverEnter admin@tutorial-network as the card name.Select never use namespaces when asked whether to use namespaces in the generated API.Select No when asked whether to secure the generated API.Select Yes when asked whether to enable event publication.Select No when asked whether to enable TLS security.Step Six: Test the REST APIs and create some dataOpen a web browser and navigate to http://localhost:3000/explorer . You should see the LoopBack API Explorer, allowing you to inspect and test the generated REST API.We should be able to see that the REST Endpoint called &#39;Query&#39; has been added and, upon expanding, reveals the list of REST Query operations defined in the business network tutorial-networkBefore we proceed, we need to create some data, to demonstrate queries adequately. Using the sample JSON data provided, create 3 Traders (Participants)and some more Commodities (Assets) using the REST APIs.First, click on &#39;Trader&#39; in the REST Explorer, then click on the &#39;POST&#39; method on /Trader, then scroll down to the Parameter section - create the following Trader instances, in turn:{  \"$class\": \"org.example.mynetwork.Trader\",  \"tradeId\": \"TRADER1\",  \"firstName\": \"Jenny\",  \"lastName\": \"Jones\"}Click &#39;Try it out&#39; to create the Participant. The &#39;Response Code&#39; (scroll down) should be 200 (SUCCESS)Create another trader by copying the following JSON:{  \"$class\": \"org.example.mynetwork.Trader\",  \"tradeId\": \"TRADER2\",  \"firstName\": \"Jack\",  \"lastName\": \"Sock\"}Create a third trader by coping the following JSON:{  \"$class\": \"org.example.mynetwork.Trader\",  \"tradeId\": \"TRADER3\",  \"firstName\": \"Rainer\",  \"lastName\": \"Valens\"}Now scroll up to the top and click on &#39;Commodity&#39; object in the REST Explorer.Click on the POST operation and scroll down to the Parameters section: In the same way as above, create two Commodity Asset records (see below) for owners TRADER1 and TRADER2:{  \"$class\": \"org.example.mynetwork.Commodity\",  \"tradingSymbol\": \"EMA\",  \"description\": \"Corn\",  \"mainExchange\": \"EURONEXT\",  \"quantity\": 10,  \"owner\": \"resource:org.example.mynetwork.Trader#TRADER1\"}{  \"$class\": \"org.example.mynetwork.Commodity\",  \"tradingSymbol\": \"CC\",  \"description\": \"Cocoa\",  \"mainExchange\": \"ICE\",  \"quantity\": 80,  \"owner\": \"resource:org.example.mynetwork.Trader#TRADER2\"}Step Seven: Perform queries using the commodity trading REST API explorerNow that we have some Assets and Participants, we can test out some queries using the generated Query REST operations.Perform a simple REST queryNow that we have assets and participants, we can try out some queries.The simplest REST query we can try out first is our named query selectCommodities.Expand the &#39;Query&#39; REST Endpoint and you will see the named queries we defined in our model.These queries are now exposed as REST queries and for which a /GET operation is generated, Note that the description of the query (that we defined in our model definition) is shown on the right hand side.Expand the selectCommodities query.Click the &#39;Try it Out&#39; button.It will return all existing Commodities - there should be 2 assets returned.Perform Filtered REST QueriesLet&#39;s select all Commodities by their Exchange - for example &#39;EURONEXT&#39; main exchange.Expand query Endpoint &#39;selectCommoditiesByExchange&#39; and scroll to the &#39;Parameters&#39; section.Enter &#39;EURONEXT&#39; in the &#39;Exchange&#39; parameter.Click &#39;Try it Out&#39;.The results reveal that only those Commodities with an Exchange of &#39;EURONEXT&#39; are shown in the response bodyPerform Transaction update using results from named QueryFinally, you will recall we had defined a simple query that filters Commodities with a Quantity greater than 60 in our query file. Queries are very powerful, when used in transaction functions, as using queries allows transaction logic to set up the set of assets or participants to perform updates on, or for creating remove actions for example.We use the selectCommoditiesWithHighQuantity query in the removeHighQuantityCommodities transaction. If you execute this /GET operation in the REST Explorer, you&#39;ll see it selects only those assets greater than 60 in quantity.Now let&#39;s use the query to perform a removal of high quantity Commodities.First check for yourself how many Commodities are present (use the &#39;Commodity&#39; /GET operation) and you should see at least two Commodities, one of which (Cocoa) has a quantity &gt; 60.Let&#39;s check out the actual query, by clicking on the REST Endpoint /selectCommoditiesWithHighQuantity and click /GET then scroll down to &#39;Try it Out&#39; - there should be one Commodity that meets the criteria.OK. Now let&#39;s execute a REST transaction, that uses our &#39;High Quantity&#39; query definition to decide which Commodities to remove.Click on the RemoveHighQuantityCommodities REST Endpoint to reveal the /POST operation for same.Click on POST, scroll down to the Parameter section and click &#39;Try it Out&#39; - note: you do not have to enter any data in the &#39;data&#39; section.Scroll down and you should see a transactionId which represents the &#39;remove&#39; invocation (itself a blockchain transaction) inside of the transaction processor function and which will update the world state - the Response Code should be 200Finally, let&#39;s verify our Commodities status. Return to the &#39;Commodity&#39; REST Operations and once again perform a /GET operation....&#39;Try it Out&#39;.The results should show that the Commodity asset &#39;Cocoa&#39; has now gone, ie only those Commodity assets with a quantity &lt;= 60 still remain, ie asset &#39;Corn&#39; in our example. The named query fed the transaction update (to remove high quantity Commodities) and which was executed in business logic.Congratulations!Well done, you&#39;ve now completed this tutorial and we hope you now have a much better idea of the power of queries in Composer. You can start creating/building your own queries (or modifying the existing queries and adding associated data to this business network - note: you would need to re-deploy any query changes) to try out!Related LinksDeveloper-TutorialDeploying a business network",
        "url": "/composer/latest/tutorials/queries"
      }
      ,
    
      "reference-query-language": {
        "title": "Query Language",
        "author": "",
        "category": "",
        "content": "Hyperledger Composer Query LanguageQueries in Hyperledger Composer are written in a bespoke query language. Queries are defined in a single query file called (queries.qry) within a business network definition.Query SyntaxAll queries must contain the description and statement properties.DescriptionThe description property is a string which describes the function of the query. It must be included but can contain anything.StatementThe statement property contains the defining rules of the query, and can have the following operators:SELECT is a mandatory operator, and by default defines the registry and asset or participant type that is to be returned.FROM is an optional operator which defines a different registry to query.WHERE is an optional operator which defines the conditions to be applied to the registry data.AND is an optional operator which defines additional conditions.OR is an optional operator which defines alternative conditions.CONTAINS is an optional operator that defines conditions for array valuesORDER BY is an optional operator which defines the sorting or results.SKIP is an optional operator which defines the number of results to skip.LIMIT is an optional operator which defines the maximum number of results to return from a query, by default limit is set at 25.Note: If you&#39;re using Hyperledger Fabric  v1.2 or below, the LIMIT and SKIP won&#39;t work as there is an issue passing the params to couchdb from fabric. Reference to Hyperledger Fabric issue : FAB-2809Example QueryThis query returns all drivers from the default registry whose age is less than the supplied parameter or whose firstName is &quot;Dan&quot;, as long as their lastName is not &quot;Selman&quot;.In practical terms, this query returns all drivers who do not have the lastName &quot;Selman&quot;, as long as they are under a defined age, or have the firstName Dan, and orders the results by lastName ascending and firstName ascending.query Q20{    description: \"Select all drivers younger than the supplied age parameter or who are named Dan and whose lastName is not Selman, ordered from A-Z by firstName\"    statement:        SELECT org.example.Driver            WHERE ((age &lt; _$ageParam OR firstName == 'Dan') AND (lastName != 'Selman'))                ORDER BY [lastName ASC, firstName ASC]}Parameters in queriesQueries can be written with undefined parameters that must be supplied when running the query. For example, the following query returns all drivers where the age property is greater than the supplied parameter:query Q17 {    description: \"Select all drivers aged older than PARAM\"    statement:        SELECT org.example.Driver            WHERE (_$ageParam &lt; age)}Sample Contains queriesThe CONTAINS filter is used to search a array field in a node. The below query returns all the drivers who earned the punctual and steady-driving badges. Considering that the badges is of array type in driver participant.query Q18 {    description: \"Select all drivers who has the following interests\"    statement:        SELECT org.example.Driver            WHERE (badges CONTAINS ['punctual', 'steady-driving'])}What next?Applying queries to a business network.Emitting events from transactions.Hyperledger Composer API documentation.",
        "url": "/composer/latest/reference/query-language"
      }
      ,
    
      "business-network-query": {
        "title": "Using Queries and Filters with Business Network Data",
        "author": "",
        "category": "tasks",
        "content": "Querying and filtering business network dataQueries are used to return data about the blockchain world-state; for example, you could write a query to return all drivers over a specified age, or all drivers with a specific name. The composer-rest-server component exposes named queries via the generated REST API.Queries are an optional component of a business network definition, written in a single query file (queries.qry).Note: When using the Hyperledger Fabric v1.2 runtime Hyperledger Fabric must be configured to use CouchDB persistence.Filters are similar to queries, but use the LoopBack filter syntax, and can only be sent using the Hyperledger Composer REST API. Currently, only the WHERE LoopBack filter is supported. The supported operators within WHERE are: =, and, or, gt, gte, lt, lte, neq. Filters are submitted using a GET call against an asset type, participant type, or transaction type; the filter is then supplied as a parameter. Filters return the results from the specified class, and will not return results from classes extending the specified class.Types of QueriesHyperledger Composer supports two types of queries: named queries and dynamic queries. Named queries are specified in the business network definition and are exposed as GET methods by the composer-rest-server component. Dynamic queries may be constructed dynamically at runtime within a Transaction Processor function, or from client code.Writing Named QueriesQueries must contain a description and a statement. Query descriptions are a string that describe the function of the query. Query statements contain the operators and functions that control the query behavior.Query descriptions can be any descriptive string. A query statement must include the SELECT operator and can optionally include FROM, WHERE, AND, ORDER BY, SKIP, and LIMIT.Queries should take the following format:query Q1{  description: \"Select all drivers older than 65.\"  statement:      SELECT org.example.Driver          WHERE (age&gt;65)}Query ParametersQueries may embed parameters using the _$ syntax. Note that query parameters must be primitive types (String, Integer, Double, Long, Boolean, DateTime), a Relationship or an Enumeration.The named query below is defined in terms of 3 parameters:query Q18 {    description: \"Select all drivers aged older than PARAM\"    statement:        SELECT org.example.Driver            WHERE (_$ageParam &lt; age)                ORDER BY [lastName DESC, firstName DESC]                    LIMIT _$limitParam                        SKIP _$skipParam}Query parameters are automatically exposed via the GET method created for named queries by the composer-rest-server.For more information on the specifics of the Hyperledger Composer query language, see the query language reference documentation.Queries using the APIQueries can be invoked by calling the buildQuery or query APIs. The buildQuery API requires the entire query string to be specified as part of the API input. The query API requires you to specify the name of the query you wish to run.For more information on the query APIs, see the API documentation.Access Control for QueriesWhen returning the results of a query, your access control rules are applied to the results. Any content which the current user does not have authority to view is stripped from the results.For example, if the current user sends a query that would return all assets, if they only have authority to view a limited selection of assets, the query would return only that limited set of assets.Using filtersFilters can only be submitted using the Hyperledger Composer REST API, and must use the LoopBack syntax. To submit a query, a GET REST call must be submitted against an asset type, participant type, or transaction type with the filter supplied as a parameter. The supported data types for parameters to be filtered are numbers, Boolean, DateTime, and strings. A basic filter takes the following format, where op indicates an operator:{\"where\": {\"field1\": {\"op\":\"value1\"}}}Please note: Only the top level WHERE operator can have more than two operands.Currently, only the WHERE LoopBack filter is supported. The supported operators within WHERE are: =, and, or, gt, gte, lt, lte, neq. Filters can combine multiple operators, in the following example, an and operator is nested within an or operator.{\"where\":{\"or\":[{\"and\":[{\"field1\":\"foo\"},{\"field2\":\"bar\"}]},{\"field3\":\"foobar\"}]}}The between operator returns values between the given range. It accepts numbers, datetime values, and strings. If supplied with strings, the between operator returns results between the supplied strings alphabetically. In the example below, the filter will return all resources where the driver property is alphabetically between a and c, inclusively.{\"where\":{\"driver\":{\"between\": [\"a\",\"c\"]}}}",
        "url": "/composer/latest/business-network/query"
      }
      ,
    
      "reference-reference-index": {
        "title": "Reference",
        "author": "",
        "category": "",
        "content": "Reference material for Hyperledger ComposerThe Hyperledger Composer reference material contains a number of topics including reference information for the npm modules, CLI commands, modeling language, APIs, connection profiles, and a glossary of common terms.HistorianThe Hyperledger Composer Historian provides a registry that contains information about historical transactionsHyperledger Composer npm ModulesHyperledger Composer contains a number of npm modules which provide the APIs and command line tools necessary for developing a solution with Hyperledger Composer.Modeling LanguageThe Hyperledger Composer modeling language is an object-oriented language which defines the business network model containing assets, participants, and transactions.Access Control LanguageThe Hyperledger Composer access control language provides declarative access control over the elements of the domain model. Access control rules define actions that individual participants or participant groups can perform on resources in the business network, including conditional actions.Query LanguageThe Hyperledger Composer query language defines queries to run and return data from business networks.Model CompatibilityComposer models are expected to change and evolve over time. However some care and discipline must be applied when making model changes to ensure that existing instances are still valid with respect to the new model.Connection ProfilesIn order to connect your business network to a fabric, you must define a connection profile. Connection profiles contain the information necessary to connect to a fabric. This topic contains example connection profiles for Hyperledger Fabric v1.1.Transaction Processor FunctionsA Hyperledger Composer business network must include one or more script files to implement transaction logic. The transaction logic is automatically invoked by the runtime whenever the relevant transactions are submitted.Hyperledger Composer CLI CommandsThe list of all Hyperledger Composer CLI commands for performing multiple administrative, operational, and development tasks.Hyperledger Composer REST ServerReference documentation for the Hyperledger Composer REST server.Hyperledger Composer Glossary of TermsThe glossary contains definitions of all Hyperledger Composer terms for developing a solution with Hyperledger Composer.",
        "url": "/composer/latest/reference/reference-index"
      }
      ,
    
      "reference-rest-server": {
        "title": "Hyperledger Composer REST Server",
        "author": "",
        "category": "",
        "content": "Hyperledger Composer REST ServerThe Hyperledger Composer REST server, composer-rest-server, can be used to generate a REST API from a deployed blockchain business network that can be easily consumed by HTTP or REST clients.Configuring the REST server using environment variablesThe REST server can be configured using environment variables, instead of supplying configuration options via the command line. The REST server supports the following environment variables:COMPOSER_CARDYou can use the COMPOSER_CARD environment variable to specify the name of the discovery business network card that the REST server should use to connect to the business network.For example:COMPOSER_CARD=admin@my-networkCOMPOSER_NAMESPACESYou can use the COMPOSER_NAMESPACES environment variable to specify if the REST server should generate a REST API with namespaces or not. Valid values are always, required, and never.For example:COMPOSER_NAMESPACES=neverCOMPOSER_AUTHENTICATIONYou can use the COMPOSER_AUTHENTICATION environment variable to specify if the REST server should enable REST API authentication or not. Valid values are true and false.For example:COMPOSER_AUTHENTICATION=trueFor more information, see Enabling authentication for the REST server.COMPOSER_MULTIUSERYou can use the COMPOSER_MULTIUSER environment variable to specify if the REST server should enable multiple user mode or not. Valid values are true and false.For example:COMPOSER_MULTIUSER=trueFor more information, see Enabling multiple user mode for the REST server.COMPOSER_PROVIDERSYou can use the COMPOSER_PROVIDERS environment variable to specify the Passport strategies that the REST server should use to authenticate clients of the REST API.For example:COMPOSER_PROVIDERS='{  \"github\": {    \"provider\": \"github\",    \"module\": \"passport-github\",    \"clientID\": \"REPLACE_WITH_CLIENT_ID\",    \"clientSecret\": \"REPLACE_WITH_CLIENT_SECRET\",    \"authPath\": \"/auth/github\",    \"callbackURL\": \"/auth/github/callback\",    \"successRedirect\": \"/\",    \"failureRedirect\": \"/\"  }}'COMPOSER_DATASOURCESYou can use the COMPOSER_DATASOURCES environment variable to specify the LoopBack data sources and the connection information required by the selected LoopBack connector.For example:COMPOSER_DATASOURCES='{  \"db\": {    \"name\": \"db\",    \"connector\": \"mongodb\",    \"host\": \"mongo\"  }}'COMPOSER_TLSYou can use the COMPOSER_TLS environment variable to specify if the REST server should enable HTTPS and TLS. Valid values are true and false.For example:COMPOSER_TLS=trueFor more information, see Securing the REST server using HTTPS and TLS.COMPOSER_TLS_CERTIFICATEYou can use the COMPOSER_TLS_CERTIFICATE environment variable to specify the certificate file that the REST server should use when HTTPS and TLS are enabled.For example:COMPOSER_TLS_CERTIFICATE=/tmp/cert.pemCOMPOSER_TLS_KEYYou can use the COMPOSER_TLS_KEY environment variable to specify the private key file that the REST server should use when HTTPS and TLS are enabled.For example:COMPOSER_TLS_KEY=/tmp/key.pemCOMPOSER_APIKEYYou can use the COMPOSER_APIKEY environment variable to specify the API key the server should accept for each request as a header parameter x-api-key.For example:COMPOSER_APIKEY=REPLACE_WITH_YOUR_API_KEYCOMPOSER_WEBSOCKETSYou can use the COMPOSER_WEBSOCKETS environment variable to specify whether the REST server publishes events.  The default value is trueFor example:COMPOSER_WEBSOCKETS=true",
        "url": "/composer/latest/reference/rest-server"
      }
      ,
    
      "api-runtime-api": {
        "title": "Api (Runtime API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIApiA class that contains the root of the transaction processor API. Methods in thisclass are made available as global functions which can be called by transactionprocessor functions. The transaction processor API should expose no internalproperties or internal methods which could be accessed or misused.DetailsModule runtimeMethod SummaryNameReturnsDescriptionbuildQueryQueryBuild a query ready for later executionemitvoidEmit an event defined in the transactiongetAssetRegistryPromiseGet an existing asset registry using the unique identifier of the asset registrygetCurrentIdentitymodule:composer-common.ResourceGet the current identitygetCurrentParticipantmodule:composer-common.ResourceGet the current participantgetFactorymodule:composer-runtime.FactoryGet the factorygetParticipantRegistryPromiseGet an existing participant registry using the unique identifier of the participant registrygetSerializermodule:composer-common.SerializerGet the serializerpostPromisePost a typed instance to a HTTP URLqueryPromiseExecute a query defined in a Composer query file, or execute a query built with buildQueryMethod DetailsgetFactorymodule:composer-runtime.Factory getFactory(  )Get the factory. The factory can be used to create new instances of assets, participants, and transactions for storing in registries. The factory can also be used for creating relationships to assets, particpants, and transactions.ReturnsFactory - The factory.See alsoFactoryParametersNo parametersExample// Get the factory.var factory = getFactory();getSerializermodule:composer-common.Serializer getSerializer(  )Get the serializer. The serializer can be used to create new instances of assets, participants, and transactions from a JavaScript object, or to create a JavaScript object suitable for long-lived persistence.ReturnsSerializer - The serializer.ParametersNo parametersExample// Get the serializer.var ser = getSerializer();getAssetRegistryPromise getAssetRegistry( string id )Get an existing asset registry using the unique identifier of the asset registry. An asset registry can be used to retrieve, update, or delete existing assets, or create new assets.ReturnsPromise - A promise. The promise is resolved with an AssetRegistry instance representing the asset registry if it exists. If the asset registry does not exist, or the current user does not have access to the asset registry, then the promise will be rejected with an error that describes the problem.ParametersNameTypeMandatoryDescriptionidstringYesThe ID of the asset registry.Example// Get the vehicle asset registry.return getAssetRegistry('org.example.Vehicle')  .then(function (vehicleAssetRegistry) {    // Call methods on the vehicle asset registry.  })  .catch(function (error) {    // Add optional error handling here.  });getParticipantRegistryPromise getParticipantRegistry( string id )Get an existing participant registry using the unique identifier of the participant registry. An participant registry can be used to retrieve, update, or delete existing participants, or create new participants.ReturnsPromise - A promise. The promise is resolved with an ParticipantRegistry instance representing the participant registry if it exists. If the participant registry does not exist, or the current user does not have access to the participant registry, then the promise will be rejected with an error that describes the problem.ParametersNameTypeMandatoryDescriptionidstringYesThe ID of the participant registry.Example// Get the driver participant registry.return getParticipantRegistry('org.example.Driver')  .then(function (driverParticipantRegistry) {    // Call methods on the driver participant registry.  })  .catch(function (error) {    // Add optional error handling here.  });getCurrentParticipantmodule:composer-common.Resource getCurrentParticipant(  )Get the current participant. The current participant is determined by the identity that was used to submit the current transaction.ReturnsResource - The current participant, or null if the transaction was submitted using an identity that does not map to a participant.ParametersNo parametersExample// Get the current participant.var currentParticipant = getCurrentParticipant();// Check to see if the current participant is a driver.if (currentParticipant.getFullyQualifiedType() !== 'org.example.Driver') {  // Throw an error as the current participant is not a driver.  throw new Error('Current participant is not a driver');}// Check to see if the current participant is the first driver.if (currentParticipant.getFullyQualifiedIdentifier() !== 'org.example.Driver#DRIVER_1') {  // Throw an error as the current participant is not a driver.  throw new Error('Current participant is not the first driver');}getCurrentIdentitymodule:composer-common.Resource getCurrentIdentity(  )Get the current identity. The current identity is the identity that was used to submit the current transaction.ReturnsResource - The current identity, or null if the transaction was submitted using an identity that does not map to a participant.ParametersNo parametersExample// Get the current identity.var currentIdentity = getCurrentIdentity();// Get the certificate from the current identity.var certificate = currentIdentity.certificate;postPromise post( string url, Typed typed, object options )Post a typed instance to a HTTP URLReturnsPromise - A promise. The promise is resolved with a HttpResponse that represents the result of the HTTP POST.ParametersNameTypeMandatoryDescriptionurlstringYesThe URL to post the data totypedTypedYesThe typed instance to be posted. The instance will be serialized to JSON.optionsobjectYesThe options that are passed to Serializer.toJSONemitemit( Resource event )Emit an event defined in the transactionParametersNameTypeMandatoryDescriptioneventResourceYesThe event to be emittedbuildQueryQuery buildQuery( string query )Build a query ready for later execution. The specified query string must be written in the Composer query language.This functionality is Blockchain platform dependent. For example, when a Composer business network is deployed to Hyperledger Fabric v1.0, Hyperledger Fabric must be configured with the CouchDB database for the world state.ReturnsQuery - The built query, which can be passed in a call to query.ParametersNameTypeMandatoryDescriptionquerystringYesThe query string, written using the Composer query language.Example// Build a query.var q = buildQuery('SELECT org.example.sample.SampleAsset WHERE (value == _$inputValue)');// Execute the query.return query(q, { inputValue: 'blue' })  .then(function (assets) {    assets.forEach(function (asset) {      // Process each asset.    });  })  .catch(function (error) {    // Add optional error handling here.  });queryPromise query( string; Query query, [Object parameters] )Execute a query defined in a Composer query file, or execute a query built with buildQuery.This functionality is Blockchain platform dependent. For example, when a Composer business network is deployed to Hyperledger Fabric v1.0, Hyperledger Fabric must be configured with the CouchDB database for the world state.ReturnsPromise - A promise that will be resolved with an array of Resource representing the resources returned by the query.ParametersNameTypeMandatoryDescriptionquerystring; QueryYesThe name of the query, or a built query.parametersObjectYesThe parameters for the query.Example// Execute the query.return query('Q1', { inputValue: 'blue' })  .then(function (assets) {    assets.forEach(function (asset) {      // Process each asset.    });  })  .catch(function (error) {    // Add optional error handling here.  });Inherited methods",
        "url": "/composer/latest/api/runtime-api"
      }
      ,
    
      "api-runtime-assetregistry": {
        "title": "AssetRegistry (Runtime API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIAssetRegistryThe AssetRegistry is used to manage a set of assets stored on the Blockchain.Do not attempt to create an instance of this class.You must use the getAssetRegistrymethod instead.DetailsModule runtimeMethod SummaryNameReturnsDescriptionaddPromiseAdd the specified asset to this asset registryaddAllPromiseAdd all of the specified assets to this asset registryexistsPromiseDetermines whether a specific asset exists in this asset registrygetPromiseGet the specified asset in this asset registry using the unique identifier of the assetgetAllPromiseGet a list of all of the existing assets in this asset registryremovePromiseRemove the specified asset from this asset registryremoveAllPromiseRemove all of the specified assets from this asset registryupdatePromiseUpdate the specified asset in this asset registryupdateAllPromiseUpdate all of the specified assets in this asset registryMethod DetailsgetAllPromise getAll(  )Get a list of all of the existing assets in this asset registry.ReturnsPromise - A promise. The promise is resolved with an array of Resource instances representing all of the assets stored in this asset registry. If the asset registry does not exist, or the current user does not have access to the asset registry, then the promise will be rejected with an error that describes the problem.ParametersNo parametersExample// Get the vehicle asset registry.return getAssetRegistry('org.example.Vehicle')  .then(function (vehicleAssetRegistry) {    // Get all of the vehicles in the vehicle asset registry.    return assetRegistry.getAll();  })  .then(function (vehicles) {    // Process the array of vehicle objects.    vehicles.forEach(function (vehicle) {      console.log(vehicle.vehicleId);    });  })  .catch(function (error) {    // Add optional error handling here.  });getPromise get( string id )Get the specified asset in this asset registry using the unique identifier of the asset.ReturnsPromise - A promise. The promise is resolved with a Resource instance representing the specified asset in this asset registry. If the specified asset does not exist, or the current user does not have access to the specified asset, then the promise will be rejected with an error that describes the problem.ParametersNameTypeMandatoryDescriptionidstringYesThe ID of the asset.Example// Get the vehicle asset registry.return getAssetRegistry('org.example.Vehicle')  .then(function (vehicleAssetRegistry) {    // Get the specific vehicle from the vehicle asset registry.    return assetRegistry.get('VEHICLE_1');  })  .then(function (vehicle) {    // Process the the vehicle object.    console.log(vehicle.vehicleId);  })  .catch(function (error) {    // Add optional error handling here.  });existsPromise exists( string id )Determines whether a specific asset exists in this asset registry.ReturnsPromise - A promise. The promise is resolved with a boolean which is true if the specified asset exists in this asset registry, and false if the specified participant does not exist.ParametersNameTypeMandatoryDescriptionidstringYesThe ID of the asset.Example// Get the vehicle asset registry.return getAssetRegistry('org.example.Vehicle')  .then(function (vehicleAssetRegistry) {    // Determine if the specific vehicle exists in the vehicle asset registry.    return assetRegistry.exists('VEHICLE_1');  })  .then(function (exists) {    // Process the the boolean result.    console.log('Vehicle exists', exists);  })  .catch(function (error) {    // Add optional error handling here.  });addAllPromise addAll(  assets )Add all of the specified assets to this asset registry.ReturnsPromise - A promise. The promise is resolved when all of the assets have been added to this asset registry. If the assets cannot be added to this asset registry, or if the assets already exist in the asset registry, then the promise will be rejected with an error that describes the problem.ParametersNameTypeMandatoryDescriptionassetsYesThe assets to add to this asset registry.Example// Get the vehicle asset registry.return getAssetRegistry('org.example.Vehicle')  .then(function (vehicleAssetRegistry) {    // Get the factory for creating new asset instances.    var factory = getFactory();    // Create the first vehicle.    var vehicle1 = factory.newResource('org.example', 'Vehicle', 'VEHICLE_1');    vehicle1.colour = 'BLUE';    // Create the second vehicle.    var vehicle2 = factory.newResource('org.example', 'Vehicle', 'VEHICLE_2');    vehicle2.colour = 'GREEN';    // Add the vehicles to the vehicle asset registry.    return vehicleAssetRegistry.addAll([vehicle1, vehicle2]);  })  .catch(function (error) {    // Add optional error handling here.  });addPromise add( Resource asset )Add the specified asset to this asset registry.ReturnsPromise - A promise. The promise is resolved when the asset has been added to this asset registry. If the asset cannot be added to this asset registry, or if the asset already exists in the asset registry, then the promise will be rejected with an error that describes the problem.ParametersNameTypeMandatoryDescriptionassetResourceYesThe assets to add to this asset registry.Example// Get the vehicle asset registry.return getAssetRegistry('org.example.Vehicle')  .then(function (vehicleAssetRegistry) {    // Get the factory for creating new asset instances.    var factory = getFactory();    // Create the vehicle.    var vehicle = factory.newResource('org.example', 'Vehicle', 'VEHICLE_1');    vehicle.colour = 'BLUE';    // Add the vehicle to the vehicle asset registry.    return vehicleAssetRegistry.add(vehicle);  })  .catch(function (error) {    // Add optional error handling here.  });updateAllPromise updateAll(  assets )Update all of the specified assets in this asset registry.ReturnsPromise - A promise. The promise is resolved when all of the assets have been updated in this asset registry. If the assets cannot be updated in this asset registry, or if the assets do not exist in the asset registry, then the promise will be rejected with an error that describes the problem.ParametersNameTypeMandatoryDescriptionassetsYesThe assets to update in this asset registry.Example// The existing vehicles that have come from elsewhere.var vehicle1;var vehicle2;// Get the vehicle asset registry.return getAssetRegistry('org.example.Vehicle')  .then(function (vehicleAssetRegistry) {    // Get the factory for creating new asset instances.    var factory = getFactory();    // Modify the properties of the first vehicle.    vehicle1.colour = 'PURPLE';    // Modify the properties of the second vehicle.    vehicle2.colour = 'ORANGE';    // Update the vehicles in the vehicle asset registry.    return vehicleAssetRegistry.updateAll([vehicle1, vehicle2]);  })  .catch(function (error) {    // Add optional error handling here.  });updatePromise update( Resource asset )Update the specified asset in this asset registry.ReturnsPromise - A promise. The promise is resolved when the asset have been updated in this asset registry. If the asset cannot be updated in this asset registry, or if the asset does not exist in the asset registry, then the promise will be rejected with an error that describes the problem.ParametersNameTypeMandatoryDescriptionassetResourceYesThe asset to update in this asset registry.Example// The existing vehicle that has come from elsewhere.var vehicle;// Get the vehicle asset registry.return getAssetRegistry('org.example.Vehicle')  .then(function (vehicleAssetRegistry) {    // Get the factory for creating new asset instances.    var factory = getFactory();    // Modify the properties of the vehicle.    vehicle.colour = 'PURPLE';    // Update the vehicle in the vehicle asset registry.    return vehicleAssetRegistry.update(vehicle);  })  .catch(function (error) {    // Add optional error handling here.  });removeAllPromise removeAll( string[]; Resource[] assets )Remove all of the specified assets from this asset registry.ReturnsPromise - A promise. The promise is resolved when all of the assets have been removed from this asset registry. If the assets cannot be removed from this asset registry, or if the assets do not exist in the asset registry, then the promise will be rejected with an error that describes the problem.ParametersNameTypeMandatoryDescriptionassetsstring[]; Resource[]YesThe assets, or the IDs of the assets, to remove from this asset registry.Example// The existing vehicles that have come from elsewhere.var vehicle1;// Get the vehicle asset registry.return getAssetRegistry('org.example.Vehicle')  .then(function (vehicleAssetRegistry) {    // Get the factory for creating new asset instances.    var factory = getFactory();    // Remove the vehicles from the vehicle asset registry. Note that    // one vehicle is specified as a vehicle instance, and the other    // vehicle is specified by the ID of the vehicle.    return vehicleAssetRegistry.removeAll([vehicle1, 'VEHICLE_2']);  })  .catch(function (error) {    // Add optional error handling here.  });removePromise remove( string; Resource asset )Remove the specified asset from this asset registry.ReturnsPromise - A promise. The promise is resolved when the asset has been removed from this asset registry. If the asset cannot be removed from this asset registry, or if the asset does not exist in the asset registry, then the promise will be rejected with an error that describes the problem.ParametersNameTypeMandatoryDescriptionassetstring; ResourceYesThe asset, or ID of the asset, to remove from this asset registry.Example// The existing vehicle that has come from elsewhere.var vehicle;// Get the vehicle asset registry.return getAssetRegistry('org.example.Vehicle')  .then(function (vehicleAssetRegistry) {    // Get the factory for creating new asset instances.    var factory = getFactory();    // Remove the vehicle from the vehicle asset registry.    return vehicleAssetRegistry.remove(vehicle);  })  .catch(function (error) {    // Add optional error handling here.  });Inherited methods",
        "url": "/composer/latest/api/runtime-assetregistry"
      }
      ,
    
      "api-runtime-factory": {
        "title": "Factory (Runtime API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIFactoryUse the Factory to create instances of Resource: transactions, participants and assets.Do not attempt to create an instance of this class.You must use the getFactorymethod instead.DetailsModule runtimeMethod SummaryNameReturnsDescriptionnewConceptConceptCreate a new concept with a given namespace, type, and identifiernewEventResourceCreate a new type with a given namespace and typenewRelationshipRelationshipCreate a new relationship with a given namespace, type, and identifiernewResourceResourceCreate a new resource (an instance of an asset, participant, or transaction)Method DetailsnewResourceResource newResource( string ns, string type, string id )Create a new resource (an instance of an asset, participant, or transaction). The properties of the new instance should be set as standard JavaScript object properties. The new instance can then be stored in a registry using the appropriate registry APIs, for example AssetRegistry.ReturnsResource - The new instance of the resource.ParametersNameTypeMandatoryDescriptionnsstringYesThe namespace of the resource to create.typestringYesThe type of the resource to create.idstringYesThe identifier of the new resource.Example// Get the factory.var factory = getFactory();// Create a new vehicle.var vehicle = factory.newResource('org.example', 'Vehicle', 'VEHICLE_1');// Set the properties of the new vehicle.vehicle.colour = 'BLUE';vehicle.manufacturer = 'Toyota';newRelationshipRelationship newRelationship( string ns, string type, string id )Create a new relationship with a given namespace, type, and identifier. A relationship is a typed pointer to an instance. For example, a new relationship with namespace &#39;org.example&#39;, type &#39;Vehicle&#39; and identifier &#39;VEHICLE_1&#39; creates` a pointer that points at an existing instance of org.example.Vehicle with the identifier &#39;VEHICLE_1&#39;.ReturnsRelationship - The new instance of the relationship.ParametersNameTypeMandatoryDescriptionnsstringYesThe namespace of the resource referenced by the relationship.typestringYesThe type of the resource referenced by the relationship.idstringYesThe identifier of the resource referenced by the relationship.Example// The existing driver of the vehicle.var driver;// Get the factory.var factory = getFactory();// Create a new relationship to the vehicle.var vehicle = factory.newRelationship('org.example', 'Vehicle', 'VEHICLE_1');// Set the relationship as the value of the vehicle property of the driver.driver.vehicle = vehicle;newConceptConcept newConcept( string ns, string type )Create a new concept with a given namespace, type, and identifier. A concept is an advanced data structureReturnsConcept - The new instance of the concept.ParametersNameTypeMandatoryDescriptionnsstringYesThe namespace of the concept.typestringYesThe type of the concept.Example// The existing driver of the vehicle.var person;// Get the factory.var factory = getFactory();// Create a new relationship to the vehicle.var record = factory.newConcept('org.example', 'Record');// Add the record to the persons array of records.person.records.push(record);newEventResource newEvent( string ns, string type )Create a new type with a given namespace and typeReturnsResource - The new instance of the event.ParametersNameTypeMandatoryDescriptionnsstringYesThe namespace of the event.typestringYesThe type of the event.Inherited methods",
        "url": "/composer/latest/api/runtime-factory"
      }
      ,
    
      "api-runtime-participantregistry": {
        "title": "ParticipantRegistry (Runtime API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIParticipantRegistryThe ParticipantRegistry is used to manage a set of participants stored on the blockchain.Do not attempt to create an instance of this class. You must use the getParticipantRegistrymethod instead.DetailsModule runtimeMethod SummaryNameReturnsDescriptionaddPromiseAdd the specified participant to this participant registryaddAllPromiseAdd all of the specified participants to this participant registryexistsPromiseDetermines whether a specific participant exists in this participant registrygetPromiseGet the specified participant in this participant registry using the unique identifier of the participantgetAllPromiseGet a list of all of the existing participants in this participant registryremovePromiseRemove the specified participant from this participant registryremoveAllPromiseRemove all of the specified participants from this participant registryupdatePromiseUpdate the specified participant in this participant registryupdateAllPromiseUpdate all of the specified participants in this participant registryMethod DetailsgetAllPromise getAll(  )Get a list of all of the existing participants in this participant registry.ReturnsPromise - A promise. The promise is resolved with an array of Resource instances representing all of the participants stored in this participant registry. If the participant registry does not exist, or the current user does not have access to the participant registry, then the promise will be rejected with an error that describes the problem.ParametersNo parametersExample// Get the driver participant registry.return getParticipantRegistry('org.example.Driver')  .then(function (participantRegistry) {    // Get all of the drivers in the driver participant registry.    return participantRegistry.getAll();  })  .then(function (drivers) {    // Process the array of driver objects.    drivers.forEach(function (driver) {      console.log(driver.driverId);    });  })  .catch(function (error) {    // Add optional error handling here.  });getPromise get( string id )Get the specified participant in this participant registry using the unique identifier of the participant.ReturnsPromise - A promise. The promise is resolved with a Resource instance representing the specified participant in this participant registry. If the specified participant does not exist, or the current user does not have access to the specified participant, then the promise will be rejected with an error that describes the problem.ParametersNameTypeMandatoryDescriptionidstringYesThe ID of the participant.Example// Get the driver participant registry.return getParticipantRegistry('org.example.Driver')  .then(function (participantRegistry) {    // Get the specific driver from the driver participant registry.    return participantRegistry.get('VEHICLE_1');  })  .then(function (driver) {    // Process the the driver object.    console.log(driver.driverId);  })  .catch(function (error) {    // Add optional error handling here.  });existsPromise exists( string id )Determines whether a specific participant exists in this participant registry.ReturnsPromise - A promise. The promise is resolved with a boolean which is true if the specified participant exists in this participant registry, and false if the specified participant does not exist.ParametersNameTypeMandatoryDescriptionidstringYesThe ID of the participant.Example// Get the driver participant registry.return getParticipantRegistry('org.example.Driver')  .then(function (participantRegistry) {    // Determine if the specific driver exists in the driver participant registry.    return participantRegistry.exists('VEHICLE_1');  })  .then(function (exists) {    // Process the the boolean result.    console.log('Driver exists', exists);  })  .catch(function (error) {    // Add optional error handling here.  });addAllPromise addAll(  participants )Add all of the specified participants to this participant registry.ReturnsPromise - A promise. The promise is resolved when all of the participants have been added to this participant registry. If the participants cannot be added to this participant registry, or if the participants already exist in the participant registry, then the promise will be rejected with an error that describes the problem.ParametersNameTypeMandatoryDescriptionparticipantsYesThe participants to add to this participant registry.Example// Get the driver participant registry.return getParticipantRegistry('org.example.Driver')  .then(function (participantRegistry) {    // Get the factory for creating new participant instances.    var factory = getFactory();    // Create the first driver.    var driver1 = factory.newResource('org.example', 'Driver', 'VEHICLE_1');    driver1.location = 'Southampton';    // Create the second driver.    var driver2 = factory.newResource('org.example', 'Driver', 'VEHICLE_2');    driver2.location = 'GREEN';    // Add the drivers to the driver participant registry.    return participantRegistry.addAll([driver1, driver2]);  })  .catch(function (error) {    // Add optional error handling here.  });addPromise add( Resource participant )Add the specified participant to this participant registry.ReturnsPromise - A promise. The promise is resolved when the participant has been added to this participant registry. If the participant cannot be added to this participant registry, or if the participant already exists in the participant registry, then the promise will be rejected with an error that describes the problem.ParametersNameTypeMandatoryDescriptionparticipantResourceYesThe participants to add to this participant registry.Example// Get the driver participant registry.return getParticipantRegistry('org.example.Driver')  .then(function (participantRegistry) {    // Get the factory for creating new participant instances.    var factory = getFactory();    // Create the driver.    var driver = factory.newResource('org.example', 'Driver', 'VEHICLE_1');    driver.location = 'Southampton';    // Add the driver to the driver participant registry.    return participantRegistry.add(driver);  })  .catch(function (error) {    // Add optional error handling here.  });updateAllPromise updateAll(  participants )Update all of the specified participants in this participant registry.ReturnsPromise - A promise. The promise is resolved when all of the participants have been updated in this participant registry. If the participants cannot be updated in this participant registry, or if the participants do not exist in the participant registry, then the promise will be rejected with an error that describes the problem.ParametersNameTypeMandatoryDescriptionparticipantsYesThe participants to update in this participant registry.Example// The existing drivers that have come from elsewhere.var driver1;var driver2;// Get the driver participant registry.return getParticipantRegistry('org.example.Driver')  .then(function (participantRegistry) {    // Get the factory for creating new participant instances.    var factory = getFactory();    // Modify the properties of the first driver.    driver1.location = 'Hursley';    // Modify the properties of the second driver.    driver2.location = 'London';    // Update the drivers in the driver participant registry.    return participantRegistry.updateAll([driver1, driver2]);  })  .catch(function (error) {    // Add optional error handling here.  });updatePromise update( Resource participant )Update the specified participant in this participant registry.ReturnsPromise - A promise. The promise is resolved when the participant have been updated in this participant registry. If the participant cannot be updated in this participant registry, or if the participant does not exist in the participant registry, then the promise will be rejected with an error that describes the problem.ParametersNameTypeMandatoryDescriptionparticipantResourceYesThe participant to update in this participant registry.Example// The existing driver that has come from elsewhere.var driver;// Get the driver participant registry.return getParticipantRegistry('org.example.Driver')  .then(function (participantRegistry) {    // Get the factory for creating new participant instances.    var factory = getFactory();    // Modify the properties of the driver.    driver.location = 'Hursley';    // Update the driver in the driver participant registry.    return participantRegistry.update(driver);  })  .catch(function (error) {    // Add optional error handling here.  });removeAllPromise removeAll( string[]; Resource[] participants )Remove all of the specified participants from this participant registry.ReturnsPromise - A promise. The promise is resolved when all of the participants have been removed from this participant registry. If the participants cannot be removed from this participant registry, or if the participants do not exist in the participant registry, then the promise will be rejected with an error that describes the problem.ParametersNameTypeMandatoryDescriptionparticipantsstring[]; Resource[]YesThe participants, or the IDs of the participants, to remove from this participant registry.Example// The existing drivers that have come from elsewhere.var driver1;// Get the driver participant registry.return getParticipantRegistry('org.example.Driver')  .then(function (participantRegistry) {    // Get the factory for creating new participant instances.    var factory = getFactory();    // Remove the drivers from the driver participant registry. Note that    // one driver is specified as a driver instance, and the other    // driver is specified by the ID of the driver.    return participantRegistry.removeAll([driver1, 'VEHICLE_2']);  })  .catch(function (error) {    // Add optional error handling here.  });removePromise remove( string; Resource participant )Remove the specified participant from this participant registry.ReturnsPromise - A promise. The promise is resolved when the participant has been removed from this participant registry. If the participant cannot be removed from this participant registry, or if the participant does not exist in the participant registry, then the promise will be rejected with an error that describes the problem.ParametersNameTypeMandatoryDescriptionparticipantstring; ResourceYesThe participant, or ID of the participant, to remove from this participant registry.Example// The existing driver that has come from elsewhere.var driver;// Get the driver participant registry.return getParticipantRegistry('org.example.Driver')  .then(function (participantRegistry) {    // Get the factory for creating new participant instances.    var factory = getFactory();    // Remove the driver from the driver participant registry.    return participantRegistry.remove(driver);  })  .catch(function (error) {    // Add optional error handling here.  });Inherited methods",
        "url": "/composer/latest/api/runtime-participantregistry"
      }
      ,
    
      "api-runtime-query": {
        "title": "Query (Runtime API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APIQueryThe Query class represents a built query.Do not attempt to create an instance of this class.You must use the buildQuerymethod instead.DetailsModule runtimeMethod DetailsInherited methods",
        "url": "/composer/latest/api/runtime-query"
      }
      ,
    
      "api-runtime-serializer": {
        "title": "Serializer (Runtime API)",
        "author": "",
        "category": "",
        "content": "Overview  -  Common API  -  Client API  -  Admin API  -  Runtime APISerializerDo not attempt to create an instance of this class.You must use the getSerializermethod instead.DetailsModule runtimeMethod SummaryNameReturnsDescriptionfromJSONResourceCreate a Resource from a JavaScript object representationtoJSONObjectConvert a Resource to a JavaScript object suitable for long-term peristent storageMethod DetailstoJSONObject toJSON( Resource resource, [Object options] )Convert a Resource to a JavaScript object suitable for long-term peristent storage.ReturnsObject - The JavaScript object that represents the resourceParametersNameTypeMandatoryDescriptionresourceResourceYesThe resource instance to convert to JSON.optionsObjectYesThe optional serialization options.Sub-optionsNameTypeMandatoryDescriptionoptions.validatebooleanYesValidate the structure of the resource with its model prior to serialization, true by default.options.convertResourcesToRelationshipsbooleanYesConvert resources that are specified for relationship fields into relationships, false by default.options.permitResourcesForRelationshipsbooleanYesPermit resources in the place of relationships (serializing them as resources), false by default.options.deduplicateResourcesbooleanYesGenerate $id for resources and if a resources appears multiple times in the object graph only the first instance is serialized in full, subsequent instances are replaced with a reference to the $idExample// Get the serializer.var serializer = getSerializer();// Serialize a vehicle.var json = serializer.toJSON(vehicle);fromJSONResource fromJSON( Object json, [Object options] )Create a Resource from a JavaScript object representation. The JavaScript object should have been created by calling the toJSON apiReturnsResource - The resource.ParametersNameTypeMandatoryDescriptionjsonObjectYesThe JavaScript object for the resource.optionsObjectYesThe optional serialization options.Sub-optionsNameTypeMandatoryDescriptionoptions.acceptResourcesForRelationshipsbooleanYesHandle JSON objects in the place of strings for relationships, false by default.options.validatebooleanYesValidate the structure of the resource with its model prior to serialization, true by default.Example// Get the serializer.var serializer = getSerializer();// Serialize a vehicle.var vehicle = serializer.fromJSON(json);Inherited methods",
        "url": "/composer/latest/api/runtime-serializer"
      }
      ,
    
      "search-search": {
        "title": "Hyperledger Composer - Search",
        "author": "",
        "category": "search",
        "content": "Search Results",
        "url": "/composer/latest/search/search"
      }
      ,
    
      "integrating-securing-the-rest-server": {
        "title": "Securing the REST server using HTTPS and TLS",
        "author": "",
        "category": "start",
        "content": "# Securing the REST server using HTTPS and TLS---When deploying {{site.data.conrefs.composer_full}} REST server in a production environment, the REST server should be configured to be secured with HTTPS and TLS (Transport Layer Security). Once the REST server has been configured with HTTPS and TLS, all data transferred between the REST server and all of the REST clients is encrypted.You must provide both a certificate and a private key pair to configure the REST server. The REST server includes a sample certificate and private key pair that can be used to easily get going, but this configuration is only recommended for ease of use during initial development. Do not use the sample certificate and private key pair in a production environment.## Enabling HTTPS and TLS by using the sample certificate and private key pairYou can enable HTTPS and TLS using the sample certificate and private key pair by using the `-t` argument to the command line:    composer-rest-server -c alice1@my-network -tAlternatively, you can enable HTTPS and TLS using the sample certificate and private key pair by using the `COMPOSER_TLS` environment variable:    export COMPOSER_TLS=true    composer-rest-server -c alice1@my-networkWhen you have successfully enabled HTTPS and TLS, you will see that the output of the REST server specifies an `https://` URL instead of a `http://` URL:    Web server listening at: https://localhost:3000    Browse your REST API at https://localhost:3000/explorerThis configuration is only recommended for ease of use during initial development. For a test, QA, or production deployment, you should provide your own certificate and private key to enable HTTPS and TLS.## Enabling HTTPS and TLS by providing a certificate and private key pairYou can enable HTTPS and TLS by providing your own certificate and private key pair. The certificate and private key pair must be provided as two separate files in the PEM format. The files must be available on the file system of the system running the REST server, and the REST server must have read access to those files.You can configure the THE REST server to use your certificate and private key pair files by using the '-e' (certificate file) and '-k' (private key file) arguments to the command line:    composer-rest-server -c alice1@my-network -t -e /tmp/cert.pem -k /tmp/key.pemAlternatively, you can configure the THE REST server to use your certificate and private key pair files by using the `COMPOSER_TLS_CERTIFICATE` and `COMPOSER_TLS_KEY` environment variables:    export COMPOSER_TLS=true    export COMPOSER_TLS_CERTIFICATE=/tmp/cert.pem    export COMPOSER_TLS_KEY=/tmp/key.pem    composer-rest-server -c alice1@my-network",
        "url": "/composer/latest/integrating/securing-the-rest-server"
      }
      ,
    
      "introduction-solution-architecture": {
        "title": "Typical Solution Architecture",
        "author": "",
        "category": "",
        "content": "# Typical {{site.data.conrefs.composer_full}} Solution Architecture{{site.data.conrefs.composer_full}} enables architects and developers to quickly create \"full-stack\" blockchain solutions. I.e. business logic that runs on the blockchain, REST APIs that expose the blockchain logic to web or mobile applications, as well as integrating the blockchain with existing enterprise systems of record.---{{site.data.conrefs.composer_full}} is composed of the following high-level components:* Execution Runtimes* JavaScript SDK* Command Line Interface* REST Server* LoopBack Connector* Playground Web User Interface* Yeoman code generator* VSCode and Atom editor plugins## Execution Runtimes{{site.data.conrefs.composer_full}} has been designed to support different pluggable runtimes, and currently has three runtime implementations:* {{site.data.conrefs.hlf_full}} {{site.data.conrefs.hlf_latest}}. State is stored on the distributed ledger.* Web, which executes within a web page, and is used by Playground. State is stored in browser local storage.* Embedded, which executes within a Node.js process, and is used primarily for unit testing business logic. State is stored in an in-memory key-value store.### Connection ProfilesConnection Profiles are used across {{site.data.conrefs.composer_full}} to specify how to connect to an execution runtime. There are different configuration options for each _type_ of execution runtime. For example, the connection profile for a {{site.data.conrefs.hlf_full}} {{site.data.conrefs.hlf_latest}} runtime will contain the TCP/IP addresses and ports for the Fabric peers, as well as cryptographic certificates etc.Connection Profiles are part of Business Network cards.## JavaScript SDKThe {{site.data.conrefs.composer_full}} JavaScript SDK is a set of Node.js APIs the enables developers to create applications to manage and interact with deployed business networks.The APIs are split between two npm modules:1. `composer-client` used to submit transactions to a business network or to perform Create, Read, Update, Delete operations on assets and participants2. `composer-admin` used to manage business networks (install, start, upgrade)Details of all the APIs are available as JSDocs (see reference).### composer-clientThis module would usually be installed as a local dependency of an application. It provides the API that is used by business applications to connect to a business network to access __assets__, __participants__ and submitting __transactions__. When in production this is only module that needs to be added as a direct dependency of the application.### composer-adminThis module would usually be installed as a local dependency of **administrative** applications. This API permits the creation of and deployment of __business network definitions__.## Command Line InterfaceThe `composer` command line tool enables developers and administrators to deploy and managed business network definitions.## REST ServerThe {{site.data.conrefs.composer_full}} REST Server automatically generates a Open API (Swagger) REST API for a business network. The REST Server (based on LoopBack technology) converts the {{site.data.conrefs.composer_short}} model for a business network into an Open API definition, and at runtime implements Create, Read, Update and Delete support for assets and participants and allows transactions to be submitted for processing or retrieved.## LoopBack ConnectorThe {{site.data.conrefs.composer_full}} LoopBack Connector is used by the {{site.data.conrefs.composer_short}} REST Server, however it may also be used standalone by integration tools that support LoopBack natively. Alternatively it may be used with the LoopBack tools to create more sophisticated customizations of the REST APIs.## Playground Web User Interface{{site.data.conrefs.composer_full}} Playground is a web user interface to define and test business networks. It allows a business analyst to quickly import samples and prototype business logic that executes on the Web or {{site.data.conrefs.hlf_full}} runtime.## Yeoman Code Generators{{site.data.conrefs.composer_full}} uses the Open Source Yeoman code generator framework to create skeleton projects:* Angular web application* Node.js application* Skeleton business network## VSCode and Atom Editor Extensions{{site.data.conrefs.composer_full}} has community contributed editor extensions for VSCode and Atom. The VSCode extension is very powerful and validates {{site.data.conrefs.composer_short}} model and ACL files, providing syntax highlighting, error detection and snippets support. The Atom plugin is much more rudimentary and only has basic syntax highlighting.",
        "url": "/composer/latest/introduction/solution-architecture"
      }
      ,
    
      "applications-subscribing-to-events": {
        "title": "Subscribing to events",
        "author": "",
        "category": "tasks",
        "content": "# Subscribing to eventsNode.js applications can subscribe to events from a business network by using the `composer-client.BusinessNetworkConnection.on` API call. Events are defined in the business network model file and are emitted by specified transactions in the transaction processor function file. For more information on publishing events, see [publishing events](../business-network/publishing-events.html).## Before you beginBefore an application can subscribe to events, you must have defined some events and the transactions which will emit them. The business network must also be deployed and you must have a connection profile that can connect to it.## Procedure1. An application must send a specific API call to subscribe to events emitted transactions in a business network. Currently, an application which subscribes to events will receive all events which are emitted. The API call should take the following format:```JavascriptbusinessNetworkConnection.on('event', (event) => {    // event: { \"$class\": \"org.namespace.BasicEvent\", \"eventId\": \"0000-0000-0000-000000#0\" }    console.log(event);});```  This includes an event called `BasicEvent` which was created in the [publishing events](../business-network/publishing-events.html) documentation. The `eventId` property is always the same as the `transactionId` of the transaction which emitted the event, with an appended number in the form `\"transactionId\": \"#number\"`.## What next?The application will now receive all of the events emitted by the business network, and it's up to the application to choose to what extent those events are integrated.---",
        "url": "/composer/latest/applications/subscribing-to-events"
      }
      ,
    
      "support-support-index": {
        "title": "Support",
        "author": "",
        "category": "start",
        "content": "#Community## Ask a question### Hyperledger Rocket.ChatYou will need a [Linux Foundation ID](https://identity.linuxfoundation.org/) , or alternatively you can log in with Facebook, GitHub, Google, or OpenStack.Let's chat### Stack OverflowAsk questions in Stack Overflow with the tag **#hyperledger-composer**.Ask now## Contribute to the Project### GitHubCheck out the code, feel free to get involved.GitHub### Community CallJoin our weekly open community calls.Learn how",
        "url": "/composer/latest/support/support-index"
      }
      ,
    
      "systemns-systemns-index": {
        "title": "System Namespace Reference",
        "author": "",
        "category": "",
        "content": "# The {{site.data.conrefs.composer_full}} system namespaceThe {{site.data.conrefs.composer_full}} system namespace is the base definition of all business network class definitions. All asset, participant, and transaction definitions extend those defined here.## SummaryIn the [summary section](./01_summary.html) there is a full list of all {{site.data.conrefs.composer}} system namespace class definitions, along with their associated namespaces, names, and descriptions. For more information on an individual class definition, check the appropriate page.## AssetsThe system namespace assets are:- Asset- Registry- AssetRegistry- ParticipantRegistry- TransactionRegistry- Network- HistorianRecord- Identity## ParticipantsThe system namespace participants are:- Participant- NetworkAdmin## TransactionsThe system namespace transactions are:- Transaction- RegistryTransaction- AssetTransaction- ParticipantTransaction- AddAsset- UpdateAsset- RemoveAsset- AddParticipant- UpdateParticipant- RemoveParticipant- IssueIdentity- BindIdentity- ActivateCurrentIdentity- RevokeIdentity- StartBusinessNetwork- ResetBusinessNetwork- SetLogLevel## EventsThe system namespace events are:- Event## EnumerationsThe system namespace enumerations are:- IdentityState",
        "url": "/composer/latest/systemns/systemns-index"
      }
      ,
    
      "business-network-testing": {
        "title": "Testing Business Networks",
        "author": "",
        "category": "tasks",
        "content": "# Testing Business Networks{{site.data.conrefs.composer_full}} supports three types of testing: interactive testing, automated unit testing and automated system testing. All three serve different purposes and are vital to ensuring the success of your blockchain projects.After you have deployed a business network definition it is often useful to run an interative \"smoke test\" to ensure that the deployment was successful. The `composer` CLI exposes several commands for running such smoke tests.At the other end of the spectrum you can write full-blown system tests using Docker Compose and Mocha/Chai, that start a runtime, deploy your business network definition and then programmatically creates assets, submits transactions and inspect the state of asset registries.Unit tests focus on ensuring that the correct changes to the world-state take place when a transaction is processed.The execution of both unit tests and system tests may be automated using a CI/CD build pipeline, such as Jenkins, Travis CI, or Circle CI or alternatives.## Interactive TestingYou can use the Playground to interactively test creating participants, assets and submitting transactions.## Testing from the Command LineThe command line can be used to inspect the state of the runtime and to submit transactions. Use the `composer network list` command to see the state of asset and participant registries. Use the `composer transaction submit` command to submit transactions.## Creating Unit TestsThe business logic in transaction processor functions should have unit tests, ideally with 100% code coverage. This will ensure that you do not have typos or logic errors in the business logic.You can use standard JavaScript testing libraries, such as Mocha, Chai, Sinon and Istanbul to unit test the logic in your transaction processor functions.The `embedded` runtime is very useful for unit testing, as it allows you to quickly test business logic in a simulated Node.js blockchain environment, without having to stand-up a {{site.data.conrefs.hlf_full}}.Please refer to the sample networks for examples of unit tests. For example:https://github.com/hyperledger/composer-sample-networks/blob/master/packages/bond-network/test/Bond.js## References* [**Composer CLI commands**](../reference/commands.html)* [**Mocha**](https://mochajs.org)* [**Chai**](http://chaijs.com)* [**Sinon**](http://sinonjs.org)* [**Istanbul**](https://istanbul.js.org)",
        "url": "/composer/latest/business-network/testing"
      }
      ,
    
      "tutorials-tutorials": {
        "title": "Tutorials",
        "author": "",
        "category": "tutorials",
        "content": "# Tutorials---We have several basic and advanced tutorials:## Playground TutorialThe Playground tutorial runs through using the Playground to track the ownership of commodities in a business network.This tutorial can be followed using the web Playground (no install necessary) or with your own Playground (acquired as part of the install instructions).[**Start Playground Tutorial**](../tutorials/playground-tutorial.html)## Developer TutorialThis tutorial presumes you have a development environment setup including the [**installation of the development tools**](../installing/development-tools.html).The developer tutorial will walk you through the steps required to build a {{site.data.conrefs.composer_full}} blockchain solution from scratch. In the space of a day or so you should be able to go from an idea for a disruptive blockchain innovation to a complete business network, running on {{site.data.conrefs.hlf_full}}.[**Start Developer Tutorial**](../tutorials/developer-tutorial.html).## Access Control Language (ACL) TutorialThis tutorial presumes that you have some experience using {{site.data.conrefs.composer_short}}.In this tutorial, you will incrementally build ACL rules for a sample Commodity Trading business network, and test the ACLs as an integral step during the rules build. You can complete the tutorial in the online Playground (and you deploy the Trade sample network there) ; but you can equally complete the tutorial if you deploy that sample network to your {{site.data.conrefs.hlf_full}} runtime.[**Start the ACL tutorial**](../tutorials/acl-trading.html).## Query TutorialThis tutorial presumes that you have some experience using {{site.data.conrefs.composer_short}}.In this tutorial, we will build on the 'Commodity Trading' developer tutorial, extending it to show the use of queries in {{site.data.conrefs.composer_short}}. This tutorial demonstrates the power of the native {{site.data.conrefs.composer_short}} query language to filter results returned using criteria and to perform operations on result sets, such as updating or removing assets using a transaction function that uses queries.[**Start the queries tutorial**](../tutorials/queries.html).## Deploying to a single organization {{site.data.conrefs.hlf_full}}This tutorial presumes that you have experience setting up an instance of {{site.data.conrefs.hlf_full}}.In this tutorial, {{site.data.conrefs.composer_full}} is configured for a running instance of {{site.data.conrefs.hlf_full}} and a business network is deployed using that configuration.[**Start the single organization {{site.data.conrefs.hlf_full}} deployment tutorial**](../tutorials/deploy-to-fabric-single-org.html).## Deploying to a multi-organization {{site.data.conrefs.hlf_full}}This tutorial presumes that you have experience using {{site.data.conrefs.hlf_full}}.In this tutorial, two organization administrators configure their instances of {{site.data.conrefs.composer_full}} to interact with the same channel in {{site.data.conrefs.hlf_full}}.[**Start the multi-organization {{site.data.conrefs.hlf_full}} deployment tutorial**](../tutorials/deploy-to-fabric-multi-org.html).## Interacting with other business networksIn this tutorial, we will demonstrate the steps that a business network developer needs to take in order to invoke a {{site.data.conrefs.composer_full}} business network from a different business network[**Start the invoking a {{site.data.conrefs.composer_full}} business network from another business network tutorial**](../tutorials/invoke-composer-network.html).---",
        "url": "/composer/latest/tutorials/tutorials"
      }
      ,
    
      "installing-uninstall-dev-env": {
        "title": "Uninstalling the development environment",
        "author": "",
        "category": "start",
        "content": "# Uninstall the development environmentFollow these instructions if you have already installed the {{site.data.conrefs.composer_full}} development tools, and you wish to uninstall them. You may want to do this if you wish to update your existing development environment to an incompatible version of {{site.data.conrefs.composer_full}} (for example, from v0.16.x to v0.19.x), or you no longer require a development environment.## Before you beginThese instructions assume that you've installed the development tools and used them before. If you have not installed the development tools before, then there's nothing to do here!# Uninstalling components### Step 1: Uninstall the CLI toolsAny running instances of the CLI tools should be stopped before continuing. If you have any running instances of the {{site.data.conrefs.composer_short}} REST server, ensure that those instances are stopped before continuing. You can look for the process `composer-rest-server` if you are not sure if there are any running instances.1. Uninstall the currently installed version of all the CLI tools:        npm uninstall -g composer-cli composer-rest-server generator-hyperledger-composer### Step 2: Uninstall PlaygroundIf you have installed the browser app \"Playground\" on your development machine, you will need to uninstall this as well. If you have any running instances of the browser app, ensure that those instances are stopped before continuing. You can look for the process `composer-playground` if you are not sure if there are any running instances.1. Uninstall the currently installed version of the browser app:        npm uninstall -g composer-playground### Step 3: Remove the business network card storeBusiness network cards are stored in a business network card store, which by default is a directory in the current users home directory. Delete this directory to remove all business network cards. Be warned that this will also delete all identities (public certificates and private keys) that are stored in the business network card store, so you may wish to back them up before continuing!1. Remove the business network card store:        rm -rf ~/.composer### Step 4: Uninstall {{site.data.conrefs.hlf_full}}You control your local {{site.data.conrefs.hlf_full}} runtime using a set of scripts which you'll find in `~/fabric-dev-servers` if you followed the suggested defaults.1. Stop the local {{site.data.conrefs.hlf_full}} runtime and remove any runtime Docker containers or images:        {{site.data.conrefs.export_fabric_version_command}}        ~/fabric-dev-servers/stopFabric.sh        ~/fabric-dev-servers/teardownFabric.sh2. Uninstall the local {{site.data.conrefs.hlf_full}} runtime:        rm -rf ~/fabric-dev-servers> Congratulations, you have uninstalled your development environment. To continue developing your blockchain applications, you will need to install the development tools from scratch.## What Next?- Install the development tools again by following [Installing the development environment](./development-tools.html)",
        "url": "/composer/latest/installing/uninstall-dev-env"
      }
      ,
    
      "installing-update-dev-env": {
        "title": "Updating the development environment",
        "author": "",
        "category": "start",
        "content": "# Updating the development environmentFollow these instructions if you have already installed the {{site.data.conrefs.composer_full}} development tools, and you wish to update your installation to the latest version of {{site.data.conrefs.composer_full}}.## Before you beginThese instructions assume that you've installed the development tools and used them before. If you have not installed the development tools before, then follow the instructions in [**Installing the development environment**](./development-tools.html).# Updating components### Step 1: Update the CLI toolsAny running instances of the CLI tools should be stopped before continuing. If you have any running instances of the {{site.data.conrefs.composer_short}} REST server, ensure that those instances are stopped before continuing. You can look for the process `composer-rest-server` if you are not sure if there are any running instances.1. Uninstall the currently installed version of all the CLI tools:        npm uninstall -g composer-cli composer-rest-server generator-hyperledger-composer2. Install the latest version of all of the CLI tools:        npm install -g composer-cli@{{site.data.conrefs.composer_version}} composer-rest-server@{{site.data.conrefs.composer_version}} generator-hyperledger-composer@{{site.data.conrefs.composer_version}}### Step 2: Update PlaygroundIf you have installed the browser app \"Playground\" on your development machine, you will need to update this as well. If you have any running instances of the browser app, ensure that those instances are stopped before continuing. You can look for the process `composer-playground` if you are not sure if there are any running instances.1. Uninstall the currently installed version of the browser app:        npm uninstall -g composer-playground2. Install the latest version of the browser app:        npm install -g composer-playground@{{site.data.conrefs.composer_version}}> Congratulations, you have updated your development environment with the latest version of the development tools. You can now continue developing your blockchain applications using the latest features and bug fixes!## What Next?- Learn how to use the web app UI with the [Playground Tutorial](../tutorials/playground-tutorial.html)- Learn how to use the CLI and VSCode tools with the [Developer Tutorial](../tutorials/developer-tutorial.html)",
        "url": "/composer/latest/installing/update-dev-env"
      }
      ,
    
      "business-network-upgrading-bna": {
        "title": "Upgrading a deployed business network",
        "author": "",
        "category": "tasks",
        "content": "# Upgrading a deployed business networkAfter a business network has been successfully deployed to a blockchain it may be necessary to upgrade the business network definition. To upgrade a business network definition, first make the updates you wish to deploy to your local copy of the business network component files (model, script, query, access control, and transaction processor files), then update the version of your local business network files. After updating the version install the new version of the `.bna` to your blockchain, and use the `composer network upgrade` command to switch to using your new version.## Before you beginBefore upgrading a deployed business network definition:- Ensure your business network has successfully deployed.- Make any required updates to your business network you wish to deploy.## Step One: Updating the business network versionIt is important that the `package.json` file is updated before installing a new version of your business network to your blockchain.1. Open the `package.json` file in your business network directory.2. Update the **version** property. The version property must be a `.` separated number, for example, `0.0.2` or `1.16.4`. Make sure to take note of the version number you are setting as it is required for the following steps.## Step Two: Package your business networkAfter updating the version number, the business network must be packaged into a business network archive (`.bna`). The `.bna` can then be installed on the blockchain and started. The `composer archive create` command can package either a directory or an npm module, for this example we'll use the directory command.1. From your business network directory run the `composer archive create` command:        composer archive create -t dir -n .## Step Three: Installing the new business networkWhen the business network has been packaged, it must be installed to the blockchain. It is installed using the same process as when the original business network was installed.1. Install the business network to your blockchain using the following command:        composer network install -a NETWORK-FILENAME.bna -c peeradmin@hlfv1    The business network card used in the command must be a peer admin card in order to install the business network to the blockchain peers.## Step Four: Upgrading to the new business networkNow that the business network has been installed to the peers, it must be started. The `composer network upgrade` command will instruct the peers to stop using the older version of the business network and begin using the version specified in the command.1. Upgrade to the business network that was installed using the following command:        composer network upgrade -c peeradmin@hlfv1 -n NETWORK-NAME -V NETWORK-VERSION    The network name and network version must match the contents of the `package.json` in the installed business network.Your business network should now be successfully upgraded.",
        "url": "/composer/latest/business-network/upgrading-bna"
      }
      ,
    
      "applications-web": {
        "title": "Writing Web applications",
        "author": "",
        "category": "start",
        "content": "# Writing Web ApplicationsTo interact with a deployed business network, web applications should make REST API calls. To create a custom REST API for a business network, use the `composer-rest-server` command.To create a skeleton Angular application that can interact with the REST API, use the `yo hyperledger-composer` command.Please follow the [Developer Tutorial](../tutorials/developer-tutorial.html) for an example of how to use the `composer-rest-server` and the Angular generator.## Generating an Angular application from a Business Network Archive (.BNA)The flow for building an Angular application is as follows:If you already have a Business Network Archive and would like to build a skeleton Angular application, use the following reference instructions, if you would like to fully understand how to develop a BNA from scratch and build an application from there please see the [Developer Tutorial](../tutorials/developer-tutorial.html).**Prerequisites**- You will need the {{site.data.conrefs.composer_full}} [development tools](../installing/development-tools.html) in order to run the Angular generator.- A Business Network Archive (.BNA) you would like to deploy.### 1. Start {{site.data.conrefs.hlf_full}} running on your local machineIf you have already installed the development tools you will have {{site.data.conrefs.hlf_full}} already installed.Head to the `fabric-dev-servers` directory and start {{site.data.conrefs.hlf_full}}. The following code is an example if you have used our development tools install guide:```bashcd ~/fabric-dev-servers{{site.data.conrefs.export_fabric_version_command}}./startFabric.sh./createPeerAdminCard.sh```This will also create a `PeerAdmin` .card file which is needed to modify code running on the peers of your deployment.You can list all of the cards you have installed at any time by running the following command:```bashcomposer card list```### 2. Prepare the {{site.data.conrefs.hlf_full}} peersIn order to install the Business Network Archive onto the {{site.data.conrefs.hlf_full}} network you need to install the business network onto the peers. It is recommended you start with a clean directory. Move your BNA into that directory and change your terminal directory to it.You will need to have the Business Network archive to do this, below you can see an example with `tutorial-network` along with the 'PeerAdmin' card for your deployment.```composer network install --card PeerAdmin@hlfv1 --archiveFile tutorial-network@0.0.1.bna```### 3. Start your Business Network on your {{site.data.conrefs.hlf_full}}We will use the `composer network start` command to start the business network, we will need to use our `PeerAdmin` card to do this. We will also need to create a user on our network, we will use an \"Admin\" username and password to get started.Below is an example using a `tutorial-network` BNA.```bashcomposer network start --networkName tutorial-network --networkVersion 0.0.1 --networkAdmin admin --networkAdminEnrollSecret adminpw --card PeerAdmin@hlfv1```This will create an 'admin' card for the business network, which for the previous example is `admin@tutorial-network.card`*Please note: The `admin` username and `adminpw` secret are for a specific {{site.data.conrefs.hlf_full}} identity configured for the instance of {{site.data.conrefs.hlf_full}} deployed in the Developer Tutorial. If you have configured a {{site.data.conrefs.hlf_full}} instance from scratch these identity details will be different.*### 4. Install the 'admin' card ready for useWe will next take the admin card we have just made and import it for use with your business network.```bashcomposer card import --file admin@tutorial-network.card```### 5. Start the REST server & generate the Swagger API documentationNavigate to your directory and run the `composer-rest-server` command.```bashcomposer-rest-server```  - Enter admin@tutorial-network as the card name. Make sure not to add the `.card` extension.  - Select never use namespaces when asked whether to use namespaces in the generated API.  - Select No when asked whether to secure the generated API.  - Select Yes when asked whether to enable event publication.  - Select No when asked whether to enable TLS security.The rest server will then be generated and available on http://localhost:3000/explorer### 6. Generate the Angular applicationThe Angular application requires the rest server to be running to connect to the Fabric instance. Make sure you have the REST server running in the background when doing this. You will also need to be in the same directory as your .BNA file when running the Yeoman generator.```bashyo hyperledger-composer```Follow the below so your output matches.```Welcome to the Hyperledger Composer project generator? Please select the type of project: AngularYou can run this generator using: 'yo hyperledger-composer:angular'Welcome to the Hyperledger Composer Angular project generator? Do you want to connect to a running Business Network? Yes? Project name: [insert]? Description: Hyperledger Composer Angular project? Author name: [insert]? Author email: [insert]? License: Apache-2.0? Name of the Business Network card: admin@tutorial-network? Do you want to generate a new REST API or connect to an existing REST API?  Connect to an existing REST API? REST server address: http://localhost? REST server port: 3000? Should namespaces be used in the generated REST API? Namespaces are not usedCreated application!```The generated application will be within a sub directory named after the `Project name` entered above.Finally enter this directory and to get the application running, run:```bashnpm start```It will be available on http://localhost:4200## References* [**Developer Tutorial**](../tutorials/developer-tutorial.html)* [**Composer REST Server**](../integrating/getting-started-rest-api.html)",
        "url": "/composer/latest/applications/web"
      }
      ,
    
      "sitemap-xml": {
        "title": "",
        "author": "",
        "category": "",
        "content": "{% if page.xsl %}{% endif %}{% assign collections = site.collections | where_exp:'collection','collection.output != false' %}{% for collection in collections %}{% assign docs = collection.docs | where_exp:'doc','doc.sitemap != false' %}{% for doc in docs %}{{ doc.url | replace:'/index.html','/' | absolute_url | xml_escape }}{% if doc.last_modified_at or doc.date %}{{ doc.last_modified_at | default: doc.date | date_to_xmlschema }}{% endif %}{% endfor %}{% endfor %}{% assign pages = site.html_pages | where_exp:'doc','doc.sitemap != false' | where_exp:'doc','doc.url != \"/404.html\"' %}{% for page in pages %}{{ page.url | replace:'/index.html','/' | absolute_url | xml_escape }}{% if page.last_modified_at %}{{ page.last_modified_at | date_to_xmlschema }}{% endif %}{% endfor %}{% assign static_files = page.static_files | where_exp:'page','page.sitemap != false' | where_exp:'page','page.name != \"404.html\"' %}{% for file in static_files %}{{ file.path | replace:'/index.html','/' | absolute_url | xml_escape }}{{ file.modified_time | date_to_xmlschema }}{% endfor %}",
        "url": "/composer/latest/sitemap.xml"
      }
      ,
    
      "robots-txt": {
        "title": "",
        "author": "",
        "category": "",
        "content": "Sitemap: {{ \"sitemap.xml\" | absolute_url }}",
        "url": "/composer/latest/robots.txt"
      }
      
    
  };
</script>
<script src="/composer/latest/assets/js/lunr.js"></script>
<script src="/composer/latest/assets/js/search.js"></script>
            
          </section>
        </div>
        <!-- Otherwise, have the main content fill all 12 columns... -->
        
      <div class="PageNavigation">
    
    
  </div>
    </article>
</div>
<script>
(function (document) {
    function clipboard_init() {
        var charts = document.querySelectorAll("div.highlight"),
            arr = [],
            i, j, maxItem, pre, btn, el;

        // Make sure we are dealing with an array
        for(i = 0, maxItem = charts.length; i < maxItem; i++) arr.push(charts[i]);

        // Find the UML source element and get the text
        for (i = 0, maxItem = arr.length; i < maxItem; i++) {
            el = arr[i];
            pre = el.childNodes[0];

            pre.id = "hl_code" + i.toString();
            btn = document.createElement('copy-button');
            btn.appendChild(document.createTextNode('Copy'));
            btn.setAttribute("class", "copy-btn");
            btn.setAttribute("data-clipboard-target", "#hl_code" + i.toString());
            el.insertBefore(btn, pre);
        }
        new Clipboard('.copy-btn');
    };

    function onReady(fn) {
        if (document.addEventListener) {
            document.addEventListener('DOMContentLoaded', fn);
        } else {
            document.attachEvent('onreadystatechange', function() {
                if (document.readyState === 'interactive')
                    fn();
            });
        }
    }

    onReady(function(){
        clipboard_init();
    });
})(document);
</script>
<script src="/composer/latest/assets/js/nav.js"></script>
<script src="/composer/latest/assets/js/search_bar.js"></script>

    

    


  </div>
</body>
</html>
